
/***********************************/
/*http://www.layabox.com  2017/12/12*/
/***********************************/
var Laya=window.Laya=(function(window,document){
	var Laya={
		__internals:[],
		__packages:{},
		__classmap:{'Object':Object,'Function':Function,'Array':Array,'String':String},
		__sysClass:{'object':'Object','array':'Array','string':'String','dictionary':'Dictionary'},
		__propun:{writable: true,enumerable: false,configurable: true},
		__presubstr:String.prototype.substr,
		__substr:function(ofs,sz){return arguments.length==1?Laya.__presubstr.call(this,ofs):Laya.__presubstr.call(this,ofs,sz>0?sz:(this.length+sz));},
		__init:function(_classs){_classs.forEach(function(o){o.__init$ && o.__init$();});},
		__isClass:function(o){return o && (o.__isclass || o==Object || o==String || o==Array);},
		__newvec:function(sz,value){
			var d=[];
			d.length=sz;
			for(var i=0;i<sz;i++) d[i]=value;
			return d;
		},
		__extend:function(d,b){
			for (var p in b){
				if (!b.hasOwnProperty(p)) continue;
				var gs=Object.getOwnPropertyDescriptor(b, p);
				var g = gs.get, s = gs.set; 
				if ( g || s ) {
					if ( g && s)
						Object.defineProperty(d,p,gs);
					else{
						g && Object.defineProperty(d, p, g);
						s && Object.defineProperty(d, p, s);
					}
				}
				else d[p] = b[p];
			}
			function __() { Laya.un(this,'constructor',d); }__.prototype=b.prototype;d.prototype=new __();Laya.un(d.prototype,'__imps',Laya.__copy({},b.prototype.__imps));
		},
		__copy:function(dec,src){
			if(!src) return null;
			dec=dec||{};
			for(var i in src) dec[i]=src[i];
			return dec;
		},
		__package:function(name,o){
			if(Laya.__packages[name]) return;
			Laya.__packages[name]=true;
			var p=window,strs=name.split('.');
			if(strs.length>1){
				for(var i=0,sz=strs.length-1;i<sz;i++){
					var c=p[strs[i]];
					p=c?c:(p[strs[i]]={});
				}
			}
			p[strs[strs.length-1]] || (p[strs[strs.length-1]]=o||{});
		},
		__hasOwnProperty:function(name,o){
			o=o ||this;
		    function classHas(name,o){
				if(Object.hasOwnProperty.call(o.prototype,name)) return true;
				var s=o.prototype.__super;
				return s==null?null:classHas(name,s);
			}
			return (Object.hasOwnProperty.call(o,name)) || classHas(name,o.__class);
		},
		__typeof:function(o,value){
			if(!o || !value) return false;
			if(value===String) return (typeof o==='string');
			if(value===Number) return (typeof o==='number');
			if(value.__interface__) value=value.__interface__;
			else if(typeof value!='string')  return (o instanceof value);
			return (o.__imps && o.__imps[value]) || (o.__class==value);
		},
		__as:function(value,type){
			return (this.__typeof(value,type))?value:null;
		},
        __int:function(value){
            return value?parseInt(value):0;
        },
		interface:function(name,_super){
			Laya.__package(name,{});
			var ins=Laya.__internals;
			var a=ins[name]=ins[name] || {self:name};
			if(_super)
			{
				var supers=_super.split(',');
				a.extend=[];
				for(var i=0;i<supers.length;i++){
					var nm=supers[i];
					ins[nm]=ins[nm] || {self:nm};
					a.extend.push(ins[nm]);
				}
			}
			var o=window,words=name.split('.');
			for(var i=0;i<words.length-1;i++) o=o[words[i]];
			o[words[words.length-1]]={__interface__:name};
		},
		class:function(o,fullName,_super,miniName){
			_super && Laya.__extend(o,_super);
			if(fullName){
				Laya.__package(fullName,o);
				Laya.__classmap[fullName]=o;
				if(fullName.indexOf('.')>0){
					if(fullName.indexOf('laya.')==0){
						var paths=fullName.split('.');
						miniName=miniName || paths[paths.length-1];
						if(Laya[miniName]) console.log("Warning!,this class["+miniName+"] already exist:",Laya[miniName]);
						Laya[miniName]=o;
					}
				}
				else {
					if(fullName=="Main")
						window.Main=o;
					else{
						if(Laya[fullName]){
							console.log("Error!,this class["+fullName+"] already exist:",Laya[fullName]);
						}
						Laya[fullName]=o;
					}
				}
			}
			var un=Laya.un,p=o.prototype;
			un(p,'hasOwnProperty',Laya.__hasOwnProperty);
			un(p,'__class',o);
			un(p,'__super',_super);
			un(p,'__className',fullName);
			un(o,'__super',_super);
			un(o,'__className',fullName);
			un(o,'__isclass',true);
			un(o,'super',function(o){this.__super.call(o);});
		},
		imps:function(dec,src){
			if(!src) return null;
			var d=dec.__imps|| Laya.un(dec,'__imps',{});
			function __(name){
				var c,exs;
				if(! (c=Laya.__internals[name]) ) return;
				d[name]=true;
				if(!(exs=c.extend)) return;
				for(var i=0;i<exs.length;i++){
					__(exs[i].self);
				}
			}
			for(var i in src) __(i);
		},
        superSet:function(clas,o,prop,value){
            var fun = clas.prototype["_$set_"+prop];
            fun && fun.call(o,value);
        },
        superGet:function(clas,o,prop){
            var fun = clas.prototype["_$get_"+prop];
           	return fun?fun.call(o):null;
        },
		getset:function(isStatic,o,name,getfn,setfn){
			if(!isStatic){
				getfn && Laya.un(o,'_$get_'+name,getfn);
				setfn && Laya.un(o,'_$set_'+name,setfn);
			}
			else{
				getfn && (o['_$GET_'+name]=getfn);
				setfn && (o['_$SET_'+name]=setfn);
			}
			if(getfn && setfn) 
				Object.defineProperty(o,name,{get:getfn,set:setfn,enumerable:false,configurable:true});
			else{
				getfn && Object.defineProperty(o,name,{get:getfn,enumerable:false,configurable:true});
				setfn && Object.defineProperty(o,name,{set:setfn,enumerable:false,configurable:true});
			}
		},
		static:function(_class,def){
				for(var i=0,sz=def.length;i<sz;i+=2){
					if(def[i]=='length') 
						_class.length=def[i+1].call(_class);
					else{
						function tmp(){
							var name=def[i];
							var getfn=def[i+1];
							Object.defineProperty(_class,name,{
								get:function(){delete this[name];return this[name]=getfn.call(this);},
								set:function(v){delete this[name];this[name]=v;},enumerable: true,configurable: true});
						}
						tmp();
					}
				}
		},		
		un:function(obj,name,value){
			value || (value=obj[name]);
			Laya.__propun.value=value;
			Object.defineProperty(obj, name, Laya.__propun);
			return value;
		},
		uns:function(obj,names){
			names.forEach(function(o){Laya.un(obj,o)});
		}
	};

    window.console=window.console || ({log:function(){}});
	window.trace=window.console.log;
	Error.prototype.throwError=function(){throw arguments;};
	//String.prototype.substr=Laya.__substr;
	Object.defineProperty(Array.prototype,'fixed',{enumerable: false});

	return Laya;
})(window,document);

(function(window,document,Laya){
	var __un=Laya.un,__uns=Laya.uns,__static=Laya.static,__class=Laya.class,__getset=Laya.getset,__newvec=Laya.__newvec;

})(window,document,Laya);


(function(window,document,Laya){
	var __un=Laya.un,__uns=Laya.uns,__static=Laya.static,__class=Laya.class,__getset=Laya.getset,__newvec=Laya.__newvec;
Laya.interface('laya.runtime.IMarket');
Laya.interface('laya.filters.IFilter');
Laya.interface('laya.display.ILayout');
Laya.interface('laya.resource.IDispose');
Laya.interface('laya.runtime.IPlatform');
Laya.interface('laya.resource.IDestroy');
Laya.interface('laya.runtime.IConchNode');
Laya.interface('laya.filters.IFilterAction');
Laya.interface('laya.runtime.ICPlatformClass');
Laya.interface('laya.resource.ICreateResource');
Laya.interface('laya.runtime.IConchRenderObject');
Laya.interface('laya.runtime.IPlatformClass','laya.runtime.IPlatform');
/**
*@private
*/
//class laya.utils.RunDriver
var RunDriver=(function(){
	function RunDriver(){}
	__class(RunDriver,'laya.utils.RunDriver');
	RunDriver.FILTER_ACTIONS=[];
	RunDriver.pixelRatio=-1;
	RunDriver._charSizeTestDiv=null;
	RunDriver.now=function(){
		return /*__JS__ */Date.now();
	}

	RunDriver.getWindow=function(){
		return /*__JS__ */window;
	}

	RunDriver.getPixelRatio=function(){
		if (RunDriver.pixelRatio < 0){
			var ctx=Browser.context;
			var backingStore=ctx.backingStorePixelRatio || ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1;
			RunDriver.pixelRatio=(Browser.window.devicePixelRatio || 1)/ backingStore;
			if (RunDriver.pixelRatio < 1)RunDriver.pixelRatio=1;
		}
		return RunDriver.pixelRatio;
	}

	RunDriver.getIncludeStr=function(name){
		return null;
	}

	RunDriver.createShaderCondition=function(conditionScript){
		var fn="(function() {return "+conditionScript+";})";
		return Laya._runScript(fn);
	}

	RunDriver.fontMap=[];
	RunDriver.measureText=function(txt,font){
		var isChinese=RunDriver.hanzi.test(txt);
		if (isChinese && RunDriver.fontMap[font]){
			return RunDriver.fontMap[font];
		};
		var ctx=Browser.context;
		ctx.font=font;
		var r=ctx.measureText(txt);
		if (isChinese)RunDriver.fontMap[font]=r;
		return r;
	}

	RunDriver.getWebGLContext=function(canvas){
	};

	RunDriver.beginFlush=function(){
	};

	RunDriver.endFinish=function(){
	};

	RunDriver.addToAtlas=null;
	RunDriver.flashFlushImage=function(atlasWebGLCanvas){
	};

	RunDriver.drawToCanvas=function(sprite,_renderType,canvasWidth,canvasHeight,offsetX,offsetY){
		var canvas=HTMLCanvas.create("2D");
		var context=new RenderContext(canvasWidth,canvasHeight,canvas);
		RenderSprite.renders[_renderType]._fun(sprite,context,offsetX,offsetY);
		return canvas;
	}

	RunDriver.createParticleTemplate2D=null;
	RunDriver.createGLTextur=null;
	RunDriver.createWebGLContext2D=null;
	RunDriver.changeWebGLSize=function(w,h){
	};

	RunDriver.createRenderSprite=function(type,next){
		return new RenderSprite(type,next);
	}

	RunDriver.createFilterAction=function(type){
		return new ColorFilterAction();
	}

	RunDriver.createGraphics=function(){
		return new Graphics();
	}

	RunDriver.clear=function(value){
		Render._context.ctx.clear();
	}

	RunDriver.cancelLoadByUrl=function(url){
	};

	RunDriver.clearAtlas=function(value){
	};

	RunDriver.isAtlas=function(bitmap){
		return false;
	}

	RunDriver.addTextureToAtlas=function(value){
	};

	RunDriver.getTexturePixels=function(value,x,y,width,height){
		return null;
	}

	RunDriver.skinAniSprite=function(){
		return null;
	}

	RunDriver.update3DLoop=function(){
	};

	__static(RunDriver,
	['hanzi',function(){return this.hanzi=new RegExp("^[\u4E00-\u9FA5]$");}
	]);
	return RunDriver;
})()


/**
*<code>Laya</code> 是全局对象的引用入口集。
*Laya类引用了一些常用的全局对象，比如Laya.stage：舞台，Laya.timer：时间管理器，Laya.loader：加载管理器，使用时注意大小写。
*/
//class Laya
var ___Laya=(function(){
	//function Laya(){}
	/**
	*表示是否捕获全局错误并弹出提示。默认为false。
	*适用于移动设备等不方便调试的时候，设置为true后，如有未知错误，可以弹窗抛出详细错误堆栈。
	*/
	__getset(1,Laya,'alertGlobalError',null,function(value){
		var erralert=0;
		if (value){
			Browser.window.onerror=function (msg,url,line,column,detail){
				if (erralert++< 5 && detail)
					alert("出错啦，请把此信息截图给研发商\n"+msg+"\n"+detail.stack||detail);
			}
			}else {
			Browser.window.onerror=null;
		}
	});

	Laya.init=function(width,height,__plugins){
		var plugins=[];for(var i=2,sz=arguments.length;i<sz;i++)plugins.push(arguments[i]);
		if (Laya._isinit)return;
		ArrayBuffer.prototype.slice || (ArrayBuffer.prototype.slice=Laya._arrayBufferSlice);
		Laya._isinit=true;
		Browser.__init__();
		Context.__init__();
		Graphics.__init__();
		Laya.timer=new Timer();
		Laya.scaleTimer=new Timer();
		Laya.loader=new LoaderManager();
		WeakObject.__init__();
		for (var i=0,n=plugins.length;i < n;i++){
			if (plugins[i].enable)plugins[i].enable();
		}
		Font.__init__();
		Style.__init__();
		ResourceManager.__init__();
		CacheManager.beginCheck();
		Laya._currentStage=Laya.stage=new Stage();
		Laya.stage.conchModel && Laya.stage.conchModel.setRootNode();
		Laya.getUrlPath();
		Laya.render=new Render(0,0);
		Laya.stage.size(width,height);
		RenderSprite.__init__();
		KeyBoardManager.__init__();
		MouseManager.instance.__init__(Laya.stage,Render.canvas);
		Input.__init__();
		SoundManager.autoStopMusic=true;
		LocalStorage.__init__();
		return Render.canvas;
	}

	Laya.getUrlPath=function(){
		var location=Browser.window.location;
		var pathName=location.pathname;
		pathName=pathName.charAt(2)==':' ? pathName.substring(1):pathName;
		URL.rootPath=URL.basePath=URL.getPath(location.protocol=="file:" ? pathName :location.protocol+"//"+location.host+location.pathname);
	}

	Laya._arrayBufferSlice=function(start,end){
		var arr=/*__JS__ */this;
		var arrU8List=new Uint8Array(arr,start,end-start);
		var newU8List=new Uint8Array(arrU8List.length);
		newU8List.set(arrU8List);
		return newU8List.buffer;
	}

	Laya._runScript=function(script){
		return Browser.window["e"+String.fromCharCode(100+10+8)+"a"+"l"](script);
	}

	Laya.stage=null;
	Laya.timer=null;
	Laya.scaleTimer=null;
	Laya.loader=null;
	Laya.version="1.7.19.1beta";
	Laya.render=null;
	Laya._currentStage=null;
	Laya._isinit=false;
	Laya.MiniAdpter=/*__JS__ */{init:function(){if (window.navigator && window.navigator.userAgent && window.navigator.userAgent.indexOf("MiniGame")>-1)console.error("请先引用小游戏适配库laya.wxmini.js,详细教程：https://ldc.layabox.com/doc/?nav=zh-ts-5-0-0")}};
	__static(Laya,
	['conchMarket',function(){return this.conchMarket=/*__JS__ */window.conch?conchMarket:null;},'PlatformClass',function(){return this.PlatformClass=/*__JS__ */window.PlatformClass;}
	]);
	return Laya;
})()


/**
*Config 用于配置一些全局参数。如需更改，请在初始化引擎之前设置。
*/
//class Config
var Config=(function(){
	function Config(){}
	__class(Config,'Config');
	Config.WebGLTextCacheCount=500;
	Config.atlasEnable=false;
	Config.showCanvasMark=false;
	Config.animationInterval=50;
	Config.isAntialias=false;
	Config.isAlpha=false;
	Config.premultipliedAlpha=true;
	Config.isStencil=true;
	Config.preserveDrawingBuffer=false;
	return Config;
})()


/**
*<code>EventDispatcher</code> 类是可调度事件的所有类的基类。
*/
//class laya.events.EventDispatcher
var EventDispatcher=(function(){
	var EventHandler;
	function EventDispatcher(){
		/**@private */
		this._events=null;
	}

	__class(EventDispatcher,'laya.events.EventDispatcher');
	var __proto=EventDispatcher.prototype;
	/**
	*检查 EventDispatcher 对象是否为特定事件类型注册了任何侦听器。
	*@param type 事件的类型。
	*@return 如果指定类型的侦听器已注册，则值为 true；否则，值为 false。
	*/
	__proto.hasListener=function(type){
		var listener=this._events && this._events[type];
		return !!listener;
	}

	/**
	*派发事件。
	*@param type 事件类型。
	*@param data （可选）回调数据。<b>注意：</b>如果是需要传递多个参数 p1,p2,p3,...可以使用数组结构如：[p1,p2,p3,...] ；如果需要回调单个参数 p ，且 p 是一个数组，则需要使用结构如：[p]，其他的单个参数 p ，可以直接传入参数 p。
	*@return 此事件类型是否有侦听者，如果有侦听者则值为 true，否则值为 false。
	*/
	__proto.event=function(type,data){
		if (!this._events || !this._events[type])return false;
		var listeners=this._events[type];
		if (listeners.run){
			if (listeners.once)delete this._events[type];
			data !=null ? listeners.runWith(data):listeners.run();
			}else {
			for (var i=0,n=listeners.length;i < n;i++){
				var listener=listeners[i];
				if (listener){
					(data !=null)? listener.runWith(data):listener.run();
				}
				if (!listener || listener.once){
					listeners.splice(i,1);
					i--;
					n--;
				}
			}
			if (listeners.length===0 && this._events)delete this._events[type];
		}
		return true;
	}

	/**
	*使用 EventDispatcher 对象注册指定类型的事件侦听器对象，以使侦听器能够接收事件通知。
	*@param type 事件的类型。
	*@param caller 事件侦听函数的执行域。
	*@param listener 事件侦听函数。
	*@param args （可选）事件侦听函数的回调参数。
	*@return 此 EventDispatcher 对象。
	*/
	__proto.on=function(type,caller,listener,args){
		return this._createListener(type,caller,listener,args,false);
	}

	/**
	*使用 EventDispatcher 对象注册指定类型的事件侦听器对象，以使侦听器能够接收事件通知，此侦听事件响应一次后自动移除。
	*@param type 事件的类型。
	*@param caller 事件侦听函数的执行域。
	*@param listener 事件侦听函数。
	*@param args （可选）事件侦听函数的回调参数。
	*@return 此 EventDispatcher 对象。
	*/
	__proto.once=function(type,caller,listener,args){
		return this._createListener(type,caller,listener,args,true);
	}

	/**@private */
	__proto._createListener=function(type,caller,listener,args,once,offBefore){
		(offBefore===void 0)&& (offBefore=true);
		offBefore && this.off(type,caller,listener,once);
		var handler=EventHandler.create(caller || this,listener,args,once);
		this._events || (this._events={});
		var events=this._events;
		if (!events[type])events[type]=handler;
		else {
			if (!events[type].run)events[type].push(handler);
			else events[type]=[events[type],handler];
		}
		return this;
	}

	/**
	*从 EventDispatcher 对象中删除侦听器。
	*@param type 事件的类型。
	*@param caller 事件侦听函数的执行域。
	*@param listener 事件侦听函数。
	*@param onceOnly （可选）如果值为 true ,则只移除通过 once 方法添加的侦听器。
	*@return 此 EventDispatcher 对象。
	*/
	__proto.off=function(type,caller,listener,onceOnly){
		(onceOnly===void 0)&& (onceOnly=false);
		if (!this._events || !this._events[type])return this;
		var listeners=this._events[type];
		if (listener !=null){
			if (listeners.run){
				if ((!caller || listeners.caller===caller)&& listeners.method===listener && (!onceOnly || listeners.once)){
					delete this._events[type];
					listeners.recover();
				}
				}else {
				var count=0;
				for (var i=0,n=listeners.length;i < n;i++){
					var item=listeners[i];
					if (!item){
						count++;
						continue ;
					}
					if (item && (!caller || item.caller===caller)&& item.method===listener && (!onceOnly || item.once)){
						count++;
						listeners[i]=null;
						item.recover();
					}
				}
				if (count===n)delete this._events[type];
			}
		}
		return this;
	}

	/**
	*从 EventDispatcher 对象中删除指定事件类型的所有侦听器。
	*@param type （可选）事件类型，如果值为 null，则移除本对象所有类型的侦听器。
	*@return 此 EventDispatcher 对象。
	*/
	__proto.offAll=function(type){
		var events=this._events;
		if (!events)return this;
		if (type){
			this._recoverHandlers(events[type]);
			delete events[type];
			}else {
			for (var name in events){
				this._recoverHandlers(events[name]);
			}
			this._events=null;
		}
		return this;
	}

	__proto._recoverHandlers=function(arr){
		if (!arr)return;
		if (arr.run){
			arr.recover();
			}else {
			for (var i=arr.length-1;i >-1;i--){
				if (arr[i]){
					arr[i].recover();
					arr[i]=null;
				}
			}
		}
	}

	/**
	*检测指定事件类型是否是鼠标事件。
	*@param type 事件的类型。
	*@return 如果是鼠标事件，则值为 true;否则，值为 false。
	*/
	__proto.isMouseEvent=function(type){
		return EventDispatcher.MOUSE_EVENTS[type];
	}

	EventDispatcher.MOUSE_EVENTS={"rightmousedown":true,"rightmouseup":true,"rightclick":true,"mousedown":true,"mouseup":true,"mousemove":true,"mouseover":true,"mouseout":true,"click":true,"doubleclick":true};
	EventDispatcher.__init$=function(){
		Object.defineProperty(laya.events.EventDispatcher.prototype,"_events",{enumerable:false,writable:true});
		/**@private */
		//class EventHandler extends laya.utils.Handler
		EventHandler=(function(_super){
			function EventHandler(caller,method,args,once){
				EventHandler.__super.call(this,caller,method,args,once);
			}
			__class(EventHandler,'',_super);
			var __proto=EventHandler.prototype;
			__proto.recover=function(){
				if (this._id > 0){
					this._id=0;
					EventHandler._pool.push(this.clear());
				}
			}
			EventHandler.create=function(caller,method,args,once){
				(once===void 0)&& (once=true);
				if (EventHandler._pool.length)return EventHandler._pool.pop().setTo(caller,method,args,once);
				return new EventHandler(caller,method,args,once);
			}
			EventHandler._pool=[];
			return EventHandler;
		})(Handler)
	}

	return EventDispatcher;
})()


/**
*<p><code>Handler</code> 是事件处理器类。</p>
*<p>推荐使用 Handler.create()方法从对象池创建，减少对象创建消耗。创建的 Handler 对象不再使用后，可以使用 Handler.recover()将其回收到对象池，回收后不要再使用此对象，否则会导致不可预料的错误。</p>
*<p><b>注意：</b>由于鼠标事件也用本对象池，不正确的回收及调用，可能会影响鼠标事件的执行。</p>
*/
//class laya.utils.Handler
var Handler=(function(){
	function Handler(caller,method,args,once){
		/**执行域(this)。*/
		//this.caller=null;
		/**处理方法。*/
		//this.method=null;
		/**参数。*/
		//this.args=null;
		/**表示是否只执行一次。如果为true，回调后执行recover()进行回收，回收后会被再利用，默认为false 。*/
		this.once=false;
		/**@private */
		this._id=0;
		(once===void 0)&& (once=false);
		this.setTo(caller,method,args,once);
	}

	__class(Handler,'laya.utils.Handler');
	var __proto=Handler.prototype;
	/**
	*设置此对象的指定属性值。
	*@param caller 执行域(this)。
	*@param method 回调方法。
	*@param args 携带的参数。
	*@param once 是否只执行一次，如果为true，执行后执行recover()进行回收。
	*@return 返回 handler 本身。
	*/
	__proto.setTo=function(caller,method,args,once){
		this._id=Handler._gid++;
		this.caller=caller;
		this.method=method;
		this.args=args;
		this.once=once;
		return this;
	}

	/**
	*执行处理器。
	*/
	__proto.run=function(){
		if (this.method==null)return null;
		var id=this._id;
		var result=this.method.apply(this.caller,this.args);
		this._id===id && this.once && this.recover();
		return result;
	}

	/**
	*执行处理器，携带额外数据。
	*@param data 附加的回调数据，可以是单数据或者Array(作为多参)。
	*/
	__proto.runWith=function(data){
		if (this.method==null)return null;
		var id=this._id;
		if (data==null)
			var result=this.method.apply(this.caller,this.args);
		else if (!this.args && !data.unshift)result=this.method.call(this.caller,data);
		else if (this.args)result=this.method.apply(this.caller,this.args.concat(data));
		else result=this.method.apply(this.caller,data);
		this._id===id && this.once && this.recover();
		return result;
	}

	/**
	*清理对象引用。
	*/
	__proto.clear=function(){
		this.caller=null;
		this.method=null;
		this.args=null;
		return this;
	}

	/**
	*清理并回收到 Handler 对象池内。
	*/
	__proto.recover=function(){
		if (this._id > 0){
			this._id=0;
			Handler._pool.push(this.clear());
		}
	}

	Handler.create=function(caller,method,args,once){
		(once===void 0)&& (once=true);
		if (Handler._pool.length)return Handler._pool.pop().setTo(caller,method,args,once);
		return new Handler(caller,method,args,once);
	}

	Handler._pool=[];
	Handler._gid=1;
	return Handler;
})()


/**
*<code>BitmapFont</code> 是位图字体类，用于定义位图字体信息。
*/
//class laya.display.BitmapFont
var BitmapFont=(function(){
	function BitmapFont(){
		this._texture=null;
		this._fontCharDic={};
		this._fontWidthMap={};
		this._complete=null;
		this._path=null;
		this._maxWidth=0;
		this._spaceWidth=10;
		this._padding=null;
		/**当前位图字体字号。*/
		this.fontSize=12;
		/**表示是否根据实际使用的字体大小缩放位图字体大小。*/
		this.autoScaleSize=false;
		/**字符间距（以像素为单位）。*/
		this.letterSpacing=0;
	}

	__class(BitmapFont,'laya.display.BitmapFont');
	var __proto=BitmapFont.prototype;
	/**
	*通过指定位图字体文件路径，加载位图字体文件，加载完成后会自动解析。
	*@param path 位图字体文件的路径。
	*@param complete 加载并解析完成的回调。如果成功返回this,如果失败返回null
	*/
	__proto.loadFont=function(path,complete){
		this._path=path;
		this._complete=complete;
		Laya.loader.load([{url:this._path,type:/*laya.net.Loader.XML*/"xml"},{url:this._path.replace(".fnt",".png"),type:/*laya.net.Loader.IMAGE*/"image"}],Handler.create(this,this.onLoaded));
	}

	/**
	*@private
	*/
	__proto.onLoaded=function(){
		this.parseFont(Loader.getRes(this._path),Loader.getRes(this._path.replace(".fnt",".png")));
		this._complete && this._complete.runWith(this._texture?this:null);
	}

	/**
	*解析字体文件。
	*@param xml 字体文件XML。
	*@param texture 字体的纹理。
	*/
	__proto.parseFont=function(xml,texture){
		if (xml==null || texture==null)return;
		this._texture=texture;
		var tX=0;
		var tScale=1;
		var tInfo=xml.getElementsByTagName("info");
		if (!tInfo[0].getAttributeNode){
			return this.parseFont2(xml,texture);
		}
		this.fontSize=parseInt(tInfo[0].getAttributeNode("size").nodeValue);
		var tPadding=tInfo[0].getAttributeNode("padding").nodeValue;
		var tPaddingArray=tPadding.split(",");
		this._padding=[parseInt(tPaddingArray[0]),parseInt(tPaddingArray[1]),parseInt(tPaddingArray[2]),parseInt(tPaddingArray[3])];
		var chars;
		chars=xml.getElementsByTagName("char");
		var i=0;
		for (i=0;i < chars.length;i++){
			var tAttribute=chars[i];
			var tId=parseInt(tAttribute.getAttributeNode("id").nodeValue);
			var xOffset=parseInt(tAttribute.getAttributeNode("xoffset").nodeValue)/ tScale;
			var yOffset=parseInt(tAttribute.getAttributeNode("yoffset").nodeValue)/ tScale;
			var xAdvance=parseInt(tAttribute.getAttributeNode("xadvance").nodeValue)/ tScale;
			var region=new Rectangle();
			region.x=parseInt(tAttribute.getAttributeNode("x").nodeValue);
			region.y=parseInt(tAttribute.getAttributeNode("y").nodeValue);
			region.width=parseInt(tAttribute.getAttributeNode("width").nodeValue);
			region.height=parseInt(tAttribute.getAttributeNode("height").nodeValue);
			var tTexture=Texture.create(texture,region.x,region.y,region.width,region.height,xOffset,yOffset);
			this._maxWidth=Math.max(this._maxWidth,xAdvance+this.letterSpacing);
			this._fontCharDic[tId]=tTexture;
			this._fontWidthMap[tId]=xAdvance;
		}
	}

	/**
	*@private
	*解析字体文件。
	*@param xml 字体文件XML。
	*@param texture 字体的纹理。
	*/
	__proto.parseFont2=function(xml,texture){
		if (xml==null || texture==null)return;
		this._texture=texture;
		var tX=0;
		var tScale=1;
		var tInfo=xml.getElementsByTagName("info");
		this.fontSize=parseInt(tInfo[0].attributes["size"].nodeValue);
		var tPadding=tInfo[0].attributes["padding"].nodeValue;
		var tPaddingArray=tPadding.split(",");
		this._padding=[parseInt(tPaddingArray[0]),parseInt(tPaddingArray[1]),parseInt(tPaddingArray[2]),parseInt(tPaddingArray[3])];
		var chars=xml.getElementsByTagName("char");
		var i=0;
		for (i=0;i < chars.length;i++){
			var tAttribute=chars[i].attributes;
			var tId=parseInt(tAttribute["id"].nodeValue);
			var xOffset=parseInt(tAttribute["xoffset"].nodeValue)/ tScale;
			var yOffset=parseInt(tAttribute["yoffset"].nodeValue)/ tScale;
			var xAdvance=parseInt(tAttribute["xadvance"].nodeValue)/ tScale;
			var region=new Rectangle();
			region.x=parseInt(tAttribute["x"].nodeValue);
			region.y=parseInt(tAttribute["y"].nodeValue);
			region.width=parseInt(tAttribute["width"].nodeValue);
			region.height=parseInt(tAttribute["height"].nodeValue);
			var tTexture=Texture.create(texture,region.x,region.y,region.width,region.height,xOffset,yOffset);
			this._maxWidth=Math.max(this._maxWidth,xAdvance+this.letterSpacing);
			this._fontCharDic[tId]=tTexture;
			this._fontWidthMap[tId]=xAdvance;
		}
	}

	/**
	*获取指定字符的字体纹理对象。
	*@param char 字符。
	*@return 指定的字体纹理对象。
	*/
	__proto.getCharTexture=function(char){
		return this._fontCharDic[char.charCodeAt(0)];
	}

	/**
	*销毁位图字体，调用Text.unregisterBitmapFont 时，默认会销毁。
	*/
	__proto.destroy=function(){
		if (this._texture){
			for (var p in this._fontCharDic){
				var tTexture=this._fontCharDic[p];
				if (tTexture)tTexture.destroy();
			}
			this._texture.destroy();
			this._fontCharDic=null;
			this._fontWidthMap=null;
			this._texture=null;
		}
	}

	/**
	*设置空格的宽（如果字体库有空格，这里就可以不用设置了）。
	*@param spaceWidth 宽度，单位为像素。
	*/
	__proto.setSpaceWidth=function(spaceWidth){
		this._spaceWidth=spaceWidth;
	}

	/**
	*获取指定字符的宽度。
	*@param char 字符。
	*@return 宽度。
	*/
	__proto.getCharWidth=function(char){
		var code=char.charCodeAt(0);
		if (this._fontWidthMap[code])return this._fontWidthMap[code]+this.letterSpacing;
		if (char==" ")return this._spaceWidth+this.letterSpacing;
		return 0;
	}

	/**
	*获取指定文本内容的宽度。
	*@param text 文本内容。
	*@return 宽度。
	*/
	__proto.getTextWidth=function(text){
		var tWidth=0;
		for (var i=0,n=text.length;i < n;i++){
			tWidth+=this.getCharWidth(text.charAt(i));
		}
		return tWidth;
	}

	/**
	*获取最大字符宽度。
	*/
	__proto.getMaxWidth=function(){
		return this._maxWidth;
	}

	/**
	*获取最大字符高度。
	*/
	__proto.getMaxHeight=function(){
		return this.fontSize;
	}

	/**
	*@private
	*将指定的文本绘制到指定的显示对象上。
	*/
	__proto.drawText=function(text,sprite,drawX,drawY,align,width){
		var tWidth=this.getTextWidth(text);
		var tTexture;
		var dx=0;
		align==="center" && (dx=(width-tWidth)/ 2);
		align==="right" && (dx=(width-tWidth));
		var tX=0;
		for (var i=0,n=text.length;i < n;i++){
			tTexture=this.getCharTexture(text.charAt(i));
			if (tTexture){
				sprite.graphics.drawTexture(tTexture,drawX+tX+dx,drawY);
				tX+=this.getCharWidth(text.charAt(i));
			}
		}
	}

	return BitmapFont;
})()


/**
*@private
*<code>Style</code> 类是元素样式定义类。
*/
//class laya.display.css.Style
var Style=(function(){
	function Style(){
		/**透明度。*/
		this.alpha=1;
		/**表示是否显示。*/
		this.visible=true;
		/**表示滚动区域。*/
		this.scrollRect=null;
		/**混合模式。*/
		this.blendMode=null;
		/**@private */
		this._type=0;
		this._tf=Style._TF_EMPTY;
	}

	__class(Style,'laya.display.css.Style');
	var __proto=Style.prototype;
	__proto.getTransform=function(){
		return this._tf;
	}

	__proto.setTransform=function(value){
		this._tf=value==='none' || !value ? Style._TF_EMPTY :value;
	}

	__proto.setTranslateX=function(value){
		this._tf===Style._TF_EMPTY && (this._tf=new TransformInfo());
		this._tf.translateX=value;
	}

	__proto.setTranslateY=function(value){
		this._tf===Style._TF_EMPTY && (this._tf=new TransformInfo());
		this._tf.translateY=value;
	}

	__proto.setScaleX=function(value){
		this._tf===Style._TF_EMPTY && (this._tf=new TransformInfo());
		this._tf.scaleX=value;
	}

	__proto.setScale=function(x,y){
		this._tf===Style._TF_EMPTY && (this._tf=new TransformInfo());
		this._tf.scaleX=x;
		this._tf.scaleY=y;
	}

	__proto.setScaleY=function(value){
		this._tf===Style._TF_EMPTY && (this._tf=new TransformInfo());
		this._tf.scaleY=value;
	}

	__proto.setRotate=function(value){
		this._tf===Style._TF_EMPTY && (this._tf=new TransformInfo());
		this._tf.rotate=value;
	}

	__proto.setSkewX=function(value){
		this._tf===Style._TF_EMPTY && (this._tf=new TransformInfo());
		this._tf.skewX=value;
	}

	__proto.setSkewY=function(value){
		this._tf===Style._TF_EMPTY && (this._tf=new TransformInfo());
		this._tf.skewY=value;
	}

	/**销毁此对象。*/
	__proto.destroy=function(){
		this.scrollRect=null;
	}

	/**@private */
	__proto.render=function(sprite,context,x,y){}
	/**@private */
	__proto.getCSSStyle=function(){
		return CSSStyle.EMPTY;
	}

	/**@private */
	__proto._enableLayout=function(){
		return false;
	}

	/**X 轴缩放值。*/
	__getset(0,__proto,'scaleX',function(){
		return this._tf.scaleX;
		},function(value){
		this.setScaleX(value);
	});

	/**元素应用的 2D 或 3D 转换的值。该属性允许我们对元素进行旋转、缩放、移动或倾斜。*/
	__getset(0,__proto,'transform',function(){
		return this.getTransform();
		},function(value){
		this.setTransform(value);
	});

	/**定义转换，只是用 X 轴的值。*/
	__getset(0,__proto,'translateX',function(){
		return this._tf.translateX;
		},function(value){
		this.setTranslateX(value);
	});

	/**定义转换，只是用 Y 轴的值。*/
	__getset(0,__proto,'translateY',function(){
		return this._tf.translateY;
		},function(value){
		this.setTranslateY(value);
	});

	/**Y 轴缩放值。*/
	__getset(0,__proto,'scaleY',function(){
		return this._tf.scaleY;
		},function(value){
		this.setScaleY(value);
	});

	/**表示元素是否显示为块级元素。*/
	__getset(0,__proto,'block',function(){
		return (this._type & 0x1)!=0;
	});

	/**定义沿着 Y 轴的 2D 倾斜转换。*/
	__getset(0,__proto,'skewY',function(){
		return this._tf.skewY;
		},function(value){
		this.setSkewY(value);
	});

	/**定义旋转角度。*/
	__getset(0,__proto,'rotate',function(){
		return this._tf.rotate;
		},function(value){
		this.setRotate(value);
	});

	/**定义沿着 X 轴的 2D 倾斜转换。*/
	__getset(0,__proto,'skewX',function(){
		return this._tf.skewX;
		},function(value){
		this.setSkewX(value);
	});

	/**表示元素的左内边距。*/
	__getset(0,__proto,'paddingLeft',function(){
		return 0;
	});

	/**表示元素的上内边距。*/
	__getset(0,__proto,'paddingTop',function(){
		return 0;
	});

	/**是否为绝对定位。*/
	__getset(0,__proto,'absolute',function(){
		return true;
	});

	Style.__init__=function(){
		Style._TF_EMPTY=new TransformInfo();
		Style.EMPTY=new Style();
	}

	Style.EMPTY=null;
	Style._TF_EMPTY=null;
	return Style;
})()


/**
*@private
*<code>Font</code> 类是字体显示定义类。
*/
//class laya.display.css.Font
var Font=(function(){
	function Font(src){
		this._type=0;
		this._weight=0;
		this._decoration=null;
		this._text=null;
		/**
		*首行缩进 （以像素为单位）。
		*/
		this.indent=0;
		this._color=Color.create(Font.defaultColor);
		this.family=Font.defaultFamily;
		this.stroke=Font._STROKE;
		this.size=Font.defaultSize;
		src && src!==Font.EMPTY && src.copyTo(this);
	}

	__class(Font,'laya.display.css.Font');
	var __proto=Font.prototype;
	/**
	*字体样式字符串。
	*/
	__proto.set=function(value){
		this._text=null;
		var strs=value.split(' ');
		for (var i=0,n=strs.length;i < n;i++){
			var str=strs[i];
			switch (str){
				case 'italic':
					this.italic=true;
					continue ;
				case 'bold':
					this.bold=true;
					continue ;
				}
			if (str.indexOf('px')> 0){
				this.size=parseInt(str);
				this.family=strs[i+1];
				i++;
				continue ;
			}
		}
	}

	/**
	*返回字体样式字符串。
	*@return 字体样式字符串。
	*/
	__proto.toString=function(){
		this._text=""
		this.italic && (this._text+="italic ");
		this.bold && (this._text+="bold ");
		return this._text+=this.size+"px "+this.family;
	}

	/**
	*将当前的属性值复制到传入的 <code>Font</code> 对象。
	*@param dec 一个 Font 对象。
	*/
	__proto.copyTo=function(dec){
		dec._type=this._type;
		dec._text=this._text;
		dec._weight=this._weight;
		dec._color=this._color;
		dec.family=this.family;
		dec.stroke=this.stroke !=Font._STROKE ? this.stroke.slice():Font._STROKE;
		dec.indent=this.indent;
		dec.size=this.size;
	}

	/**
	*表示是否为密码格式。
	*/
	__getset(0,__proto,'password',function(){
		return (this._type & 0x400)!==0;
		},function(value){
		value ? (this._type |=0x400):(this._type &=~0x400);
	});

	/**
	*表示颜色字符串。
	*/
	__getset(0,__proto,'color',function(){
		return this._color.strColor;
		},function(value){
		this._color=Color.create(value);
	});

	/**
	*表示是否为斜体。
	*/
	__getset(0,__proto,'italic',function(){
		return (this._type & 0x200)!==0;
		},function(value){
		value ? (this._type |=0x200):(this._type &=~0x200);
	});

	/**
	*表示是否为粗体。
	*/
	__getset(0,__proto,'bold',function(){
		return (this._type & 0x800)!==0;
		},function(value){
		value ? (this._type |=0x800):(this._type &=~0x800);
	});

	/**
	*文本的粗细。
	*/
	__getset(0,__proto,'weight',function(){
		return ""+this._weight;
		},function(value){
		var weight=0;
		switch (value){
			case 'normal':
				break ;
			case 'bold':
				this.bold=true;
				weight=700;
				break ;
			case 'bolder':
				weight=800;
				break ;
			case 'lighter':
				weight=100;
				break ;
			default :
				weight=parseInt(value);
			}
		this._weight=weight;
		this._text=null;
	});

	/**
	*规定添加到文本的修饰。
	*/
	__getset(0,__proto,'decoration',function(){
		return this._decoration ? this._decoration.value :"none";
		},function(value){
		var strs=value.split(' ');
		this._decoration || (this._decoration={});
		switch (strs[0]){
			case '_':
				this._decoration.type='underline'
				break ;
			case '-':
				this._decoration.type='line-through'
				break ;
			case 'overline':
				this._decoration.type='overline'
				break ;
			default :
				this._decoration.type=strs[0];
			}
		strs[1] && (this._decoration.color=Color.create(strs));
		this._decoration.value=value;
	});

	Font.__init__=function(){
		Font.EMPTY=new Font(null);
	}

	Font.EMPTY=null;
	Font.defaultColor="#000000";
	Font.defaultSize=12;
	Font.defaultFamily="Arial";
	Font.defaultFont="12px Arial";
	Font._STROKE=[0,"#000000"];
	Font._ITALIC=0x200;
	Font._PASSWORD=0x400;
	Font._BOLD=0x800;
	return Font;
})()


/**
*@private
*/
//class laya.display.css.TransformInfo
var TransformInfo=(function(){
	function TransformInfo(){
		this.translateX=0;
		this.translateY=0;
		this.scaleX=1;
		this.scaleY=1;
		this.rotate=0;
		this.skewX=0;
		this.skewY=0;
	}

	__class(TransformInfo,'laya.display.css.TransformInfo');
	return TransformInfo;
})()


/**
*<code>Graphics</code> 类用于创建绘图显示对象。Graphics可以同时绘制多个位图或者矢量图，还可以结合save，restore，transform，scale，rotate，translate，alpha等指令对绘图效果进行变化。
*Graphics以命令流方式存储，可以通过cmds属性访问所有命令流。Graphics是比Sprite更轻量级的对象，合理使用能提高应用性能(比如把大量的节点绘图改为一个节点的Graphics命令集合，能减少大量节点创建消耗)。
*@see laya.display.Sprite#graphics
*/
//class laya.display.Graphics
var Graphics=(function(){
	function Graphics(){
		/**@private */
		//this._sp=null;
		/**@private */
		this._one=null;
		/**@private */
		this._cmds=null;
		/**@private */
		//this._vectorgraphArray=null;
		/**@private */
		//this._graphicBounds=null;
		this._render=this._renderEmpty;
		if (Render.isConchNode){
			var _this_=this;
			_this_._nativeObj=new (window)._conchGraphics();
			_this_.id=_this_._nativeObj.conchID;
		}
	}

	__class(Graphics,'laya.display.Graphics');
	var __proto=Graphics.prototype;
	/**
	*<p>销毁此对象。</p>
	*/
	__proto.destroy=function(){
		this.clear();
		if (this._graphicBounds)this._graphicBounds.destroy();
		this._graphicBounds=null;
		this._vectorgraphArray=null;
		this._sp && (this._sp._renderType=0);
		this._sp=null;
	}

	/**
	*<p>清空绘制命令。</p>
	*@param recoverCmds 是否回收绘图指令
	*/
	__proto.clear=function(recoverCmds){
		(recoverCmds===void 0)&& (recoverCmds=false);
		var i=0,len=0;
		if (recoverCmds){
			var tCmd=this._one;
			if (this._cmds){
				len=this._cmds.length;
				for (i=0;i < len;i++){
					tCmd=this._cmds[i];
					if (tCmd && (tCmd.callee===Render._context._drawTexture || tCmd.callee===Render._context._drawTextureWithTransform)){
						tCmd[0]=null;
						Graphics._cache.push(tCmd);
					}
				}
				this._cmds.length=0;
				}else if (tCmd){
				if (tCmd && (tCmd.callee===Render._context._drawTexture || tCmd.callee===Render._context._drawTextureWithTransform)){
					tCmd[0]=null;
					Graphics._cache.push(tCmd);
				}
			}
			}else {
			this._cmds=null;
		}
		this._one=null;
		this._render=this._renderEmpty;
		this._sp && (this._sp._renderType &=~ /*laya.renders.RenderSprite.IMAGE*/0x01 & ~ /*laya.renders.RenderSprite.GRAPHICS*/0x200);
		this._repaint();
		if (this._vectorgraphArray){
			for (i=0,len=this._vectorgraphArray.length;i < len;i++){
				VectorGraphManager.getInstance().deleteShape(this._vectorgraphArray[i]);
			}
			this._vectorgraphArray.length=0;
		}
	}

	/**@private */
	__proto._clearBoundsCache=function(){
		if (this._graphicBounds)this._graphicBounds.reset();
	}

	/**@private */
	__proto._initGraphicBounds=function(){
		if (!this._graphicBounds){
			this._graphicBounds=new GraphicsBounds();
			this._graphicBounds._graphics=this;
		}
	}

	/**
	*@private
	*重绘此对象。
	*/
	__proto._repaint=function(){
		this._clearBoundsCache();
		this._sp && this._sp.repaint();
	}

	/**@private */
	__proto._isOnlyOne=function(){
		return !this._cmds || this._cmds.length===0;
	}

	/**
	*获取位置及宽高信息矩阵(比较耗CPU，频繁使用会造成卡顿，尽量少用)。
	*@param realSize （可选）使用图片的真实大小，默认为false
	*@return 位置与宽高组成的 一个 Rectangle 对象。
	*/
	__proto.getBounds=function(realSize){
		(realSize===void 0)&& (realSize=false);
		this._initGraphicBounds();
		return this._graphicBounds.getBounds(realSize);
	}

	/**
	*@private
	*@param realSize （可选）使用图片的真实大小，默认为false
	*获取端点列表。
	*/
	__proto.getBoundPoints=function(realSize){
		(realSize===void 0)&& (realSize=false);
		this._initGraphicBounds();
		return this._graphicBounds.getBoundPoints(realSize);
	}

	__proto._addCmd=function(a){
		this._cmds=this._cmds || [];
		a.callee=a.shift();
		this._cmds.push(a);
	}

	__proto.setFilters=function(fs){
		this._saveToCmd(Render._context._setFilters,fs);
	}

	/**
	*绘制纹理。
	*@param tex 纹理。
	*@param x （可选）X轴偏移量。
	*@param y （可选）Y轴偏移量。
	*@param width （可选）宽度。
	*@param height （可选）高度。
	*@param m （可选）矩阵信息。
	*@param alpha （可选）透明度。
	*/
	__proto.drawTexture=function(tex,x,y,width,height,m,alpha){
		(x===void 0)&& (x=0);
		(y===void 0)&& (y=0);
		(width===void 0)&& (width=0);
		(height===void 0)&& (height=0);
		(alpha===void 0)&& (alpha=1);
		if (!tex || alpha < 0.01)return null;
		if (!width)width=tex.sourceWidth;
		if (!height)height=tex.sourceHeight;
		alpha=alpha < 0 ? 0 :(alpha > 1 ? 1 :alpha);
		var offset=(!Render.isWebGL && (Browser.onFirefox || Browser.onEdge||Browser.onIE||Browser.onSafari))? 0.5 :0;
		var wRate=width / tex.sourceWidth;
		var hRate=height / tex.sourceHeight;
		width=tex.width *wRate;
		height=tex.height *hRate;
		if (tex.loaded && (width <=0 || height <=0))return null;
		x+=tex.offsetX *wRate;
		y+=tex.offsetY *hRate;
		this._sp && (this._sp._renderType |=/*laya.renders.RenderSprite.GRAPHICS*/0x200);
		var args;
		x-=offset;
		y-=offset;
		width+=2 *offset;
		height+=2 *offset;
		if (Graphics._cache.length){
			args=Graphics._cache.pop();
			args[0]=tex;
			args[1]=x;
			args[2]=y;
			args[3]=width;
			args[4]=height;
			args[5]=m;
			args[6]=alpha;
			}else {
			args=[tex,x,y,width,height,m,alpha];
		}
		args.callee=(m || alpha !=1)? Render._context._drawTextureWithTransform :Render._context._drawTexture;
		if (this._one==null && !m && alpha==1){
			this._one=args;
			this._render=this._renderOneImg;
			}else {
			this._saveToCmd(args.callee,args);
		}
		if (!tex.loaded){
			tex.once(/*laya.events.Event.LOADED*/"loaded",this,this._textureLoaded,[tex,args]);
		}
		this._repaint();
		return args;
	}

	/**
	*@private 清理贴图并替换为最新的
	*@param tex
	*/
	__proto.cleanByTexture=function(tex,x,y,width,height){
		(width===void 0)&& (width=0);
		(height===void 0)&& (height=0);
		if (!tex)return this.clear();
		if (this._one && this._render===this._renderOneImg){
			if (!width)width=tex.sourceWidth;
			if (!height)height=tex.sourceHeight;
			var wRate=width / tex.sourceWidth;
			var hRate=height / tex.sourceHeight;
			width=tex.width *wRate;
			height=tex.height *hRate;
			x+=tex.offsetX *wRate;
			y+=tex.offsetY *hRate;
			this._one[0]=tex;
			this._one[1]=x;
			this._one[2]=y;
			this._one[3]=width;
			this._one[4]=height;
			this._repaint();
			}else {
			this.clear();
			tex && this.drawTexture(tex,x,y,width,height);
		}
	}

	/**
	*批量绘制同样纹理。
	*@param tex 纹理。
	*@param pos 绘制坐标。
	*/
	__proto.drawTextures=function(tex,pos){
		if (!tex)return;
		this._saveToCmd(Render._context._drawTextures,[tex,pos]);
	}

	/**
	*用texture填充。
	*@param tex 纹理。
	*@param x X轴偏移量。
	*@param y Y轴偏移量。
	*@param width （可选）宽度。
	*@param height （可选）高度。
	*@param type （可选）填充类型 repeat|repeat-x|repeat-y|no-repeat
	*@param offset （可选）贴图纹理偏移
	*/
	__proto.fillTexture=function(tex,x,y,width,height,type,offset){
		(width===void 0)&& (width=0);
		(height===void 0)&& (height=0);
		(type===void 0)&& (type="repeat");
		if (!tex)return;
		var args=[tex,x,y,width,height,type,offset || Point.EMPTY,{}];
		if (!tex.loaded){
			tex.once(/*laya.events.Event.LOADED*/"loaded",this,this._textureLoaded,[tex,args]);
		}
		this._saveToCmd(Render._context._fillTexture,args);
	}

	__proto._textureLoaded=function(tex,param){
		param[3]=param[3] || tex.width;
		param[4]=param[4] || tex.height;
		this._repaint();
	}

	/**
	*填充一个圆形。这是一个临时函数，以后会删除，建议用户自己实现。
	*@param x
	*@param y
	*@param tex
	*@param cx 圆心位置。
	*@param cy
	*@param radius
	*@param segNum 分段数，越大越平滑。
	*/
	__proto.fillCircle=function(x,y,tex,cx,cy,radius,segNum){
		tex.bitmap.enableMerageInAtlas=false;
		var verts=new Float32Array((segNum+1)*2);
		var uvs=new Float32Array((segNum+1)*2);
		var indices=new Uint16Array(segNum*3);
		var dang=2 *Math.PI / segNum;
		var cang=0;
		verts[0]=cx;
		verts[1]=cy;
		uvs[0]=cx / tex.width;
		uvs[1]=cy / tex.height;
		var idx=2;
		for (var i=0;i < segNum;i++){
			var px=radius *Math.cos(cang)+cx;
			var py=radius *Math.sin(cang)+cy;
			verts[idx]=px;
			verts[idx+1]=py;
			uvs[idx]=px / tex.width;
			uvs[idx+1]=py / tex.height;
			cang+=dang;
			idx+=2;
		}
		idx=0;
		for (i=0;i < segNum;i++){
			indices[idx++]=0;
			indices[idx++]=i+1;
			indices[idx++]=(i+2 >=segNum+1)?1:(i+2);
		}
		this.drawTriangles(tex,x,y,verts,uvs,indices);
	}

	/**
	*绘制一组三角形
	*@param texture 纹理。
	*@param x X轴偏移量。
	*@param y Y轴偏移量。
	*@param vertices 顶点数组。
	*@param indices 顶点索引。
	*@param uvData UV数据。
	*@param matrix 缩放矩阵。
	*@param alpha alpha
	*@param color 颜色变换
	*@param blendMode blend模式
	*/
	__proto.drawTriangles=function(texture,x,y,vertices,uvs,indices,matrix,alpha,color,blendMode){
		(alpha===void 0)&& (alpha=1);
		this._saveToCmd(Render._context.drawTriangles,[texture,x,y,vertices,uvs,indices,matrix,alpha,color,blendMode]);
	}

	/**
	*@private
	*保存到命令流。
	*/
	__proto._saveToCmd=function(fun,args){
		this._sp && (this._sp._renderType |=/*laya.renders.RenderSprite.GRAPHICS*/0x200);
		if (this._one==null){
			this._one=args;
			this._render=this._renderOne;
			}else {
			this._sp && (this._sp._renderType &=~ /*laya.renders.RenderSprite.IMAGE*/0x01);
			this._render=this._renderAll;
			(this._cmds || (this._cmds=[])).length===0 && this._cmds.push(this._one);
			this._cmds.push(args);
		}
		args.callee=fun;
		this._repaint();
		return args;
	}

	/**
	*设置剪裁区域，超出剪裁区域的坐标不显示。
	*@param x X 轴偏移量。
	*@param y Y 轴偏移量。
	*@param width 宽度。
	*@param height 高度。
	*/
	__proto.clipRect=function(x,y,width,height){
		this._saveToCmd(Render._context._clipRect,[x,y,width,height]);
	}

	/**
	*在画布上绘制文本。
	*@param text 在画布上输出的文本。
	*@param x 开始绘制文本的 x 坐标位置（相对于画布）。
	*@param y 开始绘制文本的 y 坐标位置（相对于画布）。
	*@param font 定义字号和字体，比如"20px Arial"。
	*@param color 定义文本颜色，比如"#ff0000"。
	*@param textAlign 文本对齐方式，可选值："left"，"center"，"right"。
	*/
	__proto.fillText=function(text,x,y,font,color,textAlign,underLine){
		(underLine===void 0)&& (underLine=0);
		this._saveToCmd(Render._context._fillText,[text,x,y,font || Font.defaultFont,color,textAlign]);
	}

	/**
	*在画布上绘制“被填充且镶边的”文本。
	*@param text 在画布上输出的文本。
	*@param x 开始绘制文本的 x 坐标位置（相对于画布）。
	*@param y 开始绘制文本的 y 坐标位置（相对于画布）。
	*@param font 定义字体和字号，比如"20px Arial"。
	*@param fillColor 定义文本颜色，比如"#ff0000"。
	*@param borderColor 定义镶边文本颜色。
	*@param lineWidth 镶边线条宽度。
	*@param textAlign 文本对齐方式，可选值："left"，"center"，"right"。
	*/
	__proto.fillBorderText=function(text,x,y,font,fillColor,borderColor,lineWidth,textAlign){
		this._saveToCmd(Render._context._fillBorderText,[text,x,y,font || Font.defaultFont,fillColor,borderColor,lineWidth,textAlign]);
	}

	/**
	*在画布上绘制文本（没有填色）。文本的默认颜色是黑色。
	*@param text 在画布上输出的文本。
	*@param x 开始绘制文本的 x 坐标位置（相对于画布）。
	*@param y 开始绘制文本的 y 坐标位置（相对于画布）。
	*@param font 定义字体和字号，比如"20px Arial"。
	*@param color 定义文本颜色，比如"#ff0000"。
	*@param lineWidth 线条宽度。
	*@param textAlign 文本对齐方式，可选值："left"，"center"，"right"。
	*/
	__proto.strokeText=function(text,x,y,font,color,lineWidth,textAlign){
		this._saveToCmd(Render._context._strokeText,[text,x,y,font || Font.defaultFont,color,lineWidth,textAlign]);
	}

	/**
	*设置透明度。
	*@param value 透明度。
	*/
	__proto.alpha=function(value){
		value=value < 0 ? 0 :(value > 1 ? 1 :value);
		this._saveToCmd(Render._context._alpha,[value]);
	}

	/**
	*设置当前透明度。
	*@param value 透明度。
	*/
	__proto.setAlpha=function(value){
		value=value < 0 ? 0 :(value > 1 ? 1 :value);
		this._saveToCmd(Render._context._setAlpha,[value]);
	}

	/**
	*替换绘图的当前转换矩阵。
	*@param mat 矩阵。
	*@param pivotX （可选）水平方向轴心点坐标。
	*@param pivotY （可选）垂直方向轴心点坐标。
	*/
	__proto.transform=function(matrix,pivotX,pivotY){
		(pivotX===void 0)&& (pivotX=0);
		(pivotY===void 0)&& (pivotY=0);
		this._saveToCmd(Render._context._transform,[matrix,pivotX,pivotY]);
	}

	/**
	*旋转当前绘图。(推荐使用transform，性能更高)
	*@param angle 旋转角度，以弧度计。
	*@param pivotX （可选）水平方向轴心点坐标。
	*@param pivotY （可选）垂直方向轴心点坐标。
	*/
	__proto.rotate=function(angle,pivotX,pivotY){
		(pivotX===void 0)&& (pivotX=0);
		(pivotY===void 0)&& (pivotY=0);
		this._saveToCmd(Render._context._rotate,[angle,pivotX,pivotY]);
	}

	/**
	*缩放当前绘图至更大或更小。(推荐使用transform，性能更高)
	*@param scaleX 水平方向缩放值。
	*@param scaleY 垂直方向缩放值。
	*@param pivotX （可选）水平方向轴心点坐标。
	*@param pivotY （可选）垂直方向轴心点坐标。
	*/
	__proto.scale=function(scaleX,scaleY,pivotX,pivotY){
		(pivotX===void 0)&& (pivotX=0);
		(pivotY===void 0)&& (pivotY=0);
		this._saveToCmd(Render._context._scale,[scaleX,scaleY,pivotX,pivotY]);
	}

	/**
	*重新映射画布上的 (0,0)位置。
	*@param x 添加到水平坐标（x）上的值。
	*@param y 添加到垂直坐标（y）上的值。
	*/
	__proto.translate=function(x,y){
		this._saveToCmd(Render._context._translate,[x,y]);
	}

	/**
	*保存当前环境的状态。
	*/
	__proto.save=function(){
		this._saveToCmd(Render._context._save,[]);
	}

	/**
	*返回之前保存过的路径状态和属性。
	*/
	__proto.restore=function(){
		this._saveToCmd(Render._context._restore,[]);
	}

	/**
	*@private
	*替换文本内容。
	*@param text 文本内容。
	*@return 替换成功则值为true，否则值为flase。
	*/
	__proto.replaceText=function(text){
		this._repaint();
		var cmds=this._cmds;
		if (!cmds){
			if (this._one && this._isTextCmd(this._one.callee)){
				if (this._one[0].toUpperCase)this._one[0]=text;
				else this._one[0].setText(text);
				return true;
			}
			}else {
			for (var i=cmds.length-1;i >-1;i--){
				if (this._isTextCmd(cmds[i].callee)){
					if (cmds[i][0].toUpperCase)cmds[i][0]=text;
					else cmds[i][0].setText(text);
					return true;
				}
			}
		}
		return false;
	}

	/**@private */
	__proto._isTextCmd=function(fun){
		return fun===Render._context._fillText || fun===Render._context._fillBorderText || fun===Render._context._strokeText;
	}

	/**
	*@private
	*替换文本颜色。
	*@param color 颜色。
	*/
	__proto.replaceTextColor=function(color){
		this._repaint();
		var cmds=this._cmds;
		if (!cmds){
			if (this._one && this._isTextCmd(this._one.callee)){
				this._one[4]=color;
				if (!this._one[0].toUpperCase)this._one[0].changed=true;
			}
			}else {
			for (var i=cmds.length-1;i >-1;i--){
				if (this._isTextCmd(cmds[i].callee)){
					cmds[i][4]=color;
					if (!cmds[i][0].toUpperCase)cmds[i][0].changed=true;
				}
			}
		}
	}

	/**
	*加载并显示一个图片。
	*@param url 图片地址。
	*@param x （可选）显示图片的x位置。
	*@param y （可选）显示图片的y位置。
	*@param width （可选）显示图片的宽度，设置为0表示使用图片默认宽度。
	*@param height （可选）显示图片的高度，设置为0表示使用图片默认高度。
	*@param complete （可选）加载完成回调。
	*/
	__proto.loadImage=function(url,x,y,width,height,complete){
		var _$this=this;
		(x===void 0)&& (x=0);
		(y===void 0)&& (y=0);
		(width===void 0)&& (width=0);
		(height===void 0)&& (height=0);
		var tex=Loader.getRes(url);
		if (tex)onloaded(tex);
		else Laya.loader.load(url,Handler.create(null,onloaded),null,/*laya.net.Loader.IMAGE*/"image");
		function onloaded (tex){
			if (tex){
				_$this.drawTexture(tex,x,y,width,height);
				if (complete !=null)complete.call(_$this._sp,tex);
			}
		}
	}

	/**
	*@private
	*/
	__proto._renderEmpty=function(sprite,context,x,y){}
	/**
	*@private
	*/
	__proto._renderAll=function(sprite,context,x,y){
		var cmds=this._cmds,cmd;
		for (var i=0,n=cmds.length;i < n;i++){
			(cmd=cmds[i]).callee.call(context,x,y,cmd);
		}
	}

	/**
	*@private
	*/
	__proto._renderOne=function(sprite,context,x,y){
		this._one.callee.call(context,x,y,this._one);
	}

	/**
	*@private
	*/
	__proto._renderOneImg=function(sprite,context,x,y){
		this._one.callee.call(context,x,y,this._one);
		if (sprite._renderType!==2305){
			sprite._renderType |=/*laya.renders.RenderSprite.IMAGE*/0x01;
		}
	}

	/**
	*绘制一条线。
	*@param fromX X轴开始位置。
	*@param fromY Y轴开始位置。
	*@param toX X轴结束位置。
	*@param toY Y轴结束位置。
	*@param lineColor 颜色。
	*@param lineWidth （可选）线条宽度。
	*/
	__proto.drawLine=function(fromX,fromY,toX,toY,lineColor,lineWidth){
		(lineWidth===void 0)&& (lineWidth=1);
		var tId=0;
		if (Render.isWebGL){
			tId=VectorGraphManager.getInstance().getId();
			if (this._vectorgraphArray==null)this._vectorgraphArray=[];
			this._vectorgraphArray.push(tId);
		};
		var offset=lineWidth % 2===0 ? 0 :0.5;
		var arr=[fromX+offset,fromY+offset,toX+offset,toY+offset,lineColor,lineWidth,tId];
		this._saveToCmd(Render._context._drawLine,arr);
	}

	/**
	*绘制一系列线段。
	*@param x 开始绘制的X轴位置。
	*@param y 开始绘制的Y轴位置。
	*@param points 线段的点集合。格式:[x1,y1,x2,y2,x3,y3...]。
	*@param lineColor 线段颜色，或者填充绘图的渐变对象。
	*@param lineWidth （可选）线段宽度。
	*/
	__proto.drawLines=function(x,y,points,lineColor,lineWidth){
		(lineWidth===void 0)&& (lineWidth=1);
		var tId=0;
		if (!points || points.length < 4)return;
		if (Render.isWebGL){
			tId=VectorGraphManager.getInstance().getId();
			if (this._vectorgraphArray==null)this._vectorgraphArray=[];
			this._vectorgraphArray.push(tId);
		};
		var offset=lineWidth % 2===0 ? 0 :0.5;
		var arr=[x+offset,y+offset,points,lineColor,lineWidth,tId];
		this._saveToCmd(Render._context._drawLines,arr);
	}

	/**
	*绘制一系列曲线。
	*@param x 开始绘制的 X 轴位置。
	*@param y 开始绘制的 Y 轴位置。
	*@param points 线段的点集合，格式[startx,starty,ctrx,ctry,startx,starty...]。
	*@param lineColor 线段颜色，或者填充绘图的渐变对象。
	*@param lineWidth （可选）线段宽度。
	*/
	__proto.drawCurves=function(x,y,points,lineColor,lineWidth){
		(lineWidth===void 0)&& (lineWidth=1);
		var arr=[x,y,points,lineColor,lineWidth];
		this._saveToCmd(Render._context._drawCurves,arr);
	}

	/**
	*绘制矩形。
	*@param x 开始绘制的 X 轴位置。
	*@param y 开始绘制的 Y 轴位置。
	*@param width 矩形宽度。
	*@param height 矩形高度。
	*@param fillColor 填充颜色，或者填充绘图的渐变对象。
	*@param lineColor （可选）边框颜色，或者填充绘图的渐变对象。
	*@param lineWidth （可选）边框宽度。
	*/
	__proto.drawRect=function(x,y,width,height,fillColor,lineColor,lineWidth){
		(lineWidth===void 0)&& (lineWidth=1);
		var offset=lineColor ? lineWidth / 2 :0;
		var lineOffset=lineColor ? lineWidth :0;
		var arr=[x+offset,y+offset,width-lineOffset,height-lineOffset,fillColor,lineColor,lineWidth];
		this._saveToCmd(Render._context._drawRect,arr);
	}

	/**
	*绘制圆形。
	*@param x 圆点X 轴位置。
	*@param y 圆点Y 轴位置。
	*@param radius 半径。
	*@param fillColor 填充颜色，或者填充绘图的渐变对象。
	*@param lineColor （可选）边框颜色，或者填充绘图的渐变对象。
	*@param lineWidth （可选）边框宽度。
	*/
	__proto.drawCircle=function(x,y,radius,fillColor,lineColor,lineWidth){
		(lineWidth===void 0)&& (lineWidth=1);
		var offset=lineColor ? lineWidth / 2 :0;
		var tId=0;
		if (Render.isWebGL){
			tId=VectorGraphManager.getInstance().getId();
			if (this._vectorgraphArray==null)this._vectorgraphArray=[];
			this._vectorgraphArray.push(tId);
		};
		var arr=[x,y,radius-offset,fillColor,lineColor,lineWidth,tId];
		this._saveToCmd(Render._context._drawCircle,arr);
	}

	/**
	*绘制扇形。
	*@param x 开始绘制的 X 轴位置。
	*@param y 开始绘制的 Y 轴位置。
	*@param radius 扇形半径。
	*@param startAngle 开始角度。
	*@param endAngle 结束角度。
	*@param fillColor 填充颜色，或者填充绘图的渐变对象。
	*@param lineColor （可选）边框颜色，或者填充绘图的渐变对象。
	*@param lineWidth （可选）边框宽度。
	*/
	__proto.drawPie=function(x,y,radius,startAngle,endAngle,fillColor,lineColor,lineWidth){
		(lineWidth===void 0)&& (lineWidth=1);
		var offset=lineColor ? lineWidth / 2 :0;
		var lineOffset=lineColor ? lineWidth :0;
		var tId=0;
		if (Render.isWebGL){
			tId=VectorGraphManager.getInstance().getId();
			if (this._vectorgraphArray==null)this._vectorgraphArray=[];
			this._vectorgraphArray.push(tId);
		};
		var arr=[x+offset,y+offset,radius-lineOffset,startAngle,endAngle,fillColor,lineColor,lineWidth,tId];
		arr[3]=Utils.toRadian(startAngle);
		arr[4]=Utils.toRadian(endAngle);
		this._saveToCmd(Render._context._drawPie,arr);
	}

	/**
	*绘制多边形。
	*@param x 开始绘制的 X 轴位置。
	*@param y 开始绘制的 Y 轴位置。
	*@param points 多边形的点集合。
	*@param fillColor 填充颜色，或者填充绘图的渐变对象。
	*@param lineColor （可选）边框颜色，或者填充绘图的渐变对象。
	*@param lineWidth （可选）边框宽度。
	*/
	__proto.drawPoly=function(x,y,points,fillColor,lineColor,lineWidth){
		(lineWidth===void 0)&& (lineWidth=1);
		var tId=0;
		var tIsConvexPolygon=false;
		if (Render.isWebGL){
			tId=VectorGraphManager.getInstance().getId();
			if (this._vectorgraphArray==null)this._vectorgraphArray=[];
			this._vectorgraphArray.push(tId);
			if (points.length > 6){
				tIsConvexPolygon=false;
				}else {
				tIsConvexPolygon=true;
			}
		};
		var offset=lineColor ? (lineWidth % 2===0 ? 0 :0.5):0;
		var arr=[x+offset,y+offset,points,fillColor,lineColor,lineWidth,tId,tIsConvexPolygon];
		this._saveToCmd(Render._context._drawPoly,arr);
	}

	/**
	*绘制路径。
	*@param x 开始绘制的 X 轴位置。
	*@param y 开始绘制的 Y 轴位置。
	*@param paths 路径集合，路径支持以下格式：[["moveTo",x,y],["lineTo",x,y,x,y,x,y],["arcTo",x1,y1,x2,y2,r],["closePath"]]。
	*@param brush （可选）刷子定义，支持以下设置{fillStyle}。
	*@param pen （可选）画笔定义，支持以下设置{strokeStyle,lineWidth,lineJoin,lineCap,miterLimit}。
	*/
	__proto.drawPath=function(x,y,paths,brush,pen){
		var arr=[x,y,paths,brush,pen];
		this._saveToCmd(Render._context._drawPath,arr);
	}

	/**
	*@private
	*命令流。存储了所有绘制命令。
	*/
	__getset(0,__proto,'cmds',function(){
		return this._cmds;
		},function(value){
		this._sp && (this._sp._renderType |=/*laya.renders.RenderSprite.GRAPHICS*/0x200);
		this._cmds=value;
		this._render=this._renderAll;
		this._repaint();
	});

	Graphics.__init__=function(){
		if (Render.isConchNode){
			var from=laya.display.Graphics.prototype;
			var to=Browser.window.ConchGraphics.prototype;
			var list=["clear","destroy","alpha","rotate","transform","scale","translate","save","restore","clipRect","blendMode","fillText","fillBorderText","_fands","drawRect","drawCircle","drawPie","drawPoly","drawPath","drawImageM","drawLine","drawLines","_drawPs","drawCurves","replaceText","replaceTextColor","_fillImage","fillTexture","setSkinMesh","drawParticle","drawImageS"];
			for (var i=0,len=list.length;i <=len;i++){
				var temp=list[i];
				from[temp]=to[temp];
			}
			from._saveToCmd=null;
			if (to.drawImageS){
				from.drawTextures=function (tex,pos){
					if (!tex)return;
					if (!(tex.loaded && tex.bitmap && tex.source)){
						return;
					};
					var uv=tex.uv,w=tex.bitmap.width,h=tex.bitmap.height;
					this.drawImageS(tex.bitmap.source,uv[0] *w,uv[1] *h,(uv[2]-uv[0])*w,(uv[5]-uv[3])*h,tex.offsetX,tex.offsetY,tex.width,tex.height,pos);
				}
			}
			from.drawTexture=function (tex,x,y,width,height,m,alpha){
				(x===void 0)&& (x=0);
				(y===void 0)&& (y=0);
				(width===void 0)&& (width=0);
				(height===void 0)&& (height=0);
				(alpha===void 0)&& (alpha=1);
				if (!tex)return;
				if (!tex.loaded){
					tex.once(/*laya.events.Event.LOADED*/"loaded",this,function(){
						this.drawTexture(tex,x,y,width,height,m);
					});
					return;
				}
				if (!(tex.loaded && tex.bitmap && tex.source)){
					return;
				}
				if (!width)width=tex.sourceWidth;
				if (!height)height=tex.sourceHeight;
				alpha=alpha < 0 ? 0 :(alpha > 1 ? 1 :alpha);
				width=width-tex.sourceWidth+tex.width;
				height=height-tex.sourceHeight+tex.height;
				if (width <=0 || height <=0)return;
				x+=tex.offsetX;
				y+=tex.offsetY;
				var uv=tex.uv,w=tex.bitmap.width,h=tex.bitmap.height;
				this.drawImageM(tex.bitmap.source,uv[0] *w,uv[1] *h,(uv[2]-uv[0])*w,(uv[5]-uv[3])*h,x,y,width,height,m,alpha);
				this._repaint();
			}
			from.fillTexture=function (tex,x,y,width,height,type,offset){
				(width===void 0)&& (width=0);
				(height===void 0)&& (height=0);
				(type===void 0)&& (type="repeat");
				if (!tex)return;
				if (tex.loaded){
					var ctxi=Render._context.ctx;
					var w=tex.bitmap.width,h=tex.bitmap.height,uv=tex.uv;
					var pat;
					if (tex.uv !=Texture.DEF_UV){
						pat=ctxi.createPattern(tex.bitmap.source,type,uv[0] *w,uv[1] *h,(uv[2]-uv[0])*w,(uv[5]-uv[3])*h);
						}else {
						pat=ctxi.createPattern(tex.bitmap.source,type);
					};
					var sX=0,sY=0;
					if (offset){
						x+=offset.x % tex.width;
						y+=offset.y % tex.height;
						sX-=offset.x % tex.width;
						sY-=offset.y % tex.height;
					}
					this._fillImage(pat,x,y,sX,sY,width,height);
				}
			}
		}
	}

	Graphics._cache=[];
	return Graphics;
})()


/**
*@private
*Graphic bounds数据类
*/
//class laya.display.GraphicsBounds
var GraphicsBounds=(function(){
	function GraphicsBounds(){
		/**@private */
		//this._temp=null;
		/**@private */
		//this._bounds=null;
		/**@private */
		//this._rstBoundPoints=null;
		/**@private */
		this._cacheBoundsType=false;
		/**@private */
		//this._graphics=null;
	}

	__class(GraphicsBounds,'laya.display.GraphicsBounds');
	var __proto=GraphicsBounds.prototype;
	/**
	*销毁
	*/
	__proto.destroy=function(){
		this._graphics=null;
		this._temp=null;
		this._rstBoundPoints=null;
		this._bounds=null;
	}

	/**
	*重置数据
	*/
	__proto.reset=function(){
		this._temp && (this._temp.length=0);
	}

	/**
	*获取位置及宽高信息矩阵(比较耗CPU，频繁使用会造成卡顿，尽量少用)。
	*@param realSize （可选）使用图片的真实大小，默认为false
	*@return 位置与宽高组成的 一个 Rectangle 对象。
	*/
	__proto.getBounds=function(realSize){
		(realSize===void 0)&& (realSize=false);
		if (!this._bounds || !this._temp || this._temp.length < 1 || realSize !=this._cacheBoundsType){
			this._bounds=Rectangle._getWrapRec(this.getBoundPoints(realSize),this._bounds)
		}
		this._cacheBoundsType=realSize;
		return this._bounds;
	}

	/**
	*@private
	*@param realSize （可选）使用图片的真实大小，默认为false
	*获取端点列表。
	*/
	__proto.getBoundPoints=function(realSize){
		(realSize===void 0)&& (realSize=false);
		if (!this._temp || this._temp.length < 1 || realSize !=this._cacheBoundsType)
			this._temp=this._getCmdPoints(realSize);
		this._cacheBoundsType=realSize;
		return this._rstBoundPoints=Utils.copyArray(this._rstBoundPoints,this._temp);
	}

	__proto._getCmdPoints=function(realSize){
		(realSize===void 0)&& (realSize=false);
		var context=Render._context;
		var cmds=this._graphics.cmds;
		var rst;
		rst=this._temp || (this._temp=[]);
		rst.length=0;
		if (!cmds && this._graphics._one !=null){
			GraphicsBounds._tempCmds.length=0;
			GraphicsBounds._tempCmds.push(this._graphics._one);
			cmds=GraphicsBounds._tempCmds;
		}
		if (!cmds)
			return rst;
		var matrixs;
		matrixs=GraphicsBounds._tempMatrixArrays;
		matrixs.length=0;
		var tMatrix=GraphicsBounds._initMatrix;
		tMatrix.identity();
		var tempMatrix=GraphicsBounds._tempMatrix;
		var cmd;
		var tex;
		var wRate=NaN;
		var hRate=NaN;
		var oWidth=NaN;
		var oHeight=NaN;
		var offX=NaN;
		var offY=NaN;
		for (var i=0,n=cmds.length;i < n;i++){
			cmd=cmds[i];
			if (!cmd.callee)continue ;
			switch (cmd.callee){
				case context._save:
				case 7:
					matrixs.push(tMatrix);
					tMatrix=tMatrix.clone();
					break ;
				case context._restore:
				case 8:
					tMatrix=matrixs.pop();
					break ;
				case context._scale:
				case 5:
					tempMatrix.identity();
					tempMatrix.translate(-cmd[2],-cmd[3]);
					tempMatrix.scale(cmd[0],cmd[1]);
					tempMatrix.translate(cmd[2],cmd[3]);
					this._switchMatrix(tMatrix,tempMatrix);
					break ;
				case context._rotate:
				case 3:
					tempMatrix.identity();
					tempMatrix.translate(-cmd[1],-cmd[2]);
					tempMatrix.rotate(cmd[0]);
					tempMatrix.translate(cmd[1],cmd[2]);
					this._switchMatrix(tMatrix,tempMatrix);
					break ;
				case context._translate:
				case 6:
					tempMatrix.identity();
					tempMatrix.translate(cmd[0],cmd[1]);
					this._switchMatrix(tMatrix,tempMatrix);
					break ;
				case context._transform:
				case 4:
					tempMatrix.identity();
					tempMatrix.translate(-cmd[1],-cmd[2]);
					tempMatrix.concat(cmd[0]);
					tempMatrix.translate(cmd[1],cmd[2]);
					this._switchMatrix(tMatrix,tempMatrix);
					break ;
				case 16:
				case 24:
					GraphicsBounds._addPointArrToRst(rst,Rectangle._getBoundPointS(cmd[0],cmd[1],cmd[2],cmd[3]),tMatrix);
					break ;
				case 17:
					tMatrix.copyTo(tempMatrix);
					tempMatrix.concat(cmd[4]);
					GraphicsBounds._addPointArrToRst(rst,Rectangle._getBoundPointS(cmd[0],cmd[1],cmd[2],cmd[3]),tempMatrix);
					break ;
				case context._drawTexture:
					tex=cmd[0];
					if (realSize){
						if (cmd[3] && cmd[4]){
							GraphicsBounds._addPointArrToRst(rst,Rectangle._getBoundPointS(cmd[1],cmd[2],cmd[3],cmd[4]),tMatrix);
							}else {
							tex=cmd[0];
							GraphicsBounds._addPointArrToRst(rst,Rectangle._getBoundPointS(cmd[1],cmd[2],tex.width,tex.height),tMatrix);
						}
						}else {
						wRate=(cmd[3] || tex.sourceWidth)/ tex.width;
						hRate=(cmd[4] || tex.sourceHeight)/ tex.height;
						oWidth=wRate *tex.sourceWidth;
						oHeight=hRate *tex.sourceHeight;
						offX=tex.offsetX > 0 ? tex.offsetX :0;
						offY=tex.offsetY > 0 ? tex.offsetY :0;
						offX *=wRate;
						offY *=hRate;
						GraphicsBounds._addPointArrToRst(rst,Rectangle._getBoundPointS(cmd[1]-offX,cmd[2]-offY,oWidth,oHeight),tMatrix);
					}
					break ;
				case context._fillTexture:
					if (cmd[3] && cmd[4]){
						GraphicsBounds._addPointArrToRst(rst,Rectangle._getBoundPointS(cmd[1],cmd[2],cmd[3],cmd[4]),tMatrix);
						}else {
						tex=cmd[0];
						GraphicsBounds._addPointArrToRst(rst,Rectangle._getBoundPointS(cmd[1],cmd[2],tex.width,tex.height),tMatrix);
					}
					break ;
				case context._drawTextureWithTransform:;
					var drawMatrix;
					if (cmd[5]){
						tMatrix.copyTo(tempMatrix);
						tempMatrix.concat(cmd[5]);
						drawMatrix=tempMatrix;
						}else {
						drawMatrix=tMatrix;
					}
					if (realSize){
						if (cmd[3] && cmd[4]){
							GraphicsBounds._addPointArrToRst(rst,Rectangle._getBoundPointS(cmd[1],cmd[2],cmd[3],cmd[4]),drawMatrix);
							}else {
							tex=cmd[0];
							GraphicsBounds._addPointArrToRst(rst,Rectangle._getBoundPointS(cmd[1],cmd[2],tex.width,tex.height),drawMatrix);
						}
						}else {
						tex=cmd[0];
						wRate=(cmd[3] || tex.sourceWidth)/ tex.width;
						hRate=(cmd[4] || tex.sourceHeight)/ tex.height;
						oWidth=wRate *tex.sourceWidth;
						oHeight=hRate *tex.sourceHeight;
						offX=tex.offsetX > 0 ? tex.offsetX :0;
						offY=tex.offsetY > 0 ? tex.offsetY :0;
						offX *=wRate;
						offY *=hRate;
						GraphicsBounds._addPointArrToRst(rst,Rectangle._getBoundPointS(cmd[1]-offX,cmd[2]-offY,oWidth,oHeight),drawMatrix);
					}
					break ;
				case context._drawRect:
				case 13:
					GraphicsBounds._addPointArrToRst(rst,Rectangle._getBoundPointS(cmd[0],cmd[1],cmd[2],cmd[3]),tMatrix);
					break ;
				case context._drawCircle:
				case context._fillCircle:
				case 14:
					GraphicsBounds._addPointArrToRst(rst,Rectangle._getBoundPointS(cmd[0]-cmd[2],cmd[1]-cmd[2],cmd[2]+cmd[2],cmd[2]+cmd[2]),tMatrix);
					break ;
				case context._drawLine:
				case 20:
					GraphicsBounds._tempPoints.length=0;
					var lineWidth=NaN;
					lineWidth=cmd[5] *0.5;
					if (cmd[0]==cmd[2]){
						GraphicsBounds._tempPoints.push(cmd[0]+lineWidth,cmd[1],cmd[2]+lineWidth,cmd[3],cmd[0]-lineWidth,cmd[1],cmd[2]-lineWidth,cmd[3]);
						}else if (cmd[1]==cmd[3]){
						GraphicsBounds._tempPoints.push(cmd[0],cmd[1]+lineWidth,cmd[2],cmd[3]+lineWidth,cmd[0],cmd[1]-lineWidth,cmd[2],cmd[3]-lineWidth);
						}else {
						GraphicsBounds._tempPoints.push(cmd[0],cmd[1],cmd[2],cmd[3]);
					}
					GraphicsBounds._addPointArrToRst(rst,GraphicsBounds._tempPoints,tMatrix);
					break ;
				case context._drawCurves:
				case 22:
					GraphicsBounds._addPointArrToRst(rst,Bezier.I.getBezierPoints(cmd[2]),tMatrix,cmd[0],cmd[1]);
					break ;
				case context._drawPoly:
				case context._drawLines:
				case 18:
					GraphicsBounds._addPointArrToRst(rst,cmd[2],tMatrix,cmd[0],cmd[1]);
					break ;
				case context._drawPath:
				case 19:
					GraphicsBounds._addPointArrToRst(rst,this._getPathPoints(cmd[2]),tMatrix,cmd[0],cmd[1]);
					break ;
				case context._drawPie:
				case 15:
					GraphicsBounds._addPointArrToRst(rst,this._getPiePoints(cmd[0],cmd[1],cmd[2],cmd[3],cmd[4]),tMatrix);
					break ;
				}
		}
		if (rst.length > 200){
			rst=Utils.copyArray(rst,Rectangle._getWrapRec(rst)._getBoundPoints());
		}else if (rst.length > 8)
		rst=GrahamScan.scanPList(rst);
		return rst;
	}

	__proto._switchMatrix=function(tMatix,tempMatrix){
		tempMatrix.concat(tMatix);
		tempMatrix.copyTo(tMatix);
	}

	__proto._getPiePoints=function(x,y,radius,startAngle,endAngle){
		var rst=GraphicsBounds._tempPoints;
		GraphicsBounds._tempPoints.length=0;
		rst.push(x,y);
		var delta=(endAngle-startAngle)% (2 *Math.PI);
		var segnum=10;
		var step=delta / segnum;
		var i=NaN;
		var angle=startAngle;
		for (i=0;i <=segnum;i++){
			rst.push(x+radius *Math.cos(angle),y+radius *Math.sin(angle));
			angle+=step;
		}
		return rst;
	}

	__proto._getPathPoints=function(paths){
		var i=0,len=0;
		var rst=GraphicsBounds._tempPoints;
		rst.length=0;
		len=paths.length;
		var tCMD;
		for (i=0;i < len;i++){
			tCMD=paths[i];
			if (tCMD.length > 1){
				rst.push(tCMD[1],tCMD[2]);
				if (tCMD.length > 3){
					rst.push(tCMD[3],tCMD[4]);
				}
			}
		}
		return rst;
	}

	GraphicsBounds._addPointArrToRst=function(rst,points,matrix,dx,dy){
		(dx===void 0)&& (dx=0);
		(dy===void 0)&& (dy=0);
		var i=0,len=0;
		len=points.length;
		for (i=0;i < len;i+=2){
			GraphicsBounds._addPointToRst(rst,points[i]+dx,points[i+1]+dy,matrix);
		}
	}

	GraphicsBounds._addPointToRst=function(rst,x,y,matrix){
		var _tempPoint=Point.TEMP;
		_tempPoint.setTo(x ? x :0,y ? y :0);
		matrix.transformPoint(_tempPoint);
		rst.push(_tempPoint.x,_tempPoint.y);
	}

	GraphicsBounds._tempPoints=[];
	GraphicsBounds._tempMatrixArrays=[];
	GraphicsBounds._tempCmds=[];
	__static(GraphicsBounds,
	['_tempMatrix',function(){return this._tempMatrix=new Matrix();},'_initMatrix',function(){return this._initMatrix=new Matrix();}
	]);
	return GraphicsBounds;
})()


/**
*<code>Event</code> 是事件类型的集合。一般当发生事件时，<code>Event</code> 对象将作为参数传递给事件侦听器。
*/
//class laya.events.Event
var Event=(function(){
	function Event(){
		/**事件类型。*/
		//this.type=null;
		/**原生浏览器事件。*/
		//this.nativeEvent=null;
		/**事件目标触发对象。*/
		//this.target=null;
		/**事件当前冒泡对象。*/
		//this.currentTarget=null;
		/**@private */
		//this._stoped=false;
		/**分配给触摸点的唯一标识号（作为 int）。*/
		//this.touchId=0;
		/**键盘值*/
		//this.keyCode=0;
		/**滚轮滑动增量*/
		//this.delta=0;
	}

	__class(Event,'laya.events.Event');
	var __proto=Event.prototype;
	/**
	*设置事件数据。
	*@param type 事件类型。
	*@param currentTarget 事件目标触发对象。
	*@param target 事件当前冒泡对象。
	*@return 返回当前 Event 对象。
	*/
	__proto.setTo=function(type,currentTarget,target){
		this.type=type;
		this.currentTarget=currentTarget;
		this.target=target;
		return this;
	}

	/**
	*阻止对事件流中当前节点的后续节点中的所有事件侦听器进行处理。此方法不会影响当前节点 (currentTarget)中的任何事件侦听器。
	*/
	__proto.stopPropagation=function(){
		this._stoped=true;
	}

	/**鼠标在 Stage 上的 Y 轴坐标*/
	__getset(0,__proto,'stageY',function(){
		return Laya.stage.mouseY;
	});

	/**
	*包含按下或释放的键的字符代码值。字符代码值为英文键盘值。
	*/
	__getset(0,__proto,'charCode',function(){
		return this.nativeEvent.charCode;
	});

	/**
	*触摸点列表。
	*/
	__getset(0,__proto,'touches',function(){
		var arr=this.nativeEvent.touches;
		if (arr){
			var stage=Laya.stage;
			for (var i=0,n=arr.length;i < n;i++){
				var e=arr[i];
				var point=Point.TEMP;
				point.setTo(e.clientX,e.clientY);
				stage._canvasTransform.invertTransformPoint(point);
				stage.transform.invertTransformPoint(point);
				e.stageX=point.x;
				e.stageY=point.y;
			}
		}
		return arr;
	});

	/**
	*表示键在键盘上的位置。这对于区分在键盘上多次出现的键非常有用。<br>
	*例如，您可以根据此属性的值来区分左 Shift 键和右 Shift 键：左 Shift 键的值为 KeyLocation.LEFT，右 Shift 键的值为 KeyLocation.RIGHT。另一个示例是区分标准键盘 (KeyLocation.STANDARD)与数字键盘 (KeyLocation.NUM_PAD)上按下的数字键。
	*/
	__getset(0,__proto,'keyLocation',function(){
		return this.nativeEvent.keyLocation;
	});

	/**
	*表示 Ctrl 键是处于活动状态 (true)还是非活动状态 (false)。
	*/
	__getset(0,__proto,'ctrlKey',function(){
		return this.nativeEvent.ctrlKey;
	});

	/**
	*表示 Alt 键是处于活动状态 (true)还是非活动状态 (false)。
	*/
	__getset(0,__proto,'altKey',function(){
		return this.nativeEvent.altKey;
	});

	/**
	*表示 Shift 键是处于活动状态 (true)还是非活动状态 (false)。
	*/
	__getset(0,__proto,'shiftKey',function(){
		return this.nativeEvent.shiftKey;
	});

	/**鼠标在 Stage 上的 X 轴坐标*/
	__getset(0,__proto,'stageX',function(){
		return Laya.stage.mouseX;
	});

	Event.EMPTY=new Event();
	Event.MOUSE_DOWN="mousedown";
	Event.MOUSE_UP="mouseup";
	Event.CLICK="click";
	Event.RIGHT_MOUSE_DOWN="rightmousedown";
	Event.RIGHT_MOUSE_UP="rightmouseup";
	Event.RIGHT_CLICK="rightclick";
	Event.MOUSE_MOVE="mousemove";
	Event.MOUSE_OVER="mouseover";
	Event.MOUSE_OUT="mouseout";
	Event.MOUSE_WHEEL="mousewheel";
	Event.ROLL_OVER="mouseover";
	Event.ROLL_OUT="mouseout";
	Event.DOUBLE_CLICK="doubleclick";
	Event.CHANGE="change";
	Event.CHANGED="changed";
	Event.RESIZE="resize";
	Event.ADDED="added";
	Event.REMOVED="removed";
	Event.DISPLAY="display";
	Event.UNDISPLAY="undisplay";
	Event.ERROR="error";
	Event.COMPLETE="complete";
	Event.LOADED="loaded";
	Event.PROGRESS="progress";
	Event.INPUT="input";
	Event.RENDER="render";
	Event.OPEN="open";
	Event.MESSAGE="message";
	Event.CLOSE="close";
	Event.KEY_DOWN="keydown";
	Event.KEY_PRESS="keypress";
	Event.KEY_UP="keyup";
	Event.FRAME="enterframe";
	Event.DRAG_START="dragstart";
	Event.DRAG_MOVE="dragmove";
	Event.DRAG_END="dragend";
	Event.ENTER="enter";
	Event.SELECT="select";
	Event.BLUR="blur";
	Event.FOCUS="focus";
	Event.VISIBILITY_CHANGE="visibilitychange";
	Event.FOCUS_CHANGE="focuschange";
	Event.PLAYED="played";
	Event.PAUSED="paused";
	Event.STOPPED="stopped";
	Event.START="start";
	Event.END="end";
	Event.ENABLE_CHANGED="enablechanged";
	Event.ACTIVE_IN_HIERARCHY_CHANGED="activeinhierarchychanged";
	Event.COMPONENT_ADDED="componentadded";
	Event.COMPONENT_REMOVED="componentremoved";
	Event.LAYER_CHANGED="layerchanged";
	Event.HIERARCHY_LOADED="hierarchyloaded";
	Event.RECOVERED="recovered";
	Event.RELEASED="released";
	Event.LINK="link";
	Event.LABEL="label";
	Event.FULL_SCREEN_CHANGE="fullscreenchange";
	Event.DEVICE_LOST="devicelost";
	Event.MESH_CHANGED="meshchanged";
	Event.MATERIAL_CHANGED="materialchanged";
	Event.WORLDMATRIX_NEEDCHANGE="worldmatrixneedchanged";
	Event.ANIMATION_CHANGED="animationchanged";
	Event.TRIGGER_ENTER="triggerenter";
	Event.TRIGGER_STAY="triggerstay";
	Event.TRIGGER_EXIT="triggerexit";
	Event.TRAIL_FILTER_CHANGE="trailfilterchange";
	Event.DOMINO_FILTER_CHANGE="dominofilterchange";
	return Event;
})()


/**
*<code>Keyboard</code> 类的属性是一些常数，这些常数表示控制游戏时最常用的键。
*/
//class laya.events.Keyboard
var Keyboard=(function(){
	function Keyboard(){}
	__class(Keyboard,'laya.events.Keyboard');
	Keyboard.NUMBER_0=48;
	Keyboard.NUMBER_1=49;
	Keyboard.NUMBER_2=50;
	Keyboard.NUMBER_3=51;
	Keyboard.NUMBER_4=52;
	Keyboard.NUMBER_5=53;
	Keyboard.NUMBER_6=54;
	Keyboard.NUMBER_7=55;
	Keyboard.NUMBER_8=56;
	Keyboard.NUMBER_9=57;
	Keyboard.A=65;
	Keyboard.B=66;
	Keyboard.C=67;
	Keyboard.D=68;
	Keyboard.E=69;
	Keyboard.F=70;
	Keyboard.G=71;
	Keyboard.H=72;
	Keyboard.I=73;
	Keyboard.J=74;
	Keyboard.K=75;
	Keyboard.L=76;
	Keyboard.M=77;
	Keyboard.N=78;
	Keyboard.O=79;
	Keyboard.P=80;
	Keyboard.Q=81;
	Keyboard.R=82;
	Keyboard.S=83;
	Keyboard.T=84;
	Keyboard.U=85;
	Keyboard.V=86;
	Keyboard.W=87;
	Keyboard.X=88;
	Keyboard.Y=89;
	Keyboard.Z=90;
	Keyboard.F1=112;
	Keyboard.F2=113;
	Keyboard.F3=114;
	Keyboard.F4=115;
	Keyboard.F5=116;
	Keyboard.F6=117;
	Keyboard.F7=118;
	Keyboard.F8=119;
	Keyboard.F9=120;
	Keyboard.F10=121;
	Keyboard.F11=122;
	Keyboard.F12=123;
	Keyboard.F13=124;
	Keyboard.F14=125;
	Keyboard.F15=126;
	Keyboard.NUMPAD=21;
	Keyboard.NUMPAD_0=96;
	Keyboard.NUMPAD_1=97;
	Keyboard.NUMPAD_2=98;
	Keyboard.NUMPAD_3=99;
	Keyboard.NUMPAD_4=100;
	Keyboard.NUMPAD_5=101;
	Keyboard.NUMPAD_6=102;
	Keyboard.NUMPAD_7=103;
	Keyboard.NUMPAD_8=104;
	Keyboard.NUMPAD_9=105;
	Keyboard.NUMPAD_ADD=107;
	Keyboard.NUMPAD_DECIMAL=110;
	Keyboard.NUMPAD_DIVIDE=111;
	Keyboard.NUMPAD_ENTER=108;
	Keyboard.NUMPAD_MULTIPLY=106;
	Keyboard.NUMPAD_SUBTRACT=109;
	Keyboard.SEMICOLON=186;
	Keyboard.EQUAL=187;
	Keyboard.COMMA=188;
	Keyboard.MINUS=189;
	Keyboard.PERIOD=190;
	Keyboard.SLASH=191;
	Keyboard.BACKQUOTE=192;
	Keyboard.LEFTBRACKET=219;
	Keyboard.BACKSLASH=220;
	Keyboard.RIGHTBRACKET=221;
	Keyboard.QUOTE=222;
	Keyboard.ALTERNATE=18;
	Keyboard.BACKSPACE=8;
	Keyboard.CAPS_LOCK=20;
	Keyboard.COMMAND=15;
	Keyboard.CONTROL=17;
	Keyboard.DELETE=46;
	Keyboard.ENTER=13;
	Keyboard.ESCAPE=27;
	Keyboard.PAGE_UP=33;
	Keyboard.PAGE_DOWN=34;
	Keyboard.END=35;
	Keyboard.HOME=36;
	Keyboard.LEFT=37;
	Keyboard.UP=38;
	Keyboard.RIGHT=39;
	Keyboard.DOWN=40;
	Keyboard.SHIFT=16;
	Keyboard.SPACE=32;
	Keyboard.TAB=9;
	Keyboard.INSERT=45;
	return Keyboard;
})()


/**
*<p><code>KeyBoardManager</code> 是键盘事件管理类。该类从浏览器中接收键盘事件，并派发该事件。</p>
*<p>派发事件时若 Stage.focus 为空则只从 Stage 上派发该事件，否则将从 Stage.focus 对象开始一直冒泡派发该事件。所以在 Laya.stage 上监听键盘事件一定能够收到，如果在其他地方监听，则必须处在Stage.focus的冒泡链上才能收到该事件。</p>
*<p>用户可以通过代码 Laya.stage.focus=someNode 的方式来设置focus对象。</p>
*<p>用户可统一的根据事件对象中 e.keyCode 来判断按键类型，该属性兼容了不同浏览器的实现。</p>
*/
//class laya.events.KeyBoardManager
var KeyBoardManager=(function(){
	function KeyBoardManager(){}
	__class(KeyBoardManager,'laya.events.KeyBoardManager');
	KeyBoardManager.__init__=function(){
		KeyBoardManager._addEvent("keydown");
		KeyBoardManager._addEvent("keypress");
		KeyBoardManager._addEvent("keyup");
	}

	KeyBoardManager._addEvent=function(type){
		Browser.document.addEventListener(type,function(e){
			laya.events.KeyBoardManager._dispatch(e,type);
		},true);
	}

	KeyBoardManager._dispatch=function(e,type){
		if (!KeyBoardManager.enabled)return;
		KeyBoardManager._event._stoped=false;
		KeyBoardManager._event.nativeEvent=e;
		KeyBoardManager._event.keyCode=e.keyCode || e.which || e.charCode;
		if (type==="keydown")KeyBoardManager._pressKeys[KeyBoardManager._event.keyCode]=true;
		else if (type==="keyup")KeyBoardManager._pressKeys[KeyBoardManager._event.keyCode]=null;
		var target=(Laya.stage.focus && (Laya.stage.focus.event !=null)&& Laya.stage.focus.displayedInStage)? Laya.stage.focus :Laya.stage;
		var ct=target;
		while (ct){
			ct.event(type,KeyBoardManager._event.setTo(type,ct,target));
			ct=ct.parent;
		}
	}

	KeyBoardManager.hasKeyDown=function(key){
		return KeyBoardManager._pressKeys[key];
	}

	KeyBoardManager._pressKeys={};
	KeyBoardManager.enabled=true;
	__static(KeyBoardManager,
	['_event',function(){return this._event=new Event();}
	]);
	return KeyBoardManager;
})()


/**
*<p><code>KeyLocation</code> 类包含表示在键盘或类似键盘的输入设备上按键位置的常量。</p>
*<p><code>KeyLocation</code> 常数用在键盘事件对象的 <code>keyLocation </code>属性中。</p>
*/
//class laya.events.KeyLocation
var KeyLocation=(function(){
	function KeyLocation(){}
	__class(KeyLocation,'laya.events.KeyLocation');
	KeyLocation.STANDARD=0;
	KeyLocation.LEFT=1;
	KeyLocation.RIGHT=2;
	KeyLocation.NUM_PAD=3;
	return KeyLocation;
})()


/**
*<p><code>MouseManager</code> 是鼠标、触摸交互管理器。</p>
*<p>鼠标事件流包括捕获阶段、目标阶段、冒泡阶段。<br/>
*捕获阶段：此阶段引擎会从stage开始递归检测stage及其子对象，直到找到命中的目标对象或者未命中任何对象；<br/>
*目标阶段：找到命中的目标对象；<br/>
*冒泡阶段：事件离开目标对象，按节点层级向上逐层通知，直到到达舞台的过程。</p>
*/
//class laya.events.MouseManager
var MouseManager=(function(){
	function MouseManager(){
		/**canvas 上的鼠标X坐标。*/
		this.mouseX=0;
		/**canvas 上的鼠标Y坐标。*/
		this.mouseY=0;
		/**是否禁用除 stage 以外的鼠标事件检测。*/
		this.disableMouseEvent=false;
		/**鼠标按下的时间。单位为毫秒。*/
		this.mouseDownTime=0;
		/**鼠标移动精度。*/
		this.mouseMoveAccuracy=2;
		this._stage=null;
		this._target=null;
		this._lastMoveTimer=0;
		this._isLeftMouse=false;
		this._eventList=[];
		this._touchIDs={};
		this._id=1;
		this._tTouchID=0;
		this._event=new Event();
		this._matrix=new Matrix();
		this._point=new Point();
		this._rect=new Rectangle();
		this._prePoint=new Point();
		this._curTouchID=NaN;
	}

	__class(MouseManager,'laya.events.MouseManager');
	var __proto=MouseManager.prototype;
	/**
	*@private
	*初始化。
	*/
	__proto.__init__=function(stage,canvas){
		var _$this=this;
		this._stage=stage;
		var _this=this;
		var list=this._eventList;
		canvas.oncontextmenu=function (e){
			if (MouseManager.enabled)return false;
		}
		canvas.addEventListener('mousedown',function(e){
			if (MouseManager.enabled){
				if(!Browser.onIE)e.preventDefault();
				list.push(e);
				_this.mouseDownTime=Browser.now();
			}
		});
		canvas.addEventListener('mouseup',function(e){
			if (MouseManager.enabled){
				e.preventDefault();
				list.push(e);
				_this.mouseDownTime=-Browser.now();
			}
		},true);
		canvas.addEventListener('mousemove',function(e){
			if (MouseManager.enabled){
				e.preventDefault();
				var now=Browser.now();
				if (now-_this._lastMoveTimer < 10)return;
				_this._lastMoveTimer=now;
				list.push(e);
			}
		},true);
		canvas.addEventListener("mouseout",function(e){
			if (MouseManager.enabled)list.push(e);
		})
		canvas.addEventListener("mouseover",function(e){
			if (MouseManager.enabled)list.push(e);
		})
		canvas.addEventListener("touchstart",function(e){
			if (MouseManager.enabled){
				list.push(e);
				if (!MouseManager._isFirstTouch&&!Input.isInputting)e.preventDefault();
				_this.mouseDownTime=Browser.now();
			}
		});
		canvas.addEventListener("touchend",function(e){
			if (MouseManager.enabled){
				if (!MouseManager._isFirstTouch&&!Input.isInputting)e.preventDefault();
				MouseManager._isFirstTouch=false;
				list.push(e);
				_this.mouseDownTime=-Browser.now();
				}else {
				_$this._curTouchID=NaN;
			}
		},true);
		canvas.addEventListener("touchmove",function(e){
			if (MouseManager.enabled){
				e.preventDefault();
				list.push(e);
			}
		},true);
		canvas.addEventListener("touchcancel",function(e){
			if (MouseManager.enabled){
				e.preventDefault();
				list.push(e);
				}else {
				_$this._curTouchID=NaN;
			}
		},true);
		canvas.addEventListener('mousewheel',function(e){
			if (MouseManager.enabled)list.push(e);
		});
		canvas.addEventListener('DOMMouseScroll',function(e){
			if (MouseManager.enabled)list.push(e);
		});
	}

	__proto.initEvent=function(e,nativeEvent){
		var _this=this;
		_this._event._stoped=false;
		_this._event.nativeEvent=nativeEvent || e;
		_this._target=null;
		this._point.setTo(e.pageX || e.clientX,e.pageY || e.clientY);
		this._stage._canvasTransform.invertTransformPoint(this._point);
		_this.mouseX=this._point.x;
		_this.mouseY=this._point.y;
		_this._event.touchId=e.identifier || 0;
		this._tTouchID=_this._event.touchId;
		var evt;
		evt=TouchManager.I._event;
		evt._stoped=false;
		evt.nativeEvent=_this._event.nativeEvent;
		evt.touchId=_this._event.touchId;
	}

	__proto.checkMouseWheel=function(e){
		this._event.delta=e.wheelDelta ? e.wheelDelta *0.025 :-e.detail;
		var _lastOvers=TouchManager.I.getLastOvers();
		for (var i=0,n=_lastOvers.length;i < n;i++){
			var ele=_lastOvers[i];
			ele.event(/*laya.events.Event.MOUSE_WHEEL*/"mousewheel",this._event.setTo(/*laya.events.Event.MOUSE_WHEEL*/"mousewheel",ele,this._target));
		}
	}

	// _stage.event(Event.MOUSE_WHEEL,_event.setTo(Event.MOUSE_WHEEL,_stage,_target));
	__proto.onMouseMove=function(ele){
		TouchManager.I.onMouseMove(ele,this._tTouchID);
	}

	__proto.onMouseDown=function(ele){
		if (Input.isInputting && Laya.stage.focus && Laya.stage.focus["focus"] && !Laya.stage.focus.contains(this._target)){
			var pre_input=Laya.stage.focus['_tf'] || Laya.stage.focus;
			var new_input=ele['_tf'] || ele;
			if ((new_input instanceof laya.display.Input )&& new_input.multiline==pre_input.multiline)
				pre_input['_focusOut']();
			else
			pre_input.focus=false;
		}
		TouchManager.I.onMouseDown(ele,this._tTouchID,this._isLeftMouse);
	}

	__proto.onMouseUp=function(ele){
		TouchManager.I.onMouseUp(ele,this._tTouchID,this._isLeftMouse);
	}

	__proto.check=function(sp,mouseX,mouseY,callBack){
		this._point.setTo(mouseX,mouseY);
		sp.fromParentPoint(this._point);
		mouseX=this._point.x;
		mouseY=this._point.y;
		var scrollRect=sp.scrollRect;
		if (scrollRect){
			this._rect.setTo(scrollRect.x,scrollRect.y,scrollRect.width,scrollRect.height);
			if (!this._rect.contains(mouseX,mouseY))return false;
		}
		if (!this.disableMouseEvent){
			if (sp.hitTestPrior && !sp.mouseThrough && !this.hitTest(sp,mouseX,mouseY)){
				return false;
			}
			for (var i=sp._childs.length-1;i >-1;i--){
				var child=sp._childs[i];
				if (!child.destroyed && child.mouseEnabled && child.visible){
					if (this.check(child,mouseX,mouseY,callBack))return true;
				}
			}
		};
		var isHit=(sp.hitTestPrior && !sp.mouseThrough && !this.disableMouseEvent)? true :this.hitTest(sp,mouseX,mouseY);
		if (isHit){
			this._target=sp;
			callBack.call(this,sp);
			}else if (callBack===this.onMouseUp && sp===this._stage){
			this._target=this._stage;
			callBack.call(this,this._target);
		}
		return isHit;
	}

	__proto.hitTest=function(sp,mouseX,mouseY){
		var isHit=false;
		if (sp.scrollRect){
			mouseX-=sp.scrollRect.x;
			mouseY-=sp.scrollRect.y;
		}
		if ((sp.hitArea instanceof laya.utils.HitArea )){
			return sp.hitArea.isHit(mouseX,mouseY);
		}
		if (sp.width > 0 && sp.height > 0 || sp.mouseThrough || sp.hitArea){
			if (!sp.mouseThrough){
				var hitRect=this._rect;
				if (sp.hitArea)hitRect=sp.hitArea;
				else hitRect.setTo(0,0,sp.width,sp.height);
				isHit=hitRect.contains(mouseX,mouseY);
				}else {
				isHit=sp.getGraphicBounds().contains(mouseX,mouseY);
			}
		}
		return isHit;
	}

	/**
	*执行事件处理。
	*/
	__proto.runEvent=function(){
		var len=this._eventList.length;
		if (!len)return;
		var _this=this;
		var i=0,j=0,n=0,touch;
		while (i < len){
			var evt=this._eventList[i];
			if (evt.type!=='mousemove')this._prePoint.x=this._prePoint.y=-1000000;
			switch (evt.type){
				case 'mousedown':
					this._touchIDs[0]=this._id++;
					if (!MouseManager._isTouchRespond){
						_this._isLeftMouse=evt.button===0;
						_this.initEvent(evt);
						_this.check(_this._stage,_this.mouseX,_this.mouseY,_this.onMouseDown);
					}else
					MouseManager._isTouchRespond=false;
					break ;
				case 'mouseup':
					_this._isLeftMouse=evt.button===0;
					_this.initEvent(evt);
					_this.check(_this._stage,_this.mouseX,_this.mouseY,_this.onMouseUp);
					break ;
				case 'mousemove':
					if ((Math.abs(this._prePoint.x-evt.clientX)+Math.abs(this._prePoint.y-evt.clientY))>=this.mouseMoveAccuracy){
						this._prePoint.x=evt.clientX;
						this._prePoint.y=evt.clientY;
						_this.initEvent(evt);
						_this.check(_this._stage,_this.mouseX,_this.mouseY,_this.onMouseMove);
					}
					break ;
				case "touchstart":
					MouseManager._isTouchRespond=true;
					_this._isLeftMouse=true;
					var touches=evt.changedTouches;
					for (j=0,n=touches.length;j < n;j++){
						touch=touches[j];
						if (MouseManager.multiTouchEnabled || isNaN(this._curTouchID)){
							this._curTouchID=touch.identifier;
							if (this._id % 200===0)this._touchIDs={};
							this._touchIDs[touch.identifier]=this._id++;
							_this.initEvent(touch,evt);
							_this.check(_this._stage,_this.mouseX,_this.mouseY,_this.onMouseDown);
						}
					}
					break ;
				case "touchend":
				case "touchcancel":
					MouseManager._isTouchRespond=true;
					_this._isLeftMouse=true;
					var touchends=evt.changedTouches;
					for (j=0,n=touchends.length;j < n;j++){
						touch=touchends[j];
						if (MouseManager.multiTouchEnabled || touch.identifier==this._curTouchID){
							this._curTouchID=NaN;
							_this.initEvent(touch,evt);
							var isChecked=false;
							isChecked=_this.check(_this._stage,_this.mouseX,_this.mouseY,_this.onMouseUp);
							if (!isChecked){
								_this.onMouseUp(null);
							}
						}
					}
					break ;
				case "touchmove":;
					var touchemoves=evt.changedTouches;
					for (j=0,n=touchemoves.length;j < n;j++){
						touch=touchemoves[j];
						if (MouseManager.multiTouchEnabled || touch.identifier==this._curTouchID){
							_this.initEvent(touch,evt);
							_this.check(_this._stage,_this.mouseX,_this.mouseY,_this.onMouseMove);
						}
					}
					break ;
				case "wheel":
				case "mousewheel":
				case "DOMMouseScroll":
					_this.checkMouseWheel(evt);
					break ;
				case "mouseout":
					TouchManager.I.stageMouseOut();
					break ;
				case "mouseover":
					_this._stage.event(/*laya.events.Event.MOUSE_OVER*/"mouseover",_this._event.setTo(/*laya.events.Event.MOUSE_OVER*/"mouseover",_this._stage,_this._stage));
					break ;
				}
			i++;
		}
		this._eventList.length=0;
	}

	MouseManager.enabled=true;
	MouseManager.multiTouchEnabled=true;
	MouseManager._isTouchRespond=false;
	MouseManager._isFirstTouch=true;
	__static(MouseManager,
	['instance',function(){return this.instance=new MouseManager();}
	]);
	return MouseManager;
})()


/**
*@private
*Touch事件管理类，处理多点触控下的鼠标事件
*/
//class laya.events.TouchManager
var TouchManager=(function(){
	function TouchManager(){
		/**
		*当前over的touch表
		*/
		this.preOvers=[];
		/**
		*当前down的touch表
		*/
		this.preDowns=[];
		this.preRightDowns=[];
		/**
		*是否启用
		*/
		this.enable=true;
		this._lastClickTime=0;
		this._event=new Event();
	}

	__class(TouchManager,'laya.events.TouchManager');
	var __proto=TouchManager.prototype;
	__proto._clearTempArrs=function(){
		TouchManager._oldArr.length=0;
		TouchManager._newArr.length=0;
		TouchManager._tEleArr.length=0;
	}

	/**
	*从touch表里查找对应touchID的数据
	*@param touchID touch ID
	*@param arr touch表
	*@return
	*
	*/
	__proto.getTouchFromArr=function(touchID,arr){
		var i=0,len=0;
		len=arr.length;
		var tTouchO;
		for (i=0;i < len;i++){
			tTouchO=arr[i];
			if (tTouchO.id==touchID){
				return tTouchO;
			}
		}
		return null;
	}

	/**
	*从touch表里移除一个元素
	*@param touchID touch ID
	*@param arr touch表
	*
	*/
	__proto.removeTouchFromArr=function(touchID,arr){
		var i=0;
		for (i=arr.length-1;i >=0;i--){
			if (arr[i].id==touchID){
				arr.splice(i,1);
			}
		}
	}

	/**
	*创建一个touch数据
	*@param ele 当前的根节点
	*@param touchID touchID
	*@return
	*
	*/
	__proto.createTouchO=function(ele,touchID){
		var rst;
		rst=Pool.getItem("TouchData")|| {};
		rst.id=touchID;
		rst.tar=ele;
		return rst;
	}

	/**
	*处理touchStart
	*@param ele 根节点
	*@param touchID touchID
	*@param isLeft （可选）是否为左键
	*/
	__proto.onMouseDown=function(ele,touchID,isLeft){
		(isLeft===void 0)&& (isLeft=false);
		if (!this.enable)
			return;
		var preO;
		var tO;
		var arrs;
		preO=this.getTouchFromArr(touchID,this.preOvers);
		arrs=this.getEles(ele,null,TouchManager._tEleArr);
		if (!preO){
			tO=this.createTouchO(ele,touchID);
			this.preOvers.push(tO);
			}else {
			preO.tar=ele;
		}
		if (Browser.onMobile)
			this.sendEvents(arrs,/*laya.events.Event.MOUSE_OVER*/"mouseover",touchID);
		var preDowns;
		preDowns=isLeft ? this.preDowns :this.preRightDowns;
		preO=this.getTouchFromArr(touchID,preDowns);
		if (!preO){
			tO=this.createTouchO(ele,touchID);
			preDowns.push(tO);
			}else {
			preO.tar=ele;
		}
		this.sendEvents(arrs,isLeft ? /*laya.events.Event.MOUSE_DOWN*/"mousedown" :/*laya.events.Event.RIGHT_MOUSE_DOWN*/"rightmousedown",touchID);
		this._clearTempArrs();
	}

	/**
	*派发事件。
	*@param eles 对象列表。
	*@param type 事件类型。
	*@param touchID （可选）touchID，默认为0。
	*/
	__proto.sendEvents=function(eles,type,touchID){
		(touchID===void 0)&& (touchID=0);
		var i=0,len=0;
		len=eles.length;
		this._event._stoped=false;
		var _target;
		_target=eles[0];
		var tE;
		for (i=0;i < len;i++){
			tE=eles[i];
			if (tE.destroyed)return;
			tE.event(type,this._event.setTo(type,tE,_target));
			if (this._event._stoped)
				break ;
		}
	}

	/**
	*获取对象列表。
	*@param start 起始节点。
	*@param end 结束节点。
	*@param rst 返回值。如果此值不为空，则将其赋值为计算结果，从而避免创建新数组；如果此值为空，则创建新数组返回。
	*@return Array 返回节点列表。
	*/
	__proto.getEles=function(start,end,rst){
		if (!rst){
			rst=[];
			}else {
			rst.length=0;
		}
		while (start && start !=end){
			rst.push(start);
			start=start.parent;
		}
		return rst;
	}

	/**
	*touchMove时处理out事件和over时间。
	*@param eleNew 新的根节点。
	*@param elePre 旧的根节点。
	*@param touchID （可选）touchID，默认为0。
	*/
	__proto.checkMouseOutAndOverOfMove=function(eleNew,elePre,touchID){
		(touchID===void 0)&& (touchID=0);
		if (elePre==eleNew)
			return;
		var tar;
		var arrs;
		var i=0,len=0;
		if (elePre.contains(eleNew)){
			arrs=this.getEles(eleNew,elePre,TouchManager._tEleArr);
			this.sendEvents(arrs,/*laya.events.Event.MOUSE_OVER*/"mouseover",touchID);
			}else if (eleNew.contains(elePre)){
			arrs=this.getEles(elePre,eleNew,TouchManager._tEleArr);
			this.sendEvents(arrs,/*laya.events.Event.MOUSE_OUT*/"mouseout",touchID);
			}else {
			arrs=TouchManager._tEleArr;
			arrs.length=0;
			var oldArr;
			oldArr=this.getEles(elePre,null,TouchManager._oldArr);
			var newArr;
			newArr=this.getEles(eleNew,null,TouchManager._newArr);
			len=oldArr.length;
			var tIndex=0;
			for (i=0;i < len;i++){
				tar=oldArr[i];
				tIndex=newArr.indexOf(tar);
				if (tIndex >=0){
					newArr.splice(tIndex,newArr.length-tIndex);
					break ;
					}else {
					arrs.push(tar);
				}
			}
			if (arrs.length > 0){
				this.sendEvents(arrs,/*laya.events.Event.MOUSE_OUT*/"mouseout",touchID);
			}
			if (newArr.length > 0){
				this.sendEvents(newArr,/*laya.events.Event.MOUSE_OVER*/"mouseover",touchID);
			}
		}
	}

	/**
	*处理TouchMove事件
	*@param ele 根节点
	*@param touchID touchID
	*
	*/
	__proto.onMouseMove=function(ele,touchID){
		if (!this.enable)
			return;
		var preO;
		preO=this.getTouchFromArr(touchID,this.preOvers);
		var arrs;
		var tO;
		if (!preO){
			arrs=this.getEles(ele,null,TouchManager._tEleArr);
			this.sendEvents(arrs,/*laya.events.Event.MOUSE_OVER*/"mouseover",touchID);
			this.preOvers.push(this.createTouchO(ele,touchID));
			}else {
			this.checkMouseOutAndOverOfMove(ele,preO.tar);
			preO.tar=ele;
			arrs=this.getEles(ele,null,TouchManager._tEleArr);
		}
		this.sendEvents(arrs,/*laya.events.Event.MOUSE_MOVE*/"mousemove",touchID);
		this._clearTempArrs();
	}

	__proto.getLastOvers=function(){
		TouchManager._tEleArr.length=0;
		if (this.preOvers.length > 0 && this.preOvers[0].tar){
			return this.getEles(this.preOvers[0].tar,null,TouchManager._tEleArr);
		}
		TouchManager._tEleArr.push(Laya.stage);
		return TouchManager._tEleArr;
	}

	__proto.stageMouseOut=function(){
		var lastOvers;
		lastOvers=this.getLastOvers();
		this.preOvers.length=0;
		this.sendEvents(lastOvers,/*laya.events.Event.MOUSE_OUT*/"mouseout",0);
	}

	/**
	*处理TouchEnd事件
	*@param ele 根节点
	*@param touchID touchID
	*@param isLeft 是否为左键
	*/
	__proto.onMouseUp=function(ele,touchID,isLeft){
		(isLeft===void 0)&& (isLeft=false);
		if (!this.enable)
			return;
		var preO;
		var tO;
		var arrs;
		var oldArr;
		var i=0,len=0;
		var tar;
		var sendArr;
		var onMobile=Browser.onMobile;
		arrs=this.getEles(ele,null,TouchManager._tEleArr);
		this.sendEvents(arrs,isLeft ? /*laya.events.Event.MOUSE_UP*/"mouseup" :/*laya.events.Event.RIGHT_MOUSE_UP*/"rightmouseup",touchID);
		var preDowns;
		preDowns=isLeft ? this.preDowns :this.preRightDowns;
		preO=this.getTouchFromArr(touchID,preDowns);
		if (!preO){
			}else {
			var isDouble=false;
			var now=Browser.now();
			isDouble=now-this._lastClickTime < 300;
			this._lastClickTime=now;
			if (ele==preO.tar){
				sendArr=arrs;
				}else {
				oldArr=this.getEles(preO.tar,null,TouchManager._oldArr);
				sendArr=TouchManager._newArr;
				sendArr.length=0;
				len=oldArr.length;
				for (i=0;i < len;i++){
					tar=oldArr[i];
					if (arrs.indexOf(tar)>=0){
						sendArr.push(tar);
					}
				}
			}
			if (sendArr.length > 0){
				this.sendEvents(sendArr,isLeft ? /*laya.events.Event.CLICK*/"click" :/*laya.events.Event.RIGHT_CLICK*/"rightclick",touchID);
			}
			if (isLeft && isDouble){
				this.sendEvents(sendArr,/*laya.events.Event.DOUBLE_CLICK*/"doubleclick",touchID);
			}
			this.removeTouchFromArr(touchID,preDowns);
			preO.tar=null;
			Pool.recover("TouchData",preO);
		}
		preO=this.getTouchFromArr(touchID,this.preOvers);
		if (!preO){
			}else {
			if (onMobile){
				sendArr=this.getEles(preO.tar,null,sendArr);
				if (sendArr && sendArr.length > 0){
					this.sendEvents(sendArr,/*laya.events.Event.MOUSE_OUT*/"mouseout",touchID);
				}
				this.removeTouchFromArr(touchID,this.preOvers);
				preO.tar=null;
				Pool.recover("TouchData",preO);
			}
		}
		this._clearTempArrs();
	}

	TouchManager._oldArr=[];
	TouchManager._newArr=[];
	TouchManager._tEleArr=[];
	__static(TouchManager,
	['I',function(){return this.I=new TouchManager();}
	]);
	return TouchManager;
})()


/**
*<code>Filter</code> 是滤镜基类。
*/
//class laya.filters.Filter
var Filter=(function(){
	function Filter(){
		/**@private */
		this._action=null;
	}

	__class(Filter,'laya.filters.Filter');
	var __proto=Filter.prototype;
	Laya.imps(__proto,{"laya.filters.IFilter":true})
	/**@private */
	__proto.callNative=function(sp){}
	/**@private 滤镜类型。*/
	__getset(0,__proto,'type',function(){return-1});
	/**@private 滤镜动作。*/
	__getset(0,__proto,'action',function(){return this._action });
	Filter.BLUR=0x10;
	Filter.COLOR=0x20;
	Filter.GLOW=0x08;
	Filter._filterStart=null;
	Filter._filterEnd=null;
	Filter._EndTarget=null;
	Filter._recycleScope=null;
	Filter._filter=null;
	Filter._useSrc=null;
	Filter._endSrc=null;
	Filter._useOut=null;
	Filter._endOut=null;
	return Filter;
})()


/**
*@private
*<code>ColorFilterAction</code> 是一个颜色滤镜应用类。
*/
//class laya.filters.ColorFilterAction
var ColorFilterAction=(function(){
	function ColorFilterAction(){
		this.data=null;
	}

	__class(ColorFilterAction,'laya.filters.ColorFilterAction');
	var __proto=ColorFilterAction.prototype;
	Laya.imps(__proto,{"laya.filters.IFilterAction":true})
	/**
	*给指定的对象应用颜色滤镜。
	*@param srcCanvas 需要应用画布对象。
	*@return 应用了滤镜后的画布对象。
	*/
	__proto.apply=function(srcCanvas){
		var ctx=srcCanvas.ctx.ctx;
		var canvas=srcCanvas.ctx.ctx.canvas;
		if (canvas.width==0 || canvas.height==0)return canvas;
		var imgdata=ctx.getImageData(0,0,canvas.width,canvas.height);
		var data=imgdata.data;
		var nData;
		for (var i=0,n=data.length;i < n;i+=4){
			nData=this.getColor(data[i],data[i+1],data[i+2],data[i+3]);
			if (data[i+3]==0)continue ;
			data[i]=nData[0];
			data[i+1]=nData[1];
			data[i+2]=nData[2];
			data[i+3]=nData[3];
		}
		ctx.putImageData(imgdata,0,0);
		return srcCanvas;
	}

	__proto.getColor=function(red,green,blue,alpha){
		var rst=[];
		if (this.data._mat && this.data._alpha){
			var mat=this.data._mat;
			var tempAlpha=this.data._alpha;
			rst[0]=mat[0] *red+mat[1] *green+mat[2] *blue+mat[3] *alpha+tempAlpha[0];
			rst[1]=mat[4] *red+mat[5] *green+mat[6] *blue+mat[7] *alpha+tempAlpha[1];
			rst[2]=mat[8] *red+mat[9] *green+mat[10] *blue+mat[11] *alpha+tempAlpha[2];
			rst[3]=mat[12] *red+mat[13] *green+mat[14] *blue+mat[15] *alpha+tempAlpha[3];
		}
		return rst;
	}

	return ColorFilterAction;
})()


/**
*@private
*/
//class laya.maths.Arith
var Arith=(function(){
	function Arith(){}
	__class(Arith,'laya.maths.Arith');
	Arith.formatR=function(r){
		if (r > Math.PI)r-=Math.PI *2;
		if (r <-Math.PI)r+=Math.PI *2;
		return r;
	}

	Arith.isPOT=function(w,h){
		return (w > 0 && (w & (w-1))===0 && h > 0 && (h & (h-1))===0);
	}

	Arith.setMatToArray=function(mat,array){
		mat.a,mat.b,0,0,mat.c,mat.d,0,0,0,0,1,0,mat.tx+20,mat.ty+20,0,1
		array[0]=mat.a;
		array[1]=mat.b;
		array[4]=mat.c;
		array[5]=mat.d;
		array[12]=mat.tx;
		array[13]=mat.ty;
	}

	return Arith;
})()


/**
*@private
*计算贝塞尔曲线的工具类。
*/
//class laya.maths.Bezier
var Bezier=(function(){
	function Bezier(){
		/**@private */
		this._controlPoints=[new Point(),new Point(),new Point()];
		this._calFun=this.getPoint2;
	}

	__class(Bezier,'laya.maths.Bezier');
	var __proto=Bezier.prototype;
	/**@private */
	__proto._switchPoint=function(x,y){
		var tPoint=this._controlPoints.shift();
		tPoint.setTo(x,y);
		this._controlPoints.push(tPoint);
	}

	/**
	*计算二次贝塞尔点。
	*@param t
	*@param rst
	*
	*/
	__proto.getPoint2=function(t,rst){
		var p1=this._controlPoints[0];
		var p2=this._controlPoints[1];
		var p3=this._controlPoints[2];
		var lineX=Math.pow((1-t),2)*p1.x+2 *t *(1-t)*p2.x+Math.pow(t,2)*p3.x;
		var lineY=Math.pow((1-t),2)*p1.y+2 *t *(1-t)*p2.y+Math.pow(t,2)*p3.y;
		rst.push(lineX,lineY);
	}

	/**
	*计算三次贝塞尔点
	*@param t
	*@param rst
	*
	*/
	__proto.getPoint3=function(t,rst){
		var p1=this._controlPoints[0];
		var p2=this._controlPoints[1];
		var p3=this._controlPoints[2];
		var p4=this._controlPoints[3];
		var lineX=Math.pow((1-t),3)*p1.x+3 *p2.x *t *(1-t)*(1-t)+3 *p3.x *t *t *(1-t)+p4.x *Math.pow(t,3);
		var lineY=Math.pow((1-t),3)*p1.y+3 *p2.y *t *(1-t)*(1-t)+3 *p3.y *t *t *(1-t)+p4.y *Math.pow(t,3);
		rst.push(lineX,lineY);
	}

	/**
	*计算贝塞尔点序列
	*@param count
	*@param rst
	*
	*/
	__proto.insertPoints=function(count,rst){
		var i=NaN;
		count=count > 0 ? count :5;
		var dLen=NaN;
		dLen=1 / count;
		for (i=0;i <=1;i+=dLen){
			this._calFun(i,rst);
		}
	}

	/**
	*获取贝塞尔曲线上的点。
	*@param pList 控制点[x0,y0,x1,y1...]
	*@param inSertCount 每次曲线的插值数量
	*@return
	*
	*/
	__proto.getBezierPoints=function(pList,inSertCount,count){
		(inSertCount===void 0)&& (inSertCount=5);
		(count===void 0)&& (count=2);
		var i=0,len=0;
		len=pList.length;
		if (len < (count+1)*2)return [];
		var rst;
		rst=[];
		switch (count){
			case 2:
				this._calFun=this.getPoint2;
				break ;
			case 3:
				this._calFun=this.getPoint3;
				break ;
			default :
				return [];
			}
		while (this._controlPoints.length <=count){
			this._controlPoints.push(new Point());
		}
		for (i=0;i < count *2;i+=2){
			this._switchPoint(pList[i],pList[i+1]);
		}
		for (i=count *2;i < len;i+=2){
			this._switchPoint(pList[i],pList[i+1]);
			if ((i / 2)% count==0)
				this.insertPoints(inSertCount,rst);
		}
		return rst;
	}

	__static(Bezier,
	['I',function(){return this.I=new Bezier();}
	]);
	return Bezier;
})()


/**
*@private
*凸包算法。
*/
//class laya.maths.GrahamScan
var GrahamScan=(function(){
	function GrahamScan(){}
	__class(GrahamScan,'laya.maths.GrahamScan');
	GrahamScan.multiply=function(p1,p2,p0){
		return ((p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y));
	}

	GrahamScan.dis=function(p1,p2){
		return (p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y);
	}

	GrahamScan._getPoints=function(count,tempUse,rst){
		(tempUse===void 0)&& (tempUse=false);
		if (!GrahamScan._mPointList)GrahamScan._mPointList=[];
		while (GrahamScan._mPointList.length < count)GrahamScan._mPointList.push(new Point());
		if (!rst)rst=[];
		rst.length=0;
		if (tempUse){
			GrahamScan.getFrom(rst,GrahamScan._mPointList,count);
			}else {
			GrahamScan.getFromR(rst,GrahamScan._mPointList,count);
		}
		return rst;
	}

	GrahamScan.getFrom=function(rst,src,count){
		var i=0;
		for (i=0;i < count;i++){
			rst.push(src[i]);
		}
		return rst;
	}

	GrahamScan.getFromR=function(rst,src,count){
		var i=0;
		for (i=0;i < count;i++){
			rst.push(src.pop());
		}
		return rst;
	}

	GrahamScan.pListToPointList=function(pList,tempUse){
		(tempUse===void 0)&& (tempUse=false);
		var i=0,len=pList.length / 2,rst=GrahamScan._getPoints(len,tempUse,GrahamScan._tempPointList);
		for (i=0;i < len;i++){
			rst[i].setTo(pList[i+i],pList[i+i+1]);
		}
		return rst;
	}

	GrahamScan.pointListToPlist=function(pointList){
		var i=0,len=pointList.length,rst=GrahamScan._temPList,tPoint;
		rst.length=0;
		for (i=0;i < len;i++){
			tPoint=pointList[i];
			rst.push(tPoint.x,tPoint.y);
		}
		return rst;
	}

	GrahamScan.scanPList=function(pList){
		return Utils.copyArray(pList,GrahamScan.pointListToPlist(GrahamScan.scan(GrahamScan.pListToPointList(pList,true))));
	}

	GrahamScan.scan=function(PointSet){
		var i=0,j=0,k=0,top=2,tmp,n=PointSet.length,ch;
		var _tmpDic={};
		var key;
		ch=GrahamScan._temArr;
		ch.length=0;
		n=PointSet.length;
		for (i=n-1;i >=0;i--){
			tmp=PointSet[i];
			key=tmp.x+"_"+tmp.y;
			if (!_tmpDic.hasOwnProperty(key)){
				_tmpDic[key]=true;
				ch.push(tmp);
			}
		}
		n=ch.length;
		Utils.copyArray(PointSet,ch);
		for (i=1;i < n;i++)
		if ((PointSet[i].y < PointSet[k].y)|| ((PointSet[i].y==PointSet[k].y)&& (PointSet[i].x < PointSet[k].x)))
			k=i;
		tmp=PointSet[0];
		PointSet[0]=PointSet[k];
		PointSet[k]=tmp;
		for (i=1;i < n-1;i++){
			k=i;
			for (j=i+1;j < n;j++)
			if ((GrahamScan.multiply(PointSet[j],PointSet[k],PointSet[0])> 0)|| ((GrahamScan.multiply(PointSet[j],PointSet[k],PointSet[0])==0)&& (GrahamScan.dis(PointSet[0],PointSet[j])< GrahamScan.dis(PointSet[0],PointSet[k]))))
				k=j;
			tmp=PointSet[i];
			PointSet[i]=PointSet[k];
			PointSet[k]=tmp;
		}
		ch=GrahamScan._temArr;
		ch.length=0;
		if (PointSet.length < 3){
			return Utils.copyArray(ch,PointSet);
		}
		ch.push(PointSet[0],PointSet[1],PointSet[2]);
		for (i=3;i < n;i++){
			while (ch.length >=2 && GrahamScan.multiply(PointSet[i],ch[ch.length-1],ch[ch.length-2])>=0)ch.pop();
			PointSet[i] && ch.push(PointSet[i]);
		}
		return ch;
	}

	GrahamScan._mPointList=null;
	GrahamScan._tempPointList=[];
	GrahamScan._temPList=[];
	GrahamScan._temArr=[];
	return GrahamScan;
})()


/**
*@private
*<code>MathUtil</code> 是一个数据处理工具类。
*/
//class laya.maths.MathUtil
var MathUtil=(function(){
	function MathUtil(){}
	__class(MathUtil,'laya.maths.MathUtil');
	MathUtil.subtractVector3=function(l,r,o){
		o[0]=l[0]-r[0];
		o[1]=l[1]-r[1];
		o[2]=l[2]-r[2];
	}

	MathUtil.lerp=function(left,right,amount){
		return left *(1-amount)+right *amount;
	}

	MathUtil.scaleVector3=function(f,b,e){
		e[0]=f[0] *b;
		e[1]=f[1] *b;
		e[2]=f[2] *b;
	}

	MathUtil.lerpVector3=function(l,r,t,o){
		var ax=l[0],ay=l[1],az=l[2];
		o[0]=ax+t *(r[0]-ax);
		o[1]=ay+t *(r[1]-ay);
		o[2]=az+t *(r[2]-az);
	}

	MathUtil.lerpVector4=function(l,r,t,o){
		var ax=l[0],ay=l[1],az=l[2],aw=l[3];
		o[0]=ax+t *(r[0]-ax);
		o[1]=ay+t *(r[1]-ay);
		o[2]=az+t *(r[2]-az);
		o[3]=aw+t *(r[3]-aw);
	}

	MathUtil.slerpQuaternionArray=function(a,Offset1,b,Offset2,t,out,Offset3){
		var ax=a[Offset1+0],ay=a[Offset1+1],az=a[Offset1+2],aw=a[Offset1+3],bx=b[Offset2+0],by=b[Offset2+1],bz=b[Offset2+2],bw=b[Offset2+3];
		var omega,cosom,sinom,scale0,scale1;
		cosom=ax *bx+ay *by+az *bz+aw *bw;
		if (cosom < 0.0){
			cosom=-cosom;
			bx=-bx;
			by=-by;
			bz=-bz;
			bw=-bw;
		}
		if ((1.0-cosom)> 0.000001){
			omega=Math.acos(cosom);
			sinom=Math.sin(omega);
			scale0=Math.sin((1.0-t)*omega)/ sinom;
			scale1=Math.sin(t *omega)/ sinom;
			}else {
			scale0=1.0-t;
			scale1=t;
		}
		out[Offset3+0]=scale0 *ax+scale1 *bx;
		out[Offset3+1]=scale0 *ay+scale1 *by;
		out[Offset3+2]=scale0 *az+scale1 *bz;
		out[Offset3+3]=scale0 *aw+scale1 *bw;
		return out;
	}

	MathUtil.getRotation=function(x0,y0,x1,y1){
		return Math.atan2(y1-y0,x1-x0)/ Math.PI *180;
	}

	MathUtil.sortBigFirst=function(a,b){
		if (a==b)
			return 0;
		return b > a ? 1 :-1;
	}

	MathUtil.sortSmallFirst=function(a,b){
		if (a==b)
			return 0;
		return b > a ?-1 :1;
	}

	MathUtil.sortNumBigFirst=function(a,b){
		return parseFloat(b)-parseFloat(a);
	}

	MathUtil.sortNumSmallFirst=function(a,b){
		return parseFloat(a)-parseFloat(b);
	}

	MathUtil.sortByKey=function(key,bigFirst,forceNum){
		(bigFirst===void 0)&& (bigFirst=false);
		(forceNum===void 0)&& (forceNum=true);
		var _sortFun;
		if (bigFirst){
			_sortFun=forceNum ? MathUtil.sortNumBigFirst :MathUtil.sortBigFirst;
			}else {
			_sortFun=forceNum ? MathUtil.sortNumSmallFirst :MathUtil.sortSmallFirst;
		}
		return function (a,b){
			return _sortFun(a[key],b[key]);
		}
	}

	return MathUtil;
})()


/**
*<p> <code>Matrix</code> 类表示一个转换矩阵，它确定如何将点从一个坐标空间映射到另一个坐标空间。</p>
*<p>您可以对一个显示对象执行不同的图形转换，方法是设置 Matrix 对象的属性，将该 Matrix 对象应用于 Transform 对象的 matrix 属性，然后应用该 Transform 对象作为显示对象的 transform 属性。这些转换函数包括平移（x 和 y 重新定位）、旋转、缩放和倾斜。</p>
*/
//class laya.maths.Matrix
var Matrix=(function(){
	function Matrix(a,b,c,d,tx,ty){
		/**缩放或旋转图像时影响像素沿 x 轴定位的值。*/
		//this.a=NaN;
		/**旋转或倾斜图像时影响像素沿 y 轴定位的值。*/
		//this.b=NaN;
		/**旋转或倾斜图像时影响像素沿 x 轴定位的值。*/
		//this.c=NaN;
		/**缩放或旋转图像时影响像素沿 y 轴定位的值。*/
		//this.d=NaN;
		/**沿 x 轴平移每个点的距离。*/
		//this.tx=NaN;
		/**沿 y 轴平移每个点的距离。*/
		//this.ty=NaN;
		/**@private 表示此对象是否在对象池中。*/
		this.inPool=false;
		/**@private 是否有改变矩阵的值。*/
		this.bTransform=false;
		(a===void 0)&& (a=1);
		(b===void 0)&& (b=0);
		(c===void 0)&& (c=0);
		(d===void 0)&& (d=1);
		(tx===void 0)&& (tx=0);
		(ty===void 0)&& (ty=0);
		this.a=a;
		this.b=b;
		this.c=c;
		this.d=d;
		this.tx=tx;
		this.ty=ty;
		this._checkTransform();
	}

	__class(Matrix,'laya.maths.Matrix');
	var __proto=Matrix.prototype;
	/**
	*将本矩阵设置为单位矩阵。
	*@return 返回当前矩形。
	*/
	__proto.identity=function(){
		this.a=this.d=1;
		this.b=this.tx=this.ty=this.c=0;
		this.bTransform=false;
		return this;
	}

	/**@private */
	__proto._checkTransform=function(){
		return this.bTransform=(this.a!==1 || this.b!==0 || this.c!==0 || this.d!==1);
	}

	/**
	*设置沿 x 、y 轴平移每个点的距离。
	*@param x 沿 x 轴平移每个点的距离。
	*@param y 沿 y 轴平移每个点的距离。
	*@return 返回对象本身
	*/
	__proto.setTranslate=function(x,y){
		this.tx=x;
		this.ty=y;
		return this;
	}

	/**
	*沿 x 和 y 轴平移矩阵，平移的变化量由 x 和 y 参数指定。
	*@param x 沿 x 轴向右移动的量（以像素为单位）。
	*@param y 沿 y 轴向下移动的量（以像素为单位）。
	*@return 返回此矩形对象。
	*/
	__proto.translate=function(x,y){
		this.tx+=x;
		this.ty+=y;
		return this;
	}

	/**
	*对矩阵应用缩放转换。
	*@param x 用于沿 x 轴缩放对象的乘数。
	*@param y 用于沿 y 轴缩放对象的乘数。
	*/
	__proto.scale=function(x,y){
		this.a *=x;
		this.d *=y;
		this.c *=x;
		this.b *=y;
		this.tx *=x;
		this.ty *=y;
		this.bTransform=true;
	}

	/**
	*对 Matrix 对象应用旋转转换。
	*@param angle 以弧度为单位的旋转角度。
	*/
	__proto.rotate=function(angle){
		var cos=Math.cos(angle);
		var sin=Math.sin(angle);
		var a1=this.a;
		var c1=this.c;
		var tx1=this.tx;
		this.a=a1 *cos-this.b *sin;
		this.b=a1 *sin+this.b *cos;
		this.c=c1 *cos-this.d *sin;
		this.d=c1 *sin+this.d *cos;
		this.tx=tx1 *cos-this.ty *sin;
		this.ty=tx1 *sin+this.ty *cos;
		this.bTransform=true;
	}

	/**
	*对 Matrix 对象应用倾斜转换。
	*@param x 沿着 X 轴的 2D 倾斜弧度。
	*@param y 沿着 Y 轴的 2D 倾斜弧度。
	*@return 当前 Matrix 对象。
	*/
	__proto.skew=function(x,y){
		var tanX=Math.tan(x);
		var tanY=Math.tan(y);
		var a1=this.a;
		var b1=this.b;
		this.a+=tanY *this.c;
		this.b+=tanY *this.d;
		this.c+=tanX *a1;
		this.d+=tanX *b1;
		return this;
	}

	/**
	*对指定的点应用当前矩阵的逆转化并返回此点。
	*@param out 待转化的点 Point 对象。
	*@return 返回out
	*/
	__proto.invertTransformPoint=function(out){
		var a1=this.a;
		var b1=this.b;
		var c1=this.c;
		var d1=this.d;
		var tx1=this.tx;
		var n=a1 *d1-b1 *c1;
		var a2=d1 / n;
		var b2=-b1 / n;
		var c2=-c1 / n;
		var d2=a1 / n;
		var tx2=(c1 *this.ty-d1 *tx1)/ n;
		var ty2=-(a1 *this.ty-b1 *tx1)/ n;
		return out.setTo(a2 *out.x+c2 *out.y+tx2,b2 *out.x+d2 *out.y+ty2);
	}

	/**
	*将 Matrix 对象表示的几何转换应用于指定点。
	*@param out 用来设定输出结果的点。
	*@return 返回out
	*/
	__proto.transformPoint=function(out){
		return out.setTo(this.a *out.x+this.c *out.y+this.tx,this.b *out.x+this.d *out.y+this.ty);
	}

	/**
	*将 Matrix 对象表示的几何转换应用于指定点，忽略tx、ty。
	*@param out 用来设定输出结果的点。
	*@return 返回out
	*/
	__proto.transformPointN=function(out){
		return out.setTo(this.a *out.x+this.c *out.y ,this.b *out.x+this.d *out.y);
	}

	/**
	*@private
	*将 Matrix 对象表示的几何转换应用于指定点。
	*@param data 点集合。
	*@param out 存储应用转化的点的列表。
	*@return 返回out数组
	*/
	__proto.transformPointArray=function(data,out){
		var len=data.length;
		for (var i=0;i < len;i+=2){
			var x=data[i],y=data[i+1];
			out[i]=this.a *x+this.c *y+this.tx;
			out[i+1]=this.b *x+this.d *y+this.ty;
		}
		return out;
	}

	/**
	*@private
	*将 Matrix 对象表示的几何缩放转换应用于指定点。
	*@param data 点集合。
	*@param out 存储应用转化的点的列表。
	*@return 返回out数组
	*/
	__proto.transformPointArrayScale=function(data,out){
		var len=data.length;
		for (var i=0;i < len;i+=2){
			var x=data[i],y=data[i+1];
			out[i]=this.a *x+this.c *y;
			out[i+1]=this.b *x+this.d *y;
		}
		return out;
	}

	/**
	*获取 X 轴缩放值。
	*@return X 轴缩放值。
	*/
	__proto.getScaleX=function(){
		return this.b===0 ? this.a :Math.sqrt(this.a *this.a+this.b *this.b);
	}

	/**
	*获取 Y 轴缩放值。
	*@return Y 轴缩放值。
	*/
	__proto.getScaleY=function(){
		return this.c===0 ? this.d :Math.sqrt(this.c *this.c+this.d *this.d);
	}

	/**
	*执行原始矩阵的逆转换。
	*@return 当前矩阵对象。
	*/
	__proto.invert=function(){
		var a1=this.a;
		var b1=this.b;
		var c1=this.c;
		var d1=this.d;
		var tx1=this.tx;
		var n=a1 *d1-b1 *c1;
		this.a=d1 / n;
		this.b=-b1 / n;
		this.c=-c1 / n;
		this.d=a1 / n;
		this.tx=(c1 *this.ty-d1 *tx1)/ n;
		this.ty=-(a1 *this.ty-b1 *tx1)/ n;
		return this;
	}

	/**
	*将 Matrix 的成员设置为指定值。
	*@param a 缩放或旋转图像时影响像素沿 x 轴定位的值。
	*@param b 旋转或倾斜图像时影响像素沿 y 轴定位的值。
	*@param c 旋转或倾斜图像时影响像素沿 x 轴定位的值。
	*@param d 缩放或旋转图像时影响像素沿 y 轴定位的值。
	*@param tx 沿 x 轴平移每个点的距离。
	*@param ty 沿 y 轴平移每个点的距离。
	*@return 当前矩阵对象。
	*/
	__proto.setTo=function(a,b,c,d,tx,ty){
		this.a=a,this.b=b,this.c=c,this.d=d,this.tx=tx,this.ty=ty;
		return this;
	}

	/**
	*将指定矩阵与当前矩阵连接，从而将这两个矩阵的几何效果有效地结合在一起。
	*@param matrix 要连接到源矩阵的矩阵。
	*@return 当前矩阵。
	*/
	__proto.concat=function(matrix){
		var a=this.a;
		var c=this.c;
		var tx=this.tx;
		this.a=a *matrix.a+this.b *matrix.c;
		this.b=a *matrix.b+this.b *matrix.d;
		this.c=c *matrix.a+this.d *matrix.c;
		this.d=c *matrix.b+this.d *matrix.d;
		this.tx=tx *matrix.a+this.ty *matrix.c+matrix.tx;
		this.ty=tx *matrix.b+this.ty *matrix.d+matrix.ty;
		return this;
	}

	/**
	*@private
	*对矩阵应用缩放转换。反向相乘
	*@param x 用于沿 x 轴缩放对象的乘数。
	*@param y 用于沿 y 轴缩放对象的乘数。
	*/
	__proto.scaleEx=function(x,y){
		var ba=this.a,bb=this.b,bc=this.c,bd=this.d;
		if (bb!==0 || bc!==0){
			this.a=x *ba;
			this.b=x *bb;
			this.c=y *bc;
			this.d=y *bd;
			}else {
			this.a=x *ba;
			this.b=0 *bd;
			this.c=0 *ba;
			this.d=y *bd;
		}
		this.bTransform=true;
	}

	/**
	*@private
	*对 Matrix 对象应用旋转转换。反向相乘
	*@param angle 以弧度为单位的旋转角度。
	*/
	__proto.rotateEx=function(angle){
		var cos=Math.cos(angle);
		var sin=Math.sin(angle);
		var ba=this.a,bb=this.b,bc=this.c,bd=this.d;
		if (bb!==0 || bc!==0){
			this.a=cos *ba+sin *bc;
			this.b=cos *bb+sin *bd;
			this.c=-sin *ba+cos *bc;
			this.d=-sin *bb+cos *bd;
			}else {
			this.a=cos *ba;
			this.b=sin *bd;
			this.c=-sin *ba;
			this.d=cos *bd;
		}
		this.bTransform=true;
	}

	/**
	*返回此 Matrix 对象的副本。
	*@return 与原始实例具有完全相同的属性的新 Matrix 实例。
	*/
	__proto.clone=function(){
		var dec=Matrix.create();
		dec.a=this.a;
		dec.b=this.b;
		dec.c=this.c;
		dec.d=this.d;
		dec.tx=this.tx;
		dec.ty=this.ty;
		dec.bTransform=this.bTransform;
		return dec;
	}

	/**
	*将当前 Matrix 对象中的所有矩阵数据复制到指定的 Matrix 对象中。
	*@param dec 要复制当前矩阵数据的 Matrix 对象。
	*@return 已复制当前矩阵数据的 Matrix 对象。
	*/
	__proto.copyTo=function(dec){
		dec.a=this.a;
		dec.b=this.b;
		dec.c=this.c;
		dec.d=this.d;
		dec.tx=this.tx;
		dec.ty=this.ty;
		dec.bTransform=this.bTransform;
		return dec;
	}

	/**
	*返回列出该 Matrix 对象属性的文本值。
	*@return 一个字符串，它包含 Matrix 对象的属性值：a、b、c、d、tx 和 ty。
	*/
	__proto.toString=function(){
		return this.a+","+this.b+","+this.c+","+this.d+","+this.tx+","+this.ty;
	}

	/**
	*销毁此对象。
	*/
	__proto.destroy=function(){
		if (this.inPool)return;
		var cache=Matrix._cache;
		this.inPool=true;
		cache._length || (cache._length=0);
		cache[cache._length++]=this;
		this.a=this.d=1;
		this.b=this.c=this.tx=this.ty=0;
		this.bTransform=false;
	}

	Matrix.mul=function(m1,m2,out){
		var aa=m1.a,ab=m1.b,ac=m1.c,ad=m1.d,atx=m1.tx,aty=m1.ty;
		var ba=m2.a,bb=m2.b,bc=m2.c,bd=m2.d,btx=m2.tx,bty=m2.ty;
		if (bb!==0 || bc!==0){
			out.a=aa *ba+ab *bc;
			out.b=aa *bb+ab *bd;
			out.c=ac *ba+ad *bc;
			out.d=ac *bb+ad *bd;
			out.tx=ba *atx+bc *aty+btx;
			out.ty=bb *atx+bd *aty+bty;
			}else {
			out.a=aa *ba;
			out.b=ab *bd;
			out.c=ac *ba;
			out.d=ad *bd;
			out.tx=ba *atx+btx;
			out.ty=bd *aty+bty;
		}
		return out;
	}

	Matrix.mul16=function(m1,m2,out){
		var aa=m1.a,ab=m1.b,ac=m1.c,ad=m1.d,atx=m1.tx,aty=m1.ty;
		var ba=m2.a,bb=m2.b,bc=m2.c,bd=m2.d,btx=m2.tx,bty=m2.ty;
		if (bb!==0 || bc!==0){
			out[0]=aa *ba+ab *bc;
			out[1]=aa *bb+ab *bd;
			out[4]=ac *ba+ad *bc;
			out[5]=ac *bb+ad *bd;
			out[12]=ba *atx+bc *aty+btx;
			out[13]=bb *atx+bd *aty+bty;
			}else {
			out[0]=aa *ba;
			out[1]=ab *bd;
			out[4]=ac *ba;
			out[5]=ad *bd;
			out[12]=ba *atx+btx;
			out[13]=bd *aty+bty;
		}
		return out;
	}

	Matrix.mulPre=function(m1,ba,bb,bc,bd,btx,bty,out){
		var aa=m1.a,ab=m1.b,ac=m1.c,ad=m1.d,atx=m1.tx,aty=m1.ty;
		if (bb!==0 || bc!==0){
			out.a=aa *ba+ab *bc;
			out.b=aa *bb+ab *bd;
			out.c=ac *ba+ad *bc;
			out.d=ac *bb+ad *bd;
			out.tx=ba *atx+bc *aty+btx;
			out.ty=bb *atx+bd *aty+bty;
			}else {
			out.a=aa *ba;
			out.b=ab *bd;
			out.c=ac *ba;
			out.d=ad *bd;
			out.tx=ba *atx+btx;
			out.ty=bd *aty+bty;
		}
		return out;
	}

	Matrix.mulPos=function(m1,aa,ab,ac,ad,atx,aty,out){
		var ba=m1.a,bb=m1.b,bc=m1.c,bd=m1.d,btx=m1.tx,bty=m1.ty;
		if (bb!==0 || bc!==0){
			out.a=aa *ba+ab *bc;
			out.b=aa *bb+ab *bd;
			out.c=ac *ba+ad *bc;
			out.d=ac *bb+ad *bd;
			out.tx=ba *atx+bc *aty+btx;
			out.ty=bb *atx+bd *aty+bty;
			}else {
			out.a=aa *ba;
			out.b=ab *bd;
			out.c=ac *ba;
			out.d=ad *bd;
			out.tx=ba *atx+btx;
			out.ty=bd *aty+bty;
		}
		return out;
	}

	Matrix.preMul=function(parent,self,out){
		var pa=parent.a,pb=parent.b,pc=parent.c,pd=parent.d;
		var na=self.a,nb=self.b,nc=self.c,nd=self.d,ntx=self.tx,nty=self.ty;
		out.a=na *pa;
		out.b=out.c=0;
		out.d=nd *pd;
		out.tx=ntx *pa+parent.tx;
		out.ty=nty *pd+parent.ty;
		if (nb!==0 || nc!==0 || pb!==0 || pc!==0){
			out.a+=nb *pc;
			out.d+=nc *pb;
			out.b+=na *pb+nb *pd;
			out.c+=nc *pa+nd *pc;
			out.tx+=nty *pc;
			out.ty+=ntx *pb;
		}
		return out;
	}

	Matrix.preMulXY=function(parent,x,y,out){
		var pa=parent.a,pb=parent.b,pc=parent.c,pd=parent.d;
		out.a=pa;
		out.b=pb;
		out.c=pc;
		out.d=pd;
		out.tx=x *pa+parent.tx+y *pc;
		out.ty=y *pd+parent.ty+x *pb;
		return out;
	}

	Matrix.create=function(){
		var cache=Matrix._cache;
		var mat=!cache._length ? (new Matrix()):cache[--cache._length];
		mat.inPool=false;
		return mat;
	}

	Matrix.EMPTY=new Matrix();
	Matrix.TEMP=new Matrix();
	Matrix._cache=[];
	return Matrix;
})()


/**
*<code>Point</code> 对象表示二维坐标系统中的某个位置，其中 x 表示水平轴，y 表示垂直轴。
*/
//class laya.maths.Point
var Point=(function(){
	function Point(x,y){
		/**该点的水平坐标。*/
		//this.x=NaN;
		/**该点的垂直坐标。*/
		//this.y=NaN;
		(x===void 0)&& (x=0);
		(y===void 0)&& (y=0);
		this.x=x;
		this.y=y;
	}

	__class(Point,'laya.maths.Point');
	var __proto=Point.prototype;
	/**
	*将 <code>Point</code> 的成员设置为指定值。
	*@param x 水平坐标。
	*@param y 垂直坐标。
	*@return 当前 Point 对象。
	*/
	__proto.setTo=function(x,y){
		this.x=x;
		this.y=y;
		return this;
	}

	/**
	*计算当前点和目标点(x，y)的距离。
	*@param x 水平坐标。
	*@param y 垂直坐标。
	*@return 返回当前点和目标点之间的距离。
	*/
	__proto.distance=function(x,y){
		return Math.sqrt((this.x-x)*(this.x-x)+(this.y-y)*(this.y-y));
	}

	/**返回包含 x 和 y 坐标的值的字符串。*/
	__proto.toString=function(){
		return this.x+","+this.y;
	}

	/**
	*标准化向量。
	*/
	__proto.normalize=function(){
		var d=Math.sqrt(this.x *this.x+this.y *this.y);
		if (d > 0){
			var id=1.0 / d;
			this.x *=id;
			this.y *=id;
		}
	}

	Point.TEMP=new Point();
	Point.EMPTY=new Point();
	return Point;
})()


/**
*<p><code>Rectangle</code> 对象是按其位置（由它左上角的点 (x,y)确定）以及宽度和高度定义的区域。</p>
*<p>Rectangle 类的 x、y、width 和 height 属性相互独立；更改一个属性的值不会影响其他属性。</p>
*/
//class laya.maths.Rectangle
var Rectangle=(function(){
	function Rectangle(x,y,width,height){
		/**矩形左上角的 X 轴坐标。*/
		//this.x=NaN;
		/**矩形左上角的 Y 轴坐标。*/
		//this.y=NaN;
		/**矩形的宽度。*/
		//this.width=NaN;
		/**矩形的高度。*/
		//this.height=NaN;
		(x===void 0)&& (x=0);
		(y===void 0)&& (y=0);
		(width===void 0)&& (width=0);
		(height===void 0)&& (height=0);
		this.x=x;
		this.y=y;
		this.width=width;
		this.height=height;
	}

	__class(Rectangle,'laya.maths.Rectangle');
	var __proto=Rectangle.prototype;
	/**
	*将 Rectangle 的属性设置为指定值。
	*@param x x 矩形左上角的 X 轴坐标。
	*@param y x 矩形左上角的 Y 轴坐标。
	*@param width 矩形的宽度。
	*@param height 矩形的高。
	*@return 返回属性值修改后的矩形对象本身。
	*/
	__proto.setTo=function(x,y,width,height){
		this.x=x;
		this.y=y;
		this.width=width;
		this.height=height;
		return this;
	}

	/**
	*复制 source 对象的属性值到此矩形对象中。
	*@param sourceRect 源 Rectangle 对象。
	*@return 返回属性值修改后的矩形对象本身。
	*/
	__proto.copyFrom=function(source){
		this.x=source.x;
		this.y=source.y;
		this.width=source.width;
		this.height=source.height;
		return this;
	}

	/**
	*确定由此 Rectangle 对象定义的矩形区域内是否包含指定的点。
	*@param x 点的 X 轴坐标值（水平位置）。
	*@param y 点的 Y 轴坐标值（垂直位置）。
	*@return 如果 Rectangle 对象包含指定的点，则值为 true；否则为 false。
	*/
	__proto.contains=function(x,y){
		if (this.width <=0 || this.height <=0)return false;
		if (x >=this.x && x < this.right){
			if (y >=this.y && y < this.bottom){
				return true;
			}
		}
		return false;
	}

	/**
	*确定在 rect 参数中指定的对象是否与此 Rectangle 对象相交。此方法检查指定的 Rectangle 对象的 x、y、width 和 height 属性，以查看它是否与此 Rectangle 对象相交。
	*@param rect Rectangle 对象。
	*@return 如果传入的矩形对象与此对象相交，则返回 true 值，否则返回 false。
	*/
	__proto.intersects=function(rect){
		return !(rect.x > (this.x+this.width)|| (rect.x+rect.width)< this.x || rect.y > (this.y+this.height)|| (rect.y+rect.height)< this.y);
	}

	/**
	*如果在 rect 参数中指定的 Rectangle 对象与此 Rectangle 对象相交，则返回交集区域作为 Rectangle 对象。如果矩形不相交，则此方法返回null。
	*@param rect 待比较的矩形区域。
	*@param out （可选）待输出的矩形区域。如果为空则创建一个新的。建议：尽量复用对象，减少对象创建消耗。
	*@return 返回相交的矩形区域对象。
	*/
	__proto.intersection=function(rect,out){
		if (!this.intersects(rect))return null;
		out || (out=new Rectangle());
		out.x=Math.max(this.x,rect.x);
		out.y=Math.max(this.y,rect.y);
		out.width=Math.min(this.right,rect.right)-out.x;
		out.height=Math.min(this.bottom,rect.bottom)-out.y;
		return out;
	}

	/**
	*<p>矩形联合，通过填充两个矩形之间的水平和垂直空间，将这两个矩形组合在一起以创建一个新的 Rectangle 对象。</p>
	*<p>注意：union()方法忽略高度或宽度值为 0 的矩形，如：var rect2:Rectangle=new Rectangle(300,300,50,0);</p>
	*@param 要添加到此 Rectangle 对象的 Rectangle 对象。
	*@param out 用于存储输出结果的矩形对象。如果为空，则创建一个新的。建议：尽量复用对象，减少对象创建消耗。Rectangle.TEMP对象用于对象复用。
	*@return 充当两个矩形的联合的新 Rectangle 对象。
	*/
	__proto.union=function(source,out){
		out || (out=new Rectangle());
		this.clone(out);
		if (source.width <=0 || source.height <=0)return out;
		out.addPoint(source.x,source.y);
		out.addPoint(source.right,source.bottom);
		return this;
	}

	/**
	*返回一个 Rectangle 对象，其 x、y、width 和 height 属性的值与当前 Rectangle 对象的对应值相同。
	*@param out （可选）用于存储结果的矩形对象。如果为空，则创建一个新的。建议：尽量复用对象，减少对象创建消耗。。Rectangle.TEMP对象用于对象复用。
	*@return Rectangle 对象，其 x、y、width 和 height 属性的值与当前 Rectangle 对象的对应值相同。
	*/
	__proto.clone=function(out){
		out || (out=new Rectangle());
		out.x=this.x;
		out.y=this.y;
		out.width=this.width;
		out.height=this.height;
		return out;
	}

	/**
	*当前 Rectangle 对象的水平位置 x 和垂直位置 y 以及高度 width 和宽度 height 以逗号连接成的字符串。
	*/
	__proto.toString=function(){
		return this.x+","+this.y+","+this.width+","+this.height;
	}

	/**
	*检测传入的 Rectangle 对象的属性是否与当前 Rectangle 对象的属性 x、y、width、height 属性值都相等。
	*@param rect 待比较的 Rectangle 对象。
	*@return 如果判断的属性都相等，则返回 true ,否则返回 false。
	*/
	__proto.equals=function(rect){
		if (!rect || rect.x!==this.x || rect.y!==this.y || rect.width!==this.width || rect.height!==this.height)return false;
		return true;
	}

	/**
	*<p>为当前矩形对象加一个点，以使当前矩形扩展为包含当前矩形和此点的最小矩形。</p>
	*<p>此方法会修改本对象。</p>
	*@param x 点的 X 坐标。
	*@param y 点的 Y 坐标。
	*@return 返回此 Rectangle 对象。
	*/
	__proto.addPoint=function(x,y){
		this.x > x && (this.width+=this.x-x,this.x=x);
		this.y > y && (this.height+=this.y-y,this.y=y);
		if (this.width < x-this.x)this.width=x-this.x;
		if (this.height < y-this.y)this.height=y-this.y;
		return this;
	}

	/**
	*@private
	*返回代表当前矩形的顶点数据。
	*@return 顶点数据。
	*/
	__proto._getBoundPoints=function(){
		var rst=Rectangle._temB;
		rst.length=0;
		if (this.width==0 || this.height==0)return rst;
		rst.push(this.x,this.y,this.x+this.width,this.y,this.x,this.y+this.height,this.x+this.width,this.y+this.height);
		return rst;
	}

	/**
	*确定此 Rectangle 对象是否为空。
	*@return 如果 Rectangle 对象的宽度或高度小于等于 0，则返回 true 值，否则返回 false。
	*/
	__proto.isEmpty=function(){
		if (this.width <=0 || this.height <=0)return true;
		return false;
	}

	/**此矩形右侧的 X 轴坐标。 x 和 width 属性的和。*/
	__getset(0,__proto,'right',function(){
		return this.x+this.width;
	});

	/**此矩形底端的 Y 轴坐标。y 和 height 属性的和。*/
	__getset(0,__proto,'bottom',function(){
		return this.y+this.height;
	});

	Rectangle._getBoundPointS=function(x,y,width,height){
		var rst=Rectangle._temA;
		rst.length=0;
		if (width==0 || height==0)return rst;
		rst.push(x,y,x+width,y,x,y+height,x+width,y+height);
		return rst;
	}

	Rectangle._getWrapRec=function(pointList,rst){
		if (!pointList || pointList.length < 1)return rst ? rst.setTo(0,0,0,0):Rectangle.TEMP.setTo(0,0,0,0);
		rst=rst ? rst :new Rectangle();
		var i,len=pointList.length,minX,maxX,minY,maxY,tPoint=Point.TEMP;
		minX=minY=99999;
		maxX=maxY=-minX;
		for (i=0;i < len;i+=2){
			tPoint.x=pointList[i];
			tPoint.y=pointList[i+1];
			minX=minX < tPoint.x ? minX :tPoint.x;
			minY=minY < tPoint.y ? minY :tPoint.y;
			maxX=maxX > tPoint.x ? maxX :tPoint.x;
			maxY=maxY > tPoint.y ? maxY :tPoint.y;
		}
		return rst.setTo(minX,minY,maxX-minX,maxY-minY);
	}

	Rectangle.EMPTY=new Rectangle();
	Rectangle.TEMP=new Rectangle();
	Rectangle._temB=[];
	Rectangle._temA=[];
	return Rectangle;
})()


/**
*<code>SoundManager</code> 是一个声音管理类。提供了对背景音乐、音效的播放控制方法。
*引擎默认有两套声音方案：WebAudio和H5Audio
*播放音效，优先使用WebAudio播放声音，如果WebAudio不可用，则用H5Audio播放，H5Audio在部分机器上有兼容问题（比如不能混音，播放有延迟等）。
*播放背景音乐，则使用H5Audio播放（使用WebAudio会增加特别大的内存，并且要等加载完毕后才能播放，有延迟）
*建议背景音乐用mp3类型，音效用wav或者mp3类型（如果打包为app，音效只能用wav格式）。
*详细教程及声音格式请参考：http://ldc.layabox.com/doc/?nav=ch-as-1-7-0
*/
//class laya.media.SoundManager
var SoundManager=(function(){
	function SoundManager(){}
	__class(SoundManager,'laya.media.SoundManager');
	__getset(1,SoundManager,'useAudioMusic',function(){
		return SoundManager._useAudioMusic;
		},function(value){
		SoundManager._useAudioMusic=value;
		if (value){
			SoundManager._musicClass=AudioSound;
			}else{
			SoundManager._musicClass=null;
		}
	});

	/**
	*失去焦点后是否自动停止背景音乐。
	*@param v Boolean 失去焦点后是否自动停止背景音乐。
	*
	*/
	/**
	*失去焦点后是否自动停止背景音乐。
	*/
	__getset(1,SoundManager,'autoStopMusic',function(){
		return SoundManager._autoStopMusic;
		},function(v){
		Laya.stage.off(/*laya.events.Event.BLUR*/"blur",null,SoundManager._stageOnBlur);
		Laya.stage.off(/*laya.events.Event.FOCUS*/"focus",null,SoundManager._stageOnFocus);
		Laya.stage.off(/*laya.events.Event.VISIBILITY_CHANGE*/"visibilitychange",null,SoundManager._visibilityChange);
		SoundManager._autoStopMusic=v;
		if (v){
			Laya.stage.on(/*laya.events.Event.BLUR*/"blur",null,SoundManager._stageOnBlur);
			Laya.stage.on(/*laya.events.Event.FOCUS*/"focus",null,SoundManager._stageOnFocus);
			Laya.stage.on(/*laya.events.Event.VISIBILITY_CHANGE*/"visibilitychange",null,SoundManager._visibilityChange);
		}
	});

	/**
	*背景音乐和所有音效是否静音。
	*/
	__getset(1,SoundManager,'muted',function(){
		return SoundManager._muted;
		},function(value){
		if (value==SoundManager._muted)return;
		if (value){
			SoundManager.stopAllSound();
		}
		SoundManager.musicMuted=value;
		SoundManager._muted=value;
	});

	/**
	*背景音乐（不包括音效）是否静音。
	*/
	__getset(1,SoundManager,'musicMuted',function(){
		return SoundManager._musicMuted;
		},function(value){
		if (value==SoundManager._musicMuted)return;
		if (value){
			if (SoundManager._tMusic){
				if (SoundManager._musicChannel&&!SoundManager._musicChannel.isStopped){
					SoundManager._musicChannel.pause();
					}else{
					SoundManager._musicChannel=null;
				}
				}else{
				SoundManager._musicChannel=null;
			}
			SoundManager._musicMuted=value;
			}else {
			SoundManager._musicMuted=value;
			if (SoundManager._tMusic){
				if (SoundManager._musicChannel){
					SoundManager._musicChannel.resume();
				}
			}
		}
	});

	/**
	*所有音效（不包括背景音乐）是否静音。
	*/
	__getset(1,SoundManager,'soundMuted',function(){
		return SoundManager._soundMuted;
		},function(value){
		SoundManager._soundMuted=value;
	});

	SoundManager.addChannel=function(channel){
		if (SoundManager._channels.indexOf(channel)>=0)return;
		SoundManager._channels.push(channel);
	}

	SoundManager.removeChannel=function(channel){
		var i=0;
		for (i=SoundManager._channels.length-1;i >=0;i--){
			if (SoundManager._channels[i]==channel){
				SoundManager._channels.splice(i,1);
			}
		}
	}

	SoundManager.disposeSoundIfNotUsed=function(url){
		var i=0;
		for (i=SoundManager._channels.length-1;i >=0;i--){
			if (SoundManager._channels[i].url==url){
				return;
			}
		}
		SoundManager.destroySound(url);
	}

	SoundManager._visibilityChange=function(){
		if (Laya.stage.isVisibility){
			SoundManager._stageOnFocus();
			}else {
			SoundManager._stageOnBlur();
		}
	}

	SoundManager._stageOnBlur=function(){
		SoundManager._isActive=false;
		if (SoundManager._musicChannel){
			if (!SoundManager._musicChannel.isStopped){
				SoundManager._blurPaused=true;
				SoundManager._musicChannel.pause();
			}
		}
		SoundManager.stopAllSound();
		Laya.stage.once(/*laya.events.Event.MOUSE_DOWN*/"mousedown",null,SoundManager._stageOnFocus);
	}

	SoundManager._recoverWebAudio=function(){
		if(WebAudioSound.ctx&&WebAudioSound.ctx.state!="running"&&WebAudioSound.ctx.resume)
			WebAudioSound.ctx.resume();
	}

	SoundManager._stageOnFocus=function(){
		SoundManager._isActive=true;
		SoundManager._recoverWebAudio();
		Laya.stage.off(/*laya.events.Event.MOUSE_DOWN*/"mousedown",null,SoundManager._stageOnFocus);
		if (SoundManager._blurPaused){
			if (SoundManager._musicChannel && SoundManager._musicChannel.isStopped){
				SoundManager._blurPaused=false;
				SoundManager._musicChannel.resume();
			}
		}
	}

	SoundManager.playSound=function(url,loops,complete,soundClass,startTime){
		(loops===void 0)&& (loops=1);
		(startTime===void 0)&& (startTime=0);
		if (!SoundManager._isActive || !url)return null;
		if (SoundManager._muted)return null;
		SoundManager._recoverWebAudio();
		url=URL.formatURL(url);
		if (url==SoundManager._tMusic){
			if (SoundManager._musicMuted)return null;
			}else {
			if (Render.isConchApp){
				var ext=Utils.getFileExtension(url);
				if (ext !="wav" && ext !="ogg"){
					alert("The sound only supports wav or ogg format,for optimal performance reason,please refer to the official website document.");
					return null;
				}
			}
			if (SoundManager._soundMuted)return null;
		};
		var tSound;
		if (!Browser.onMiniGame){
			tSound=Laya.loader.getRes(url);
		}
		if (!soundClass)soundClass=SoundManager._soundClass;
		if (!tSound){
			tSound=new soundClass();
			tSound.load(url);
			Loader.cacheRes(url,tSound);
		};
		var channel;
		channel=tSound.play(startTime,loops);
		if (!channel)return null;
		channel.url=url;
		channel.volume=(url==SoundManager._tMusic)? SoundManager.musicVolume :SoundManager.soundVolume;
		channel.completeHandler=complete;
		return channel;
	}

	SoundManager.destroySound=function(url){
		var tSound=Laya.loader.getRes(url);
		if (tSound){
			Loader.clearRes(url);
			tSound.dispose();
		}
	}

	SoundManager.playMusic=function(url,loops,complete,startTime){
		(loops===void 0)&& (loops=0);
		(startTime===void 0)&& (startTime=0);
		url=URL.formatURL(url);
		SoundManager._tMusic=url;
		if (SoundManager._musicChannel)SoundManager._musicChannel.stop();
		return SoundManager._musicChannel=SoundManager.playSound(url,loops,complete,SoundManager._musicClass,startTime);
	}

	SoundManager.stopSound=function(url){
		url=URL.formatURL(url);
		var i=0;
		var channel;
		for (i=SoundManager._channels.length-1;i >=0;i--){
			channel=SoundManager._channels[i];
			if (channel.url==url){
				channel.stop();
			}
		}
	}

	SoundManager.stopAll=function(){
		SoundManager._tMusic=null;
		var i=0;
		var channel;
		for (i=SoundManager._channels.length-1;i >=0;i--){
			channel=SoundManager._channels[i];
			channel.stop();
		}
	}

	SoundManager.stopAllSound=function(){
		var i=0;
		var channel;
		for (i=SoundManager._channels.length-1;i >=0;i--){
			channel=SoundManager._channels[i];
			if (channel.url !=SoundManager._tMusic){
				channel.stop();
			}
		}
	}

	SoundManager.stopMusic=function(){
		if (SoundManager._musicChannel)SoundManager._musicChannel.stop();
		SoundManager._tMusic=null;
	}

	SoundManager.setSoundVolume=function(volume,url){
		if (url){
			url=URL.formatURL(url);
			SoundManager._setVolume(url,volume);
			}else {
			SoundManager.soundVolume=volume;
			var i=0;
			var channel;
			for (i=SoundManager._channels.length-1;i >=0;i--){
				channel=SoundManager._channels[i];
				if (channel.url !=SoundManager._tMusic){
					channel.volume=volume;
				}
			}
		}
	}

	SoundManager.setMusicVolume=function(volume){
		SoundManager.musicVolume=volume;
		SoundManager._setVolume(SoundManager._tMusic,volume);
	}

	SoundManager._setVolume=function(url,volume){
		url=URL.formatURL(url);
		var i=0;
		var channel;
		for (i=SoundManager._channels.length-1;i >=0;i--){
			channel=SoundManager._channels[i];
			if (channel.url==url){
				channel.volume=volume;
			}
		}
	}

	SoundManager.musicVolume=1;
	SoundManager.soundVolume=1;
	SoundManager.playbackRate=1;
	SoundManager._useAudioMusic=true;
	SoundManager._muted=false;
	SoundManager._soundMuted=false;
	SoundManager._musicMuted=false;
	SoundManager._tMusic=null;
	SoundManager._musicChannel=null;
	SoundManager._channels=[];
	SoundManager._autoStopMusic=false;
	SoundManager._blurPaused=false;
	SoundManager._isActive=true;
	SoundManager._soundClass=null;
	SoundManager._musicClass=null;
	SoundManager.autoReleaseSound=true;
	return SoundManager;
})()


/**
*<p> <code>LocalStorage</code> 类用于没有时间限制的数据存储。</p>
*/
//class laya.net.LocalStorage
var LocalStorage=(function(){
	var Storage;
	function LocalStorage(){}
	__class(LocalStorage,'laya.net.LocalStorage');
	LocalStorage.__init__=function(){
		if (!LocalStorage._baseClass){
			LocalStorage._baseClass=Storage;
			Storage.init();
		}
		LocalStorage.items=LocalStorage._baseClass.items;
		LocalStorage.support=LocalStorage._baseClass.support;
	}

	LocalStorage.setItem=function(key,value){
		LocalStorage._baseClass.setItem(key,value);
	}

	LocalStorage.getItem=function(key){
		return LocalStorage._baseClass.getItem(key);
	}

	LocalStorage.setJSON=function(key,value){
		LocalStorage._baseClass.setJSON(key,value);
	}

	LocalStorage.getJSON=function(key){
		return LocalStorage._baseClass.getJSON(key);
	}

	LocalStorage.removeItem=function(key){
		LocalStorage._baseClass.removeItem(key);
	}

	LocalStorage.clear=function(){
		LocalStorage._baseClass.clear();
	}

	LocalStorage._baseClass=null;
	LocalStorage.items=null;
	LocalStorage.support=false;
	LocalStorage.__init$=function(){
		//class Storage
		Storage=(function(){
			function Storage(){}
			__class(Storage,'');
			Storage.init=function(){
				/*__JS__ */try{Storage.items=window.localStorage;Storage.setItem('laya','1');Storage.removeItem('laya');Storage.support=true;}catch(e){}if(!Storage.support)console.log('LocalStorage is not supprot or browser is private mode.');
			}
			Storage.setItem=function(key,value){
				try {
					Storage.support && Storage.items.setItem(key,value);
					}catch (e){
					console.warn("set localStorage failed",e);
				}
			}
			Storage.getItem=function(key){
				return Storage.support ? Storage.items.getItem(key):null;
			}
			Storage.setJSON=function(key,value){
				try {
					Storage.support && Storage.items.setItem(key,JSON.stringify(value));
					}catch (e){
					console.warn("set localStorage failed",e);
				}
			}
			Storage.getJSON=function(key){
				return JSON.parse(Storage.support ? Storage.items.getItem(key):null);
			}
			Storage.removeItem=function(key){
				Storage.support && Storage.items.removeItem(key);
			}
			Storage.clear=function(){
				Storage.support && Storage.items.clear();
			}
			Storage.items=null;
			Storage.support=false;
			return Storage;
		})()
	}

	return LocalStorage;
})()


/**
*<p>资源版本的生成由layacmd或IDE完成，使用 <code>ResourceVersion</code> 简化使用过程。</p>
*<p>调用 <code>enable</code> 启用资源版本管理。</p>
*/
//class laya.net.ResourceVersion
var ResourceVersion=(function(){
	function ResourceVersion(){}
	__class(ResourceVersion,'laya.net.ResourceVersion');
	ResourceVersion.enable=function(manifestFile,callback,type){
		(type===void 0)&& (type=2);
		laya.net.ResourceVersion.type=type;
		Laya.loader.load(manifestFile,Handler.create(null,ResourceVersion.onManifestLoaded,[callback]),null,/*laya.net.Loader.JSON*/"json");
		URL.customFormat=ResourceVersion.addVersionPrefix;
	}

	ResourceVersion.onManifestLoaded=function(callback,data){
		ResourceVersion.manifest=data;
		callback.run();
		if (!data){
			console.warn("资源版本清单文件不存在，不使用资源版本管理。忽略ERR_FILE_NOT_FOUND错误。");
		}
	}

	ResourceVersion.addVersionPrefix=function(originURL){
		if (ResourceVersion.manifest && ResourceVersion.manifest[originURL]){
			if (ResourceVersion.type==2)return ResourceVersion.manifest[originURL];
			return ResourceVersion.manifest[originURL]+"/"+originURL;
		}
		return originURL;
	}

	ResourceVersion.FOLDER_VERSION=1;
	ResourceVersion.FILENAME_VERSION=2;
	ResourceVersion.manifest=null;
	ResourceVersion.type=1;
	return ResourceVersion;
})()


/**
*@private
*/
//class laya.net.TTFLoader
var TTFLoader=(function(){
	function TTFLoader(){
		this.fontName=null;
		this.complete=null;
		this.err=null;
		this._fontTxt=null;
		this._url=null;
		this._div=null;
		this._txtWidth=NaN;
		this._http=null;
	}

	__class(TTFLoader,'laya.net.TTFLoader');
	var __proto=TTFLoader.prototype;
	__proto.load=function(fontPath){
		this._url=fontPath;
		var tArr=fontPath.split(".ttf")[0].split("/");
		this.fontName=tArr[tArr.length-1];
		if (Browser.window.conch){
			this._loadConch();
		}else
		if (Browser.window.FontFace){
			this._loadWithFontFace()
		}
		else {
			this._loadWithCSS();
		}
	}

	__proto._loadConch=function(){
		this._http=new HttpRequest();
		this._http.on(/*laya.events.Event.ERROR*/"error",this,this._onErr);
		this._http.on(/*laya.events.Event.COMPLETE*/"complete",this,this._onHttpLoaded);
		this._http.send(this._url,null,"get",/*laya.net.Loader.BUFFER*/"arraybuffer");
	}

	__proto._onHttpLoaded=function(data){
		Browser.window.conch.setFontFaceFromBuffer(this.fontName,data);
		this._clearHttp();
		this._complete();
	}

	__proto._clearHttp=function(){
		if (this._http){
			this._http.off(/*laya.events.Event.ERROR*/"error",this,this._onErr);
			this._http.off(/*laya.events.Event.COMPLETE*/"complete",this,this._onHttpLoaded);
			this._http=null;
		}
	}

	__proto._onErr=function(){
		this._clearHttp();
		if (this.err){
			this.err.runWith("fail:"+this._url);
			this.err=null;
		}
	}

	__proto._complete=function(){
		Laya.timer.clear(this,this._complete);
		Laya.timer.clear(this,this._checkComplete);
		if (this._div && this._div.parentNode){
			this._div.parentNode.removeChild(this._div);
			this._div=null;
		}
		if (this.complete){
			this.complete.runWith(this);
			this.complete=null;
		}
	}

	__proto._checkComplete=function(){
		if (RunDriver.measureText("LayaTTFFont",this._fontTxt).width !=this._txtWidth){
			this._complete();
		}
	}

	__proto._loadWithFontFace=function(){
		var fontFace=new Browser.window.FontFace(this.fontName,"url('"+this._url+"')");
		Browser.window.document.fonts.add(fontFace);
		var self=this;
		fontFace.loaded.then((function(){
			self._complete()
		}));
		fontFace.load();
	}

	__proto._createDiv=function(){
		this._div=Browser.createElement("div");
		this._div.innerHTML="laya";
		var _style=this._div.style;
		_style.fontFamily=this.fontName;
		_style.position="absolute";
		_style.left="-100px";
		_style.top="-100px";
		Browser.document.body.appendChild(this._div);
	}

	__proto._loadWithCSS=function(){
		var _$this=this;
		var fontStyle=Browser.createElement("style");
		fontStyle.type="text/css";
		Browser.document.body.appendChild(fontStyle);
		fontStyle.textContent="@font-face { font-family:'"+this.fontName+"'; src:url('"+this._url+"');}";
		this._fontTxt="40px "+this.fontName;
		this._txtWidth=RunDriver.measureText("LayaTTFFont",this._fontTxt).width;
		var self=this;
		fontStyle.onload=function (){
			Laya.timer.once(10000,self,_$this._complete);
		};
		Laya.timer.loop(20,this,this._checkComplete);
		this._createDiv();
	}

	TTFLoader._testString="LayaTTFFont";
	return TTFLoader;
})()


/**
*<p> <code>URL</code> 类用于定义地址信息。</p>
*/
//class laya.net.URL
var URL=(function(){
	function URL(url){
		/**@private */
		this._url=null;
		/**@private */
		this._path=null;
		this._url=URL.formatURL(url);
		this._path=URL.getPath(url);
	}

	__class(URL,'laya.net.URL');
	var __proto=URL.prototype;
	/**地址的路径。*/
	__getset(0,__proto,'path',function(){
		return this._path;
	});

	/**格式化后的地址。*/
	__getset(0,__proto,'url',function(){
		return this._url;
	});

	URL.formatURL=function(url,base){
		if (!url)return "null path";
		if (url.indexOf(":")> 0)return url;
		if (URL.customFormat !=null)url=URL.customFormat(url,base);
		var char1=url.charAt(0);
		if (char1==="."){
			return URL.formatRelativePath((base || URL.basePath)+url);
			}else if (char1==='~'){
			return URL.rootPath+url.substring(1);
			}else if (char1==="d"){
			if (url.indexOf("data:image")===0)return url;
			}else if (char1==="/"){
			return url;
		}
		return (base || URL.basePath)+url;
	}

	URL.formatRelativePath=function(value){
		var parts=value.split("/");
		for (var i=0,len=parts.length;i < len;i++){
			if (parts[i]=='..'){
				parts.splice(i-1,2);
				i-=2;
			}
		}
		return parts.join('/');
	}

	URL.isAbsolute=function(url){
		return url.indexOf(":")> 0 || url.charAt(0)=='/';
	}

	URL.getPath=function(url){
		var ofs=url.lastIndexOf('/');
		return ofs > 0 ? url.substr(0,ofs+1):"";
	}

	URL.getFileName=function(url){
		var ofs=url.lastIndexOf('/');
		return ofs > 0 ? url.substr(ofs+1):url;
	}

	URL.version={};
	URL.basePath="";
	URL.rootPath="";
	URL.customFormat=function(url){
		var newUrl=URL.version[url];
		if (!Render.isConchApp && newUrl)url+="?v="+newUrl;
		return url;
	}

	return URL;
})()


/**
*@private
*<code>Render</code> 是渲染管理类。它是一个单例，可以使用 Laya.render 访问。
*/
//class laya.renders.Render
var Render=(function(){
	function Render(width,height){
		/**@private */
		this._timeId=0;
		var style=Render._mainCanvas.source.style;
		style.position='absolute';
		style.top=style.left="0px";
		style.background="#000000";
		Render._mainCanvas.source.id="layaCanvas";
		var isWebGl=laya.renders.Render.isWebGL;
		Render._mainCanvas.source.width=width;
		Render._mainCanvas.source.height=height;
		isWebGl && Render.WebGL.init(Render._mainCanvas,width,height);
		Browser.container.appendChild(Render._mainCanvas.source);
		Render._context=new RenderContext(width,height,isWebGl ? null :Render._mainCanvas);
		Render._context.ctx.setIsMainContext();
		Browser.window.requestAnimationFrame(loop);
		function loop (){
			Laya.stage._loop();
			Browser.window.requestAnimationFrame(loop);
		}
		Laya.stage.on("visibilitychange",this,this._onVisibilitychange);
	}

	__class(Render,'laya.renders.Render');
	var __proto=Render.prototype;
	/**@private */
	__proto._onVisibilitychange=function(){
		if (!Laya.stage.isVisibility){
			this._timeId=Browser.window.setInterval(this._enterFrame,1000);
			}else if (this._timeId !=0){
			Browser.window.clearInterval(this._timeId);
		}
	}

	/**@private */
	__proto._enterFrame=function(e){
		Laya.stage._loop();
	}

	/**目前使用的渲染器。*/
	__getset(1,Render,'context',function(){
		return Render._context;
	});

	/**渲染使用的原生画布引用。 */
	__getset(1,Render,'canvas',function(){
		return Render._mainCanvas.source;
	});

	Render._context=null;
	Render._mainCanvas=null;
	Render.WebGL=null;
	Render.isConchNode=false;
	Render.isConchApp=false;
	Render.isConchWebGL=false;
	Render.isWebGL=false;
	Render.is3DMode=false;
	Render.optimizeTextureMemory=function(url,texture){
		return true;
	}

	Render.__init$=function(){
		/*__JS__ */window.ConchRenderType=window.ConchRenderType||1;
		/*__JS__ */window.ConchRenderType|=(!window.conch?0:0x04);;{
			Render.isConchNode=/*__JS__ */(window.ConchRenderType & 5)==5;
			Render.isConchApp=/*__JS__ */(window.ConchRenderType & 0x04)==0x04;
			Render.isConchWebGL=/*__JS__ */window.ConchRenderType==6;
		};;
	}

	return Render;
})()


/**
*@private
*渲染环境
*/
//class laya.renders.RenderContext
var RenderContext=(function(){
	function RenderContext(width,height,canvas){
		/**全局x坐标 */
		this.x=0;
		/**全局y坐标 */
		this.y=0;
		/**当前使用的画布 */
		//this.canvas=null;
		/**当前使用的画布上下文 */
		//this.ctx=null;
		this._drawTexture=function(x,y,args){
			if (args[0].loaded)this.ctx.drawTexture(args[0],args[1],args[2],args[3],args[4],x,y);
		}
		this._fillTexture=function(x,y,args){
			if (args[0].loaded)this.ctx.fillTexture(args[0],args[1]+x,args[2]+y,args[3],args[4],args[5],args[6],args[7]);
		}
		this._drawTextureWithTransform=function(x,y,args){
			if (args[0].loaded)this.ctx.drawTextureWithTransform(args[0],args[1],args[2],args[3],args[4],args[5],x,y,args[6]);
		}
		this._fillQuadrangle=function(x,y,args){
			this.ctx.fillQuadrangle(args[0],args[1],args[2],args[3],args[4]);
		}
		this._drawRect=function(x,y,args){
			var ctx=this.ctx;
			if (args[4] !=null){
				ctx.fillStyle=args[4];
				ctx.fillRect(x+args[0],y+args[1],args[2],args[3],null);
			}
			if (args[5] !=null){
				ctx.strokeStyle=args[5];
				ctx.lineWidth=args[6];
				ctx.strokeRect(x+args[0],y+args[1],args[2],args[3],args[6]);
			}
		}
		//矢量方法
		this._drawPie=function(x,y,args){
			var ctx=this.ctx;
			Render.isWebGL && ctx.setPathId(args[8]);
			ctx.beginPath();
			if (Render.isWebGL){
				ctx.movePath(args[0]+x,args[1]+y);
				ctx.moveTo(0,0);
				}else {
				ctx.moveTo(x+args[0],y+args[1]);
			}
			ctx.arc(x+args[0],y+args[1],args[2],args[3],args[4]);
			ctx.closePath();
			this._fillAndStroke(args[5],args[6],args[7],true);
		}
		this._clipRect=function(x,y,args){
			this.ctx.clipRect(x+args[0],y+args[1],args[2],args[3]);
		}
		this._fillRect=function(x,y,args){
			this.ctx.fillRect(x+args[0],y+args[1],args[2],args[3],args[4]);
		}
		this._drawCircle=function(x,y,args){
			var ctx=this.ctx;
			Render.isWebGL && ctx.setPathId(args[6]);
			Stat.drawCall++;
			ctx.beginPath();
			Render.isWebGL && ctx.movePath(args[0]+x,args[1]+y);
			ctx.arc(args[0]+x,args[1]+y,args[2],0,RenderContext.PI2);
			ctx.closePath();
			this._fillAndStroke(args[3],args[4],args[5],true);
		}
		this._fillCircle=function(x,y,args){
			Stat.drawCall++;
			var ctx=this.ctx;
			ctx.beginPath();
			ctx.fillStyle=args[3];
			ctx.arc(args[0]+x,args[1]+y,args[2],0,RenderContext.PI2);
			ctx.fill();
		}
		this._setShader=function(x,y,args){
			this.ctx.setShader(args[0]);
		}
		this._drawLine=function(x,y,args){
			var ctx=this.ctx;
			Render.isWebGL && ctx.setPathId(args[6]);
			ctx.beginPath();
			ctx.strokeStyle=args[4];
			ctx.lineWidth=args[5];
			if (Render.isWebGL){
				ctx.movePath(x,y);
				ctx.moveTo(args[0],args[1]);
				ctx.lineTo(args[2],args[3]);
				}else {
				ctx.moveTo(x+args[0],y+args[1]);
				ctx.lineTo(x+args[2],y+args[3]);
			}
			ctx.stroke();
		}
		this._drawLines=function(x,y,args){
			var ctx=this.ctx;
			Render.isWebGL && ctx.setPathId(args[5]);
			ctx.beginPath();
			x+=args[0],y+=args[1];
			Render.isWebGL && ctx.movePath(x,y);
			ctx.strokeStyle=args[3];
			ctx.lineWidth=args[4];
			var points=args[2];
			var i=2,n=points.length;
			if (Render.isWebGL){
				ctx.moveTo(points[0],points[1]);
				while (i < n){
					ctx.lineTo(points[i++],points[i++]);
				}
				}else {
				ctx.moveTo(x+points[0],y+points[1]);
				while (i < n){
					ctx.lineTo(x+points[i++],y+points[i++]);
				}
			}
			ctx.stroke();
		}
		this._drawLinesWebGL=function(x,y,args){
			this.ctx.drawLines(x+this.x+args[0],y+this.y+args[1],args[2],args[3],args[4]);
		}
		//x:Number,y:Number,points:Array,lineColor:String,lineWidth:Number=1
		this._drawCurves=function(x,y,args){
			this.ctx.drawCurves(x,y,args);
		}
		this._draw=function(x,y,args){
			args[0].call(null,this,x,y);
		}
		this._transformByMatrix=function(x,y,args){
			this.ctx.transformByMatrix(args[0]);
		}
		this._setTransform=function(x,y,args){
			this.ctx.setTransform(args[0],args[1],args[2],args[3],args[4],args[5]);
		}
		this._setTransformByMatrix=function(x,y,args){
			this.ctx.setTransformByMatrix(args[0]);
		}
		this._save=function(x,y,args){
			this.ctx.save();
		}
		this._restore=function(x,y,args){
			this.ctx.restore();
		}
		this._translate=function(x,y,args){
			this.ctx.translate(args[0],args[1]);
		}
		this._transform=function(x,y,args){
			this.ctx.translate(args[1]+x,args[2]+y);
			var mat=args[0];
			this.ctx.transform(mat.a,mat.b,mat.c,mat.d,mat.tx,mat.ty);
			this.ctx.translate(-x-args[1],-y-args[2]);
		}
		this._rotate=function(x,y,args){
			this.ctx.translate(args[1]+x,args[2]+y);
			this.ctx.rotate(args[0]);
			this.ctx.translate(-x-args[1],-y-args[2]);
		}
		this._scale=function(x,y,args){
			this.ctx.translate(args[2]+x,args[3]+y);
			this.ctx.scale(args[0],args[1]);
			this.ctx.translate(-x-args[2],-y-args[3]);
		}
		this._alpha=function(x,y,args){
			this.ctx.globalAlpha *=args[0];
		}
		this._setAlpha=function(x,y,args){
			this.ctx.globalAlpha=args[0];
		}
		this._fillText=function(x,y,args){
			this.ctx.fillText(args[0],args[1]+x,args[2]+y,args[3],args[4],args[5]);
		}
		this._strokeText=function(x,y,args){
			this.ctx.strokeText(args[0],args[1]+x,args[2]+y,args[3],args[4],args[5],args[6]);
		}
		this._fillBorderText=function(x,y,args){
			this.ctx.fillBorderText(args[0],args[1]+x,args[2]+y,args[3],args[4],args[5],args[6],args[7]);
		}
		this._blendMode=function(x,y,args){
			this.ctx.globalCompositeOperation=args[0];
		}
		this._beginClip=function(x,y,args){
			this.ctx.beginClip && this.ctx.beginClip(x+args[0],y+args[1],args[2],args[3]);
		}
		this._setIBVB=function(x,y,args){
			this.ctx.setIBVB(args[0]+x,args[1]+y,args[2],args[3],args[4],args[5],args[6],args[7]);
		}
		this._fillTrangles=function(x,y,args){
			this.ctx.fillTrangles(args[0],args[1]+x,args[2]+y,args[3],args[4]);
		}
		//x:Number,y:Number,paths:Array,brush:Object=null,pen:Object=null
		this._drawPath=function(x,y,args){
			var ctx=this.ctx;
			Render.isWebGL && ctx.setPathId(-1);
			ctx.beginPath();
			x+=args[0],y+=args[1];
			Render.isWebGL && ctx.movePath(x,y);
			var paths=args[2];
			for (var i=0,n=paths.length;i < n;i++){
				var path=paths[i];
				switch (path[0]){
					case "moveTo":
						Render.isWebGL ? ctx.moveTo(path[1],path[2]):ctx.moveTo(x+path[1],y+path[2]);
						break ;
					case "lineTo":
						Render.isWebGL ? ctx.lineTo(path[1],path[2]):ctx.lineTo(x+path[1],y+path[2]);
						break ;
					case "arcTo":
						Render.isWebGL ? ctx.arcTo(path[1],path[2],path[3],path[4],path[5]):ctx.arcTo(x+path[1],y+path[2],x+path[3],y+path[4],path[5]);
						break ;
					case "closePath":
						ctx.closePath();
						break ;
					}
			};
			var brush=args[3];
			if (brush !=null){
				ctx.fillStyle=brush.fillStyle;
				ctx.fill();
			};
			var pen=args[4];
			if (pen !=null){
				ctx.strokeStyle=pen.strokeStyle;
				ctx.lineWidth=pen.lineWidth || 1;
				ctx.lineJoin=pen.lineJoin;
				ctx.lineCap=pen.lineCap;
				ctx.miterLimit=pen.miterLimit;
				ctx.stroke();
			}
		}
		// polygon(x:Number,y:Number,r:Number,edges:Number,color:uint,borderWidth:int=2,borderColor:uint=0)
		this.drawPoly=function(x,y,args){
			this.ctx.drawPoly(x+this.x+args[0],y+this.y+args[1],args[2],args[3],args[4],args[5],args[6]);
		}
		//x:Number,y:Number,points:Array,fillColor:String,lineColor:String=null,lineWidth:Number=1
		this._drawPoly=function(x,y,args){
			var ctx=this.ctx;
			var points=args[2];
			var i=2,n=points.length;
			if (Render.isWebGL){
				ctx.setPathId(args[6]);
				ctx.beginPath();
				x+=args[0],y+=args[1];
				ctx.movePath(x,y);
				ctx.moveTo(points[0],points[1]);
				while (i < n){
					ctx.lineTo(points[i++],points[i++]);
				}
				}else {
				ctx.beginPath();
				x+=args[0],y+=args[1];
				ctx.moveTo(x+points[0],y+points[1]);
				while (i < n){
					ctx.lineTo(x+points[i++],y+points[i++]);
				}
			}
			ctx.closePath();
			this._fillAndStroke(args[3],args[4],args[5],args[7]);
		}
		this._drawSkin=function(x,y,args){
			var tSprite=args[0];
			if (tSprite){
				var ctx=this.ctx;
				tSprite.render(ctx,x,y);
			}
		}
		this._drawParticle=function(x,y,args){
			this.ctx.drawParticle(x+this.x,y+this.y,args[0]);
		}
		this._setFilters=function(x,y,args){
			this.ctx.setFilters(args);
		}
		if (canvas){
			this.ctx=canvas.getContext('2d');
			}else {
			canvas=HTMLCanvas.create("3D");
			this.ctx=RunDriver.createWebGLContext2D(canvas);
			canvas._setContext(this.ctx);
		}
		canvas.size(width,height);
		this.canvas=canvas;
	}

	__class(RenderContext,'laya.renders.RenderContext');
	var __proto=RenderContext.prototype;
	/**销毁当前渲染环境*/
	__proto.destroy=function(){
		if (this.canvas){
			this.canvas.destroy();
			this.canvas=null;
			this.ctx=null;
		}
		if (this.ctx){
			this.ctx.destroy();
			this.ctx=null;
		}
	}

	__proto.drawTexture=function(tex,x,y,width,height){
		if (tex.loaded)this.ctx.drawTexture(tex,x,y,width,height,this.x,this.y);
	}

	__proto._drawTextures=function(x,y,args){
		if (args[0].loaded)this.ctx.drawTextures(args[0],args[1],x+this.x,y+this.y);
	}

	__proto.drawTextureWithTransform=function(tex,x,y,width,height,m,alpha){
		if (tex.loaded)this.ctx.drawTextureWithTransform(tex,x,y,width,height,m,this.x,this.y,alpha);
	}

	__proto.fillQuadrangle=function(tex,x,y,point4,m){
		this.ctx.fillQuadrangle(tex,x,y,point4,m);
	}

	__proto.drawCanvas=function(canvas,x,y,width,height){
		this.ctx.drawCanvas(canvas,x+this.x,y+this.y,width,height);
	}

	__proto.drawRect=function(x,y,width,height,color,lineWidth){
		(lineWidth===void 0)&& (lineWidth=1);
		var ctx=this.ctx;
		ctx.strokeStyle=color;
		ctx.lineWidth=lineWidth;
		ctx.strokeRect(x+this.x,y+this.y,width,height,lineWidth);
	}

	__proto._fillAndStroke=function(fillColor,strokeColor,lineWidth,isConvexPolygon){
		(isConvexPolygon===void 0)&& (isConvexPolygon=false);
		var ctx=this.ctx;
		if (fillColor !=null){
			ctx.fillStyle=fillColor;
			if (Render.isWebGL){
				ctx.fill(isConvexPolygon);
				}else {
				ctx.fill();
			}
		}
		if (strokeColor !=null && lineWidth > 0){
			ctx.strokeStyle=strokeColor;
			ctx.lineWidth=lineWidth;
			ctx.stroke();
		}
	}

	//ctx.translate(-x-args[0],-y-args[1]);
	__proto.clipRect=function(x,y,width,height){
		this.ctx.clipRect(x+this.x,y+this.y,width,height);
	}

	__proto.fillRect=function(x,y,width,height,fillStyle){
		this.ctx.fillRect(x+this.x,y+this.y,width,height,fillStyle);
	}

	__proto.drawCircle=function(x,y,radius,color,lineWidth){
		(lineWidth===void 0)&& (lineWidth=1);
		Stat.drawCall++;
		var ctx=this.ctx;
		ctx.beginPath();
		ctx.strokeStyle=color;
		ctx.lineWidth=lineWidth;
		ctx.arc(x+this.x,y+this.y,radius,0,RenderContext.PI2);
		ctx.stroke();
	}

	/**
	*绘制三角形
	*@param x
	*@param y
	*@param tex
	*@param args [x,y,texture,vertices,indices,uvs,matrix]
	*/
	__proto.drawTriangles=function(x,y,args){
		if (Render.isWebGL){
			this.ctx.drawTriangles(args[0],x+args[1],y+args[2],args[3],args[4],args[5],args[6],args[7],args[8],args[9]);
			}else {
			var indices=args[5];
			var i=0,len=indices.length;
			var ctx=this.ctx;
			for (i=0;i < len;i+=3){
				var index0=indices[i] *2;
				var index1=indices[i+1] *2;
				var index2=indices[i+2] *2;
				ctx.drawTriangle(args[0],args[3],args[4],index0,index1,index2,args[6],true);
			}
		}
	}

	__proto.fillCircle=function(x,y,radius,color){
		Stat.drawCall++;
		var ctx=this.ctx;
		ctx.beginPath();
		ctx.fillStyle=color;
		ctx.arc(x+this.x,y+this.y,radius,0,RenderContext.PI2);
		ctx.fill();
	}

	__proto.setShader=function(shader){
		this.ctx.setShader(shader);
	}

	__proto.drawLine=function(fromX,fromY,toX,toY,color,lineWidth){
		(lineWidth===void 0)&& (lineWidth=1);
		var ctx=this.ctx;
		ctx.beginPath();
		ctx.strokeStyle=color;
		ctx.lineWidth=lineWidth;
		ctx.moveTo(this.x+fromX,this.y+fromY);
		ctx.lineTo(this.x+toX,this.y+toY);
		ctx.stroke();
	}

	__proto.clear=function(){
		this.ctx.clear();
	}

	__proto.transformByMatrix=function(value){
		this.ctx.transformByMatrix(value);
	}

	__proto.setTransform=function(a,b,c,d,tx,ty){
		this.ctx.setTransform(a,b,c,d,tx,ty);
	}

	__proto.setTransformByMatrix=function(value){
		this.ctx.setTransformByMatrix(value);
	}

	__proto.save=function(){
		this.ctx.save();
	}

	__proto.restore=function(){
		this.ctx.restore();
	}

	__proto.translate=function(x,y){
		this.ctx.translate(x,y);
	}

	__proto.transform=function(a,b,c,d,tx,ty){
		this.ctx.transform(a,b,c,d,tx,ty);
	}

	__proto.rotate=function(angle){
		this.ctx.rotate(angle);
	}

	__proto.scale=function(scaleX,scaleY){
		this.ctx.scale(scaleX,scaleY);
	}

	__proto.alpha=function(value){
		this.ctx.globalAlpha *=value;
	}

	__proto.setAlpha=function(value){
		this.ctx.globalAlpha=value;
	}

	__proto.fillWords=function(words,x,y,font,color,underLine){
		(underLine===void 0)&& (underLine=0);
		this.ctx.fillWords(words,x,y,font,color,underLine);
	}

	/***@private */
	__proto.fillBorderWords=function(words,x,y,font,fillColor,borderColor,lineWidth){
		this.ctx.fillBorderWords(words,x,y,font,fillColor,borderColor,lineWidth);
	}

	__proto.fillText=function(text,x,y,font,color,textAlign){
		this.ctx.fillText(text,x+this.x,y+this.y,font,color,textAlign);
	}

	__proto.strokeText=function(text,x,y,font,color,lineWidth,textAlign){
		this.ctx.strokeText(text,x+this.x,y+this.y,font,color,lineWidth,textAlign);
	}

	__proto.blendMode=function(type){
		this.ctx.globalCompositeOperation=type;
	}

	__proto.flush=function(){
		this.ctx.flush && this.ctx.flush();
	}

	__proto.addRenderObject=function(o){
		this.ctx.addRenderObject(o);
	}

	__proto.beginClip=function(x,y,w,h){
		this.ctx.beginClip && this.ctx.beginClip(x,y,w,h);
	}

	__proto.endClip=function(){
		this.ctx.endClip && this.ctx.endClip();
	}

	__proto.fillTrangles=function(x,y,args){
		this.ctx.fillTrangles(args[0],args[1],args[2],args[3],args.length > 4 ? args[4] :null);
	}

	RenderContext.PI2=2 *Math.PI;
	return RenderContext;
})()


/**
*@private
*精灵渲染器
*/
//class laya.renders.RenderSprite
var RenderSprite=(function(){
	function RenderSprite(type,next){
		/**@private */
		//this._next=null;
		/**@private */
		//this._fun=null;
		this._next=next || RenderSprite.NORENDER;
		switch (type){
			case 0:
				this._fun=this._no;
				return;
			case 0x01:
				this._fun=this._image;
				return;
			case 0x02:
				this._fun=this._alpha;
				return;
			case 0x04:
				this._fun=this._transform;
				return;
			case 0x08:
				this._fun=this._blend;
				return;
			case 0x10:
				this._fun=this._canvas;
				return;
			case 0x40:
				this._fun=this._mask;
				return;
			case 0x80:
				this._fun=this._clip;
				return;
			case 0x100:
				this._fun=this._style;
				return;
			case 0x200:
				this._fun=this._graphics;
				return;
			case 0x800:
				this._fun=this._childs;
				return;
			case 0x400:
				this._fun=this._custom;
				return;
			case 0x01 | 0x200:
				this._fun=this._image2;
				return;
			case 0x01 | 0x04 | 0x200:
				this._fun=this._image2;
				return;
			case 0x20:
				this._fun=Filter._filter;
				return;
			case 0x11111:
				this._fun=RenderSprite._initRenderFun;
				return;
			}
		this.onCreate(type);
	}

	__class(RenderSprite,'laya.renders.RenderSprite');
	var __proto=RenderSprite.prototype;
	__proto.onCreate=function(type){}
	__proto._style=function(sprite,context,x,y){
		sprite._style.render(sprite,context,x,y);
		var next=this._next;
		next._fun.call(next,sprite,context,x,y);
	}

	__proto._no=function(sprite,context,x,y){}
	__proto._custom=function(sprite,context,x,y){
		sprite.customRender(context,x,y);
		var tf=sprite._style._tf;
		this._next._fun.call(this._next,sprite,context,x-tf.translateX,y-tf.translateY);
	}

	__proto._clip=function(sprite,context,x,y){
		var next=this._next;
		if (next==RenderSprite.NORENDER)return;
		var r=sprite._style.scrollRect;
		context.ctx.save();
		context.ctx.clipRect(x,y,r.width,r.height);
		next._fun.call(next,sprite,context,x-r.x,y-r.y);
		context.ctx.restore();
	}

	__proto._blend=function(sprite,context,x,y){
		var style=sprite._style;
		if (style.blendMode){
			context.ctx.globalCompositeOperation=style.blendMode;
		};
		var next=this._next;
		next._fun.call(next,sprite,context,x,y);
		context.ctx.globalCompositeOperation="source-over";
	}

	__proto._mask=function(sprite,context,x,y){
		var next=this._next;
		next._fun.call(next,sprite,context,x,y);
		var mask=sprite.mask;
		if (mask){
			context.ctx.globalCompositeOperation="destination-in";
			if (mask.numChildren > 0 || !mask.graphics._isOnlyOne()){
				mask.cacheAsBitmap=true;
			}
			mask.render(context,x-sprite.pivotX,y-sprite.pivotY);
		}
		context.ctx.globalCompositeOperation="source-over";
	}

	__proto._graphics=function(sprite,context,x,y){
		var tf=sprite._style._tf;
		sprite._graphics && sprite._graphics._render(sprite,context,x-tf.translateX,y-tf.translateY);
		var next=this._next;
		next._fun.call(next,sprite,context,x,y);
	}

	__proto._image=function(sprite,context,x,y){
		var style=sprite._style;
		context.ctx.drawTexture2(x,y,style._tf.translateX,style._tf.translateY,sprite.transform,style.alpha,style.blendMode,sprite._graphics._one);
	}

	__proto._image2=function(sprite,context,x,y){
		var tf=sprite._style._tf;
		context.ctx.drawTexture2(x,y,tf.translateX,tf.translateY,sprite.transform,1,null,sprite._graphics._one);
	}

	__proto._alpha=function(sprite,context,x,y){
		var style=sprite._style;
		var alpha;
		if ((alpha=style.alpha)> 0.01 || sprite._needRepaint()){
			var temp=context.ctx.globalAlpha;
			context.ctx.globalAlpha *=alpha;
			var next=this._next;
			next._fun.call(next,sprite,context,x,y);
			context.ctx.globalAlpha=temp;
		}
	}

	__proto._transform=function(sprite,context,x,y){
		var transform=sprite.transform,_next=this._next;
		if (transform && _next !=RenderSprite.NORENDER){
			context.save();
			context.transform(transform.a,transform.b,transform.c,transform.d,transform.tx+x,transform.ty+y);
			_next._fun.call(_next,sprite,context,0,0);
			context.restore();
		}else
		_next._fun.call(_next,sprite,context,x,y);
	}

	__proto._childs=function(sprite,context,x,y){
		var style=sprite._style;
		var tf=style._tf;
		x=x-tf.translateX+style.paddingLeft;
		y=y-tf.translateY+style.paddingTop;
		if (style._calculation){
			var words=sprite._getWords();
			if (words){
				var tStyle=style;
				if (tStyle){
					if (tStyle.stroke){
						context.fillBorderWords(words,x,y,tStyle.font,tStyle.color,tStyle.strokeColor,tStyle.stroke);
						}else{
						context.fillWords(words,x,y,tStyle.font,tStyle.color,(tStyle.textDecoration!="none"&&tStyle.underLine)?1:0);
					}
				}
			}
		};
		var childs=sprite._childs,n=childs.length,ele;
		if (sprite.viewport || (sprite.optimizeScrollRect && sprite._style.scrollRect)){
			var rect=sprite.viewport || sprite._style.scrollRect;
			var left=rect.x;
			var top=rect.y;
			var right=rect.right;
			var bottom=rect.bottom;
			var _x=NaN,_y=NaN;
			for (i=0;i < n;++i){
				if ((ele=childs [i]).visible && ((_x=ele._x)< right && (_x+ele.width)> left && (_y=ele._y)< bottom && (_y+ele.height)> top)){
					ele.render(context,x,y);
				}
			}
			}else {
			for (var i=0;i < n;++i)
			(ele=(childs [i]))._style.visible && ele.render(context,x,y);
		}
	}

	//}
	__proto._canvas=function(sprite,context,x,y){
		var _cacheCanvas=sprite._$P.cacheCanvas;
		if (!_cacheCanvas){
			this._next._fun.call(this._next,sprite,context,x,y);
			return;
		}
		_cacheCanvas.type==='bitmap' ? (Stat.canvasBitmap++):(Stat.canvasNormal++);
		var tx=_cacheCanvas.ctx;
		if (sprite._needRepaint()|| !tx){
			this._canvas_repaint(sprite,context,x,y);
		}
		else{
			var tRec=_cacheCanvas._cacheRec;
			context.drawCanvas(tx.canvas,x+tRec.x,y+tRec.y,tRec.width,tRec.height);
		}
	}

	__proto._canvas_repaint=function(sprite,context,x,y){
		var _cacheCanvas=sprite._$P.cacheCanvas;
		var _next=this._next;
		if (!_cacheCanvas){
			_next._fun.call(_next,sprite,tx,x,y);
			return;
		};
		var tx=_cacheCanvas.ctx;
		var _repaint=sprite._needRepaint()|| (!tx);
		var canvas;
		var left;
		var top;
		var tRec;
		var tCacheType=_cacheCanvas.type;
		tCacheType==='bitmap' ? (Stat.canvasBitmap++):(Stat.canvasNormal++);
		if (_repaint){
			if (!_cacheCanvas._cacheRec)
				_cacheCanvas._cacheRec=new Rectangle();
			var w,h;
			if (!Render.isWebGL || tCacheType==="bitmap"){
				tRec=sprite.getSelfBounds();
				tRec.x=tRec.x-sprite.pivotX;
				tRec.y=tRec.y-sprite.pivotY;
				tRec.x=tRec.x-16;
				tRec.y=tRec.y-16;
				tRec.width=tRec.width+32;
				tRec.height=tRec.height+32;
				tRec.x=Math.floor(tRec.x+x)-x;
				tRec.y=Math.floor(tRec.y+y)-y;
				tRec.width=Math.floor(tRec.width);
				tRec.height=Math.floor(tRec.height);
				_cacheCanvas._cacheRec.copyFrom(tRec);
				}else{
				_cacheCanvas._cacheRec.setTo(-sprite.pivotX,-sprite.pivotY,1,1);
			}
			tRec=_cacheCanvas._cacheRec;
			var scaleX=Render.isWebGL ? 1 :Browser.pixelRatio *Laya.stage.clientScaleX;
			var scaleY=Render.isWebGL ? 1 :Browser.pixelRatio *Laya.stage.clientScaleY;
			if (!Render.isWebGL){
				var chainScaleX=1;
				var chainScaleY=1;
				var tar;
				tar=sprite;
				while (tar && tar !=Laya.stage){
					chainScaleX *=tar.scaleX;
					chainScaleY *=tar.scaleY;
					tar=tar.parent;
				}
				if (Render.isWebGL){
					if (chainScaleX < 1)scaleX *=chainScaleX;
					if (chainScaleY < 1)scaleY *=chainScaleY;
					}else {
					if (chainScaleX > 1)scaleX *=chainScaleX;
					if (chainScaleY > 1)scaleY *=chainScaleY;
				}
			}
			if (sprite.scrollRect){
				var scrollRect=sprite.scrollRect;
				tRec.x-=scrollRect.x;
				tRec.y-=scrollRect.y;
			}
			w=tRec.width *scaleX;
			h=tRec.height *scaleY;
			left=tRec.x;
			top=tRec.y;
			if (Render.isWebGL && tCacheType==='bitmap' && (w > 2048 || h > 2048)){
				console.warn("cache bitmap size larger than 2048,cache ignored");
				if (_cacheCanvas.ctx){
					Pool.recover("RenderContext",_cacheCanvas.ctx);
					_cacheCanvas.ctx.canvas.size(0,0);
					_cacheCanvas.ctx=null;
				}
				_next._fun.call(_next,sprite,context,x,y);
				return;
			}
			if (!tx){
				tx=_cacheCanvas.ctx=Pool.getItem("RenderContext")|| new RenderContext(w,h,HTMLCanvas.create(/*laya.resource.HTMLCanvas.TYPEAUTO*/"AUTO"));
			}
			tx.ctx.sprite=sprite;
			canvas=tx.canvas;
			canvas.clear();
			(canvas.width !=w || canvas.height !=h)&& canvas.size(w,h);
			if (tCacheType==='bitmap')canvas.context.asBitmap=true;
			else if(tCacheType==='normal')canvas.context.asBitmap=false;
			var t;
			if (scaleX !=1 || scaleY !=1){
				var ctx=(tx).ctx;
				ctx.save();
				ctx.scale(scaleX,scaleY);
				if (!Render.isConchWebGL && Render.isConchApp){
					t=sprite._$P.cf;
					t && ctx.setFilterMatrix && ctx.setFilterMatrix(t._mat,t._alpha);
				}
				_next._fun.call(_next,sprite,tx,-left,-top);
				ctx.restore();
				if (!Render.isConchApp || Render.isConchWebGL)sprite._applyFilters();
				}else {
				ctx=(tx).ctx;
				if (!Render.isConchWebGL && Render.isConchApp){
					t=sprite._$P.cf;
					t && ctx.setFilterMatrix && ctx.setFilterMatrix(t._mat,t._alpha);
				}
				_next._fun.call(_next,sprite,tx,-left,-top);
				if (!Render.isConchApp || Render.isConchWebGL)sprite._applyFilters();
			}
			if (sprite._$P.staticCache)_cacheCanvas.reCache=false;
			Stat.canvasReCache++;
			}else {
			tRec=_cacheCanvas._cacheRec;
			left=tRec.x;
			top=tRec.y;
			canvas=tx.canvas;
		}
		context.drawCanvas(canvas,x+left,y+top,tRec.width,tRec.height);
	}

	RenderSprite.__init__=function(){
		var i=0,len=0;
		var initRender;
		initRender=RunDriver.createRenderSprite(0x11111,null);
		len=RenderSprite.renders.length=0x800 *2;
		for (i=0;i < len;i++)
		RenderSprite.renders[i]=initRender;
		RenderSprite.renders[0]=RunDriver.createRenderSprite(0,null);
		function _initSame (value,o){
			var n=0;
			for (var i=0;i < value.length;i++){
				n |=value[i];
				RenderSprite.renders[n]=o;
			}
		}
		_initSame([0x01,0x200,0x04,0x02],new RenderSprite(0x01,null));
		RenderSprite.renders[0x01 | 0x200]=RunDriver.createRenderSprite(0x01 | 0x200,null);
		RenderSprite.renders[0x01 | 0x04 | 0x200]=new RenderSprite(0x01 | 0x04 | 0x200,null);
	}

	RenderSprite._initRenderFun=function(sprite,context,x,y){
		var type=sprite._renderType;
		var r=RenderSprite.renders[type]=RenderSprite._getTypeRender(type);
		r._fun(sprite,context,x,y);
	}

	RenderSprite._getTypeRender=function(type){
		var rst=null;
		var tType=0x800;
		while (tType > 1){
			if (tType & type)
				rst=RunDriver.createRenderSprite(tType,rst);
			tType=tType >> 1;
		}
		return rst;
	}

	RenderSprite.IMAGE=0x01;
	RenderSprite.ALPHA=0x02;
	RenderSprite.TRANSFORM=0x04;
	RenderSprite.BLEND=0x08;
	RenderSprite.CANVAS=0x10;
	RenderSprite.FILTERS=0x20;
	RenderSprite.MASK=0x40;
	RenderSprite.CLIP=0x80;
	RenderSprite.STYLE=0x100;
	RenderSprite.GRAPHICS=0x200;
	RenderSprite.CUSTOM=0x400;
	RenderSprite.CHILDS=0x800;
	RenderSprite.INIT=0x11111;
	RenderSprite.renders=[];
	RenderSprite.NORENDER=new RenderSprite(0,null);
	return RenderSprite;
})()


/**
*@private
*Context扩展类
*/
//class laya.resource.Context
var Context=(function(){
	function Context(){
		/***@private */
		//this._canvas=null;
		this._repaint=false;
	}

	__class(Context,'laya.resource.Context');
	var __proto=Context.prototype;
	__proto.replaceReset=function(){
		var i=0,len=0;
		len=Context.replaceKeys.length;
		var key;
		for (i=0;i < len;i++){
			key=Context.replaceKeys[i];
			this[Context.newKeys[i]]=this[key];
		}
	}

	__proto.replaceResotre=function(){
		/*__JS__ */this.__restore();
		/*__JS__ */this.__reset();
	}

	__proto.setIsMainContext=function(){}
	__proto.drawTextures=function(tex,pos,tx,ty){
		Stat.drawCall+=pos.length / 2;
		var w=tex.width;
		var h=tex.height;
		for (var i=0,sz=pos.length;i < sz;i+=2){
			this.drawTexture(tex,pos[i],pos[i+1],w,h,tx,ty);
		}
	}

	/***@private */
	__proto.drawCanvas=function(canvas,x,y,width,height){
		Stat.drawCall++;
		this.drawImage(canvas.source,x,y,width,height);
	}

	/***@private */
	__proto.fillRect=function(x,y,width,height,style){
		Stat.drawCall++;
		style && (this.fillStyle=style);
		/*__JS__ */this.__fillRect(x,y,width,height);
	}

	/***@private */
	__proto.fillText=function(text,x,y,font,color,textAlign){
		Stat.drawCall++;
		if (arguments.length > 3 && font !=null){
			this.font=font;
			this.fillStyle=color;
			/*__JS__ */this.textAlign=textAlign;
			this.textBaseline="top";
		}
		/*__JS__ */this.__fillText(text,x,y);
	}

	/***@private */
	__proto.fillBorderText=function(text,x,y,font,fillColor,borderColor,lineWidth,textAlign){
		Stat.drawCall++;
		this.font=font;
		this.fillStyle=fillColor;
		this.textBaseline="top";
		/*__JS__ */this.strokeStyle=borderColor;
		/*__JS__ */this.lineWidth=lineWidth;
		/*__JS__ */this.textAlign=textAlign;
		/*__JS__ */this.__strokeText(text,x,y);
		/*__JS__ */this.__fillText(text,x,y);
	}

	/***@private */
	__proto.strokeText=function(text,x,y,font,color,lineWidth,textAlign){
		Stat.drawCall++;
		if (arguments.length > 3 && font !=null){
			this.font=font;
			/*__JS__ */this.strokeStyle=color;
			/*__JS__ */this.lineWidth=lineWidth;
			/*__JS__ */this.textAlign=textAlign;
			this.textBaseline="top";
		}
		/*__JS__ */this.__strokeText(text,x,y);
	}

	/***@private */
	__proto.transformByMatrix=function(value){
		this.transform(value.a,value.b,value.c,value.d,value.tx,value.ty);
	}

	/***@private */
	__proto.setTransformByMatrix=function(value){
		this.setTransform(value.a,value.b,value.c,value.d,value.tx,value.ty);
	}

	/***@private */
	__proto.clipRect=function(x,y,width,height){
		Stat.drawCall++;
		this.beginPath();
		this.rect(x,y,width,height);
		this.clip();
	}

	/***@private */
	__proto.drawTexture=function(tex,x,y,width,height,tx,ty){
		Stat.drawCall++;
		var uv=tex.uv,w=tex.bitmap.width,h=tex.bitmap.height;
		this.drawImage(tex.source,uv[0] *w,uv[1] *h,(uv[2]-uv[0])*w,(uv[5]-uv[3])*h,x+tx,y+ty,width,height);
	}

	/***@private */
	__proto.drawTextureWithTransform=function(tex,x,y,width,height,m,tx,ty,alpha){
		Stat.drawCall++;
		var uv=tex.uv,w=tex.bitmap.width,h=tex.bitmap.height;
		this.save();
		alpha !=1 && (this.globalAlpha *=alpha);
		if (m){
			this.transform(m.a,m.b,m.c,m.d,m.tx+tx,m.ty+ty);
			this.drawImage(tex.source,uv[0] *w,uv[1] *h,(uv[2]-uv[0])*w,(uv[5]-uv[3])*h,x ,y,width,height);
			}else {
			this.drawImage(tex.source,uv[0] *w,uv[1] *h,(uv[2]-uv[0])*w,(uv[5]-uv[3])*h,x+tx ,y+ty,width,height);
		}
		this.restore();
	}

	/***@private */
	__proto.drawTexture2=function(x,y,pivotX,pivotY,m,alpha,blendMode,args2){
		var tex=args2[0];
		if (!(tex.loaded && tex.bitmap && tex.source)){
			return;
		}
		Stat.drawCall++;
		var alphaChanged=alpha!==1;
		if (alphaChanged){
			var temp=this.globalAlpha;
			this.globalAlpha *=alpha;
		};
		var uv=tex.uv,w=tex.bitmap.width,h=tex.bitmap.height;
		if (m){
			this.save();
			this.transform(m.a,m.b,m.c,m.d,m.tx+x,m.ty+y);
			this.drawImage(tex.source,uv[0] *w,uv[1] *h,(uv[2]-uv[0])*w,(uv[5]-uv[3])*h,args2[1]-pivotX ,args2[2]-pivotY,args2[3],args2[4]);
			this.restore();
			}else {
			this.drawImage(tex.source,uv[0] *w,uv[1] *h,(uv[2]-uv[0])*w,(uv[5]-uv[3])*h,args2[1]-pivotX+x ,args2[2]-pivotY+y,args2[3],args2[4]);
		}
		if (alphaChanged)this.globalAlpha=temp;
	}

	__proto.fillTexture=function(texture,x,y,width,height,type,offset,other){
		if (!other.pat){
			if (texture.uv !=Texture.DEF_UV){
				var canvas=new HTMLCanvas("2D");
				canvas.getContext('2d');
				canvas.size(texture.width,texture.height);
				canvas.context.drawTexture(texture,0,0,texture.width,texture.height,0,0);
				texture=new Texture(canvas);
			}
			other.pat=this.createPattern(texture.bitmap.source,type);
		};
		var oX=x,oY=y;
		var sX=0,sY=0;
		if (offset){
			oX+=offset.x % texture.width;
			oY+=offset.y % texture.height;
			sX-=offset.x % texture.width;
			sY-=offset.y % texture.height;
		}
		this.translate(oX,oY);
		this.fillRect(sX,sY,width,height,other.pat);
		this.translate(-oX,-oY);
	}

	__proto.drawTriangle=function(texture,vertices,uvs,index0,index1,index2,matrix,canvasPadding){
		var source=texture.bitmap;
		var textureSource=source.source;
		var textureWidth=texture.width;
		var textureHeight=texture.height;
		var sourceWidth=source.width;
		var sourceHeight=source.height;
		var u0=uvs[index0] *sourceWidth;
		var u1=uvs[index1] *sourceWidth;
		var u2=uvs[index2] *sourceWidth;
		var v0=uvs[index0+1] *sourceHeight;
		var v1=uvs[index1+1] *sourceHeight;
		var v2=uvs[index2+1] *sourceHeight;
		var x0=vertices[index0];
		var x1=vertices[index1];
		var x2=vertices[index2];
		var y0=vertices[index0+1];
		var y1=vertices[index1+1];
		var y2=vertices[index2+1];
		if (canvasPadding){
			var paddingX=1;
			var paddingY=1;
			var centerX=(x0+x1+x2)/ 3;
			var centerY=(y0+y1+y2)/ 3;
			var normX=x0-centerX;
			var normY=y0-centerY;
			var dist=Math.sqrt((normX *normX)+(normY *normY));
			x0=centerX+((normX / dist)*(dist+paddingX));
			y0=centerY+((normY / dist)*(dist+paddingY));
			normX=x1-centerX;
			normY=y1-centerY;
			dist=Math.sqrt((normX *normX)+(normY *normY));
			x1=centerX+((normX / dist)*(dist+paddingX));
			y1=centerY+((normY / dist)*(dist+paddingY));
			normX=x2-centerX;
			normY=y2-centerY;
			dist=Math.sqrt((normX *normX)+(normY *normY));
			x2=centerX+((normX / dist)*(dist+paddingX));
			y2=centerY+((normY / dist)*(dist+paddingY));
		}
		this.save();
		if (matrix)
			this.transform(matrix.a,matrix.b,matrix.c,matrix.d,matrix.tx,matrix.ty);
		this.beginPath();
		this.moveTo(x0,y0);
		this.lineTo(x1,y1);
		this.lineTo(x2,y2);
		this.closePath();
		this.clip();
		var delta=(u0 *v1)+(v0 *u2)+(u1 *v2)-(v1 *u2)-(v0 *u1)-(u0 *v2);
		var dDelta=1 / delta;
		var deltaA=(x0 *v1)+(v0 *x2)+(x1 *v2)-(v1 *x2)-(v0 *x1)-(x0 *v2);
		var deltaB=(u0 *x1)+(x0 *u2)+(u1 *x2)-(x1 *u2)-(x0 *u1)-(u0 *x2);
		var deltaC=(u0 *v1 *x2)+(v0 *x1 *u2)+(x0 *u1 *v2)-(x0 *v1 *u2)-(v0 *u1 *x2)-(u0 *x1 *v2);
		var deltaD=(y0 *v1)+(v0 *y2)+(y1 *v2)-(v1 *y2)-(v0 *y1)-(y0 *v2);
		var deltaE=(u0 *y1)+(y0 *u2)+(u1 *y2)-(y1 *u2)-(y0 *u1)-(u0 *y2);
		var deltaF=(u0 *v1 *y2)+(v0 *y1 *u2)+(y0 *u1 *v2)-(y0 *v1 *u2)-(v0 *u1 *y2)-(u0 *y1 *v2);
		this.transform(deltaA *dDelta,deltaD *dDelta,deltaB *dDelta,deltaE *dDelta,deltaC *dDelta,deltaF *dDelta);
		this.drawImage(textureSource,texture.uv[0] *sourceWidth,texture.uv[1] *sourceHeight,textureWidth,textureHeight,texture.uv[0] *sourceWidth,texture.uv[1] *sourceHeight,textureWidth,textureHeight);
		this.restore();
	}

	/***@private */
	__proto.flush=function(){
		return 0;
	}

	/***@private */
	__proto.fillWords=function(words,x,y,font,color,underLine){
		font && (this.font=font);
		color && (this.fillStyle=color);
		var _this=this;
		this.textBaseline="top";
		/*__JS__ */this.textAlign='left';
		for (var i=0,n=words.length;i < n;i++){
			var a=words[i];
			/*__JS__ */this.__fillText(a.char,a.x+x,a.y+y);
			if (underLine===1){
				var tHeight=a.height;
				var dX=a.style.letterSpacing*0.5;
				if (!dX)dX=0;
				this.beginPath();
				this.strokeStyle=color;
				this.lineWidth=1;
				this.moveTo(x+a.x-dX+0.5,y+a.y+tHeight+0.5);
				this.lineTo(x+a.x+a.width+dX+0.5,y+a.y+tHeight+0.5);
				this.stroke();
			}
		}
	}

	/***@private */
	__proto.fillBorderWords=function(words,x,y,font,color,borderColor,lineWidth){
		font && (this.font=font);
		color && (this.fillStyle=color);
		this.textBaseline="top";
		/*__JS__ */this.lineWidth=lineWidth;
		/*__JS__ */this.textAlign='left';
		/*__JS__ */this.strokeStyle=borderColor;
		for (var i=0,n=words.length;i < n;i++){
			var a=words[i];
			/*__JS__ */this.__strokeText(a.char,a.x+x,a.y+y);
			/*__JS__ */this.__fillText(a.char,a.x+x,a.y+y);
		}
	}

	/***@private */
	__proto.destroy=function(){
		/*__JS__ */this.canvas.width=this.canvas.height=0;
	}

	/***@private */
	__proto.clear=function(){
		this.clearRect(0,0,this._canvas.width,this._canvas.height);
		this._repaint=false;
	}

	__proto.drawCurves=function(x,y,args){
		this.beginPath();
		this.strokeStyle=args[3];
		this.lineWidth=args[4];
		var points=args[2];
		x+=args[0],y+=args[1];
		this.moveTo(x+points[0],y+points[1]);
		var i=2,n=points.length;
		while (i < n){
			this.quadraticCurveTo(x+points[i++],y+points[i++],x+points[i++],y+points[i++]);
		}
		this.stroke();
	}

	Context.__init__=function(to){
		var from=laya.resource.Context.prototype;
		to=to || /*__JS__ */CanvasRenderingContext2D.prototype;
		if (to.inited)return;
		to.inited=true;
		to.__fillText=to.fillText;
		to.__fillRect=to.fillRect;
		to.__strokeText=to.strokeText;
		var funs=['drawTextures',"drawTriangle",'fillWords','fillBorderWords','setIsMainContext','fillRect','strokeText','fillTexture','fillText','transformByMatrix','setTransformByMatrix','clipRect','drawTexture','drawTexture2','drawTextureWithTransform','flush','clear','destroy','drawCanvas','fillBorderText','drawCurves'];
		funs.forEach(function(i){
			to[i]=from[i];
		});
	}

	Context.replaceCanvasGetSet=function(tar,key){
		var oldO=/*__JS__ */Object.getOwnPropertyDescriptor(tar,key);
		if (!oldO||!oldO.configurable)return false;
		var newO={};
		var tkey;
		for (tkey in oldO){
			if (tkey !="set"){
				newO[tkey]=oldO[tkey];
			}
		};
		var preFun=oldO["set"];
		newO["set"]=function (v){
			var _self=/*__JS__ */this;
			preFun.call(_self,v);
			var _ct=_self.getContext("2d");
			if (_ct && "__reset" in _ct){
				_ct.__reset();
			}
		}
		/*__JS__ */Object.defineProperty(tar,key,newO);
		return true;
	}

	Context.replaceGetSet=function(tar,key){
		var oldO=/*__JS__ */Object.getOwnPropertyDescriptor(tar,key);
		if (!oldO||!oldO.configurable)return false;
		var newO={};
		var tkey;
		for (tkey in oldO){
			if (tkey !="set"){
				newO[tkey]=oldO[tkey];
			}
		};
		var preFun=oldO["set"];
		var dataKey="___"+key+"__";
		Context.newKeys.push(dataKey);
		newO["set"]=function (v){
			var _self=/*__JS__ */this;
			if (v !=_self[dataKey]){
				_self[dataKey]=v;
				preFun.call(_self,v);
			}
		}
		/*__JS__ */Object.defineProperty(tar,key,newO);
		return true;
	}

	Context._default=new Context();
	Context.newKeys=[];
	__static(Context,
	['replaceKeys',function(){return this.replaceKeys=["font","fillStyle","textBaseline"];}
	]);
	return Context;
})()


/**
*@private
*<code>ResourceManager</code> 是资源管理类。它用于资源的载入、获取、销毁。
*/
//class laya.resource.ResourceManager
var ResourceManager=(function(){
	function ResourceManager(name){
		/**唯一标识ID。*/
		this._id=0;
		/**名字。*/
		this._name=null;
		/**所管理资源。*/
		this._resources=null;
		/**所管理资源的累计内存,以字节为单位。*/
		this._memorySize=0;
		/**垃圾回收比例，范围是0到1。*/
		this._garbageCollectionRate=NaN;
		/**自动释放机制中内存是否溢出。*/
		this._isOverflow=false;
		/**是否启用自动释放机制。*/
		this.autoRelease=false;
		/**自动释放机制的内存触发上限,以字节为单位。*/
		this.autoReleaseMaxSize=0;
		this._id=++ResourceManager._uniqueIDCounter;
		this._name=name ? name :"Content Manager";
		ResourceManager._isResourceManagersSorted=false;
		this._memorySize=0;
		this._isOverflow=false;
		this.autoRelease=false;
		this.autoReleaseMaxSize=1024 *1024 *512;
		this._garbageCollectionRate=0.2;
		ResourceManager._resourceManagers.push(this);
		this._resources=[];
	}

	__class(ResourceManager,'laya.resource.ResourceManager');
	var __proto=ResourceManager.prototype;
	Laya.imps(__proto,{"laya.resource.IDispose":true})
	/**
	*获取指定索引的资源 Resource 对象。
	*@param 索引。
	*@return 资源 Resource 对象。
	*/
	__proto.getResourceByIndex=function(index){
		return this._resources[index];
	}

	/**
	*获取此管理器所管理的资源个数。
	*@return 资源个数。
	*/
	__proto.getResourcesLength=function(){
		return this._resources.length;
	}

	/**
	*添加指定资源。
	*@param resource 需要添加的资源 Resource 对象。
	*@return 是否添加成功。
	*/
	__proto.addResource=function(resource){
		if (resource.resourceManager)
			resource.resourceManager.removeResource(resource);
		var index=this._resources.indexOf(resource);
		if (index===-1){
			resource._resourceManager=this;
			this._resources.push(resource);
			this.addSize(resource.memorySize);
			return true;
		}
		return false;
	}

	/**
	*移除指定资源。
	*@param resource 需要移除的资源 Resource 对象
	*@return 是否移除成功。
	*/
	__proto.removeResource=function(resource){
		var index=this._resources.indexOf(resource);
		if (index!==-1){
			this._resources.splice(index,1);
			resource._resourceManager=null;
			this._memorySize-=resource.memorySize;
			return true;
		}
		return false;
	}

	/**
	*卸载此资源管理器载入的资源。
	*/
	__proto.unload=function(){
		var tempResources=this._resources.slice(0,this._resources.length);
		for (var i=0;i < tempResources.length;i++){
			var resource=tempResources[i];
			resource.destroy();
		}
		tempResources.length=0;
	}

	/**释放资源。*/
	__proto.dispose=function(){
		if (this===ResourceManager._systemResourceManager)
			throw new Error("systemResourceManager不能被释放！");
		ResourceManager._resourceManagers.splice(ResourceManager._resourceManagers.indexOf(this),1);
		ResourceManager._isResourceManagersSorted=false;
		var tempResources=this._resources.slice(0,this._resources.length);
		for (var i=0;i < tempResources.length;i++){
			var resource=tempResources[i];
			resource.resourceManager.removeResource(resource);
			resource.destroy();
		}
		tempResources.length=0;
	}

	/**
	*增加内存。
	*@param add 需要增加的内存大小。
	*/
	__proto.addSize=function(add){
		if (add){
			if (this.autoRelease && add > 0)
				((this._memorySize+add)> this.autoReleaseMaxSize)&& (this.garbageCollection((1-this._garbageCollectionRate)*this.autoReleaseMaxSize));
			this._memorySize+=add;
		}
	}

	/**
	*垃圾回收。
	*@param reserveSize 保留尺寸。
	*/
	__proto.garbageCollection=function(reserveSize){
		var all=this._resources;
		all=all.slice();
		all.sort(function(a,b){
			if (!a || !b)
				throw new Error("a或b不能为空！");
			if (a.released && b.released)
				return 0;
			else if (a.released)
			return 1;
			else if (b.released)
			return-1;
			return a._lastUseFrameCount-b._lastUseFrameCount;
		});
		var currentFrameCount=Stat.loopCount;
		for (var i=0,n=all.length;i < n;i++){
			var resou=all[i];
			if (currentFrameCount-resou._lastUseFrameCount > 1){
				resou.releaseResource();
				}else {
				if (this._memorySize >=reserveSize)
					this._isOverflow=true;
				return;
			}
			if (this._memorySize < reserveSize){
				this._isOverflow=false;
				return;
			}
		}
	}

	/**
	*唯一标识 ID 。
	*/
	__getset(0,__proto,'id',function(){
		return this._id;
	});

	/**
	*名字。
	*/
	__getset(0,__proto,'name',function(){
		return this._name;
		},function(value){
		if ((value || value!=="")&& this._name!==value){
			this._name=value;
			ResourceManager._isResourceManagersSorted=false;
		}
	});

	/**
	*此管理器所管理资源的累计内存，以字节为单位。
	*/
	__getset(0,__proto,'memorySize',function(){
		return this._memorySize;
	});

	/**
	*系统资源管理器。
	*/
	__getset(1,ResourceManager,'systemResourceManager',function(){
		return ResourceManager._systemResourceManager;
	});

	ResourceManager.__init__=function(){
		ResourceManager.currentResourceManager=ResourceManager.systemResourceManager;
	}

	ResourceManager.getLoadedResourceManagerByIndex=function(index){
		return ResourceManager._resourceManagers[index];
	}

	ResourceManager.getLoadedResourceManagersCount=function(){
		return ResourceManager._resourceManagers.length;
	}

	ResourceManager.recreateContentManagers=function(force){
		(force===void 0)&& (force=false);
		var temp=ResourceManager.currentResourceManager;
		for (var i=0;i < ResourceManager._resourceManagers.length;i++){
			ResourceManager.currentResourceManager=ResourceManager._resourceManagers[i];
			for (var j=0;j < ResourceManager.currentResourceManager._resources.length;j++){
				ResourceManager.currentResourceManager._resources[j].releaseResource(force);
				ResourceManager.currentResourceManager._resources[j].activeResource(force);
			}
		}
		ResourceManager.currentResourceManager=temp;
	}

	ResourceManager.releaseContentManagers=function(force){
		(force===void 0)&& (force=false);
		var temp=ResourceManager.currentResourceManager;
		for (var i=0;i < ResourceManager._resourceManagers.length;i++){
			ResourceManager.currentResourceManager=ResourceManager._resourceManagers[i];
			for (var j=0;j < ResourceManager.currentResourceManager._resources.length;j++){
				var resource=ResourceManager.currentResourceManager._resources[j];
				(!resource.released)&& (resource.releaseResource(force));
			}
		}
		ResourceManager.currentResourceManager=temp;
	}

	ResourceManager._uniqueIDCounter=0;
	ResourceManager._isResourceManagersSorted=false;
	ResourceManager._resourceManagers=[];
	__static(ResourceManager,
	['_systemResourceManager',function(){return this._systemResourceManager=new ResourceManager("System Resource Manager");},'currentResourceManager',function(){return this.currentResourceManager=ResourceManager._systemResourceManager;}
	]);
	return ResourceManager;
})()


/**
*@private
*/
//class laya.system.System
var System=(function(){
	function System(){}
	__class(System,'laya.system.System');
	System.changeDefinition=function(name,classObj){
		Laya[name]=classObj;
		var str=name+"=classObj";
		Laya._runScript(str);
	}

	System.__init__=function(){
		if (Render.isConchApp){
			/*__JS__ */conch.disableConchResManager();
			/*__JS__ */conch.disableConchAutoRestoreLostedDevice();
		}
	}

	return System;
})()


SoundManager;
/**
*<code>Browser</code> 是浏览器代理类。封装浏览器及原生 js 提供的一些功能。
*/
//class laya.utils.Browser
var Browser=(function(){
	function Browser(){}
	__class(Browser,'laya.utils.Browser');
	/**设备像素比。*/
	__getset(1,Browser,'pixelRatio',function(){
		Browser.__init__();
		if (Browser.userAgent.indexOf("Mozilla/6.0(Linux; Android 6.0; HUAWEI NXT-AL10 Build/HUAWEINXT-AL10)")>-1)return 2;
		return RunDriver.getPixelRatio();
	});

	/**浏览器窗口物理高度，其值等于clientHeight *pixelRatio，并且浏览器发生反转之后，宽高会互换。*/
	__getset(1,Browser,'height',function(){
		Browser.__init__();
		return ((Laya.stage && Laya.stage.canvasRotation)? Browser.clientWidth :Browser.clientHeight)*Browser.pixelRatio;
	});

	/**
	*浏览器窗口可视宽度。
	*通过分析浏览器信息获得。浏览器多个属性值优先级为：window.innerWidth(包含滚动条宽度)> document.body.clientWidth(不包含滚动条宽度)，如果前者为0或为空，则选择后者。
	*/
	__getset(1,Browser,'clientWidth',function(){
		Browser.__init__();
		return Browser.window.innerWidth || Browser.document.body.clientWidth;
	});

	/**浏览器原生 window 对象的引用。*/
	__getset(1,Browser,'window',function(){
		Browser.__init__();
		return Browser._window;
	});

	/**
	*浏览器窗口可视高度。
	*通过分析浏览器信息获得。浏览器多个属性值优先级为：window.innerHeight(包含滚动条高度)> document.body.clientHeight(不包含滚动条高度)> document.documentElement.clientHeight(不包含滚动条高度)，如果前者为0或为空，则选择后者。
	*/
	__getset(1,Browser,'clientHeight',function(){
		Browser.__init__();
		return Browser.window.innerHeight || Browser.document.body.clientHeight || Browser.document.documentElement.clientHeight;
	});

	/**浏览器窗口物理宽度，其值等于clientWidth *pixelRatio，并且浏览器发生反转之后，宽高会互换。*/
	__getset(1,Browser,'width',function(){
		Browser.__init__();
		return ((Laya.stage && Laya.stage.canvasRotation)? Browser.clientHeight :Browser.clientWidth)*Browser.pixelRatio;
	});

	/**画布容器，用来盛放画布的容器。方便对画布进行控制*/
	__getset(1,Browser,'container',function(){
		Browser.__init__();
		if (!Browser._container){
			Browser._container=Browser.createElement("div");
			Browser._container.id="layaContainer";
			Browser.document.body.appendChild(Browser._container);
		}
		return Browser._container;
		},function(value){
		Browser._container=value;
	});

	/**浏览器原生 document 对象的引用。*/
	__getset(1,Browser,'document',function(){
		Browser.__init__();
		return Browser._document;
	});

	Browser.__init__=function(){
		SoundManager;
		if (Browser._window)return;
		Browser._window=RunDriver.getWindow();
		Browser._document=Browser.window.document;
		Browser._window.addEventListener('message',function(e){
			laya.utils.Browser._onMessage(e);
		},false);
		/*__JS__ */Browser.document.__createElement=Browser.document.createElement;
		/*__JS__ */window.requestAnimationFrame=window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (c){return window.setTimeout(c,1000 / 60);};;
		/*__JS__ */var $BS=window.document.body.style;$BS['-webkit-user-select']='none';$BS['-webkit-tap-highlight-color']='rgba(200,200,200,0)';;
		Browser.userAgent=/*[SAFE]*/ Browser.window.navigator.userAgent;
		Browser.u=/*[SAFE]*/ Browser.userAgent;
		Browser.onIOS=/*[SAFE]*/ !!Browser.u.match(/\(i[^;]+;(U;)? CPU.+Mac OS X/);
		Browser.onMobile=/*[SAFE]*/ Browser.u.indexOf("Mobile")>-1;
		Browser.onIPhone=/*[SAFE]*/ Browser.u.indexOf("iPhone")>-1;
		Browser.onMac=/*[SAFE]*/ Browser.u.indexOf("Mac OS X")>-1;
		Browser.onIPad=/*[SAFE]*/ Browser.u.indexOf("iPad")>-1;
		Browser.onAndroid=/*[SAFE]*/ Browser.u.indexOf('Android')>-1 || Browser.u.indexOf('Adr')>-1;
		Browser.onWP=/*[SAFE]*/ Browser.u.indexOf("Windows Phone")>-1;
		Browser.onQQBrowser=/*[SAFE]*/ Browser.u.indexOf("QQBrowser")>-1;
		Browser.onMQQBrowser=/*[SAFE]*/ Browser.u.indexOf("MQQBrowser")>-1 || (Browser.u.indexOf("Mobile")>-1 && Browser.u.indexOf("QQ")>-1);
		Browser.onIE=/*[SAFE]*/ !!Browser.window.ActiveXObject || "ActiveXObject" in Browser.window;
		Browser.onWeiXin=/*[SAFE]*/ Browser.u.indexOf('MicroMessenger')>-1;
		Browser.onPC=/*[SAFE]*/ !Browser.onMobile;
		Browser.onSafari=/*[SAFE]*/ Browser.u.indexOf("Safari")>-1;
		Browser.onFirefox=/*[SAFE]*/ Browser.u.indexOf('Firefox')>-1;
		Browser.onEdge=/*[SAFE]*/ Browser.u.indexOf('Edge')>-1;
		Browser.onMiniGame=/*[SAFE]*/ Browser.u.indexOf('MiniGame')>-1;
		Browser.onLimixiu=/*[SAFE]*/ Browser.u.indexOf('limixiu')>-1;
		Browser.httpProtocol=/*[SAFE]*/ Browser.window.location.protocol=="http:";
		if (Browser.onMiniGame && Browser.window.focus==null){
			console.error("请先初始化小游戏适配库，详细教程https://ldc.layabox.com/doc/?nav=zh-ts-5-0-0");
		}
		Browser.webAudioEnabled=/*[SAFE]*/ Browser.window["AudioContext"] || Browser.window["webkitAudioContext"] || Browser.window["mozAudioContext"] ? true :false;
		Browser.soundType=/*[SAFE]*/ Browser.webAudioEnabled ? "WEBAUDIOSOUND" :"AUDIOSOUND";
		/*__JS__ */Sound=Browser.webAudioEnabled?WebAudioSound:AudioSound;;
		/*__JS__ */if (Browser.webAudioEnabled)WebAudioSound.initWebAudio();;
		AudioSound._initMusicAudio();
		/*__JS__ */Browser.enableTouch=(('ontouchstart' in window)|| window.DocumentTouch && document instanceof DocumentTouch);
		/*__JS__ */window.focus();
		/*__JS__ */SoundManager._soundClass=Sound;;
		SoundManager._musicClass=AudioSound;
		Render._mainCanvas=Render._mainCanvas || HTMLCanvas.create('2D');
		if (Browser.canvas)return;
		Browser.canvas=HTMLCanvas.create('2D');
		Browser.context=Browser.canvas.getContext('2d');
	}

	Browser._onMessage=function(e){
		if (!e.data)return;
		if (e.data.name=="size"){
			Browser.window.innerWidth=e.data.width;
			Browser.window.innerHeight=e.data.height;
			Browser.window.__innerHeight=e.data.clientHeight;
			if (!Browser.document.createEvent){
				console.warn("no document.createEvent");
				return;
			};
			var evt=Browser.document.createEvent("HTMLEvents");
			evt.initEvent("resize",false,false);
			Browser.window.dispatchEvent(evt);
			return;
		}
	}

	Browser.createElement=function(type){
		Browser.__init__();
		return Browser.document.__createElement(type);
	}

	Browser.getElementById=function(type){
		Browser.__init__();
		return Browser.document.getElementById(type);
	}

	Browser.removeElement=function(ele){
		if (ele && ele.parentNode)ele.parentNode.removeChild(ele);
	}

	Browser.now=function(){
		return RunDriver.now();
	}

	Browser._window=null;
	Browser._document=null;
	Browser._container=null;
	Browser.userAgent=null;
	Browser.u=null;
	Browser.onIOS=false;
	Browser.onMac=false;
	Browser.onMobile=false;
	Browser.onIPhone=false;
	Browser.onIPad=false;
	Browser.onAndroid=false;
	Browser.onWP=false;
	Browser.onQQBrowser=false;
	Browser.onMQQBrowser=false;
	Browser.onSafari=false;
	Browser.onFirefox=false;
	Browser.onEdge=false;
	Browser.onIE=false;
	Browser.onWeiXin=false;
	Browser.onMiniGame=false;
	Browser.onLimixiu=false;
	Browser.onPC=false;
	Browser.httpProtocol=false;
	Browser.webAudioEnabled=false;
	Browser.soundType=null;
	Browser.enableTouch=false;
	Browser.canvas=null;
	Browser.context=null;
	Browser.__init$=function(){
		AudioSound;
		WebAudioSound;
	}

	return Browser;
})()


/**
*<p> <code>Byte</code> 类提供用于优化读取、写入以及处理二进制数据的方法和属性。</p>
*<p><b>注意：</b> <code>Byte</code> 类适用于需要在字节层访问数据的高级开发人员。</p>
*/
//class laya.utils.Byte
var Byte=(function(){
	function Byte(data){
		/**
		*@private
		*是否为小端数据。
		*/
		this._xd_=true;
		this._allocated_=8;
		/**
		*@private
		*原始数据。
		*/
		//this._d_=null;
		/**
		*@private
		*DataView
		*/
		//this._u8d_=null;
		/**@private */
		this._pos_=0;
		/**@private */
		this._length=0;
		if (data){
			this._u8d_=new Uint8Array(data);
			this._d_=new DataView(this._u8d_.buffer);
			this._length=this._d_.byteLength;
			}else {
			this.___resizeBuffer(this._allocated_);
		}
	}

	__class(Byte,'laya.utils.Byte');
	var __proto=Byte.prototype;
	/**@private */
	__proto.___resizeBuffer=function(len){
		try {
			var newByteView=new Uint8Array(len);
			if (this._u8d_ !=null){
				if (this._u8d_.length <=len)newByteView.set(this._u8d_);
				else newByteView.set(this._u8d_.subarray(0,len));
			}
			this._u8d_=newByteView;
			this._d_=new DataView(newByteView.buffer);
			}catch (err){
			throw "___resizeBuffer err:"+len;
		}
	}

	/**
	*<p>常用于解析固定格式的字节流。</p>
	*<p>先从字节流的当前字节偏移位置处读取一个 <code>Uint16</code> 值，然后以此值为长度，读取此长度的字符串。</p>
	*@return 读取的字符串。
	*/
	__proto.getString=function(){
		return this.rUTF(this.getUint16());
	}

	/**
	*从字节流中 <code>start</code> 参数指定的位置开始，读取 <code>len</code> 参数指定的字节数的数据，用于创建一个 <code>Float32Array</code> 对象并返回此对象。
	*@param start 开始位置。
	*@param len 需要读取的字节长度。如果要读取的长度超过可读取范围，则只返回可读范围内的值。
	*@return 读取的 Float32Array 对象。
	*/
	__proto.getFloat32Array=function(start,len){
		var end=start+len;
		end=(end > this._length)? this._length :end;
		var v=new Float32Array(this._d_.buffer.slice(start,end));
		this._pos_=end;
		return v;
	}

	/**
	*从字节流中 <code>start</code> 参数指定的位置开始，读取 <code>len</code> 参数指定的字节数的数据，用于创建一个 <code>Uint8Array</code> 对象并返回此对象。
	*@param start 开始位置。
	*@param len 需要读取的字节长度。如果要读取的长度超过可读取范围，则只返回可读范围内的值。
	*@return 读取的 Uint8Array 对象。
	*/
	__proto.getUint8Array=function(start,len){
		var end=start+len;
		end=(end > this._length)? this._length :end;
		var v=new Uint8Array(this._d_.buffer.slice(start,end));
		this._pos_=end;
		return v;
	}

	/**
	*从字节流中 <code>start</code> 参数指定的位置开始，读取 <code>len</code> 参数指定的字节数的数据，用于创建一个 <code>Int16Array</code> 对象并返回此对象。
	*@param start 开始读取的字节偏移量位置。
	*@param len 需要读取的字节长度。如果要读取的长度超过可读取范围，则只返回可读范围内的值。
	*@return 读取的 Uint8Array 对象。
	*/
	__proto.getInt16Array=function(start,len){
		var end=start+len;
		end=(end > this._length)? this._length :end;
		var v=new Int16Array(this._d_.buffer.slice(start,end));
		this._pos_=end;
		return v;
	}

	/**
	*从字节流的当前字节偏移位置处读取一个 IEEE 754 单精度（32 位）浮点数。
	*@return 单精度（32 位）浮点数。
	*/
	__proto.getFloat32=function(){
		if (this._pos_+4 > this._length)throw "getFloat32 error - Out of bounds";
		var v=this._d_.getFloat32(this._pos_,this._xd_);
		this._pos_+=4;
		return v;
	}

	/**
	*从字节流的当前字节偏移量位置处读取一个 IEEE 754 双精度（64 位）浮点数。
	*@return 双精度（64 位）浮点数。
	*/
	__proto.getFloat64=function(){
		if (this._pos_+8 > this._length)throw "getFloat64 error - Out of bounds";
		var v=this._d_.getFloat64(this._pos_,this._xd_);
		this._pos_+=8;
		return v;
	}

	/**
	*在字节流的当前字节偏移量位置处写入一个 IEEE 754 单精度（32 位）浮点数。
	*@param value 单精度（32 位）浮点数。
	*/
	__proto.writeFloat32=function(value){
		this.ensureWrite(this._pos_+4);
		this._d_.setFloat32(this._pos_,value,this._xd_);
		this._pos_+=4;
	}

	/**
	*在字节流的当前字节偏移量位置处写入一个 IEEE 754 双精度（64 位）浮点数。
	*@param value 双精度（64 位）浮点数。
	*/
	__proto.writeFloat64=function(value){
		this.ensureWrite(this._pos_+8);
		this._d_.setFloat64(this._pos_,value,this._xd_);
		this._pos_+=8;
	}

	/**
	*从字节流的当前字节偏移量位置处读取一个 Int32 值。
	*@return Int32 值。
	*/
	__proto.getInt32=function(){
		if (this._pos_+4 > this._length)throw "getInt32 error - Out of bounds";
		var float=this._d_.getInt32(this._pos_,this._xd_);
		this._pos_+=4;
		return float;
	}

	/**
	*从字节流的当前字节偏移量位置处读取一个 Uint32 值。
	*@return Uint32 值。
	*/
	__proto.getUint32=function(){
		if (this._pos_+4 > this._length)throw "getUint32 error - Out of bounds";
		var v=this._d_.getUint32(this._pos_,this._xd_);
		this._pos_+=4;
		return v;
	}

	/**
	*在字节流的当前字节偏移量位置处写入指定的 Int32 值。
	*@param value 需要写入的 Int32 值。
	*/
	__proto.writeInt32=function(value){
		this.ensureWrite(this._pos_+4);
		this._d_.setInt32(this._pos_,value,this._xd_);
		this._pos_+=4;
	}

	/**
	*在字节流的当前字节偏移量位置处写入 Uint32 值。
	*@param value 需要写入的 Uint32 值。
	*/
	__proto.writeUint32=function(value){
		this.ensureWrite(this._pos_+4);
		this._d_.setUint32(this._pos_,value,this._xd_);
		this._pos_+=4;
	}

	/**
	*从字节流的当前字节偏移量位置处读取一个 Int16 值。
	*@return Int16 值。
	*/
	__proto.getInt16=function(){
		if (this._pos_+2 > this._length)throw "getInt16 error - Out of bounds";
		var us=this._d_.getInt16(this._pos_,this._xd_);
		this._pos_+=2;
		return us;
	}

	/**
	*从字节流的当前字节偏移量位置处读取一个 Uint16 值。
	*@return Uint16 值。
	*/
	__proto.getUint16=function(){
		if (this._pos_+2 > this._length)throw "getUint16 error - Out of bounds";
		var us=this._d_.getUint16(this._pos_,this._xd_);
		this._pos_+=2;
		return us;
	}

	/**
	*在字节流的当前字节偏移量位置处写入指定的 Uint16 值。
	*@param value 需要写入的Uint16 值。
	*/
	__proto.writeUint16=function(value){
		this.ensureWrite(this._pos_+2);
		this._d_.setUint16(this._pos_,value,this._xd_);
		this._pos_+=2;
	}

	/**
	*在字节流的当前字节偏移量位置处写入指定的 Int16 值。
	*@param value 需要写入的 Int16 值。
	*/
	__proto.writeInt16=function(value){
		this.ensureWrite(this._pos_+2);
		this._d_.setInt16(this._pos_,value,this._xd_);
		this._pos_+=2;
	}

	/**
	*从字节流的当前字节偏移量位置处读取一个 Uint8 值。
	*@return Uint8 值。
	*/
	__proto.getUint8=function(){
		if (this._pos_+1 > this._length)throw "getUint8 error - Out of bounds";
		return this._d_.getUint8(this._pos_++);
	}

	/**
	*在字节流的当前字节偏移量位置处写入指定的 Uint8 值。
	*@param value 需要写入的 Uint8 值。
	*/
	__proto.writeUint8=function(value){
		this.ensureWrite(this._pos_+1);
		this._d_.setUint8(this._pos_,value);
		this._pos_++;
	}

	/**
	*@private
	*从字节流的指定字节偏移量位置处读取一个 Uint8 值。
	*@param pos 字节读取位置。
	*@return Uint8 值。
	*/
	__proto._getUInt8=function(pos){
		return this._d_.getUint8(pos);
	}

	/**
	*@private
	*从字节流的指定字节偏移量位置处读取一个 Uint16 值。
	*@param pos 字节读取位置。
	*@return Uint16 值。
	*/
	__proto._getUint16=function(pos){
		return this._d_.getUint16(pos,this._xd_);
	}

	/**
	*@private
	*使用 getFloat32()读取6个值，用于创建并返回一个 Matrix 对象。
	*@return Matrix 对象。
	*/
	__proto._getMatrix=function(){
		var rst=new Matrix(this.getFloat32(),this.getFloat32(),this.getFloat32(),this.getFloat32(),this.getFloat32(),this.getFloat32());
		return rst;
	}

	/**
	*@private
	*读取指定长度的 UTF 型字符串。
	*@param len 需要读取的长度。
	*@return 读取的字符串。
	*/
	__proto.rUTF=function(len){
		var v="",max=this._pos_+len,c=0,c2=0,c3=0,f=String.fromCharCode;
		var u=this._u8d_,i=0;
		while (this._pos_ < max){
			c=u[this._pos_++];
			if (c < 0x80){
				if (c !=0){
					v+=f(c);
				}
				}else if (c < 0xE0){
				v+=f(((c & 0x3F)<< 6)| (u[this._pos_++] & 0x7F));
				}else if (c < 0xF0){
				c2=u[this._pos_++];
				v+=f(((c & 0x1F)<< 12)| ((c2 & 0x7F)<< 6)| (u[this._pos_++] & 0x7F));
				}else {
				c2=u[this._pos_++];
				c3=u[this._pos_++];
				v+=f(((c & 0x0F)<< 18)| ((c2 & 0x7F)<< 12)| ((c3 << 6)& 0x7F)| (u[this._pos_++] & 0x7F));
			}
			i++;
		}
		return v;
	}

	/**
	*@private
	*读取 <code>len</code> 参数指定的长度的字符串。
	*@param len 要读取的字符串的长度。
	*@return 指定长度的字符串。
	*/
	__proto.getCustomString=function(len){
		var v="",ulen=0,c=0,c2=0,f=String.fromCharCode;
		var u=this._u8d_,i=0;
		while (len > 0){
			c=u[this._pos_];
			if (c < 0x80){
				v+=f(c);
				this._pos_++;
				len--;
				}else {
				ulen=c-0x80;
				this._pos_++;
				len-=ulen;
				while (ulen > 0){
					c=u[this._pos_++];
					c2=u[this._pos_++];
					v+=f((c2 << 8)| c);
					ulen--;
				}
			}
		}
		return v;
	}

	/**
	*清除字节数组的内容，并将 length 和 pos 属性重置为 0。调用此方法将释放 Byte 实例占用的内存。
	*/
	__proto.clear=function(){
		this._pos_=0;
		this.length=0;
	}

	/**
	*@private
	*获取此对象的 ArrayBuffer 引用。
	*@return
	*/
	__proto.__getBuffer=function(){
		return this._d_.buffer;
	}

	/**
	*<p>将 UTF-8 字符串写入字节流。类似于 writeUTF()方法，但 writeUTFBytes()不使用 16 位长度的字为字符串添加前缀。</p>
	*<p>对应的读取方法为： getUTFBytes 。</p>
	*@param value 要写入的字符串。
	*/
	__proto.writeUTFBytes=function(value){
		value=value+"";
		for (var i=0,sz=value.length;i < sz;i++){
			var c=value.charCodeAt(i);
			if (c <=0x7F){
				this.writeByte(c);
				}else if (c <=0x7FF){
				this.ensureWrite(this._pos_+2);
				this._u8d_.set([0xC0 | (c >> 6),0x80 | (c & 0x3F)],this._pos_);
				this._pos_+=2;
				}else if (c <=0xFFFF){
				this.ensureWrite(this._pos_+3);
				this._u8d_.set([0xE0 | (c >> 12),0x80 | ((c >> 6)& 0x3F),0x80 | (c & 0x3F)],this._pos_);
				this._pos_+=3;
				}else {
				this.ensureWrite(this._pos_+4);
				this._u8d_.set([0xF0 | (c >> 18),0x80 | ((c >> 12)& 0x3F),0x80 | ((c >> 6)& 0x3F),0x80 | (c & 0x3F)],this._pos_);
				this._pos_+=4;
			}
		}
	}

	/**
	*<p>将 UTF-8 字符串写入字节流。先写入以字节表示的 UTF-8 字符串长度（作为 16 位整数），然后写入表示字符串字符的字节。</p>
	*<p>对应的读取方法为： getUTFString 。</p>
	*@param value 要写入的字符串值。
	*/
	__proto.writeUTFString=function(value){
		var tPos=this.pos;
		this.writeUint16(1);
		this.writeUTFBytes(value);
		var dPos=this.pos-tPos-2;
		if (dPos >=65536){
			throw "writeUTFString byte len more than 65536";
		}
		this._d_.setUint16(tPos,dPos,this._xd_);
	}

	/**
	*@private
	*读取 UTF-8 字符串。
	*@return 读取的字符串。
	*/
	__proto.readUTFString=function(){
		return this.readUTFBytes(this.getUint16());
	}

	/**
	*<p>从字节流中读取一个 UTF-8 字符串。假定字符串的前缀是一个无符号的短整型（以此字节表示要读取的长度）。</p>
	*<p>对应的写入方法为： writeUTFString 。</p>
	*@return 读取的字符串。
	*/
	__proto.getUTFString=function(){
		return this.readUTFString();
	}

	/**
	*@private
	*读字符串，必须是 writeUTFBytes 方法写入的字符串。
	*@param len 要读的buffer长度，默认将读取缓冲区全部数据。
	*@return 读取的字符串。
	*/
	__proto.readUTFBytes=function(len){
		(len===void 0)&& (len=-1);
		if (len==0)return "";
		var lastBytes=this.bytesAvailable;
		if (len > lastBytes)throw "readUTFBytes error - Out of bounds";
		len=len > 0 ? len :lastBytes;
		return this.rUTF(len);
	}

	/**
	*<p>从字节流中读取一个由 length 参数指定的长度的 UTF-8 字节序列，并返回一个字符串。</p>
	*<p>一般读取的是由 writeUTFBytes 方法写入的字符串。</p>
	*@param len 要读的buffer长度，默认将读取缓冲区全部数据。
	*@return 读取的字符串。
	*/
	__proto.getUTFBytes=function(len){
		(len===void 0)&& (len=-1);
		return this.readUTFBytes(len);
	}

	/**
	*<p>在字节流中写入一个字节。</p>
	*<p>使用参数的低 8 位。忽略高 24 位。</p>
	*@param value
	*/
	__proto.writeByte=function(value){
		this.ensureWrite(this._pos_+1);
		this._d_.setInt8(this._pos_,value);
		this._pos_+=1;
	}

	/**
	*@private
	*从字节流中读取带符号的字节。
	*/
	__proto.readByte=function(){
		if (this._pos_+1 > this._length)throw "readByte error - Out of bounds";
		return this._d_.getInt8(this._pos_++);
	}

	/**
	*<p>从字节流中读取带符号的字节。</p>
	*<p>返回值的范围是从-128 到 127。</p>
	*@return 介于-128 和 127 之间的整数。
	*/
	__proto.getByte=function(){
		return this.readByte();
	}

	/**
	*<p>保证该字节流的可用长度不小于 <code>lengthToEnsure</code> 参数指定的值。</p>
	*@param lengthToEnsure 指定的长度。
	*/
	__proto.ensureWrite=function(lengthToEnsure){
		if (this._length < lengthToEnsure)this._length=lengthToEnsure;
		if (this._allocated_ < lengthToEnsure)this.length=lengthToEnsure;
	}

	/**
	*<p>将指定 arraybuffer 对象中的以 offset 为起始偏移量， length 为长度的字节序列写入字节流。</p>
	*<p>如果省略 length 参数，则使用默认长度 0，该方法将从 offset 开始写入整个缓冲区；如果还省略了 offset 参数，则写入整个缓冲区。</p>
	*<p>如果 offset 或 length 小于0，本函数将抛出异常。</p>
	*$NEXTBIG 由于没有判断length和arraybuffer的合法性，当开发者填写了错误的length值时，会导致写入多余的空白数据甚至内存溢出，为了避免影响开发者正在使用此方法的功能，下个重大版本会修复这些问题。
	*@param arraybuffer 需要写入的 Arraybuffer 对象。
	*@param offset Arraybuffer 对象的索引的偏移量（以字节为单位）
	*@param length 从 Arraybuffer 对象写入到 Byte 对象的长度（以字节为单位）
	*/
	__proto.writeArrayBuffer=function(arraybuffer,offset,length){
		(offset===void 0)&& (offset=0);
		(length===void 0)&& (length=0);
		if (offset < 0 || length < 0)throw "writeArrayBuffer error - Out of bounds";
		if (length==0)length=arraybuffer.byteLength-offset;
		this.ensureWrite(this._pos_+length);
		var uint8array=new Uint8Array(arraybuffer);
		this._u8d_.set(uint8array.subarray(offset,offset+length),this._pos_);
		this._pos_+=length;
	}

	/**
	*获取此对象的 ArrayBuffer 数据，数据只包含有效数据部分。
	*/
	__getset(0,__proto,'buffer',function(){
		var rstBuffer=this._d_.buffer;
		if (rstBuffer.byteLength==this.length)return rstBuffer;
		return rstBuffer.slice(0,this.length);
	});

	/**
	*<p> <code>Byte</code> 实例的字节序。取值为：<code>BIG_ENDIAN</code> 或 <code>BIG_ENDIAN</code> 。</p>
	*<p>主机字节序，是 CPU 存放数据的两种不同顺序，包括小端字节序和大端字节序。通过 <code>getSystemEndian</code> 可以获取当前系统的字节序。</p>
	*<p> <code>BIG_ENDIAN</code> ：大端字节序，地址低位存储值的高位，地址高位存储值的低位。有时也称之为网络字节序。<br/>
	*<code>LITTLE_ENDIAN</code> ：小端字节序，地址低位存储值的低位，地址高位存储值的高位。</p>
	*/
	__getset(0,__proto,'endian',function(){
		return this._xd_ ? "littleEndian" :"bigEndian";
		},function(endianStr){
		this._xd_=(endianStr=="littleEndian");
	});

	/**
	*<p> <code>Byte</code> 对象的长度（以字节为单位）。</p>
	*<p>如果将长度设置为大于当前长度的值，则用零填充字节数组的右侧；如果将长度设置为小于当前长度的值，将会截断该字节数组。</p>
	*<p>如果要设置的长度大于当前已分配的内存空间的字节长度，则重新分配内存空间，大小为以下两者较大者：要设置的长度、当前已分配的长度的2倍，并将原有数据拷贝到新的内存空间中；如果要设置的长度小于当前已分配的内存空间的字节长度，也会重新分配内存空间，大小为要设置的长度，并将原有数据从头截断为要设置的长度存入新的内存空间中。</p>
	*/
	__getset(0,__proto,'length',function(){
		return this._length;
		},function(value){
		if (this._allocated_ < value)
			this.___resizeBuffer(this._allocated_=Math.floor(Math.max(value,this._allocated_ *2)));
		else if (this._allocated_ > value)
		this.___resizeBuffer(this._allocated_=value);
		this._length=value;
	});

	/**
	*移动或返回 Byte 对象的读写指针的当前位置（以字节为单位）。下一次调用读取方法时将在此位置开始读取，或者下一次调用写入方法时将在此位置开始写入。
	*/
	__getset(0,__proto,'pos',function(){
		return this._pos_;
		},function(value){
		this._pos_=value;
	});

	/**
	*可从字节流的当前位置到末尾读取的数据的字节数。
	*/
	__getset(0,__proto,'bytesAvailable',function(){
		return this._length-this._pos_;
	});

	Byte.getSystemEndian=function(){
		if (!Byte._sysEndian){
			var buffer=new ArrayBuffer(2);
			new DataView(buffer).setInt16(0,256,true);
			Byte._sysEndian=(new Int16Array(buffer))[0]===256 ? /*CLASS CONST:laya.utils.Byte.LITTLE_ENDIAN*/"littleEndian" :/*CLASS CONST:laya.utils.Byte.BIG_ENDIAN*/"bigEndian";
		}
		return Byte._sysEndian;
	}

	Byte.BIG_ENDIAN="bigEndian";
	Byte.LITTLE_ENDIAN="littleEndian";
	Byte._sysEndian=null;
	return Byte;
})()


/**
*@private
*对象缓存统一管理类
*/
//class laya.utils.CacheManager
var CacheManager=(function(){
	function CacheManager(){}
	__class(CacheManager,'laya.utils.CacheManager');
	CacheManager.regCacheByFunction=function(disposeFunction,getCacheListFunction){
		CacheManager.unRegCacheByFunction(disposeFunction,getCacheListFunction);
		var cache;
		cache={tryDispose:disposeFunction,getCacheList:getCacheListFunction};
		CacheManager._cacheList.push(cache);
	}

	CacheManager.unRegCacheByFunction=function(disposeFunction,getCacheListFunction){
		var i=0,len=0;
		len=CacheManager._cacheList.length;
		for (i=0;i < len;i++){
			if (CacheManager._cacheList[i].tryDispose==disposeFunction && CacheManager._cacheList[i].getCacheList==getCacheListFunction){
				CacheManager._cacheList.splice(i,1);
				return;
			}
		}
	}

	CacheManager.forceDispose=function(){
		var i=0,len=CacheManager._cacheList.length;
		for (i=0;i < len;i++){
			CacheManager._cacheList[i].tryDispose(true);
		}
	}

	CacheManager.beginCheck=function(waitTime){
		(waitTime===void 0)&& (waitTime=15000);
		Laya.timer.loop(waitTime,null,CacheManager._checkLoop);
	}

	CacheManager.stopCheck=function(){
		Laya.timer.clear(null,CacheManager._checkLoop);
	}

	CacheManager._checkLoop=function(){
		var cacheList=CacheManager._cacheList;
		if (cacheList.length < 1)return;
		var tTime=Browser.now();
		var count=0;
		var len=0;
		len=count=cacheList.length;
		while (count > 0){
			CacheManager._index++;
			CacheManager._index=CacheManager._index % len;
			cacheList[CacheManager._index].tryDispose(false);
			if (Browser.now()-tTime > CacheManager.loopTimeLimit)break ;
			count--;
		}
	}

	CacheManager.loopTimeLimit=2;
	CacheManager._cacheList=[];
	CacheManager._index=0;
	return CacheManager;
})()


/**
*<code>ClassUtils</code> 是一个类工具类。
*/
//class laya.utils.ClassUtils
var ClassUtils=(function(){
	function ClassUtils(){}
	__class(ClassUtils,'laya.utils.ClassUtils');
	ClassUtils.regClass=function(className,classDef){
		ClassUtils._classMap[className]=classDef;
	}

	ClassUtils.getRegClass=function(className){
		return ClassUtils._classMap[className];
	}

	ClassUtils.getInstance=function(className){
		var compClass=ClassUtils.getClass(className);
		if (compClass)
			return new compClass();
		else
		console.warn("[error] Undefined class:",className);
		return null;
	}

	ClassUtils.createByJson=function(json,node,root,customHandler,instanceHandler){
		if ((typeof json=='string'))
			json=JSON.parse(json);
		var props=json.props;
		if (!node){
			node=instanceHandler ? instanceHandler.runWith(json):ClassUtils.getInstance(props.runtime || json.type);
			if (!node)
				return null;
		};
		var child=json.child;
		if (child){
			for (var i=0,n=child.length;i < n;i++){
				var data=child[i];
				if ((data.props.name==="render" || data.props.renderType==="render")&& node["_$set_itemRender"])
					node.itemRender=data;
				else {
					if (data.type=="Graphic"){
						ClassUtils.addGraphicsToSprite(data,node);
						}else if (ClassUtils.isDrawType(data.type)){
						ClassUtils.addGraphicToSprite(data,node,true);
						}else {
						var tChild=ClassUtils.createByJson(data,null,root,customHandler,instanceHandler)
						if (data.type=="Script"){
							if (tChild.hasOwnProperty("owner")){
								tChild["owner"]=node;
								}else if (tChild.hasOwnProperty("target")){
								tChild["target"]=node;
							}
							}else if (data.props.renderType=="mask"){
							node.mask=tChild;
							}else {
							node.addChild(tChild);
						}
					}
				}
			}
		}
		if (props){
			for (var prop in props){
				var value=props[prop];
				if (prop==="var" && root){
					root[value]=node;
					}else if ((value instanceof Array)&& (typeof (node[prop])=='function')){
					node[prop].apply(node,value);
					}else {
					node[prop]=value;
				}
			}
		}
		if (customHandler && json.customProps){
			customHandler.runWith([node,json]);
		}
		if (node["created"])
			node.created();
		return node;
	}

	ClassUtils.addGraphicsToSprite=function(graphicO,sprite){
		var graphics;
		graphics=graphicO.child;
		if (!graphics || graphics.length < 1)
			return;
		var g;
		g=ClassUtils._getGraphicsFromSprite(graphicO,sprite);
		var ox=0;
		var oy=0;
		if (graphicO.props){
			ox=ClassUtils._getObjVar(graphicO.props,"x",0);
			oy=ClassUtils._getObjVar(graphicO.props,"y",0);
		}
		if (ox !=0 && oy !=0){
			g.translate(ox,oy);
		};
		var i=0,len=0;
		len=graphics.length;
		for (i=0;i < len;i++){
			ClassUtils._addGraphicToGraphics(graphics[i],g);
		}
		if (ox !=0 && oy !=0){
			g.translate(-ox,-oy);
		}
	}

	ClassUtils.addGraphicToSprite=function(graphicO,sprite,isChild){
		(isChild===void 0)&& (isChild=false);
		var g;
		g=isChild ? ClassUtils._getGraphicsFromSprite(graphicO,sprite):sprite.graphics;
		ClassUtils._addGraphicToGraphics(graphicO,g);
	}

	ClassUtils._getGraphicsFromSprite=function(dataO,sprite){
		var g;
		if (!dataO || !dataO.props)
			return sprite.graphics;
		var propsName;
		propsName=dataO.props.renderType;
		switch (propsName){
			case "hit":
			case "unHit":;
				var hitArea;
				if (!sprite.hitArea){
					sprite.hitArea=new HitArea();
				}
				hitArea=sprite.hitArea;
				if (!hitArea[propsName]){
					hitArea[propsName]=new Graphics();
				}
				g=hitArea[propsName];
				break ;
			default :
			}
		if (!g)
			g=sprite.graphics;
		return g;
	}

	ClassUtils._getTransformData=function(propsO){
		var m;
		if (propsO.hasOwnProperty("pivotX")|| propsO.hasOwnProperty("pivotY")){
			m=m || new Matrix();
			m.translate(-ClassUtils._getObjVar(propsO,"pivotX",0),-ClassUtils._getObjVar(propsO,"pivotY",0));
		};
		var sx=ClassUtils._getObjVar(propsO,"scaleX",1),sy=ClassUtils._getObjVar(propsO,"scaleY",1);
		var rotate=ClassUtils._getObjVar(propsO,"rotation",0);
		var skewX=ClassUtils._getObjVar(propsO,"skewX",0);
		var skewY=ClassUtils._getObjVar(propsO,"skewY",0);
		if (sx !=1 || sy !=1 || rotate !=0){
			m=m || new Matrix();
			m.scale(sx,sy);
			m.rotate(rotate *0.0174532922222222);
		}
		return m;
	}

	ClassUtils._addGraphicToGraphics=function(graphicO,graphic){
		var propsO;
		propsO=graphicO.props;
		if (!propsO)
			return;
		var drawConfig;
		drawConfig=ClassUtils.DrawTypeDic[graphicO.type];
		if (!drawConfig)
			return;
		var g;
		g=graphic;
		var m;
		var params=ClassUtils._getParams(propsO,drawConfig[1],drawConfig[2],drawConfig[3]);
		m=ClassUtils._tM;
		if (m || ClassUtils._alpha !=1){
			g.save();
			if (m)
				g.transform(m);
			if (ClassUtils._alpha !=1)
				g.alpha(ClassUtils._alpha);
		}
		g[drawConfig[0]].apply(g,params);
		if (m || ClassUtils._alpha !=1){
			g.restore();
		}
	}

	ClassUtils._adptLineData=function(params){
		params[2]=parseFloat(params[0])+parseFloat(params[2]);
		params[3]=parseFloat(params[1])+parseFloat(params[3]);
		return params;
	}

	ClassUtils._adptTextureData=function(params){
		params[0]=Loader.getRes(params[0]);
		return params;
	}

	ClassUtils._adptLinesData=function(params){
		params[2]=ClassUtils._getPointListByStr(params[2]);
		return params;
	}

	ClassUtils.isDrawType=function(type){
		if (type=="Image")
			return false;
		return ClassUtils.DrawTypeDic.hasOwnProperty(type);
	}

	ClassUtils._getParams=function(obj,params,xPos,adptFun){
		(xPos===void 0)&& (xPos=0);
		var rst;
		rst=ClassUtils._temParam;
		rst.length=params.length;
		var i=0,len=0;
		len=params.length;
		for (i=0;i < len;i++){
			rst[i]=ClassUtils._getObjVar(obj,params[i][0],params[i][1]);
		}
		ClassUtils._alpha=ClassUtils._getObjVar(obj,"alpha",1);
		var m;
		m=ClassUtils._getTransformData(obj);
		if (m){
			if (!xPos)xPos=0;
			m.translate(rst[xPos],rst[xPos+1]);
			rst[xPos]=rst[xPos+1]=0;
			ClassUtils._tM=m;
			}else {
			ClassUtils._tM=null;
		}
		if (adptFun && ClassUtils[adptFun]){
			rst=ClassUtils[adptFun](rst);
		}
		return rst;
	}

	ClassUtils._getPointListByStr=function(str){
		var pointArr;
		pointArr=str.split(",");
		var i=0,len=0;
		len=pointArr.length;
		for (i=0;i < len;i++){
			pointArr[i]=parseFloat(pointArr[i]);
		}
		return pointArr;
	}

	ClassUtils._getObjVar=function(obj,key,noValue){
		if (obj.hasOwnProperty(key)){
			return obj[key];
		}
		return noValue;
	}

	ClassUtils._temParam=[];
	ClassUtils._classMap={'Sprite':'laya.display.Sprite','Text':'laya.display.Text','Animation':'laya.display.Animation','Skeleton':'laya.ani.bone.Skeleton','Particle2D':'laya.particle.Particle2D','div':'laya.html.dom.HTMLDivElement','p':'laya.html.dom.HTMLElement','img':'laya.html.dom.HTMLImageElement','span':'laya.html.dom.HTMLElement','br':'laya.html.dom.HTMLBrElement','style':'laya.html.dom.HTMLStyleElement','font':'laya.html.dom.HTMLElement','a':'laya.html.dom.HTMLElement','#text':'laya.html.dom.HTMLElement'};
	ClassUtils.getClass=function(className){
		var classObject=ClassUtils._classMap[className] || className;
		if ((typeof classObject=='string'))
			return Laya["__classmap"][classObject];
		return classObject;
	}

	ClassUtils._tM=null;
	ClassUtils._alpha=NaN;
	__static(ClassUtils,
	['DrawTypeDic',function(){return this.DrawTypeDic={"Rect":["drawRect",[["x",0],["y",0],["width",0],["height",0],["fillColor",null],["lineColor",null],["lineWidth",1]]],"Circle":["drawCircle",[["x",0],["y",0],["radius",0],["fillColor",null],["lineColor",null],["lineWidth",1]]],"Pie":["drawPie",[["x",0],["y",0],["radius",0],["startAngle",0],["endAngle",0],["fillColor",null],["lineColor",null],["lineWidth",1]]],"Image":["drawTexture",[["x",0],["y",0],["width",0],["height",0]]],"Texture":["drawTexture",[["skin",null],["x",0],["y",0],["width",0],["height",0]],1,"_adptTextureData"],"FillTexture":["fillTexture",[["skin",null],["x",0],["y",0],["width",0],["height",0],["repeat",null]],1,"_adptTextureData"],"FillText":["fillText",[["text",""],["x",0],["y",0],["font",null],["color",null],["textAlign",null]],1],"Line":["drawLine",[["x",0],["y",0],["toX",0],["toY",0],["lineColor",null],["lineWidth",0]],0,"_adptLineData"],"Lines":["drawLines",[["x",0],["y",0],["points",""],["lineColor",null],["lineWidth",0]],0,"_adptLinesData"],"Curves":["drawCurves",[["x",0],["y",0],["points",""],["lineColor",null],["lineWidth",0]],0,"_adptLinesData"],"Poly":["drawPoly",[["x",0],["y",0],["points",""],["fillColor",null],["lineColor",null],["lineWidth",1]],0,"_adptLinesData"]};}
	]);
	return ClassUtils;
})()


/**
*@private
*<code>Color</code> 是一个颜色值处理类。
*/
//class laya.utils.Color
var Color=(function(){
	function Color(str){
		/**@private */
		this._color=[];
		/**字符串型颜色值。*/
		//this.strColor=null;
		/**uint 型颜色值。*/
		//this.numColor=0;
		//this._drawStyle=null;
		if ((typeof str=='string')){
			this.strColor=str;
			if (str===null)str="#000000";
			str.charAt(0)=='#' && (str=str.substr(1));
			var len=str.length;
			if (len==3 || len==4){
				var temp="";
				for (var i=0;i < len;i++){
					temp+=(str[i]+str[i]);
				}
				str=temp;
			};
			var color=this.numColor=parseInt(str,16);
			var flag=(str.length==8);
			if (flag){
				this._color=[parseInt(str.substr(0,2),16)/ 255,((0x00FF0000 & color)>> 16)/ 255,((0x0000FF00 & color)>> 8)/ 255,(0x000000FF & color)/ 255];
				return;
			}
			}else {
			color=this.numColor=str;
			this.strColor=Utils.toHexColor(color);
		}
		this._color=[((0xFF0000 & color)>> 16)/ 255,((0xFF00 & color)>> 8)/ 255,(0xFF & color)/ 255,1];
		(this._color).__id=++Color._COLODID;
	}

	__class(Color,'laya.utils.Color');
	Color._initDefault=function(){
		Color._DEFAULT={};
		for (var i in Color._COLOR_MAP)Color._SAVE[i]=Color._DEFAULT[i]=new Color(Color._COLOR_MAP[i]);
		return Color._DEFAULT;
	}

	Color._initSaveMap=function(){
		Color._SAVE_SIZE=0;
		Color._SAVE={};
		for (var i in Color._DEFAULT)Color._SAVE[i]=Color._DEFAULT[i];
	}

	Color.create=function(str){
		var color=Color._SAVE[str+""];
		if (color !=null)return color;
		(Color._SAVE_SIZE < 1000)|| Color._initSaveMap();
		return Color._SAVE[str+""]=new Color(str);
	}

	Color._SAVE={};
	Color._SAVE_SIZE=0;
	Color._COLOR_MAP={"white":'#FFFFFF',"red":'#FF0000',"green":'#00FF00',"blue":'#0000FF',"black":'#000000',"yellow":'#FFFF00','gray':'#AAAAAA'};
	Color._DEFAULT=Color._initDefault();
	Color._COLODID=1;
	return Color;
})()


/**
*<code>Dictionary</code> 是一个字典型的数据存取类。
*/
//class laya.utils.Dictionary
var Dictionary=(function(){
	function Dictionary(){
		this._values=[];
		this._keys=[];
	}

	__class(Dictionary,'laya.utils.Dictionary');
	var __proto=Dictionary.prototype;
	/**
	*给指定的键名设置值。
	*@param key 键名。
	*@param value 值。
	*/
	__proto.set=function(key,value){
		var index=this.indexOf(key);
		if (index >=0){
			this._values[index]=value;
			return;
		}
		this._keys.push(key);
		this._values.push(value);
	}

	/**
	*获取指定对象的键名索引。
	*@param key 键名对象。
	*@return 键名索引。
	*/
	__proto.indexOf=function(key){
		var index=this._keys.indexOf(key);
		if (index >=0)return index;
		key=((typeof key=='string'))? Number(key):(((typeof key=='number'))? key.toString():key);
		return this._keys.indexOf(key);
	}

	/**
	*返回指定键名的值。
	*@param key 键名对象。
	*@return 指定键名的值。
	*/
	__proto.get=function(key){
		var index=this.indexOf(key);
		return index < 0 ? null :this._values[index];
	}

	/**
	*移除指定键名的值。
	*@param key 键名对象。
	*@return 是否成功移除。
	*/
	__proto.remove=function(key){
		var index=this.indexOf(key);
		if (index >=0){
			this._keys.splice(index,1);
			this._values.splice(index,1);
			return true;
		}
		return false;
	}

	/**
	*清除此对象的键名列表和键值列表。
	*/
	__proto.clear=function(){
		this._values.length=0;
		this._keys.length=0;
	}

	/**
	*获取所有的子元素列表。
	*/
	__getset(0,__proto,'values',function(){
		return this._values;
	});

	/**
	*获取所有的子元素键名列表。
	*/
	__getset(0,__proto,'keys',function(){
		return this._keys;
	});

	return Dictionary;
})()


/**
*@private
*<code>Dragging</code> 类是触摸滑动控件。
*/
//class laya.utils.Dragging
var Dragging=(function(){
	function Dragging(){
		/**被拖动的对象。*/
		//this.target=null;
		/**缓动衰减系数。*/
		this.ratio=0.92;
		/**单帧最大偏移量。*/
		this.maxOffset=60;
		/**滑动范围。*/
		//this.area=null;
		/**表示拖动是否有惯性。*/
		//this.hasInertia=false;
		/**橡皮筋最大值。*/
		//this.elasticDistance=NaN;
		/**橡皮筋回弹时间，单位为毫秒。*/
		//this.elasticBackTime=NaN;
		/**事件携带数据。*/
		//this.data=null;
		this._dragging=false;
		this._clickOnly=true;
		//this._elasticRateX=NaN;
		//this._elasticRateY=NaN;
		//this._lastX=NaN;
		//this._lastY=NaN;
		//this._offsetX=NaN;
		//this._offsetY=NaN;
		//this._offsets=null;
		//this._disableMouseEvent=false;
		//this._tween=null;
		//this._parent=null;
	}

	__class(Dragging,'laya.utils.Dragging');
	var __proto=Dragging.prototype;
	/**
	*开始拖拽。
	*@param target 待拖拽的 <code>Sprite</code> 对象。
	*@param area 滑动范围。
	*@param hasInertia 拖动是否有惯性。
	*@param elasticDistance 橡皮筋最大值。
	*@param elasticBackTime 橡皮筋回弹时间，单位为毫秒。
	*@param data 事件携带数据。
	*@param disableMouseEvent 鼠标事件是否有效。
	*@param ratio 惯性阻尼系数
	*/
	__proto.start=function(target,area,hasInertia,elasticDistance,elasticBackTime,data,disableMouseEvent,ratio){
		(ratio===void 0)&& (ratio=0.92);
		this.clearTimer();
		this.target=target;
		this.area=area;
		this.hasInertia=hasInertia;
		this.elasticDistance=area ? elasticDistance :0;
		this.elasticBackTime=elasticBackTime;
		this.data=data;
		this._disableMouseEvent=disableMouseEvent;
		this.ratio=ratio;
		if (target.globalScaleX !=1 || target.globalScaleY !=1){
			this._parent=target.parent;
			}else {
			this._parent=Laya.stage;
		}
		this._clickOnly=true;
		this._dragging=true;
		this._elasticRateX=this._elasticRateY=1;
		this._lastX=this._parent.mouseX;
		this._lastY=this._parent.mouseY;
		Laya.stage.on(/*laya.events.Event.MOUSE_UP*/"mouseup",this,this.onStageMouseUp);
		Laya.stage.on(/*laya.events.Event.MOUSE_OUT*/"mouseout",this,this.onStageMouseUp);
		Laya.timer.frameLoop(1,this,this.loop);
	}

	/**
	*清除计时器。
	*/
	__proto.clearTimer=function(){
		Laya.timer.clear(this,this.loop);
		Laya.timer.clear(this,this.tweenMove);
		if (this._tween){
			this._tween.recover();
			this._tween=null;
		}
	}

	/**
	*停止拖拽。
	*/
	__proto.stop=function(){
		if (this._dragging){
			MouseManager.instance.disableMouseEvent=false;
			Laya.stage.off(/*laya.events.Event.MOUSE_UP*/"mouseup",this,this.onStageMouseUp);
			Laya.stage.off(/*laya.events.Event.MOUSE_OUT*/"mouseout",this,this.onStageMouseUp);
			this._dragging=false;
			this.target && this.area && this.backToArea();
			this.clear();
		}
	}

	/**
	*拖拽的循环处理函数。
	*/
	__proto.loop=function(){
		var point=this._parent.getMousePoint();
		var mouseX=point.x;
		var mouseY=point.y;
		var offsetX=mouseX-this._lastX;
		var offsetY=mouseY-this._lastY;
		if (this._clickOnly){
			if (Math.abs(offsetX *Laya.stage._canvasTransform.getScaleX())> 1 || Math.abs(offsetY *Laya.stage._canvasTransform.getScaleY())> 1){
				this._clickOnly=false;
				this._offsets || (this._offsets=[]);
				this._offsets.length=0;
				this.target.event(/*laya.events.Event.DRAG_START*/"dragstart",this.data);
				MouseManager.instance.disableMouseEvent=this._disableMouseEvent;
				this.target._set$P("$_MOUSEDOWN",false);
			}else return;
			}else {
			this._offsets.push(offsetX,offsetY);
		}
		if (offsetX===0 && offsetY===0)return;
		this._lastX=mouseX;
		this._lastY=mouseY;
		this.target.x+=offsetX *this._elasticRateX;
		this.target.y+=offsetY *this._elasticRateY;
		this.area && this.checkArea();
		this.target.event(/*laya.events.Event.DRAG_MOVE*/"dragmove",this.data);
	}

	/**
	*拖拽区域检测。
	*/
	__proto.checkArea=function(){
		if (this.elasticDistance <=0){
			this.backToArea();
			}else {
			if (this.target.x < this.area.x){
				var offsetX=this.area.x-this.target.x;
				}else if (this.target.x > this.area.x+this.area.width){
				offsetX=this.target.x-this.area.x-this.area.width;
				}else {
				offsetX=0;
			}
			this._elasticRateX=Math.max(0,1-(offsetX / this.elasticDistance));
			if (this.target.y < this.area.y){
				var offsetY=this.area.y-this.target.y;
				}else if (this.target.y > this.area.y+this.area.height){
				offsetY=this.target.y-this.area.y-this.area.height;
				}else {
				offsetY=0;
			}
			this._elasticRateY=Math.max(0,1-(offsetY / this.elasticDistance));
		}
	}

	/**
	*移动至设定的拖拽区域。
	*/
	__proto.backToArea=function(){
		this.target.x=Math.min(Math.max(this.target.x,this.area.x),this.area.x+this.area.width);
		this.target.y=Math.min(Math.max(this.target.y,this.area.y),this.area.y+this.area.height);
	}

	/**
	*舞台的抬起事件侦听函数。
	*@param e Event 对象。
	*/
	__proto.onStageMouseUp=function(e){
		MouseManager.instance.disableMouseEvent=false;
		Laya.stage.off(/*laya.events.Event.MOUSE_UP*/"mouseup",this,this.onStageMouseUp);
		Laya.stage.off(/*laya.events.Event.MOUSE_OUT*/"mouseout",this,this.onStageMouseUp);
		Laya.timer.clear(this,this.loop);
		if (this._clickOnly || !this.target)return;
		if (this.hasInertia){
			if (this._offsets.length < 1){
				this._offsets.push(this._parent.mouseX-this._lastX,this._parent.mouseY-this._lastY);
			}
			this._offsetX=this._offsetY=0;
			var len=this._offsets.length;
			var n=Math.min(len,6);
			var m=this._offsets.length-n;
			for (var i=len-1;i > m;i--){
				this._offsetY+=this._offsets[i--];
				this._offsetX+=this._offsets[i];
			}
			this._offsetX=this._offsetX / n *2;
			this._offsetY=this._offsetY / n *2;
			if (Math.abs(this._offsetX)> this.maxOffset)this._offsetX=this._offsetX > 0 ? this.maxOffset :-this.maxOffset;
			if (Math.abs(this._offsetY)> this.maxOffset)this._offsetY=this._offsetY > 0 ? this.maxOffset :-this.maxOffset;
			Laya.timer.frameLoop(1,this,this.tweenMove);
			}else if (this.elasticDistance > 0){
			this.checkElastic();
			}else {
			this.clear();
		}
	}

	/**
	*橡皮筋效果检测。
	*/
	__proto.checkElastic=function(){
		var tx=NaN;
		var ty=NaN;
		if (this.target.x < this.area.x)tx=this.area.x;
		else if (this.target.x > this.area.x+this.area.width)tx=this.area.x+this.area.width;
		if (this.target.y < this.area.y)ty=this.area.y;
		else if (this.target.y > this.area.y+this.area.height)ty=this.area.y+this.area.height;
		if (!isNaN(tx)|| !isNaN(ty)){
			var obj={};
			if (!isNaN(tx))obj.x=tx;
			if (!isNaN(ty))obj.y=ty;
			this._tween=Tween.to(this.target,obj,this.elasticBackTime,Ease.sineOut,Handler.create(this,this.clear),0,false,false);
			}else {
			this.clear();
		}
	}

	/**
	*移动。
	*/
	__proto.tweenMove=function(){
		this._offsetX *=this.ratio *this._elasticRateX;
		this._offsetY *=this.ratio *this._elasticRateY;
		this.target.x+=this._offsetX;
		this.target.y+=this._offsetY;
		this.area && this.checkArea();
		this.target.event(/*laya.events.Event.DRAG_MOVE*/"dragmove",this.data);
		if ((Math.abs(this._offsetX)< 1 && Math.abs(this._offsetY)< 1)|| this._elasticRateX < 0.5 || this._elasticRateY < 0.5){
			Laya.timer.clear(this,this.tweenMove);
			if (this.elasticDistance > 0)this.checkElastic();
			else this.clear();
		}
	}

	/**
	*结束拖拽。
	*/
	__proto.clear=function(){
		if (this.target){
			this.clearTimer();
			var sp=this.target;
			this.target=null;
			this._parent=null;
			sp.event(/*laya.events.Event.DRAG_END*/"dragend",this.data);
		}
	}

	return Dragging;
})()


/**
*<code>Ease</code> 类定义了缓动函数，以便实现 <code>Tween</code> 动画的缓动效果。
*/
//class laya.utils.Ease
var Ease=(function(){
	function Ease(){}
	__class(Ease,'laya.utils.Ease');
	Ease.linearNone=function(t,b,c,d){
		return c *t / d+b;
	}

	Ease.linearIn=function(t,b,c,d){
		return c *t / d+b;
	}

	Ease.linearInOut=function(t,b,c,d){
		return c *t / d+b;
	}

	Ease.linearOut=function(t,b,c,d){
		return c *t / d+b;
	}

	Ease.bounceIn=function(t,b,c,d){
		return c-Ease.bounceOut(d-t,0,c,d)+b;
	}

	Ease.bounceInOut=function(t,b,c,d){
		if (t < d *0.5)return Ease.bounceIn(t *2,0,c,d)*.5+b;
		else return Ease.bounceOut(t *2-d,0,c,d)*.5+c *.5+b;
	}

	Ease.bounceOut=function(t,b,c,d){
		if ((t /=d)< (1 / 2.75))return c *(7.5625 *t *t)+b;
		else if (t < (2 / 2.75))return c *(7.5625 *(t-=(1.5 / 2.75))*t+.75)+b;
		else if (t < (2.5 / 2.75))return c *(7.5625 *(t-=(2.25 / 2.75))*t+.9375)+b;
		else return c *(7.5625 *(t-=(2.625 / 2.75))*t+.984375)+b;
	}

	Ease.backIn=function(t,b,c,d,s){
		(s===void 0)&& (s=1.70158);
		return c *(t /=d)*t *((s+1)*t-s)+b;
	}

	Ease.backInOut=function(t,b,c,d,s){
		(s===void 0)&& (s=1.70158);
		if ((t /=d *0.5)< 1)return c *0.5 *(t *t *(((s *=(1.525))+1)*t-s))+b;
		return c / 2 *((t-=2)*t *(((s *=(1.525))+1)*t+s)+2)+b;
	}

	Ease.backOut=function(t,b,c,d,s){
		(s===void 0)&& (s=1.70158);
		return c *((t=t / d-1)*t *((s+1)*t+s)+1)+b;
	}

	Ease.elasticIn=function(t,b,c,d,a,p){
		(a===void 0)&& (a=0);
		(p===void 0)&& (p=0);
		var s;
		if (t==0)return b;
		if ((t /=d)==1)return b+c;
		if (!p)p=d *.3;
		if (!a || (c > 0 && a < c)|| (c < 0 && a <-c)){
			a=c;
			s=p / 4;
		}else s=p / Ease.PI2 *Math.asin(c / a);
		return-(a *Math.pow(2,10 *(t-=1))*Math.sin((t *d-s)*Ease.PI2 / p))+b;
	}

	Ease.elasticInOut=function(t,b,c,d,a,p){
		(a===void 0)&& (a=0);
		(p===void 0)&& (p=0);
		var s;
		if (t==0)return b;
		if ((t /=d *0.5)==2)return b+c;
		if (!p)p=d *(.3 *1.5);
		if (!a || (c > 0 && a < c)|| (c < 0 && a <-c)){
			a=c;
			s=p / 4;
		}else s=p / Ease.PI2 *Math.asin(c / a);
		if (t < 1)return-.5 *(a *Math.pow(2,10 *(t-=1))*Math.sin((t *d-s)*Ease.PI2 / p))+b;
		return a *Math.pow(2,-10 *(t-=1))*Math.sin((t *d-s)*Ease.PI2 / p)*.5+c+b;
	}

	Ease.elasticOut=function(t,b,c,d,a,p){
		(a===void 0)&& (a=0);
		(p===void 0)&& (p=0);
		var s;
		if (t==0)return b;
		if ((t /=d)==1)return b+c;
		if (!p)p=d *.3;
		if (!a || (c > 0 && a < c)|| (c < 0 && a <-c)){
			a=c;
			s=p / 4;
		}else s=p / Ease.PI2 *Math.asin(c / a);
		return (a *Math.pow(2,-10 *t)*Math.sin((t *d-s)*Ease.PI2 / p)+c+b);
	}

	Ease.strongIn=function(t,b,c,d){
		return c *(t /=d)*t *t *t *t+b;
	}

	Ease.strongInOut=function(t,b,c,d){
		if ((t /=d *0.5)< 1)return c *0.5 *t *t *t *t *t+b;
		return c *0.5 *((t-=2)*t *t *t *t+2)+b;
	}

	Ease.strongOut=function(t,b,c,d){
		return c *((t=t / d-1)*t *t *t *t+1)+b;
	}

	Ease.sineInOut=function(t,b,c,d){
		return-c *0.5 *(Math.cos(Math.PI *t / d)-1)+b;
	}

	Ease.sineIn=function(t,b,c,d){
		return-c *Math.cos(t / d *Ease.HALF_PI)+c+b;
	}

	Ease.sineOut=function(t,b,c,d){
		return c *Math.sin(t / d *Ease.HALF_PI)+b;
	}

	Ease.quintIn=function(t,b,c,d){
		return c *(t /=d)*t *t *t *t+b;
	}

	Ease.quintInOut=function(t,b,c,d){
		if ((t /=d *0.5)< 1)return c *0.5 *t *t *t *t *t+b;
		return c *0.5 *((t-=2)*t *t *t *t+2)+b;
	}

	Ease.quintOut=function(t,b,c,d){
		return c *((t=t / d-1)*t *t *t *t+1)+b;
	}

	Ease.quartIn=function(t,b,c,d){
		return c *(t /=d)*t *t *t+b;
	}

	Ease.quartInOut=function(t,b,c,d){
		if ((t /=d *0.5)< 1)return c *0.5 *t *t *t *t+b;
		return-c *0.5 *((t-=2)*t *t *t-2)+b;
	}

	Ease.quartOut=function(t,b,c,d){
		return-c *((t=t / d-1)*t *t *t-1)+b;
	}

	Ease.cubicIn=function(t,b,c,d){
		return c *(t /=d)*t *t+b;
	}

	Ease.cubicInOut=function(t,b,c,d){
		if ((t /=d *0.5)< 1)return c *0.5 *t *t *t+b;
		return c *0.5 *((t-=2)*t *t+2)+b;
	}

	Ease.cubicOut=function(t,b,c,d){
		return c *((t=t / d-1)*t *t+1)+b;
	}

	Ease.quadIn=function(t,b,c,d){
		return c *(t /=d)*t+b;
	}

	Ease.quadInOut=function(t,b,c,d){
		if ((t /=d *0.5)< 1)return c *0.5 *t *t+b;
		return-c *0.5 *((--t)*(t-2)-1)+b;
	}

	Ease.quadOut=function(t,b,c,d){
		return-c *(t /=d)*(t-2)+b;
	}

	Ease.expoIn=function(t,b,c,d){
		return (t==0)? b :c *Math.pow(2,10 *(t / d-1))+b-c *0.001;
	}

	Ease.expoInOut=function(t,b,c,d){
		if (t==0)return b;
		if (t==d)return b+c;
		if ((t /=d *0.5)< 1)return c *0.5 *Math.pow(2,10 *(t-1))+b;
		return c *0.5 *(-Math.pow(2,-10 *--t)+2)+b;
	}

	Ease.expoOut=function(t,b,c,d){
		return (t==d)? b+c :c *(-Math.pow(2,-10 *t / d)+1)+b;
	}

	Ease.circIn=function(t,b,c,d){
		return-c *(Math.sqrt(1-(t /=d)*t)-1)+b;
	}

	Ease.circInOut=function(t,b,c,d){
		if ((t /=d *0.5)< 1)return-c *0.5 *(Math.sqrt(1-t *t)-1)+b;
		return c *0.5 *(Math.sqrt(1-(t-=2)*t)+1)+b;
	}

	Ease.circOut=function(t,b,c,d){
		return c *Math.sqrt(1-(t=t / d-1)*t)+b;
	}

	Ease.HALF_PI=Math.PI *0.5;
	Ease.PI2=Math.PI *2;
	return Ease;
})()


/**
*鼠标点击区域，可以设置绘制一系列矢量图作为点击区域和非点击区域（目前只支持圆形，矩形，多边形）
*/
//class laya.utils.HitArea
var HitArea=(function(){
	function HitArea(){
		/**@private */
		this._hit=null;
		/**@private */
		this._unHit=null;
	}

	__class(HitArea,'laya.utils.HitArea');
	var __proto=HitArea.prototype;
	/**
	*是否包含某个点
	*@param x x坐标
	*@param y y坐标
	*@return 是否点击到
	*/
	__proto.isHit=function(x,y){
		if (!HitArea.isHitGraphic(x,y,this.hit))return false;
		return !HitArea.isHitGraphic(x,y,this.unHit);
	}

	/**
	*检测对象是否包含指定的点。
	*@param x 点的 X 轴坐标值（水平位置）。
	*@param y 点的 Y 轴坐标值（垂直位置）。
	*@return 如果包含指定的点，则值为 true；否则为 false。
	*/
	__proto.contains=function(x,y){
		return this.isHit(x,y);
	}

	/**
	*可点击区域，可以设置绘制一系列矢量图作为点击区域（目前只支持圆形，矩形，多边形）
	*/
	__getset(0,__proto,'hit',function(){
		if (!this._hit)this._hit=new Graphics();
		return this._hit;
		},function(value){
		this._hit=value;
	});

	/**
	*不可点击区域，可以设置绘制一系列矢量图作为非点击区域（目前只支持圆形，矩形，多边形）
	*/
	__getset(0,__proto,'unHit',function(){
		if (!this._unHit)this._unHit=new Graphics();
		return this._unHit;
		},function(value){
		this._unHit=value;
	});

	HitArea.isHitGraphic=function(x,y,graphic){
		if (!graphic)return false;
		var cmds;
		cmds=graphic.cmds;
		if (!cmds && graphic._one){
			cmds=HitArea._cmds;
			cmds.length=1;
			cmds[0]=graphic._one;
		}
		if (!cmds)return false;
		var i=0,len=0;
		len=cmds.length;
		var cmd;
		for (i=0;i < len;i++){
			cmd=cmds[i];
			if (!cmd)continue ;
			var context=Render._context;
			switch (cmd.callee){
				case context._translate:
				case 6:
					x-=cmd[0];
					y-=cmd[1];
				default :
				}
			if (HitArea.isHitCmd(x,y,cmd))return true;
		}
		return false;
	}

	HitArea.isHitCmd=function(x,y,cmd){
		if (!cmd)return false;
		var context=Render._context;
		var rst=false;
		switch (cmd["callee"]){
			case context._drawRect:
			case 13:
				HitArea._rec.setTo(cmd[0],cmd[1],cmd[2],cmd[3]);
				rst=HitArea._rec.contains(x,y);
				break ;
			case context._drawCircle:
			case context._fillCircle:
			case 14:;
				var d=NaN;
				x-=cmd[0];
				y-=cmd[1];
				d=x *x+y *y;
				rst=d < cmd[2] *cmd[2];
				break ;
			case context._drawPoly:
			case 18:
				x-=cmd[0];
				y-=cmd[1];
				rst=HitArea.ptInPolygon(x,y,cmd[2]);
				break ;
			default :
				break ;
			}
		return rst;
	}

	HitArea.ptInPolygon=function(x,y,areaPoints){
		var p;
		p=HitArea._ptPoint;
		p.setTo(x,y);
		var nCross=0;
		var p1x=NaN,p1y=NaN,p2x=NaN,p2y=NaN;
		var len=0;
		len=areaPoints.length;
		for (var i=0;i < len;i+=2){
			p1x=areaPoints[i];
			p1y=areaPoints[i+1];
			p2x=areaPoints[(i+2)% len];
			p2y=areaPoints[(i+3)% len];
			if (p1y==p2y)
				continue ;
			if (p.y < Math.min(p1y,p2y))
				continue ;
			if (p.y >=Math.max(p1y,p2y))
				continue ;
			var tx=(p.y-p1y)*(p2x-p1x)/ (p2y-p1y)+p1x;
			if (tx > p.x){
				nCross++;
			}
		}
		return (nCross % 2==1);
	}

	HitArea._cmds=[];
	__static(HitArea,
	['_rec',function(){return this._rec=new Rectangle();},'_ptPoint',function(){return this._ptPoint=new Point();}
	]);
	return HitArea;
})()


/**
*@private
*<code>HTMLChar</code> 是一个 HTML 字符类。
*/
//class laya.utils.HTMLChar
var HTMLChar=(function(){
	function HTMLChar(char,w,h,style){
		//this._sprite=null;
		//this._x=NaN;
		//this._y=NaN;
		//this._w=NaN;
		//this._h=NaN;
		/**表示是否是正常单词(英文|.|数字)。*/
		//this.isWord=false;
		/**字符。*/
		//this.char=null;
		/**字符数量。*/
		//this.charNum=NaN;
		/**CSS 样式。*/
		//this.style=null;
		this.char=char;
		this.charNum=char.charCodeAt(0);
		this._x=this._y=0;
		this.width=w;
		this.height=h;
		this.style=style;
		this.isWord=!HTMLChar._isWordRegExp.test(char);
	}

	__class(HTMLChar,'laya.utils.HTMLChar');
	var __proto=HTMLChar.prototype;
	Laya.imps(__proto,{"laya.display.ILayout":true})
	/**
	*设置与此对象绑定的显示对象 <code>Sprite</code> 。
	*@param sprite 显示对象 <code>Sprite</code> 。
	*/
	__proto.setSprite=function(sprite){
		this._sprite=sprite;
	}

	/**
	*获取与此对象绑定的显示对象 <code>Sprite</code>。
	*@return
	*/
	__proto.getSprite=function(){
		return this._sprite;
	}

	/**@private */
	__proto._isChar=function(){
		return true;
	}

	/**@private */
	__proto._getCSSStyle=function(){
		return this.style;
	}

	/**
	*宽度。
	*/
	__getset(0,__proto,'width',function(){
		return this._w;
		},function(value){
		this._w=value;
	});

	/**
	*此对象存储的 X 轴坐标值。
	*当设置此值时，如果此对象有绑定的 Sprite 对象，则改变 Sprite 对象的属性 x 的值。
	*/
	__getset(0,__proto,'x',function(){
		return this._x;
		},function(value){
		if (this._sprite){
			this._sprite.x=value;
		}
		this._x=value;
	});

	/**
	*此对象存储的 Y 轴坐标值。
	*当设置此值时，如果此对象有绑定的 Sprite 对象，则改变 Sprite 对象的属性 y 的值。
	*/
	__getset(0,__proto,'y',function(){
		return this._y;
		},function(value){
		if (this._sprite){
			this._sprite.y=value;
		}
		this._y=value;
	});

	/**
	*高度。
	*/
	__getset(0,__proto,'height',function(){
		return this._h;
		},function(value){
		this._h=value;
	});

	HTMLChar._isWordRegExp=new RegExp("[\\w\.]","");
	return HTMLChar;
})()


/**
*<code>Log</code> 类用于在界面内显示日志记录信息。
*/
//class laya.utils.Log
var Log=(function(){
	function Log(){}
	__class(Log,'laya.utils.Log');
	Log.enable=function(){
		if (!Log._logdiv){
			Log._logdiv=Browser.window.document.createElement('div');
			Browser.window.document.body.appendChild(Log._logdiv);
			Log._logdiv.style.cssText="pointer-events:none;border:white;overflow:hidden;z-index:1000000;background:rgba(100,100,100,0.6);color:white;position: absolute;left:0px;top:0px;width:50%;height:50%;";
		}
	}

	Log.toggle=function(){
		var style=Log._logdiv.style;
		if (style.width=="1px"){
			style.width=style.height="50%";
			}else {
			style.width=style.height="1px";
		}
	}

	Log.print=function(value){
		if (Log._logdiv){
			if (Log._count >=Log.maxCount)Log.clear();
			Log._count++;
			Log._logdiv.innerText+=value+"\n";
			Log._logdiv.scrollTop=Log._logdiv.scrollHeight;
		}
	}

	Log.clear=function(){
		Log._logdiv.innerText="";
		Log._count=0;
	}

	Log._logdiv=null;
	Log._count=0;
	Log.maxCount=20;
	return Log;
})()


/**
*<code>Mouse</code> 类用于控制鼠标光标。
*/
//class laya.utils.Mouse
var Mouse=(function(){
	function Mouse(){}
	__class(Mouse,'laya.utils.Mouse');
	/**
	*设置鼠标样式
	*@param cursorStr
	*例如auto move no-drop col-resize
	*all-scroll pointer not-allowed row-resize
	*crosshair progress e-resize ne-resize
	*default text n-resize nw-resize
	*help vertical-text s-resize se-resize
	*inherit wait w-resize sw-resize
	*
	*/
	__getset(1,Mouse,'cursor',function(){
		return Mouse._style.cursor;
		},function(cursorStr){
		Mouse._style.cursor=cursorStr;
	});

	Mouse.hide=function(){
		if (Mouse.cursor !="none"){
			Mouse._preCursor=Mouse.cursor;
			Mouse.cursor="none";
		}
	}

	Mouse.show=function(){
		if (Mouse.cursor=="none"){
			if (Mouse._preCursor){
				Mouse.cursor=Mouse._preCursor;
				}else {
				Mouse.cursor="auto";
			}
		}
	}

	Mouse._preCursor=null;
	__static(Mouse,
	['_style',function(){return this._style=Browser.document.body.style;}
	]);
	return Mouse;
})()


/**
*<p> <code>Pool</code> 是对象池类，用于对象的存贮、重复使用。</p>
*<p>合理使用对象池，可以有效减少对象创建的开销，避免频繁的垃圾回收，从而优化游戏流畅度。</p>
*/
//class laya.utils.Pool
var Pool=(function(){
	function Pool(){}
	__class(Pool,'laya.utils.Pool');
	Pool.getPoolBySign=function(sign){
		return Pool._poolDic[sign] || (Pool._poolDic[sign]=[]);
	}

	Pool.clearBySign=function(sign){
		if (Pool._poolDic[sign])Pool._poolDic[sign].length=0;
	}

	Pool.recover=function(sign,item){
		if (item["__InPool"])return;
		item["__InPool"]=true;
		Pool.getPoolBySign(sign).push(item);
	}

	Pool.getItemByClass=function(sign,cls){
		var pool=Pool.getPoolBySign(sign);
		var rst=pool.length ? pool.pop():new cls();
		rst["__InPool"]=false;
		return rst;
	}

	Pool.getItemByCreateFun=function(sign,createFun){
		var pool=Pool.getPoolBySign(sign);
		var rst=pool.length ? pool.pop():createFun();
		rst["__InPool"]=false;
		return rst;
	}

	Pool.getItem=function(sign){
		var pool=Pool.getPoolBySign(sign);
		var rst=pool.length ? pool.pop():null;
		if (rst){
			rst["__InPool"]=false;
		}
		return rst;
	}

	Pool._poolDic={};
	Pool.InPoolSign="__InPool";
	return Pool;
})()


/**
*@private
*基于个数的对象缓存管理器
*/
//class laya.utils.PoolCache
var PoolCache=(function(){
	function PoolCache(){
		/**
		*对象在Pool中的标识
		*/
		this.sign=null;
		/**
		*允许缓存的最大数量
		*/
		this.maxCount=1000;
	}

	__class(PoolCache,'laya.utils.PoolCache');
	var __proto=PoolCache.prototype;
	/**
	*获取缓存的对象列表
	*@return
	*
	*/
	__proto.getCacheList=function(){
		return Pool.getPoolBySign(this.sign);
	}

	/**
	*尝试清理缓存
	*@param force 是否强制清理
	*
	*/
	__proto.tryDispose=function(force){
		var list;
		list=Pool.getPoolBySign(this.sign);
		if (list.length > this.maxCount){
			list.splice(this.maxCount,list.length-this.maxCount);
		}
	}

	PoolCache.addPoolCacheManager=function(sign,maxCount){
		(maxCount===void 0)&& (maxCount=100);
		var cache;
		cache=new PoolCache();
		cache.sign=sign;
		cache.maxCount=maxCount;
		CacheManager.regCacheByFunction(Utils.bind(cache.tryDispose,cache),Utils.bind(cache.getCacheList,cache));
	}

	return PoolCache;
})()


/**
*<p> <code>Stat</code> 是一个性能统计面板，可以实时更新相关的性能参数。</p>
*<p>参与统计的性能参数如下（所有参数都是每大约1秒进行更新）：<br/>
*FPS(Canvas)/FPS(WebGL)：Canvas 模式或者 WebGL 模式下的帧频，也就是每秒显示的帧数，值越高、越稳定，感觉越流畅；<br/>
*Sprite：统计所有渲染节点（包括容器）数量，它的大小会影响引擎进行节点遍历、数据组织和渲染的效率。其值越小，游戏运行效率越高；<br/>
*DrawCall：此值是决定性能的重要指标，其值越小，游戏运行效率越高。Canvas模式下表示每大约1秒的图像绘制次数；WebGL模式下表示每大约1秒的渲染提交批次，每次准备数据并通知GPU渲染绘制的过程称为1次DrawCall，在每次DrawCall中除了在通知GPU的渲染上比较耗时之外，切换材质与shader也是非常耗时的操作；<br/>
*CurMem：Canvas模式下，表示内存占用大小，值越小越好，过高会导致游戏闪退；WebGL模式下，表示内存与显存的占用，值越小越好；<br/>
*Shader：是 WebGL 模式独有的性能指标，表示每大约1秒 Shader 提交次数，值越小越好；<br/>
*Canvas：由三个数值组成，只有设置 CacheAs 后才会有值，默认为0/0/0。从左到右数值的意义分别为：每帧重绘的画布数量 / 缓存类型为"normal"类型的画布数量 / 缓存类型为"bitmap"类型的画布数量。</p>
*/
//class laya.utils.Stat
var Stat=(function(){
	function Stat(){}
	__class(Stat,'laya.utils.Stat');
	/**
	*点击性能统计显示区域的处理函数。
	*/
	__getset(1,Stat,'onclick',null,function(fn){
		if (Stat._sp){
			Stat._sp.on("click",Stat._sp,fn);
		}
		if (Stat._canvas){
			Stat._canvas.source.onclick=fn;
			Stat._canvas.source.style.pointerEvents='';
		}
	});

	Stat.show=function(x,y){
		(x===void 0)&& (x=0);
		(y===void 0)&& (y=0);
		if (Render.isConchApp && !Render.isConchWebGL){
			Browser.window.conch.showFPS && Browser.window.conch.showFPS(x,y);
			return;
		}
		if (!Render.isConchWebGL && !Browser.onMiniGame &&! Browser.onLimixiu)Stat._useCanvas=true;
		Stat._show=true;
		Stat._fpsData.length=60;
		Stat._view[0]={title:"FPS(Canvas)",value:"_fpsStr",color:"yellow",units:"int"};
		Stat._view[1]={title:"Sprite",value:"_spriteStr",color:"white",units:"int"};
		Stat._view[2]={title:"DrawCall",value:"drawCall",color:"white",units:"int"};
		Stat._view[3]={title:"CurMem",value:"currentMemorySize",color:"yellow",units:"M"};
		if (Render.isWebGL){
			Stat._view[4]={title:"Shader",value:"shaderCall",color:"white",units:"int"};
			if (!Render.is3DMode){
				Stat._view[0].title="FPS(WebGL)";
				Stat._view[5]={title:"Canvas",value:"_canvasStr",color:"white",units:"int"};
				}else {
				Stat._view[0].title="FPS(3D)";
				Stat._view[5]={title:"TriFaces",value:"trianglesFaces",color:"white",units:"int"};
				Stat._view[6]={title:"treeNodeColl",value:"treeNodeCollision",color:"white",units:"int"};
				Stat._view[7]={title:"treeSpriteColl",value:"treeSpriteCollision",color:"white",units:"int"};
			}
			}else {
			Stat._view[4]={title:"Canvas",value:"_canvasStr",color:"white",units:"int"};
		}
		if (Stat._useCanvas){
			Stat.createUIPre(x,y);
		}else
		Stat.createUI(x,y);
		Stat.enable();
	}

	Stat.createUIPre=function(x,y){
		var pixel=Browser.pixelRatio;
		Stat._width=pixel *130;
		Stat._vx=pixel *75;
		Stat._height=pixel *(Stat._view.length *12+3 *pixel)+4;
		Stat._fontSize=12 *pixel;
		for (var i=0;i < Stat._view.length;i++){
			Stat._view[i].x=4;
			Stat._view[i].y=i *Stat._fontSize+2 *pixel;
		}
		if (!Stat._canvas){
			Stat._canvas=new HTMLCanvas('2D');
			Stat._canvas.size(Stat._width,Stat._height);
			Stat._ctx=Stat._canvas.getContext('2d');
			Stat._ctx.textBaseline="top";
			Stat._ctx.font=Stat._fontSize+"px Sans-serif";
			Stat._canvas.source.style.cssText="pointer-events:none;background:rgba(150,150,150,0.8);z-index:100000;position: absolute;direction:ltr;left:"+x+"px;top:"+y+"px;width:"+(Stat._width / pixel)+"px;height:"+(Stat._height / pixel)+"px;";
		}
		Stat._first=true;
		Stat.loop();
		Stat._first=false;
		Browser.container.appendChild(Stat._canvas.source);
	}

	Stat.createUI=function(x,y){
		var stat=Stat._sp;
		var pixel=Browser.pixelRatio;
		if (!stat){
			stat=new Sprite();
			Stat._leftText=new Text();
			Stat._leftText.pos(5,5);
			Stat._leftText.color="#ffffff";
			stat.addChild(Stat._leftText);
			Stat._txt=new Text();
			Stat._txt.pos(80*pixel,5);
			Stat._txt.color="#ffffff";
			stat.addChild(Stat._txt);
			Stat._sp=stat;
		}
		stat.pos(x,y);
		var text="";
		for (var i=0;i < Stat._view.length;i++){
			var one=Stat._view[i];
			text+=one.title+"\n";
		}
		Stat._leftText.text=text;
		var width=pixel *138;
		var height=pixel *(Stat._view.length *12+3 *pixel)+4;
		Stat._txt.fontSize=Stat._fontSize *pixel;
		Stat._leftText.fontSize=Stat._fontSize *pixel;
		stat.size(width,height);
		stat.graphics.clear();
		stat.graphics.setAlpha(0.5);
		stat.graphics.drawRect(0,0,width,height,"#999999");
		stat.graphics.setAlpha(1);
		Stat.loop();
	}

	Stat.enable=function(){
		Laya.timer.frameLoop(1,Stat,Stat.loop);
	}

	Stat.hide=function(){
		Stat._show=false;
		Laya.timer.clear(Stat,Stat.loop);
		if (Stat._canvas){
			Browser.removeElement(Stat._canvas.source);
		}
	}

	Stat.clear=function(){
		Stat.trianglesFaces=Stat.drawCall=Stat.shaderCall=Stat.spriteCount=Stat.spriteRenderUseCacheCount=Stat.treeNodeCollision=Stat.treeSpriteCollision=Stat.canvasNormal=Stat.canvasBitmap=Stat.canvasReCache=0;
	}

	Stat.loop=function(){
		Stat._count++;
		var timer=Browser.now();
		if (timer-Stat._timer < 1000)return;
		var count=Stat._count;
		Stat.FPS=Math.round((count *1000)/ (timer-Stat._timer));
		if (Stat._show){
			Stat.trianglesFaces=Math.round(Stat.trianglesFaces / count);
			if (!Stat._useCanvas){
				Stat.drawCall=Math.round(Stat.drawCall / count)-2;
				Stat.shaderCall=Math.round(Stat.shaderCall / count)-4;
				Stat.spriteCount=Math.round(Stat.spriteCount / count)-4;
				}else{
				Stat.drawCall=Math.round(Stat.drawCall / count)-2;
				Stat.shaderCall=Math.round(Stat.shaderCall / count);
				Stat.spriteCount=Math.round(Stat.spriteCount / count)-1;
			}
			Stat.spriteRenderUseCacheCount=Math.round(Stat.spriteRenderUseCacheCount / count);
			Stat.canvasNormal=Math.round(Stat.canvasNormal / count);
			Stat.canvasBitmap=Math.round(Stat.canvasBitmap / count);
			Stat.canvasReCache=Math.ceil(Stat.canvasReCache / count);
			Stat.treeNodeCollision=Math.round(Stat.treeNodeCollision / count);
			Stat.treeSpriteCollision=Math.round(Stat.treeSpriteCollision / count);
			var delay=Stat.FPS > 0 ? Math.floor(1000 / Stat.FPS).toString():" ";
			Stat._fpsStr=Stat.FPS+(Stat.renderSlow ? " slow" :"")+" "+delay;
			Stat._spriteStr=Stat.spriteCount+(Stat.spriteRenderUseCacheCount ? ("/"+Stat.spriteRenderUseCacheCount):'');
			Stat._canvasStr=Stat.canvasReCache+"/"+Stat.canvasNormal+"/"+Stat.canvasBitmap;
			Stat.currentMemorySize=ResourceManager.systemResourceManager.memorySize;
			if (Stat._useCanvas){
				Stat.renderInfoPre();
			}else
			Stat.renderInfo();
			Stat.clear();
		}
		Stat._count=0;
		Stat._timer=timer;
	}

	Stat.renderInfoPre=function(){
		if (Stat._canvas){
			var ctx=Stat._ctx;
			ctx.clearRect(Stat._first ? 0 :Stat._vx,0,Stat._width,Stat._height);
			for (var i=0;i < Stat._view.length;i++){
				var one=Stat._view[i];
				if (Stat._first){
					ctx.fillStyle="white";
					ctx.fillText(one.title,one.x,one.y,null,null,null);
				}
				ctx.fillStyle=one.color;
				var value=Stat[one.value];
				(one.units=="M")&& (value=Math.floor(value / (1024 *1024)*100)/ 100+" M");
				ctx.fillText(value+"",one.x+Stat._vx,one.y,null,null,null);
			}
		}
	}

	Stat.renderInfo=function(){
		var text="";
		for (var i=0;i < Stat._view.length;i++){
			var one=Stat._view[i];
			var value=Stat[one.value];
			(one.units=="M")&& (value=Math.floor(value / (1024 *1024)*100)/ 100+" M");
			(one.units=="K")&& (value=Math.floor(value / (1024)*100)/ 100+" K");
			text+=value+"\n";
		}
		Stat._txt.text=text;
	}

	Stat.FPS=0;
	Stat.loopCount=0;
	Stat.shaderCall=0;
	Stat.drawCall=0;
	Stat.trianglesFaces=0;
	Stat.spriteCount=0;
	Stat.spriteRenderUseCacheCount=0;
	Stat.treeNodeCollision=0;
	Stat.treeSpriteCollision=0;
	Stat.canvasNormal=0;
	Stat.canvasBitmap=0;
	Stat.canvasReCache=0;
	Stat.renderSlow=false;
	Stat.currentMemorySize=0;
	Stat._fpsStr=null;
	Stat._canvasStr=null;
	Stat._spriteStr=null;
	Stat._fpsData=[];
	Stat._timer=0;
	Stat._count=0;
	Stat._view=[];
	Stat._fontSize=12;
	Stat._txt=null;
	Stat._leftText=null;
	Stat._sp=null;
	Stat._show=false;
	Stat._useCanvas=false;
	Stat._canvas=null;
	Stat._ctx=null;
	Stat._first=false;
	Stat._vx=NaN;
	Stat._width=0;
	Stat._height=100;
	return Stat;
})()


/**
*@private
*<code>StringKey</code> 类用于存取字符串对应的数字。
*/
//class laya.utils.StringKey
var StringKey=(function(){
	function StringKey(){
		this._strsToID={};
		this._idToStrs=[];
		this._length=0;
	}

	__class(StringKey,'laya.utils.StringKey');
	var __proto=StringKey.prototype;
	/**
	*添加一个字符。
	*@param str 字符，将作为key 存储相应生成的数字。
	*@return 此字符对应的数字。
	*/
	__proto.add=function(str){
		var index=this._strsToID[str];
		if (index !=null)return index;
		this._idToStrs[this._length]=str;
		return this._strsToID[str]=this._length++;
	}

	/**
	*获取指定字符对应的ID。
	*@param str 字符。
	*@return 此字符对应的ID。
	*/
	__proto.getID=function(str){
		var index=this._strsToID[str];
		return index==null ?-1 :index;
	}

	/**
	*根据指定ID获取对应字符。
	*@param id ID。
	*@return 此id对应的字符。
	*/
	__proto.getName=function(id){
		var str=this._idToStrs[id];
		return str==null ? undefined :str;
	}

	return StringKey;
})()


/**
*<code>Timer</code> 是时钟管理类。它是一个单例，不要手动实例化此类，应该通过 Laya.timer 访问。
*/
//class laya.utils.Timer
var Timer=(function(){
	var TimerHandler;
	function Timer(){
		/**两帧之间的时间间隔,单位毫秒。*/
		this._delta=0;
		/**时针缩放。*/
		this.scale=1;
		/**当前的帧数。*/
		this.currFrame=0;
		/**@private */
		this._mid=1;
		/**@private */
		this._map=[];
		/**@private */
		this._laters=[];
		/**@private */
		this._handlers=[];
		/**@private */
		this._temp=[];
		/**@private */
		this._count=0;
		this.currTimer=this._now();
		this._lastTimer=this._now();
		this._init();
	}

	__class(Timer,'laya.utils.Timer');
	var __proto=Timer.prototype;
	/**@private */
	__proto._init=function(){
		Laya.timer && Laya.timer.frameLoop(1,this,this._update);
	}

	/**@private */
	__proto._now=function(){
		return /*__JS__ */Date.now();
	}

	/**
	*@private
	*帧循环处理函数。
	*/
	__proto._update=function(){
		if (this.scale <=0){
			this._lastTimer=this._now();
			return;
		};
		var frame=this.currFrame=this.currFrame+this.scale;
		var now=this._now();
		this._delta=(now-this._lastTimer)*this.scale;
		var timer=this.currTimer=this.currTimer+this._delta;
		this._lastTimer=now;
		var handlers=this._handlers;
		this._count=0;
		for (i=0,n=handlers.length;i < n;i++){
			handler=handlers[i];
			if (handler.method!==null){
				var t=handler.userFrame ? frame :timer;
				if (t >=handler.exeTime){
					if (handler.repeat){
						if (!handler.jumpFrame){
							handler.exeTime+=handler.delay;
							handler.run(false);
							if (t > handler.exeTime){
								handler.exeTime+=Math.ceil((t-handler.exeTime)/ handler.delay)*handler.delay;
							}
							}else {
							while (t >=handler.exeTime){
								handler.exeTime+=handler.delay;
								handler.run(false);
							}
						}
						}else {
						handler.run(true);
					}
				}
				}else {
				this._count++;
			}
		}
		if (this._count > 30 || frame % 200===0)this._clearHandlers();
		var laters=this._laters;
		for (var i=0,n=laters.length-1;i <=n;i++){
			var handler=laters[i];
			if (handler.method!==null){
				this._map[handler.key]=null;
				handler.run(false);
			}
			this._recoverHandler(handler);
			i===n && (n=laters.length-1);
		}
		laters.length=0;
	}

	/**@private */
	__proto._clearHandlers=function(){
		var handlers=this._handlers;
		for (var i=0,n=handlers.length;i < n;i++){
			var handler=handlers[i];
			if (handler.method!==null)this._temp.push(handler);
			else this._recoverHandler(handler);
		}
		this._handlers=this._temp;
		this._temp=handlers;
		this._temp.length=0;
	}

	/**@private */
	__proto._recoverHandler=function(handler){
		if(this._map[handler.key]==handler)this._map[handler.key]=null;
		handler.clear();
		Timer._pool.push(handler);
	}

	/**@private */
	__proto._create=function(useFrame,repeat,delay,caller,method,args,coverBefore){
		if (!delay){
			method.apply(caller,args);
			return null;
		}
		if (coverBefore){
			var handler=this._getHandler(caller,method);
			if (handler){
				handler.repeat=repeat;
				handler.userFrame=useFrame;
				handler.delay=delay;
				handler.caller=caller;
				handler.method=method;
				handler.args=args;
				handler.exeTime=delay+(useFrame ? this.currFrame :this.currTimer+this._now()-this._lastTimer);
				return handler;
			}
		}
		handler=Timer._pool.length > 0 ? Timer._pool.pop():new TimerHandler();
		handler.repeat=repeat;
		handler.userFrame=useFrame;
		handler.delay=delay;
		handler.caller=caller;
		handler.method=method;
		handler.args=args;
		handler.exeTime=delay+(useFrame ? this.currFrame :this.currTimer+this._now()-this._lastTimer)+1;
		this._indexHandler(handler);
		this._handlers.push(handler);
		return handler;
	}

	/**@private */
	__proto._indexHandler=function(handler){
		var caller=handler.caller;
		var method=handler.method;
		var cid=caller ? caller.$_GID || (caller.$_GID=Utils.getGID()):0;
		var mid=method.$_TID || (method.$_TID=(this._mid++)*100000);
		handler.key=cid+mid;
		this._map[handler.key]=handler;
	}

	/**
	*定时执行一次。
	*@param delay 延迟时间(单位为毫秒)。
	*@param caller 执行域(this)。
	*@param method 定时器回调函数。
	*@param args 回调参数。
	*@param coverBefore 是否覆盖之前的延迟执行，默认为 true 。
	*/
	__proto.once=function(delay,caller,method,args,coverBefore){
		(coverBefore===void 0)&& (coverBefore=true);
		this._create(false,false,delay,caller,method,args,coverBefore);
	}

	/**
	*定时重复执行。
	*@param delay 间隔时间(单位毫秒)。
	*@param caller 执行域(this)。
	*@param method 定时器回调函数。
	*@param args 回调参数。
	*@param coverBefore 是否覆盖之前的延迟执行，默认为 true 。
	*@param jumpFrame 时钟是否跳帧。基于时间的循环回调，单位时间间隔内，如能执行多次回调，出于性能考虑，引擎默认只执行一次，设置jumpFrame=true后，则回调会连续执行多次
	*/
	__proto.loop=function(delay,caller,method,args,coverBefore,jumpFrame){
		(coverBefore===void 0)&& (coverBefore=true);
		(jumpFrame===void 0)&& (jumpFrame=false);
		var handler=this._create(false,true,delay,caller,method,args,coverBefore);
		if (handler)handler.jumpFrame=jumpFrame;
	}

	/**
	*定时执行一次(基于帧率)。
	*@param delay 延迟几帧(单位为帧)。
	*@param caller 执行域(this)。
	*@param method 定时器回调函数。
	*@param args 回调参数。
	*@param coverBefore 是否覆盖之前的延迟执行，默认为 true 。
	*/
	__proto.frameOnce=function(delay,caller,method,args,coverBefore){
		(coverBefore===void 0)&& (coverBefore=true);
		this._create(true,false,delay,caller,method,args,coverBefore);
	}

	/**
	*定时重复执行(基于帧率)。
	*@param delay 间隔几帧(单位为帧)。
	*@param caller 执行域(this)。
	*@param method 定时器回调函数。
	*@param args 回调参数。
	*@param coverBefore 是否覆盖之前的延迟执行，默认为 true 。
	*/
	__proto.frameLoop=function(delay,caller,method,args,coverBefore){
		(coverBefore===void 0)&& (coverBefore=true);
		this._create(true,true,delay,caller,method,args,coverBefore);
	}

	/**返回统计信息。*/
	__proto.toString=function(){
		return "callLater:"+this._laters.length+" handlers:"+this._handlers.length+" pool:"+Timer._pool.length;
	}

	/**
	*清理定时器。
	*@param caller 执行域(this)。
	*@param method 定时器回调函数。
	*/
	__proto.clear=function(caller,method){
		var handler=this._getHandler(caller,method);
		if (handler){
			this._map[handler.key]=null;handler.key=0;
			handler.clear();
		}
	}

	/**
	*清理对象身上的所有定时器。
	*@param caller 执行域(this)。
	*/
	__proto.clearAll=function(caller){
		if (!caller)return;
		for (var i=0,n=this._handlers.length;i < n;i++){
			var handler=this._handlers[i];
			if (handler.caller===caller){
				this._map[handler.key]=null;handler.key=0;
				handler.clear();
			}
		}
	}

	/**@private */
	__proto._getHandler=function(caller,method){
		var cid=caller ? caller.$_GID || (caller.$_GID=Utils.getGID()):0;
		var mid=method.$_TID || (method.$_TID=(this._mid++)*100000);
		return this._map[cid+mid];
	}

	/**
	*延迟执行。
	*@param caller 执行域(this)。
	*@param method 定时器回调函数。
	*@param args 回调参数。
	*/
	__proto.callLater=function(caller,method,args){
		if (this._getHandler(caller,method)==null){
			if (Timer._pool.length)
				var handler=Timer._pool.pop();
			else handler=new TimerHandler();
			handler.caller=caller;
			handler.method=method;
			handler.args=args;
			this._indexHandler(handler);
			this._laters.push(handler);
		}
	}

	/**
	*立即执行 callLater 。
	*@param caller 执行域(this)。
	*@param method 定时器回调函数。
	*/
	__proto.runCallLater=function(caller,method){
		var handler=this._getHandler(caller,method);
		if (handler && handler.method !=null){
			this._map[handler.key]=null;
			handler.run(true);
		}
	}

	/**
	*立即提前执行定时器，执行之后从队列中删除
	*@param caller 执行域(this)。
	*@param method 定时器回调函数。
	*/
	__proto.runTimer=function(caller,method){
		this.runCallLater(caller,method);
	}

	/**
	*两帧之间的时间间隔,单位毫秒。
	*/
	__getset(0,__proto,'delta',function(){
		return this._delta;
	});

	Timer._pool=[];
	Timer.__init$=function(){
		/**@private */
		//class TimerHandler
		TimerHandler=(function(){
			function TimerHandler(){
				this.key=0;
				this.repeat=false;
				this.delay=0;
				this.userFrame=false;
				this.exeTime=0;
				this.caller=null;
				this.method=null;
				this.args=null;
				this.jumpFrame=false;
			}
			__class(TimerHandler,'');
			var __proto=TimerHandler.prototype;
			__proto.clear=function(){
				this.caller=null;
				this.method=null;
				this.args=null;
			}
			__proto.run=function(withClear){
				var caller=this.caller;
				if (caller && caller.destroyed)return this.clear();
				var method=this.method;
				var args=this.args;
				withClear && this.clear();
				if (method==null)return;
				args ? method.apply(caller,args):method.call(caller);
			}
			return TimerHandler;
		})()
	}

	return Timer;
})()


/**
*<code>Tween</code> 是一个缓动类。使用此类能够实现对目标对象属性的渐变。
*/
//class laya.utils.Tween
var Tween=(function(){
	function Tween(){
		/**@private */
		//this._complete=null;
		/**@private */
		//this._target=null;
		/**@private */
		//this._ease=null;
		/**@private */
		//this._props=null;
		/**@private */
		//this._duration=0;
		/**@private */
		//this._delay=0;
		/**@private */
		//this._startTimer=0;
		/**@private */
		//this._usedTimer=0;
		/**@private */
		//this._usedPool=false;
		/**@private */
		//this._delayParam=null;
		/**@private 唯一标识，TimeLintLite用到*/
		this.gid=0;
		/**更新回调，缓动数值发生变化时，回调变化的值*/
		//this.update=null;
	}

	__class(Tween,'laya.utils.Tween');
	var __proto=Tween.prototype;
	/**
	*缓动对象的props属性到目标值。
	*@param target 目标对象(即将更改属性值的对象)。
	*@param props 变化的属性列表，比如{x:100,y:20,ease:Ease.backOut,complete:Handler.create(this,onComplete),update:new Handler(this,onComplete)}。
	*@param duration 花费的时间，单位毫秒。
	*@param ease 缓动类型，默认为匀速运动。
	*@param complete 结束回调函数。
	*@param delay 延迟执行时间。
	*@param coverBefore 是否覆盖之前的缓动。
	*@return 返回Tween对象。
	*/
	__proto.to=function(target,props,duration,ease,complete,delay,coverBefore){
		(delay===void 0)&& (delay=0);
		(coverBefore===void 0)&& (coverBefore=false);
		return this._create(target,props,duration,ease,complete,delay,coverBefore,true,false,true);
	}

	/**
	*从props属性，缓动到当前状态。
	*@param target 目标对象(即将更改属性值的对象)。
	*@param props 变化的属性列表，比如{x:100,y:20,ease:Ease.backOut,complete:Handler.create(this,onComplete),update:new Handler(this,onComplete)}。
	*@param duration 花费的时间，单位毫秒。
	*@param ease 缓动类型，默认为匀速运动。
	*@param complete 结束回调函数。
	*@param delay 延迟执行时间。
	*@param coverBefore 是否覆盖之前的缓动。
	*@return 返回Tween对象。
	*/
	__proto.from=function(target,props,duration,ease,complete,delay,coverBefore){
		(delay===void 0)&& (delay=0);
		(coverBefore===void 0)&& (coverBefore=false);
		return this._create(target,props,duration,ease,complete,delay,coverBefore,false,false,true);
	}

	/**@private */
	__proto._create=function(target,props,duration,ease,complete,delay,coverBefore,isTo,usePool,runNow){
		if (!target)throw new Error("Tween:target is null");
		this._target=target;
		this._duration=duration;
		this._ease=ease || props.ease || Tween.easeNone;
		this._complete=complete || props.complete;
		this._delay=delay;
		this._props=[];
		this._usedTimer=0;
		this._startTimer=Browser.now();
		this._usedPool=usePool;
		this._delayParam=null;
		this.update=props.update;
		var gid=(target.$_GID || (target.$_GID=Utils.getGID()));
		if (!Tween.tweenMap[gid]){
			Tween.tweenMap[gid]=[this];
			}else {
			if (coverBefore)Tween.clearTween(target);
			Tween.tweenMap[gid].push(this);
		}
		if (runNow){
			if (delay <=0)this.firstStart(target,props,isTo);
			else{
				this._delayParam=[target,props,isTo];
				Laya.scaleTimer.once(delay,this,this.firstStart,this._delayParam);
			}
			}else {
			this._initProps(target,props,isTo);
		}
		return this;
	}

	__proto.firstStart=function(target,props,isTo){
		this._delayParam=null;
		if (target.destroyed){
			this.clear();
			return;
		}
		this._initProps(target,props,isTo);
		this._beginLoop();
	}

	__proto._initProps=function(target,props,isTo){
		for (var p in props){
			if ((typeof (target[p])=='number')){
				var start=isTo ? target[p] :props[p];
				var end=isTo ? props[p] :target[p];
				this._props.push([p,start,end-start]);
				if (!isTo)target[p]=start;
			}
		}
	}

	__proto._beginLoop=function(){
		Laya.scaleTimer.frameLoop(1,this,this._doEase);
	}

	/**执行缓动**/
	__proto._doEase=function(){
		this._updateEase(Browser.now());
	}

	/**@private */
	__proto._updateEase=function(time){
		var target=this._target;
		if (!target)return;
		if (target.destroyed)return Tween.clearTween(target);
		var usedTimer=this._usedTimer=time-this._startTimer-this._delay;
		if (usedTimer < 0)return;
		if (usedTimer >=this._duration)return this.complete();
		var ratio=usedTimer > 0 ? this._ease(usedTimer,0,1,this._duration):0;
		var props=this._props;
		for (var i=0,n=props.length;i < n;i++){
			var prop=props[i];
			target[prop[0]]=prop[1]+(ratio *prop[2]);
		}
		if (this.update)this.update.run();
	}

	/**
	*立即结束缓动并到终点。
	*/
	__proto.complete=function(){
		if (!this._target)return;
		Laya.scaleTimer.runTimer(this,this.firstStart);
		var target=this._target;
		var props=this._props;
		var handler=this._complete;
		for (var i=0,n=props.length;i < n;i++){
			var prop=props[i];
			target[prop[0]]=prop[1]+prop[2];
		}
		if (this.update)this.update.run();
		this.clear();
		handler && handler.run();
	}

	/**
	*暂停缓动，可以通过resume或restart重新开始。
	*/
	__proto.pause=function(){
		Laya.scaleTimer.clear(this,this._beginLoop);
		Laya.scaleTimer.clear(this,this._doEase);
		Laya.scaleTimer.clear(this,this.firstStart);
		var time=Browser.now();
		var dTime=NaN;
		dTime=time-this._startTimer-this._delay;
		if (dTime < 0){
			this._usedTimer=dTime;
		}
	}

	/**
	*设置开始时间。
	*@param startTime 开始时间。
	*/
	__proto.setStartTime=function(startTime){
		this._startTimer=startTime;
	}

	/**
	*停止并清理当前缓动。
	*/
	__proto.clear=function(){
		if (this._target){
			this._remove();
			this._clear();
		}
	}

	/**
	*@private
	*/
	__proto._clear=function(){
		this.pause();
		Laya.scaleTimer.clear(this,this.firstStart);
		this._complete=null;
		this._target=null;
		this._ease=null;
		this._props=null;
		this._delayParam=null;
		if (this._usedPool){
			this.update=null;
			Pool.recover("tween",this);
		}
	}

	/**回收到对象池。*/
	__proto.recover=function(){
		this._usedPool=true;
		this._clear();
	}

	__proto._remove=function(){
		var tweens=Tween.tweenMap[this._target.$_GID];
		if (tweens){
			for (var i=0,n=tweens.length;i < n;i++){
				if (tweens[i]===this){
					tweens.splice(i,1);
					break ;
				}
			}
		}
	}

	/**
	*重新开始暂停的缓动。
	*/
	__proto.restart=function(){
		this.pause();
		this._usedTimer=0;
		this._startTimer=Browser.now();
		if (this._delayParam){
			Laya.scaleTimer.once(this._delay,this,this.firstStart,this._delayParam);
			return;
		};
		var props=this._props;
		for (var i=0,n=props.length;i < n;i++){
			var prop=props[i];
			this._target[prop[0]]=prop[1];
		}
		Laya.scaleTimer.once(this._delay,this,this._beginLoop);
	}

	/**
	*恢复暂停的缓动。
	*/
	__proto.resume=function(){
		if (this._usedTimer >=this._duration)return;
		this._startTimer=Browser.now()-this._usedTimer-this._delay;
		if (this._delayParam){
			if (this._usedTimer < 0){
				Laya.scaleTimer.once(-this._usedTimer,this,this.firstStart,this._delayParam);
				}else{
				this.firstStart.apply(this,this._delayParam);
			}
			}else{
			this._beginLoop();
		}
	}

	/**设置当前执行比例**/
	__getset(0,__proto,'progress',null,function(v){
		var uTime=v *this._duration;
		this._startTimer=Browser.now()-this._delay-uTime;
	});

	Tween.to=function(target,props,duration,ease,complete,delay,coverBefore,autoRecover){
		(delay===void 0)&& (delay=0);
		(coverBefore===void 0)&& (coverBefore=false);
		(autoRecover===void 0)&& (autoRecover=true);
		return Pool.getItemByClass("tween",Tween)._create(target,props,duration,ease,complete,delay,coverBefore,true,autoRecover,true);
	}

	Tween.from=function(target,props,duration,ease,complete,delay,coverBefore,autoRecover){
		(delay===void 0)&& (delay=0);
		(coverBefore===void 0)&& (coverBefore=false);
		(autoRecover===void 0)&& (autoRecover=true);
		return Pool.getItemByClass("tween",Tween)._create(target,props,duration,ease,complete,delay,coverBefore,false,autoRecover,true);
	}

	Tween.clearAll=function(target){
		if (!target || !target.$_GID)return;
		var tweens=Tween.tweenMap[target.$_GID];
		if (tweens){
			for (var i=0,n=tweens.length;i < n;i++){
				tweens[i]._clear();
			}
			tweens.length=0;
		}
	}

	Tween.clear=function(tween){
		tween.clear();
	}

	Tween.clearTween=function(target){
		Tween.clearAll(target);
	}

	Tween.easeNone=function(t,b,c,d){
		return c *t / d+b;
	}

	Tween.tweenMap={};
	return Tween;
})()


/**
*<code>Utils</code> 是工具类。
*/
//class laya.utils.Utils
var Utils=(function(){
	function Utils(){}
	__class(Utils,'laya.utils.Utils');
	Utils.toRadian=function(angle){
		return angle *Utils._pi2;
	}

	Utils.toAngle=function(radian){
		return radian *Utils._pi;
	}

	Utils.toHexColor=function(color){
		if (color < 0 || isNaN(color))return null;
		var str=color.toString(16);
		while (str.length < 6)str="0"+str;
		return "#"+str;
	}

	Utils.getGID=function(){
		return Utils._gid++;
	}

	Utils.concatArray=function(source,array){
		if (!array)return source;
		if (!source)return array;
		var i=0,len=array.length;
		for (i=0;i < len;i++){
			source.push(array[i]);
		}
		return source;
	}

	Utils.clearArray=function(array){
		if (!array)return array;
		array.length=0;
		return array;
	}

	Utils.copyArray=function(source,array){
		source || (source=[]);
		if (!array)return source;
		source.length=array.length;
		var i=0,len=array.length;
		for (i=0;i < len;i++){
			source[i]=array[i];
		}
		return source;
	}

	Utils.getGlobalRecByPoints=function(sprite,x0,y0,x1,y1){
		var newLTPoint;
		newLTPoint=new Point(x0,y0);
		newLTPoint=sprite.localToGlobal(newLTPoint);
		var newRBPoint;
		newRBPoint=new Point(x1,y1);
		newRBPoint=sprite.localToGlobal(newRBPoint);
		return Rectangle._getWrapRec([newLTPoint.x,newLTPoint.y,newRBPoint.x,newRBPoint.y]);
	}

	Utils.getGlobalPosAndScale=function(sprite){
		return Utils.getGlobalRecByPoints(sprite,0,0,1,1);
	}

	Utils.bind=function(fun,scope){
		var rst=fun;
		/*__JS__ */rst=fun.bind(scope);;
		return rst;
	}

	Utils.measureText=function(txt,font){
		return RunDriver.measureText(txt,font);
	}

	Utils.updateOrder=function(array){
		if (!array || array.length < 2)return false;
		var i=1,j=0,len=array.length,key=NaN,c;
		while (i < len){
			j=i;
			c=array[j];
			key=array[j]._zOrder;
			while (--j >-1){
				if (array[j]._zOrder > key)array[j+1]=array[j];
				else break ;
			}
			array[j+1]=c;
			i++;
		};
		var model=c.parent.conchModel;
		if (model){
			if (model.updateZOrder !=null){
				model.updateZOrder();
				}else {
				for (i=0;i < len;i++){
					model.removeChild(array[i].conchModel);
				}
				for (i=0;i < len;i++){
					model.addChildAt(array[i].conchModel,i);
				}
			}
		}
		return true;
	}

	Utils.transPointList=function(points,x,y){
		var i=0,len=points.length;
		for (i=0;i < len;i+=2){
			points[i]+=x;
			points[i+1]+=y;
		}
	}

	Utils.parseInt=function(str,radix){
		(radix===void 0)&& (radix=0);
		var result=Browser.window.parseInt(str,radix);
		if (isNaN(result))return 0;
		return result;
	}

	Utils.getFileExtension=function(path){
		Utils._extReg.lastIndex=path.lastIndexOf(".");
		var result=Utils._extReg.exec(path);
		if (result && result.length > 1){
			return result[1].toLowerCase();
		}
		return null;
	}

	Utils.getTransformRelativeToWindow=function(coordinateSpace,x,y){
		var stage=Laya.stage;
		var globalTransform=laya.utils.Utils.getGlobalPosAndScale(coordinateSpace);
		var canvasMatrix=stage._canvasTransform.clone();
		var canvasLeft=canvasMatrix.tx;
		var canvasTop=canvasMatrix.ty;
		canvasMatrix.rotate(-Math.PI / 180 *Laya.stage.canvasDegree);
		canvasMatrix.scale(Laya.stage.clientScaleX,Laya.stage.clientScaleY);
		var perpendicular=(Laya.stage.canvasDegree % 180 !=0);
		var tx=NaN,ty=NaN;
		if (perpendicular){
			tx=y+globalTransform.y;
			ty=x+globalTransform.x;
			tx *=canvasMatrix.d;
			ty *=canvasMatrix.a;
			if (Laya.stage.canvasDegree==90){
				tx=canvasLeft-tx;
				ty+=canvasTop;
			}
			else {
				tx+=canvasLeft;
				ty=canvasTop-ty;
			}
		}
		else {
			tx=x+globalTransform.x;
			ty=y+globalTransform.y;
			tx *=canvasMatrix.a;
			ty *=canvasMatrix.d;
			tx+=canvasLeft;
			ty+=canvasTop;
		};
		var domScaleX=NaN,domScaleY=NaN;
		if (perpendicular){
			domScaleX=canvasMatrix.d *globalTransform.height;
			domScaleY=canvasMatrix.a *globalTransform.width;
			}else {
			domScaleX=canvasMatrix.a *globalTransform.width;
			domScaleY=canvasMatrix.d *globalTransform.height;
		}
		return {x:tx,y:ty,scaleX:domScaleX,scaleY:domScaleY};
	}

	Utils.fitDOMElementInArea=function(dom,coordinateSpace,x,y,width,height){
		if (!dom._fitLayaAirInitialized){
			dom._fitLayaAirInitialized=true;
			dom.style.transformOrigin=dom.style.webKittransformOrigin="left top";
			dom.style.position="absolute"
		};
		var transform=Utils.getTransformRelativeToWindow(coordinateSpace,x,y);
		dom.style.transform=dom.style.webkitTransform="scale("+transform.scaleX+","+transform.scaleY+") rotate("+(Laya.stage.canvasDegree)+"deg)";
		dom.style.width=width+'px';
		dom.style.height=height+'px';
		dom.style.left=transform.x+'px';
		dom.style.top=transform.y+'px';
	}

	Utils.isOkTextureList=function(textureList){
		if (!textureList)return false;
		var i=0,len=textureList.length;
		var tTexture;
		for (i=0;i < len;i++){
			tTexture=textureList[i];
			if (!tTexture||!tTexture.source)return false;
		}
		return true;
	}

	Utils.isOKCmdList=function(cmds){
		if (!cmds)return false;
		var i=0,len=cmds.length;
		var context=Render._context;
		var cmd;
		var tex;
		for (i=0;i < len;i++){
			cmd=cmds[i];
			switch(cmd.callee){
				case context._drawTexture:
				case context._fillTexture:
				case context._drawTextureWithTransform:
					tex=cmd[0];
					if (!tex || !tex.source)return false;
				}
		}
		return true;
	}

	Utils._gid=1;
	Utils._pi=180 / Math.PI;
	Utils._pi2=Math.PI / 180;
	Utils._extReg=/\.(\w+)\??/g;
	Utils.parseXMLFromString=function(value){
		var rst;
		value=value.replace(/>\s+</g,'><');
		/*__JS__ */rst=(new DOMParser()).parseFromString(value,'text/xml');
		if (rst.firstChild.textContent.indexOf("This page contains the following errors")>-1){
			throw new Error(rst.firstChild.firstChild.textContent);
		}
		return rst;
	}

	return Utils;
})()


/**
*@private
*/
//class laya.utils.VectorGraphManager
var VectorGraphManager=(function(){
	function VectorGraphManager(){
		this.useDic={};
		this.shapeDic={};
		this.shapeLineDic={};
		this._id=0;
		this._checkKey=false;
		this._freeIdArray=[];
		if (Render.isWebGL){
			CacheManager.regCacheByFunction(Utils.bind(this.startDispose,this),Utils.bind(this.getCacheList,this));
		}
	}

	__class(VectorGraphManager,'laya.utils.VectorGraphManager');
	var __proto=VectorGraphManager.prototype;
	/**
	*得到个空闲的ID
	*@return
	*/
	__proto.getId=function(){
		return this._id++;
	}

	/**
	*添加一个图形到列表中
	*@param id
	*@param shape
	*/
	__proto.addShape=function(id,shape){
		this.shapeDic[id]=shape;
		if (!this.useDic[id]){
			this.useDic[id]=true;
		}
	}

	/**
	*添加一个线图形到列表中
	*@param id
	*@param Line
	*/
	__proto.addLine=function(id,Line){
		this.shapeLineDic[id]=Line;
		if (!this.shapeLineDic[id]){
			this.shapeLineDic[id]=true;
		}
	}

	/**
	*检测一个对象是否在使用中
	*@param id
	*/
	__proto.getShape=function(id){
		if (this._checkKey){
			if (this.useDic[id] !=null){
				this.useDic[id]=true;
			}
		}
	}

	/**
	*删除一个图形对象
	*@param id
	*/
	__proto.deleteShape=function(id){
		if (this.shapeDic[id]){
			this.shapeDic[id]=null;
			delete this.shapeDic[id];
		}
		if (this.shapeLineDic[id]){
			this.shapeLineDic[id]=null;
			delete this.shapeLineDic[id];
		}
		if (this.useDic[id] !=null){
			delete this.useDic[id];
		}
	}

	/**
	*得到缓存列表
	*@return
	*/
	__proto.getCacheList=function(){
		var str;
		var list=[];
		for (str in this.shapeDic){
			list.push(this.shapeDic[str]);
		}
		for (str in this.shapeLineDic){
			list.push(this.shapeLineDic[str]);
		}
		return list;
	}

	/**
	*开始清理状态，准备销毁
	*/
	__proto.startDispose=function(key){
		var str;
		for (str in this.useDic){
			this.useDic[str]=false;
		}
		this._checkKey=true;
	}

	/**
	*确认销毁
	*/
	__proto.endDispose=function(){
		if (this._checkKey){
			var str;
			for (str in this.useDic){
				if (!this.useDic[str]){
					this.deleteShape(str);
				}
			}
			this._checkKey=false;
		}
	}

	VectorGraphManager.getInstance=function(){
		return VectorGraphManager.instance=VectorGraphManager.instance|| new VectorGraphManager();
	}

	VectorGraphManager.instance=null;
	return VectorGraphManager;
})()


/**
*封装弱引用WeakMap
*如果支持WeakMap，则使用WeakMap，如果不支持，则用Object代替
*注意：如果采用Object，为了防止内存泄漏，则采用定时清理缓存策略
*/
//class laya.utils.WeakObject
var WeakObject=(function(){
	function WeakObject(){
		/**@private */
		this._obj=null;
		this._obj=WeakObject.supportWeakMap ? new Browser.window.WeakMap():{};
		if (!WeakObject.supportWeakMap)WeakObject._maps.push(this);
	}

	__class(WeakObject,'laya.utils.WeakObject');
	var __proto=WeakObject.prototype;
	/**
	*设置缓存
	*@param key kye对象，可被回收
	*@param value object对象，可被回收
	*/
	__proto.set=function(key,value){
		if (key==null)return;
		if (WeakObject.supportWeakMap){
			var objKey=key;
			if ((typeof key=='string')|| (typeof key=='number')){
				objKey=WeakObject._keys[key];
				if (!objKey)objKey=WeakObject._keys[key]={k:key};
			}
			this._obj.set(objKey,value);
			}else {
			if ((typeof key=='string')|| (typeof key=='number')){
				this._obj[key]=value;
				}else {
				key.$_GID || (key.$_GID=Utils.getGID());
				this._obj[key.$_GID]=value;
			}
		}
	}

	/**
	*获取缓存
	*@param key kye对象，可被回收
	*/
	__proto.get=function(key){
		if (key==null)return null;
		if (WeakObject.supportWeakMap){
			var objKey=((typeof key=='string')|| (typeof key=='number'))? WeakObject._keys[key] :key;
			if (!objKey)return null;
			return this._obj.get(objKey);
			}else {
			if ((typeof key=='string')|| (typeof key=='number'))return this._obj[key];
			return this._obj[key.$_GID];
		}
	}

	/**
	*删除缓存
	*/
	__proto.del=function(key){
		if (key==null)return;
		if (WeakObject.supportWeakMap){
			var objKey=((typeof key=='string')|| (typeof key=='number'))? WeakObject._keys[key] :key;
			if (!objKey)return;
			/*__JS__ */this._obj.delete(objKey);
			}else {
			if ((typeof key=='string')|| (typeof key=='number'))delete this._obj[key];
			else delete this._obj[this._obj.$_GID];
		}
	}

	/**
	*是否有缓存
	*/
	__proto.has=function(key){
		if (key==null)return false;
		if (WeakObject.supportWeakMap){
			var objKey=((typeof key=='string')|| (typeof key=='number'))? WeakObject._keys[key] :key;
			return this._obj.has(objKey);
			}else {
			if ((typeof key=='string')|| (typeof key=='number'))return this._obj[key] !=null;
			return this._obj[this._obj.$_GID] !=null;
		}
	}

	WeakObject.__init__=function(){
		WeakObject.supportWeakMap=Browser.window.WeakMap !=null;
		if (!WeakObject.supportWeakMap)Laya.timer.loop(WeakObject.delInterval,null,WeakObject.clearCache);
	}

	WeakObject.clearCache=function(){
		for (var i=0,n=WeakObject._maps.length;i < n;i++){
			var obj=WeakObject._maps[i];
			obj._obj={};
		}
	}

	WeakObject.supportWeakMap=false;
	WeakObject.delInterval=5 *60 *1000;
	WeakObject._keys={};
	WeakObject._maps=[];
	__static(WeakObject,
	['I',function(){return this.I=new WeakObject();}
	]);
	return WeakObject;
})()


/**
*@private
*/
//class laya.utils.WordText
var WordText=(function(){
	function WordText(){
		this.id=NaN;
		this.save=[];
		this.toUpperCase=null;
		this.changed=false;
		this._text=null;
	}

	__class(WordText,'laya.utils.WordText');
	var __proto=WordText.prototype;
	__proto.setText=function(txt){
		this.changed=true;
		this._text=txt;
	}

	__proto.toString=function(){
		return this._text;
	}

	__proto.charCodeAt=function(i){
		return this._text ? this._text.charCodeAt(i):NaN;
	}

	__proto.charAt=function(i){
		return this._text ? this._text.charAt(i):null;
	}

	__getset(0,__proto,'length',function(){
		return this._text ? this._text.length :0;
	});

	return WordText;
})()


/**
*<code>Node</code> 类是可放在显示列表中的所有对象的基类。该显示列表管理 Laya 运行时中显示的所有对象。使用 Node 类排列显示列表中的显示对象。Node 对象可以有子显示对象。
*/
//class laya.display.Node extends laya.events.EventDispatcher
var Node=(function(_super){
	function Node(){
		/**@private */
		this._bits=0;
		/**@private 是否在显示列表中显示*/
		this._displayedInStage=false;
		/**@private 父节点对象*/
		this._parent=null;
		/**@private */
		this.conchModel=null;
		/**节点名称。*/
		this.name="";
		/**[只读]是否已经销毁。对象销毁后不能再使用。*/
		this._destroyed=false;
		Node.__super.call(this);
		this._childs=Node.ARRAY_EMPTY;
		this._$P=Node.PROP_EMPTY;
		this.timer=Laya.scaleTimer;
		this.conchModel=Render.isConchNode ? this.createConchModel():null;
	}

	__class(Node,'laya.display.Node',_super);
	var __proto=Node.prototype;
	/**@private */
	__proto._setBit=function(type,value){
		if (type==0x1){
			var preValue=this._getBit(type);
			if (preValue !=value){
				this._updateDisplayedInstage();
			}
		}
		if (value){
			this._bits |=type;
			}else {
			this._bits &=~type;
		}
	}

	/**@private */
	__proto._getBit=function(type){
		return (this._bits & type)!=0;
	}

	/**@private */
	__proto._setUpNoticeChain=function(){
		if (this._getBit(0x1)){
			this._setUpNoticeType(0x1);
		}
	}

	/**@private */
	__proto._setUpNoticeType=function(type){
		var ele=this;
		ele._setBit(type,true);
		ele=ele.parent;
		while (ele){
			if (ele._getBit(type))return;
			ele._setBit(type,true);
			ele=ele.parent;
		}
	}

	/**
	*<p>增加事件侦听器，以使侦听器能够接收事件通知。</p>
	*<p>如果侦听鼠标事件，则会自动设置自己和父亲节点的属性 mouseEnabled 的值为 true(如果父节点mouseEnabled=false，则停止设置父节点mouseEnabled属性)。</p>
	*@param type 事件的类型。
	*@param caller 事件侦听函数的执行域。
	*@param listener 事件侦听函数。
	*@param args （可选）事件侦听函数的回调参数。
	*@return 此 EventDispatcher 对象。
	*/
	__proto.on=function(type,caller,listener,args){
		if (type===/*laya.events.Event.DISPLAY*/"display" || type===/*laya.events.Event.UNDISPLAY*/"undisplay"){
			if (!this._getBit(0x1)){
				this._setUpNoticeType(0x1);
			}
		}
		return this._createListener(type,caller,listener,args,false);
	}

	/**
	*<p>增加事件侦听器，以使侦听器能够接收事件通知，此侦听事件响应一次后则自动移除侦听。</p>
	*<p>如果侦听鼠标事件，则会自动设置自己和父亲节点的属性 mouseEnabled 的值为 true(如果父节点mouseEnabled=false，则停止设置父节点mouseEnabled属性)。</p>
	*@param type 事件的类型。
	*@param caller 事件侦听函数的执行域。
	*@param listener 事件侦听函数。
	*@param args （可选）事件侦听函数的回调参数。
	*@return 此 EventDispatcher 对象。
	*/
	__proto.once=function(type,caller,listener,args){
		if (type===/*laya.events.Event.DISPLAY*/"display" || type===/*laya.events.Event.UNDISPLAY*/"undisplay"){
			if (!this._getBit(0x1)){
				this._setUpNoticeType(0x1);
			}
		}
		return this._createListener(type,caller,listener,args,true);
	}

	/**@private */
	__proto.createConchModel=function(){
		return null;
	}

	/**
	*<p>销毁此对象。destroy对象默认会把自己从父节点移除，并且清理自身引用关系，等待js自动垃圾回收机制回收。destroy后不能再使用。</p>
	*<p>destroy时会移除自身的事情监听，自身的timer监听，移除子对象及从父节点移除自己。</p>
	*@param destroyChild （可选）是否同时销毁子节点，若值为true,则销毁子节点，否则不销毁子节点。
	*/
	__proto.destroy=function(destroyChild){
		(destroyChild===void 0)&& (destroyChild=true);
		this._destroyed=true;
		this._parent && this._parent.removeChild(this);
		if (this._childs){
			if (destroyChild)this.destroyChildren();
			else this.removeChildren();
		}
		this._childs=null;
		this._$P=null;
		this.offAll();
		this.timer.clearAll(this);
	}

	/**
	*销毁所有子对象，不销毁自己本身。
	*/
	__proto.destroyChildren=function(){
		if (this._childs){
			for (var i=this._childs.length-1;i >-1;i--){
				this._childs[i].destroy(true);
			}
		}
	}

	/**
	*添加子节点。
	*@param node 节点对象
	*@return 返回添加的节点
	*/
	__proto.addChild=function(node){
		if (!node || this.destroyed || node===this)return node;
		if ((node).zOrder)this._set$P("hasZorder",true);
		if (node._parent===this){
			var index=this.getChildIndex(node);
			if (index!==this._childs.length-1){
				this._childs.splice(index,1);
				this._childs.push(node);
				if (this.conchModel){
					this.conchModel.removeChild(node.conchModel);
					this.conchModel.addChildAt(node.conchModel,this._childs.length-1);
				}
				this._childChanged();
			}
			}else {
			node.parent && node.parent.removeChild(node);
			this._childs===Node.ARRAY_EMPTY && (this._childs=[]);
			this._childs.push(node);
			this.conchModel && this.conchModel.addChildAt(node.conchModel,this._childs.length-1);
			node.parent=this;
			this._childChanged();
		}
		return node;
	}

	/**
	*批量增加子节点
	*@param ...args 无数子节点。
	*/
	__proto.addChildren=function(__args){
		var args=arguments;
		var i=0,n=args.length;
		while (i < n){
			this.addChild(args[i++]);
		}
	}

	/**
	*添加子节点到指定的索引位置。
	*@param node 节点对象。
	*@param index 索引位置。
	*@return 返回添加的节点。
	*/
	__proto.addChildAt=function(node,index){
		if (!node || this.destroyed || node===this)return node;
		if ((node).zOrder)this._set$P("hasZorder",true);
		if (index >=0 && index <=this._childs.length){
			if (node._parent===this){
				var oldIndex=this.getChildIndex(node);
				this._childs.splice(oldIndex,1);
				this._childs.splice(index,0,node);
				if (this.conchModel){
					this.conchModel.removeChild(node.conchModel);
					this.conchModel.addChildAt(node.conchModel,index);
				}
				this._childChanged();
				}else {
				node.parent && node.parent.removeChild(node);
				this._childs===Node.ARRAY_EMPTY && (this._childs=[]);
				this._childs.splice(index,0,node);
				this.conchModel && this.conchModel.addChildAt(node.conchModel,index);
				node.parent=this;
			}
			return node;
			}else {
			throw new Error("appendChildAt:The index is out of bounds");
		}
	}

	/**
	*根据子节点对象，获取子节点的索引位置。
	*@param node 子节点。
	*@return 子节点所在的索引位置。
	*/
	__proto.getChildIndex=function(node){
		return this._childs.indexOf(node);
	}

	/**
	*根据子节点的名字，获取子节点对象。
	*@param name 子节点的名字。
	*@return 节点对象。
	*/
	__proto.getChildByName=function(name){
		var nodes=this._childs;
		if (nodes){
			for (var i=0,n=nodes.length;i < n;i++){
				var node=nodes[i];
				if (node.name===name)return node;
			}
		}
		return null;
	}

	/**@private */
	__proto._get$P=function(key){
		return this._$P[key];
	}

	/**@private */
	__proto._set$P=function(key,value){
		if (!this.destroyed){
			this._$P===Node.PROP_EMPTY && (this._$P={});
			this._$P[key]=value;
		}
		return value;
	}

	/**
	*根据子节点的索引位置，获取子节点对象。
	*@param index 索引位置
	*@return 子节点
	*/
	__proto.getChildAt=function(index){
		return this._childs[index];
	}

	/**
	*设置子节点的索引位置。
	*@param node 子节点。
	*@param index 新的索引。
	*@return 返回子节点本身。
	*/
	__proto.setChildIndex=function(node,index){
		var childs=this._childs;
		if (index < 0 || index >=childs.length){
			throw new Error("setChildIndex:The index is out of bounds.");
		};
		var oldIndex=this.getChildIndex(node);
		if (oldIndex < 0)throw new Error("setChildIndex:node is must child of this object.");
		childs.splice(oldIndex,1);
		childs.splice(index,0,node);
		if (this.conchModel){
			this.conchModel.removeChild(node.conchModel);
			this.conchModel.addChildAt(node.conchModel,index);
		}
		this._childChanged();
		return node;
	}

	/**
	*@private
	*子节点发生改变。
	*@param child 子节点。
	*/
	__proto._childChanged=function(child){}
	/**
	*删除子节点。
	*@param node 子节点
	*@return 被删除的节点
	*/
	__proto.removeChild=function(node){
		if (!this._childs)return node;
		var index=this._childs.indexOf(node);
		return this.removeChildAt(index);
	}

	/**
	*从父容器删除自己，如已经被删除不会抛出异常。
	*@return 当前节点（ Node ）对象。
	*/
	__proto.removeSelf=function(){
		this._parent && this._parent.removeChild(this);
		return this;
	}

	/**
	*根据子节点名字删除对应的子节点对象，如果找不到不会抛出异常。
	*@param name 对象名字。
	*@return 查找到的节点（ Node ）对象。
	*/
	__proto.removeChildByName=function(name){
		var node=this.getChildByName(name);
		node && this.removeChild(node);
		return node;
	}

	/**
	*根据子节点索引位置，删除对应的子节点对象。
	*@param index 节点索引位置。
	*@return 被删除的节点。
	*/
	__proto.removeChildAt=function(index){
		var node=this.getChildAt(index);
		if (node){
			this._childs.splice(index,1);
			this.conchModel && this.conchModel.removeChild(node.conchModel);
			node.parent=null;
		}
		return node;
	}

	/**
	*删除指定索引区间的所有子对象。
	*@param beginIndex 开始索引。
	*@param endIndex 结束索引。
	*@return 当前节点对象。
	*/
	__proto.removeChildren=function(beginIndex,endIndex){
		(beginIndex===void 0)&& (beginIndex=0);
		(endIndex===void 0)&& (endIndex=0x7fffffff);
		if (this._childs && this._childs.length > 0){
			var childs=this._childs;
			if (beginIndex===0 && endIndex >=n){
				var arr=childs;
				this._childs=Node.ARRAY_EMPTY;
				}else {
				arr=childs.splice(beginIndex,endIndex-beginIndex);
			}
			for (var i=0,n=arr.length;i < n;i++){
				arr[i].parent=null;
				this.conchModel && this.conchModel.removeChild(arr[i].conchModel);
			}
		}
		return this;
	}

	/**
	*替换子节点。
	*@internal 将传入的新节点对象替换到已有子节点索引位置处。
	*@param newNode 新节点。
	*@param oldNode 老节点。
	*@return 返回新节点。
	*/
	__proto.replaceChild=function(newNode,oldNode){
		var index=this._childs.indexOf(oldNode);
		if (index >-1){
			this._childs.splice(index,1,newNode);
			if (this.conchModel){
				this.conchModel.removeChild(oldNode.conchModel);
				this.conchModel.addChildAt(newNode.conchModel,index);
			}
			oldNode.parent=null;
			newNode.parent=this;
			return newNode;
		}
		return null;
	}

	/**@private */
	__proto._updateDisplayedInstage=function(){
		var ele;
		ele=this;
		var stage=Laya.stage;
		this._displayedInStage=false;
		while (ele){
			if (ele._getBit(0x1)){
				this._displayedInStage=ele._displayedInStage;
				break ;
			}
			if (ele==stage || ele._displayedInStage){
				this._displayedInStage=true;
				break ;
			}
			ele=ele.parent;
		}
	}

	/**@private */
	__proto._setDisplay=function(value){
		if (this._displayedInStage!==value){
			this._displayedInStage=value;
			if (value)this.event(/*laya.events.Event.DISPLAY*/"display");
			else this.event(/*laya.events.Event.UNDISPLAY*/"undisplay");
		}
	}

	/**
	*@private
	*设置指定节点对象是否可见(是否在渲染列表中)。
	*@param node 节点。
	*@param display 是否可见。
	*/
	__proto._displayChild=function(node,display){
		var childs=node._childs;
		if (childs){
			for (var i=0,n=childs.length;i < n;i++){
				var child=childs[i];
				if (!child._getBit(0x1))continue ;
				if (child._childs.length > 0){
					this._displayChild(child,display);
					}else {
					child._setDisplay(display);
				}
			}
		}
		node._setDisplay(display);
	}

	/**
	*当前容器是否包含指定的 <code>Node</code> 节点对象 。
	*@param node 指定的 <code>Node</code> 节点对象 。
	*@return 一个布尔值表示是否包含指定的 <code>Node</code> 节点对象 。
	*/
	__proto.contains=function(node){
		if (node===this)return true;
		while (node){
			if (node.parent===this)return true;
			node=node.parent;
		}
		return false;
	}

	/**
	*定时重复执行某函数。功能同Laya.timer.timerLoop()。
	*@param delay 间隔时间(单位毫秒)。
	*@param caller 执行域(this)。
	*@param method 结束时的回调方法。
	*@param args （可选）回调参数。
	*@param coverBefore （可选）是否覆盖之前的延迟执行，默认为true。
	*@param jumpFrame 时钟是否跳帧。基于时间的循环回调，单位时间间隔内，如能执行多次回调，出于性能考虑，引擎默认只执行一次，设置jumpFrame=true后，则回调会连续执行多次
	*/
	__proto.timerLoop=function(delay,caller,method,args,coverBefore,jumpFrame){
		(coverBefore===void 0)&& (coverBefore=true);
		(jumpFrame===void 0)&& (jumpFrame=false);
		this.timer.loop(delay,caller,method,args,coverBefore,jumpFrame);
	}

	/**
	*定时执行某函数一次。功能同Laya.timer.timerOnce()。
	*@param delay 延迟时间(单位毫秒)。
	*@param caller 执行域(this)。
	*@param method 结束时的回调方法。
	*@param args （可选）回调参数。
	*@param coverBefore （可选）是否覆盖之前的延迟执行，默认为true。
	*/
	__proto.timerOnce=function(delay,caller,method,args,coverBefore){
		(coverBefore===void 0)&& (coverBefore=true);
		this.timer._create(false,false,delay,caller,method,args,coverBefore);
	}

	/**
	*定时重复执行某函数(基于帧率)。功能同Laya.timer.frameLoop()。
	*@param delay 间隔几帧(单位为帧)。
	*@param caller 执行域(this)。
	*@param method 结束时的回调方法。
	*@param args （可选）回调参数。
	*@param coverBefore （可选）是否覆盖之前的延迟执行，默认为true。
	*/
	__proto.frameLoop=function(delay,caller,method,args,coverBefore){
		(coverBefore===void 0)&& (coverBefore=true);
		this.timer._create(true,true,delay,caller,method,args,coverBefore);
	}

	/**
	*定时执行一次某函数(基于帧率)。功能同Laya.timer.frameOnce()。
	*@param delay 延迟几帧(单位为帧)。
	*@param caller 执行域(this)
	*@param method 结束时的回调方法
	*@param args （可选）回调参数
	*@param coverBefore （可选）是否覆盖之前的延迟执行，默认为true
	*/
	__proto.frameOnce=function(delay,caller,method,args,coverBefore){
		(coverBefore===void 0)&& (coverBefore=true);
		this.timer._create(true,false,delay,caller,method,args,coverBefore);
	}

	/**
	*清理定时器。功能同Laya.timer.clearTimer()。
	*@param caller 执行域(this)。
	*@param method 结束时的回调方法。
	*/
	__proto.clearTimer=function(caller,method){
		this.timer.clear(caller,method);
	}

	/**
	*子对象数量。
	*/
	__getset(0,__proto,'numChildren',function(){
		return this._childs.length;
	});

	/**
	*[只读]是否已经销毁。对象销毁后不能再使用。
	*@return
	*/
	__getset(0,__proto,'destroyed',function(){
		return this._destroyed;
	});

	/**父节点。*/
	__getset(0,__proto,'parent',function(){
		return this._parent;
		},function(value){
		if (this._parent!==value){
			if (value){
				this._parent=value;
				this.event(/*laya.events.Event.ADDED*/"added");
				if (this._getBit(0x1)){
					this._setUpNoticeChain();
					value.displayedInStage && this._displayChild(this,true);
				}
				value._childChanged(this);
				}else {
				this.event(/*laya.events.Event.REMOVED*/"removed");
				this._parent._childChanged();
				if (this._getBit(0x1))this._displayChild(this,false);
				this._parent=value;
			}
		}
	});

	/**表示是否在显示列表中显示。*/
	__getset(0,__proto,'displayedInStage',function(){
		if (this._getBit(0x1))return this._displayedInStage;
		this._setUpNoticeType(0x1);
		return this._displayedInStage;
	});

	Node.ARRAY_EMPTY=[];
	Node.PROP_EMPTY={};
	Node.NOTICE_DISPLAY=0x1;
	Node.MOUSEENABLE=0x2;
	return Node;
})(EventDispatcher)


/**
*@private
*<code>CSSStyle</code> 类是元素CSS样式定义类。
*/
//class laya.display.css.CSSStyle extends laya.display.css.Style
var CSSStyle=(function(_super){
	function CSSStyle(ower){
		this._bgground=null;
		this._border=null;
		//this._ower=null;
		this._rect=null;
		/**@private */
		this.underLine=0;
		/**行高。 */
		this.lineHeight=0;
		CSSStyle.__super.call(this);
		this._padding=CSSStyle._PADDING;
		this._spacing=CSSStyle._SPACING;
		this._aligns=CSSStyle._ALIGNS;
		this._font=Font.EMPTY;
		this._ower=ower;
	}

	__class(CSSStyle,'laya.display.css.CSSStyle',_super);
	var __proto=CSSStyle.prototype;
	/**@inheritDoc */
	__proto.destroy=function(){
		this._ower=null;
		this._font=null;
		this._rect=null;
	}

	/**
	*复制传入的 CSSStyle 属性值。
	*@param src 待复制的 CSSStyle 对象。
	*/
	__proto.inherit=function(src){
		this._font=src._font;
		this._spacing=src._spacing===CSSStyle._SPACING ? CSSStyle._SPACING :src._spacing.slice();
		this.lineHeight=src.lineHeight;
	}

	/**@private */
	__proto._widthAuto=function(){
		return (this._type & 0x40000)!==0;
	}

	/**@inheritDoc */
	__proto.widthed=function(sprite){
		return (this._type & 0x8)!=0;
	}

	/**
	*@private
	*/
	__proto._calculation=function(type,value){
		if (value.indexOf('%')< 0)return false;
		var ower=this._ower;
		var parent=ower.parent;
		var rect=this._rect;
		function getValue (pw,w,nums){
			return (pw *nums[0]+w *nums[1]+nums[2]);
		}
		function onParentResize (type){
			var pw=parent.width,w=ower.width;
			rect.width && (ower.width=getValue(pw,w,rect.width));
			rect.height && (ower.height=getValue(pw,w,rect.height));
			rect.left && (ower.x=getValue(pw,w,rect.left));
			rect.top && (ower.y=getValue(pw,w,rect.top));
		}
		if (rect===null){
			parent._getCSSStyle()._type |=0x80000;
			parent.on(/*laya.events.Event.RESIZE*/"resize",this,onParentResize);
			this._rect=rect={input:{}};
		};
		var nums=value.split(' ');
		nums[0]=parseFloat(nums[0])/ 100;
		if (nums.length==1)
			nums[1]=nums[2]=0;
		else {
			nums[1]=parseFloat(nums[1])/ 100;
			nums[2]=parseFloat(nums[2]);
		}
		rect[type]=nums;
		rect.input[type]=value;
		onParentResize(type);
		return true;
	}

	/**
	*是否已设置高度。
	*@param sprite 显示对象 Sprite。
	*@return 一个Boolean 表示是否已设置高度。
	*/
	__proto.heighted=function(sprite){
		return (this._type & 0x2000)!=0;
	}

	/**
	*设置宽高。
	*@param w 宽度。
	*@param h 高度。
	*/
	__proto.size=function(w,h){
		var ower=this._ower;
		var resize=false;
		if (w!==-1 && w !=this._ower.width){
			this._type |=0x8;
			this._ower.width=w;
			resize=true;
		}
		if (h!==-1 && h !=this._ower.height){
			this._type |=0x2000;
			this._ower.height=h;
			resize=true;
		}
		if (resize){
			ower._layoutLater();
			(this._type & 0x80000)&& ower.event(/*laya.events.Event.RESIZE*/"resize",this);
		}
	}

	/**@private */
	__proto._getAlign=function(){
		return this._aligns[0];
	}

	/**@private */
	__proto._getValign=function(){
		return this._aligns[1];
	}

	/**@private */
	__proto._getCssFloat=function(){
		return (this._type & 0x8000)!=0 ? 0x8000 :0;
	}

	__proto._createFont=function(){
		return (this._type & 0x1000)? this._font :(this._type |=0x1000,this._font=new Font(this._font));
	}

	/**@inheritDoc */
	__proto.render=function(sprite,context,x,y){
		var w=sprite.width;
		var h=sprite.height;
		x-=sprite.pivotX;
		y-=sprite.pivotY;
		this._bgground && this._bgground.color !=null && context.ctx.fillRect(x,y,w,h,this._bgground.color);
		this._border && this._border.color && context.drawRect(x,y,w,h,this._border.color.strColor,this._border.size);
	}

	/**@inheritDoc */
	__proto.getCSSStyle=function(){
		return this;
	}

	/**
	*设置 CSS 样式字符串。
	*@param text CSS样式字符串。
	*/
	__proto.cssText=function(text){
		this.attrs(CSSStyle.parseOneCSS(text,';'));
	}

	/**
	*根据传入的属性名、属性值列表，设置此对象的属性值。
	*@param attrs 属性名与属性值列表。
	*/
	__proto.attrs=function(attrs){
		if (attrs){
			for (var i=0,n=attrs.length;i < n;i++){
				var attr=attrs[i];
				this[attr[0]]=attr[1];
			}
		}
	}

	/**@inheritDoc */
	__proto.setTransform=function(value){
		(value==='none')? (this._tf=Style._TF_EMPTY):this.attrs(CSSStyle.parseOneCSS(value,','));
	}

	/**
	*定义 X 轴、Y 轴移动转换。
	*@param x X 轴平移量。
	*@param y Y 轴平移量。
	*/
	__proto.translate=function(x,y){
		this._tf===Style._TF_EMPTY && (this._tf=new TransformInfo());
		this._tf.translateX=x;
		this._tf.translateY=y;
	}

	/**
	*定义 缩放转换。
	*@param x X 轴缩放值。
	*@param y Y 轴缩放值。
	*/
	__proto.scale=function(x,y){
		this._tf===Style._TF_EMPTY && (this._tf=new TransformInfo());
		this._tf.scaleX=x;
		this._tf.scaleY=y;
	}

	/**@private */
	__proto._enableLayout=function(){
		return (this._type & 0x2)===0 && (this._type & 0x4)===0;
	}

	/**
	*是否显示为块级元素。
	*/
	__getset(0,__proto,'block',_super.prototype._$get_block,function(value){
		value ? (this._type |=0x1):(this._type &=(~0x1));
	});

	/**
	*垂直对齐方式。
	*/
	__getset(0,__proto,'valign',function(){
		return CSSStyle._valigndef[this._aligns[1]];
		},function(value){
		this._aligns===CSSStyle._ALIGNS && (this._aligns=[0,0,0]);
		this._aligns[1]=CSSStyle._valigndef[value];
	});

	/**
	*高度。
	*/
	__getset(0,__proto,'height',null,function(h){
		this._type |=0x2000;
		if ((typeof h=='string')){
			if (this._calculation("height",h))return;
			h=parseInt(h);
		}
		this.size(-1,h);
	});

	/**
	*宽度。
	*/
	__getset(0,__proto,'width',null,function(w){
		this._type |=0x8;
		if ((typeof w=='string')){
			var offset=w.indexOf('auto');
			if (offset >=0){
				this._type |=0x40000;
				w=w.substr(0,offset);
			}
			if (this._calculation("width",w))return;
			w=parseInt(w);
		}
		this.size(w,-1);
	});

	/**
	*字体粗细。
	*/
	__getset(0,__proto,'fontWeight',function(){
		return this._font.weight;
		},function(value){
		this._createFont().weight=value;
	});

	/**
	*表示左边距。
	*/
	__getset(0,__proto,'left',null,function(value){
		var ower=this._ower;
		if (((typeof value=='string'))){
			if (value==="center")
				value="50% -50% 0";
			else if (value==="right")
			value="100% -100% 0";
			if (this._calculation("left",value))return;
			value=parseInt(value);
		}
		ower.x=value;
	});

	__getset(0,__proto,'_translate',null,function(value){
		this.translate(value[0],value[1]);
	});

	/**@inheritDoc */
	__getset(0,__proto,'absolute',function(){
		return (this._type & 0x4)!==0;
	});

	/**
	*表示上边距。
	*/
	__getset(0,__proto,'top',null,function(value){
		var ower=this._ower;
		if (((typeof value=='string'))){
			if (value==="middle")
				value="50% -50% 0";
			else if (value==="bottom")
			value="100% -100% 0";
			if (this._calculation("top",value))return;
			value=parseInt(value);
		}
		ower.y=value;
	});

	/**
	*水平对齐方式。
	*/
	__getset(0,__proto,'align',function(){
		return CSSStyle._aligndef[this._aligns[0]];
		},function(value){
		this._aligns===CSSStyle._ALIGNS && (this._aligns=[0,0,0]);
		this._aligns[0]=CSSStyle._aligndef[value];
	});

	/**
	*表示是否加粗。
	*/
	__getset(0,__proto,'bold',function(){
		return this._font.bold;
		},function(value){
		this._createFont().bold=value;
	});

	/**
	*边距信息。
	*/
	__getset(0,__proto,'padding',function(){
		return this._padding;
		},function(value){
		this._padding=value;
	});

	/**
	*行间距。
	*/
	__getset(0,__proto,'leading',function(){
		return this._spacing[1];
		},function(d){
		((typeof d=='string'))&& (d=parseInt(d+""));
		this._spacing===CSSStyle._SPACING && (this._spacing=[0,0]);
		this._spacing[1]=d;
	});

	/**
	*是否是行元素。
	*/
	__getset(0,__proto,'lineElement',function(){
		return (this._type & 0x10000)!=0;
		},function(value){
		value ? (this._type |=0x10000):(this._type &=(~0x10000));
	});

	/**
	*浮动方向。
	*/
	__getset(0,__proto,'cssFloat',function(){
		return (this._type & 0x8000)!=0 ? "right" :"left";
		},function(value){
		this.lineElement=false;
		value==="right" ? (this._type |=0x8000):(this._type &=(~0x8000));
	});

	/**
	*添加到文本的修饰。
	*/
	__getset(0,__proto,'textDecoration',function(){
		return this._font.decoration;
		},function(value){
		this._createFont().decoration=value;
	});

	/**
	*设置如何处理元素内的空白。
	*/
	__getset(0,__proto,'whiteSpace',function(){
		return (this._type & 0x20000)? "nowrap" :"";
		},function(type){
		type==="nowrap" && (this._type |=0x20000);
		type==="none" && (this._type &=~0x20000);
	});

	__getset(0,__proto,'background',null,function(value){
		if (!value){
			this._bgground=null;
			return;
		}
		this._bgground || (this._bgground={});
		this._bgground.color=value;
		this._ower.conchModel && this._ower.conchModel.bgColor(value);
		this._type |=0x4000;
		this._ower._renderType |=/*laya.renders.RenderSprite.STYLE*/0x100;
	});

	/**
	*表示是否换行。
	*/
	__getset(0,__proto,'wordWrap',function(){
		return (this._type & 0x20000)===0;
		},function(value){
		value ? (this._type &=~0x20000):(this._type |=0x20000);
	});

	/**
	*字体颜色。
	*/
	__getset(0,__proto,'color',function(){
		return this._font.color;
		},function(value){
		this._createFont().color=value;
	});

	/**
	*<p>指定文本字段是否是密码文本字段。</p>
	*如果此属性的值为 true，则文本字段被视为密码文本字段，并使用星号而不是实际字符来隐藏输入的字符。如果为 false，则不会将文本字段视为密码文本字段。
	*/
	__getset(0,__proto,'password',function(){
		return this._font.password;
		},function(value){
		this._createFont().password=value;
	});

	/**
	*背景颜色。
	*/
	__getset(0,__proto,'backgroundColor',function(){
		return this._bgground ? this._bgground.color :null;
		},function(value){
		if (value==='none')this._bgground=null;
		else (this._bgground || (this._bgground={}),this._bgground.color=value);
		this._ower.conchModel && this._ower.conchModel.bgColor(value);
		this._ower._renderType |=/*laya.renders.RenderSprite.STYLE*/0x100;
	});

	/**
	*字体信息。
	*/
	__getset(0,__proto,'font',function(){
		return this._font.toString();
		},function(value){
		this._createFont().set(value);
	});

	/**
	*文本的粗细。
	*/
	__getset(0,__proto,'weight',null,function(value){
		this._createFont().weight=value;
	});

	/**
	*间距。
	*/
	__getset(0,__proto,'letterSpacing',function(){
		return this._spacing[0];
		},function(d){
		((typeof d=='string'))&& (d=parseInt(d+""));
		this._spacing===CSSStyle._SPACING && (this._spacing=[0,0]);
		this._spacing[0]=d;
	});

	/**
	*字体大小。
	*/
	__getset(0,__proto,'fontSize',function(){
		return this._font.size;
		},function(value){
		this._createFont().size=value;
	});

	/**
	*表示是否为斜体。
	*/
	__getset(0,__proto,'italic',function(){
		return this._font.italic;
		},function(value){
		this._createFont().italic=value;
	});

	/**
	*字体系列。
	*/
	__getset(0,__proto,'fontFamily',function(){
		return this._font.family;
		},function(value){
		this._createFont().family=value;
	});

	/**
	*<p>描边宽度（以像素为单位）。</p>
	*默认值0，表示不描边。
	*@default 0
	*/
	__getset(0,__proto,'stroke',function(){
		return this._font.stroke[0];
		},function(value){
		if (this._createFont().stroke===Font._STROKE)this._font.stroke=[0,"#000000"];
		this._font.stroke[0]=value;
	});

	/**
	*<p>描边颜色，以字符串表示。</p>
	*@default "#000000";
	*/
	__getset(0,__proto,'strokeColor',function(){
		return this._font.stroke[1];
		},function(value){
		if (this._createFont().stroke===Font._STROKE)this._font.stroke=[0,"#000000"];
		this._font.stroke[1]=value;
	});

	/**
	*边框属性，比如border="5px solid red"
	*/
	__getset(0,__proto,'border',function(){
		return this._border ? this._border.value :"";
		},function(value){
		if (value=='none'){
			this._border=null;
			return;
		}
		this._border || (this._border={});
		this._border.value=value;
		var values=value.split(' ');
		this._border.color=Color.create(values[values.length-1]);
		if (values.length==1){
			this._border.size=1;
			this._border.type='solid';
			return;
		};
		var i=0;
		if (values[0].indexOf('px')> 0){
			this._border.size=parseInt(values[0]);
			i++;
		}else this._border.size=1;
		this._border.type=values[i];
		this._ower._renderType |=/*laya.renders.RenderSprite.STYLE*/0x100;
	});

	/**
	*边框的颜色。
	*/
	__getset(0,__proto,'borderColor',function(){
		return (this._border && this._border.color)? this._border.color.strColor :null;
		},function(value){
		if (!value){
			this._border=null;
			return;
		}
		this._border || (this._border={size:1,type:'solid'});
		this._border.color=(value==null)? null :Color.create(value);
		this._ower.conchModel && this._ower.conchModel.border(this._border.color.strColor);
		this._ower._renderType |=/*laya.renders.RenderSprite.STYLE*/0x100;
	});

	/**
	*元素的定位类型。
	*/
	__getset(0,__proto,'position',function(){
		return (this._type & 0x4)? "absolute" :"";
		},function(value){
		value=="absolute" ? (this._type |=0x4):(this._type &=~0x4);
	});

	/**
	*规定元素应该生成的框的类型。
	*/
	__getset(0,__proto,'display',null,function(value){
		switch (value){
			case '':
				this._type &=~0x2;
				this.visible=true;
				break ;
			case 'none':
				this._type |=0x2;
				this.visible=false;
				this._ower._layoutLater();
				break ;
			}
	});

	/**@inheritDoc */
	__getset(0,__proto,'paddingLeft',function(){
		return this.padding[3];
	});

	/**@inheritDoc */
	__getset(0,__proto,'paddingTop',function(){
		return this.padding[0];
	});

	__getset(0,__proto,'_scale',null,function(value){
		this._ower.scale(value[0],value[1]);
	});

	__getset(0,__proto,'_rotate',null,function(value){
		this._ower.rotation=value;
	});

	CSSStyle.parseOneCSS=function(text,clipWord){
		var out=[];
		var attrs=text.split(clipWord);
		var valueArray;
		for (var i=0,n=attrs.length;i < n;i++){
			var attr=attrs[i];
			var ofs=attr.indexOf(':');
			var name=attr.substr(0,ofs).replace(/^\s+|\s+$/g,'');
			if (name.length==0)
				continue ;
			var value=attr.substr(ofs+1).replace(/^\s+|\s+$/g,'');
			var one=[name,value];
			switch (name){
				case 'italic':
				case 'bold':
					one[1]=value=="true";
					break ;
				case 'line-height':
					one[0]='lineHeight';
					one[1]=parseInt(value);
					break ;
				case 'font-size':
					one[0]='fontSize';
					one[1]=parseInt(value);
					break ;
				case 'padding':
					valueArray=value.split(' ');
					valueArray.length > 1 || (valueArray[1]=valueArray[2]=valueArray[3]=valueArray[0]);
					one[1]=[parseInt(valueArray[0]),parseInt(valueArray[1]),parseInt(valueArray[2]),parseInt(valueArray[3])];
					break ;
				case 'rotate':
					one[0]="_rotate";
					one[1]=parseFloat(value);
					break ;
				case 'scale':
					valueArray=value.split(' ');
					one[0]="_scale";
					one[1]=[parseFloat(valueArray[0]),parseFloat(valueArray[1])];
					break ;
				case 'translate':
					valueArray=value.split(' ');
					one[0]="_translate";
					one[1]=[parseInt(valueArray[0]),parseInt(valueArray[1])];
					break ;
				default :
					(one[0]=CSSStyle._CSSTOVALUE[name])|| (one[0]=name);
				}
			out.push(one);
		}
		return out;
	}

	CSSStyle.parseCSS=function(text,uri){
		var one;
		while ((one=CSSStyle._parseCSSRegExp.exec(text))!=null){
			CSSStyle.styleSheets[one[1]]=CSSStyle.parseOneCSS(one[2],';');
		}
	}

	CSSStyle.EMPTY=new CSSStyle(null);
	CSSStyle._CSSTOVALUE={'letter-spacing':'letterSpacing','line-spacing':'lineSpacing','white-space':'whiteSpace','line-height':'lineHeight','scale-x':'scaleX','scale-y':'scaleY','translate-x':'translateX','translate-y':'translateY','font-family':'fontFamily','font-weight':'fontWeight','vertical-align':'valign','text-decoration':'textDecoration','background-color':'backgroundColor','border-color':'borderColor','float':'cssFloat'};
	CSSStyle._parseCSSRegExp=new RegExp("([\.\#]\\w+)\\s*{([\\s\\S]*?)}","g");
	CSSStyle._aligndef={'left':0,'center':1,'right':2,0:'left',1:'center',2:'right'};
	CSSStyle._valigndef={'top':0,'middle':1,'bottom':2,0:'top',1:'middle',2:'bottom'};
	CSSStyle.styleSheets={};
	CSSStyle.ALIGN_CENTER=1;
	CSSStyle.ALIGN_RIGHT=2;
	CSSStyle.VALIGN_MIDDLE=1;
	CSSStyle.VALIGN_BOTTOM=2;
	CSSStyle._CSS_BLOCK=0x1;
	CSSStyle._DISPLAY_NONE=0x2;
	CSSStyle._ABSOLUTE=0x4;
	CSSStyle._WIDTH_SET=0x8;
	CSSStyle._PADDING=[0,0,0,0];
	CSSStyle._RECT=[-1,-1,-1,-1];
	CSSStyle._SPACING=[0,0];
	CSSStyle._ALIGNS=[0,0,0];
	CSSStyle.ADDLAYOUTED=0x200;
	CSSStyle._NEWFONT=0x1000;
	CSSStyle._HEIGHT_SET=0x2000;
	CSSStyle._BACKGROUND_SET=0x4000;
	CSSStyle._FLOAT_RIGHT=0x8000;
	CSSStyle._LINE_ELEMENT=0x10000;
	CSSStyle._NOWARP=0x20000;
	CSSStyle._WIDTHAUTO=0x40000;
	CSSStyle._LISTERRESZIE=0x80000;
	return CSSStyle;
})(Style)


/**
*@private
*使用Audio标签播放声音
*/
//class laya.media.h5audio.AudioSound extends laya.events.EventDispatcher
var AudioSound=(function(_super){
	function AudioSound(){
		/**
		*声音URL
		*/
		this.url=null;
		/**
		*播放用的audio标签
		*/
		this.audio=null;
		/**
		*是否已加载完成
		*/
		this.loaded=false;
		AudioSound.__super.call(this);
	}

	__class(AudioSound,'laya.media.h5audio.AudioSound',_super);
	var __proto=AudioSound.prototype;
	/**
	*释放声音
	*
	*/
	__proto.dispose=function(){
		var ad=AudioSound._audioCache[this.url];
		if (ad){
			ad.src="";
			delete AudioSound._audioCache[this.url];
		}
	}

	/**
	*加载声音
	*@param url
	*
	*/
	__proto.load=function(url){
		url=URL.formatURL(url);
		this.url=url;
		var ad;
		if (url==SoundManager._tMusic){
			AudioSound._initMusicAudio();
			ad=AudioSound._musicAudio;
			if (ad.src !=url){
				AudioSound._audioCache[ad.src]=null;
				ad=null;
			}
			}else{
			ad=AudioSound._audioCache[url];
		}
		if (ad && ad.readyState >=2){
			this.event(/*laya.events.Event.COMPLETE*/"complete");
			return;
		}
		if (!ad){
			if (url==SoundManager._tMusic){
				AudioSound._initMusicAudio();
				ad=AudioSound._musicAudio;
				}else{
				ad=Browser.createElement("audio");
			}
			AudioSound._audioCache[url]=ad;
			ad.src=url;
		}
		ad.addEventListener("canplaythrough",onLoaded);
		ad.addEventListener("error",onErr);
		var me=this;
		function onLoaded (){
			offs();
			me.loaded=true;
			me.event(/*laya.events.Event.COMPLETE*/"complete");
		}
		function onErr (){
			ad.load=null;
			offs();
			me.event(/*laya.events.Event.ERROR*/"error");
		}
		function offs (){
			ad.removeEventListener("canplaythrough",onLoaded);
			ad.removeEventListener("error",onErr);
		}
		this.audio=ad;
		if (ad.load){
			ad.load();
			}else {
			onErr();
		}
	}

	/**
	*播放声音
	*@param startTime 起始时间
	*@param loops 循环次数
	*@return
	*
	*/
	__proto.play=function(startTime,loops){
		(startTime===void 0)&& (startTime=0);
		(loops===void 0)&& (loops=0);
		if (!this.url)return null;
		var ad;
		if (this.url==SoundManager._tMusic){
			ad=AudioSound._musicAudio;
			}else{
			ad=AudioSound._audioCache[this.url];
		}
		if (!ad)return null;
		var tAd;
		tAd=Pool.getItem("audio:"+this.url);
		if (Render.isConchApp){
			if (!tAd){
				tAd=Browser.createElement("audio");
				tAd.src=this.url;
			}
		}
		else {
			if (this.url==SoundManager._tMusic){
				AudioSound._initMusicAudio();
				tAd=AudioSound._musicAudio;
				tAd.src=this.url;
				}else{
				tAd=tAd ? tAd :ad.cloneNode(true);
			}
		};
		var channel=new AudioSoundChannel(tAd);
		channel.url=this.url;
		channel.loops=loops;
		channel.startTime=startTime;
		channel.play();
		SoundManager.addChannel(channel);
		return channel;
	}

	/**
	*获取总时间。
	*/
	__getset(0,__proto,'duration',function(){
		var ad;
		ad=AudioSound._audioCache[this.url];
		if (!ad)
			return 0;
		return ad.duration;
	});

	AudioSound._initMusicAudio=function(){
		if (AudioSound._musicAudio)return;
		if (!AudioSound._musicAudio)AudioSound._musicAudio=Browser.createElement("audio");
		if (!Render.isConchApp){
			Browser.document.addEventListener("mousedown",AudioSound._makeMusicOK);
		}
	}

	AudioSound._makeMusicOK=function(){
		Browser.document.removeEventListener("mousedown",AudioSound._makeMusicOK);
		if (!AudioSound._musicAudio.src){
			AudioSound._musicAudio.src="";
			AudioSound._musicAudio.load();
			}else{
			AudioSound._musicAudio.play();
		}
	}

	AudioSound._audioCache={};
	AudioSound._musicAudio=null;
	return AudioSound;
})(EventDispatcher)


/**
*<p> <code>SoundChannel</code> 用来控制程序中的声音。每个声音均分配给一个声道，而且应用程序可以具有混合在一起的多个声道。</p>
*<p> <code>SoundChannel</code> 类包含控制声音的播放、暂停、停止、音量的方法，以及获取声音的播放状态、总时间、当前播放时间、总循环次数、播放地址等信息的方法。</p>
*/
//class laya.media.SoundChannel extends laya.events.EventDispatcher
var SoundChannel=(function(_super){
	function SoundChannel(){
		/**
		*声音地址。
		*/
		this.url=null;
		/**
		*循环次数。
		*/
		this.loops=0;
		/**
		*开始时间。
		*/
		this.startTime=NaN;
		/**
		*表示声音是否已暂停。
		*/
		this.isStopped=false;
		/**
		*播放完成处理器。
		*/
		this.completeHandler=null;
		SoundChannel.__super.call(this);
	}

	__class(SoundChannel,'laya.media.SoundChannel',_super);
	var __proto=SoundChannel.prototype;
	/**
	*播放。
	*/
	__proto.play=function(){}
	/**
	*停止。
	*/
	__proto.stop=function(){}
	/**
	*暂停。
	*/
	__proto.pause=function(){}
	/**
	*继续播放。
	*/
	__proto.resume=function(){}
	/**
	*private
	*/
	__proto.__runComplete=function(handler){
		if (handler){
			handler.run();
		}
	}

	/**
	*音量范围从 0（静音）至 1（最大音量）。
	*/
	__getset(0,__proto,'volume',function(){
		return 1;
		},function(v){
	});

	/**
	*获取当前播放时间。
	*/
	__getset(0,__proto,'position',function(){
		return 0;
	});

	/**
	*获取总时间。
	*/
	__getset(0,__proto,'duration',function(){
		return 0;
	});

	return SoundChannel;
})(EventDispatcher)


/**
*<code>Sound</code> 类是用来播放控制声音的类。
*/
//class laya.media.Sound extends laya.events.EventDispatcher
var Sound=(function(_super){
	function Sound(){
		Sound.__super.call(this);;
	}

	__class(Sound,'laya.media.Sound',_super);
	var __proto=Sound.prototype;
	/**
	*加载声音。
	*@param url 地址。
	*
	*/
	__proto.load=function(url){}
	/**
	*播放声音。
	*@param startTime 开始时间,单位秒
	*@param loops 循环次数,0表示一直循环
	*@return 声道 SoundChannel 对象。
	*
	*/
	__proto.play=function(startTime,loops){
		(startTime===void 0)&& (startTime=0);
		(loops===void 0)&& (loops=0);
		return null;
	}

	/**
	*释放声音资源。
	*
	*/
	__proto.dispose=function(){}
	/**
	*获取总时间。
	*/
	__getset(0,__proto,'duration',function(){
		return 0;
	});

	return Sound;
})(EventDispatcher)


/**
*@private
*web audio api方式播放声音
*/
//class laya.media.webaudio.WebAudioSound extends laya.events.EventDispatcher
var WebAudioSound=(function(_super){
	function WebAudioSound(){
		/**
		*声音URL
		*/
		this.url=null;
		/**
		*是否已加载完成
		*/
		this.loaded=false;
		/**
		*声音文件数据
		*/
		this.data=null;
		/**
		*声音原始文件数据
		*/
		this.audioBuffer=null;
		/**
		*待播放的声音列表
		*/
		this.__toPlays=null;
		/**
		*@private
		*/
		this._disposed=false;
		WebAudioSound.__super.call(this);
	}

	__class(WebAudioSound,'laya.media.webaudio.WebAudioSound',_super);
	var __proto=WebAudioSound.prototype;
	/**
	*加载声音
	*@param url
	*
	*/
	__proto.load=function(url){
		var me=this;
		url=URL.formatURL(url);
		this.url=url;
		this.audioBuffer=WebAudioSound._dataCache[url];
		if (this.audioBuffer){
			this._loaded(this.audioBuffer);
			return;
		}
		WebAudioSound.e.on("loaded:"+url,this,this._loaded);
		WebAudioSound.e.on("err:"+url,this,this._err);
		if (WebAudioSound.__loadingSound[url]){
			return;
		}
		WebAudioSound.__loadingSound[url]=true;
		var request=new Browser.window.XMLHttpRequest();
		request.open("GET",url,true);
		request.responseType="arraybuffer";
		request.onload=function (){
			if (me._disposed){
				me._removeLoadEvents();
				return;
			}
			me.data=request.response;
			WebAudioSound.buffs.push({"buffer":me.data,"url":me.url});
			WebAudioSound.decode();
		};
		request.onerror=function (e){
			me._err();
		}
		request.send();
	}

	__proto._err=function(){
		this._removeLoadEvents();
		WebAudioSound.__loadingSound[this.url]=false;
		this.event(/*laya.events.Event.ERROR*/"error");
	}

	__proto._loaded=function(audioBuffer){
		this._removeLoadEvents();
		if (this._disposed){
			return;
		}
		this.audioBuffer=audioBuffer;
		WebAudioSound._dataCache[this.url]=this.audioBuffer;
		this.loaded=true;
		this.event(/*laya.events.Event.COMPLETE*/"complete");
	}

	__proto._removeLoadEvents=function(){
		WebAudioSound.e.off("loaded:"+this.url,this,this._loaded);
		WebAudioSound.e.off("err:"+this.url,this,this._err);
	}

	__proto.__playAfterLoaded=function(){
		if (!this.__toPlays)return;
		var i=0,len=0;
		var toPlays;
		toPlays=this.__toPlays;
		len=toPlays.length;
		var tParams;
		for (i=0;i < len;i++){
			tParams=toPlays[i];
			if (tParams[2] && !(tParams [2]).isStopped){
				this.play(tParams[0],tParams[1],tParams[2]);
			}
		}
		this.__toPlays.length=0;
	}

	/**
	*播放声音
	*@param startTime 起始时间
	*@param loops 循环次数
	*@return
	*
	*/
	__proto.play=function(startTime,loops,channel){
		(startTime===void 0)&& (startTime=0);
		(loops===void 0)&& (loops=0);
		channel=channel ? channel :new WebAudioSoundChannel();
		if (!this.audioBuffer){
			if (this.url){
				if (!this.__toPlays)this.__toPlays=[];
				this.__toPlays.push([startTime,loops,channel]);
				this.once(/*laya.events.Event.COMPLETE*/"complete",this,this.__playAfterLoaded);
				this.load(this.url);
			}
		}
		channel.url=this.url;
		channel.loops=loops;
		channel["audioBuffer"]=this.audioBuffer;
		channel.startTime=startTime;
		channel.play();
		SoundManager.addChannel(channel);
		return channel;
	}

	__proto.dispose=function(){
		this._disposed=true;
		delete WebAudioSound._dataCache[this.url];
		delete WebAudioSound.__loadingSound[this.url];
		this.audioBuffer=null;
		this.data=null;
		this.__toPlays=[];
	}

	__getset(0,__proto,'duration',function(){
		if (this.audioBuffer){
			return this.audioBuffer.duration;
		}
		return 0;
	});

	WebAudioSound.decode=function(){
		if (WebAudioSound.buffs.length <=0 || WebAudioSound.isDecoding){
			return;
		}
		WebAudioSound.isDecoding=true;
		WebAudioSound.tInfo=WebAudioSound.buffs.shift();
		WebAudioSound.ctx.decodeAudioData(WebAudioSound.tInfo["buffer"],WebAudioSound._done,WebAudioSound._fail);
	}

	WebAudioSound._done=function(audioBuffer){
		WebAudioSound.e.event("loaded:"+WebAudioSound.tInfo.url,audioBuffer);
		WebAudioSound.isDecoding=false;
		WebAudioSound.decode();
	}

	WebAudioSound._fail=function(){
		WebAudioSound.e.event("err:"+WebAudioSound.tInfo.url,null);
		WebAudioSound.isDecoding=false;
		WebAudioSound.decode();
	}

	WebAudioSound._playEmptySound=function(){
		if (WebAudioSound.ctx==null){
			return;
		};
		var source=WebAudioSound.ctx.createBufferSource();
		source.buffer=WebAudioSound._miniBuffer;
		source.connect(WebAudioSound.ctx.destination);
		source.start(0,0,0);
	}

	WebAudioSound._unlock=function(){
		if (WebAudioSound._unlocked){
			return;
		}
		WebAudioSound._playEmptySound();
		if (WebAudioSound.ctx.state=="running"){
			Browser.document.removeEventListener("mousedown",WebAudioSound._unlock,true);
			Browser.document.removeEventListener("touchend",WebAudioSound._unlock,true);
			WebAudioSound._unlocked=true;
		}
	}

	WebAudioSound.initWebAudio=function(){
		if (WebAudioSound.ctx.state !="running"){
			WebAudioSound._unlock();
			Browser.document.addEventListener("mousedown",WebAudioSound._unlock,true);
			Browser.document.addEventListener("touchend",WebAudioSound._unlock,true);
		}
	}

	WebAudioSound._dataCache={};
	WebAudioSound.buffs=[];
	WebAudioSound.isDecoding=false;
	WebAudioSound._unlocked=false;
	WebAudioSound.tInfo=null;
	WebAudioSound.__loadingSound={};
	__static(WebAudioSound,
	['window',function(){return this.window=Browser.window;},'webAudioEnabled',function(){return this.webAudioEnabled=WebAudioSound.window["AudioContext"] || WebAudioSound.window["webkitAudioContext"] || WebAudioSound.window["mozAudioContext"];},'ctx',function(){return this.ctx=WebAudioSound.webAudioEnabled ? new (WebAudioSound.window["AudioContext"] || WebAudioSound.window["webkitAudioContext"] || WebAudioSound.window["mozAudioContext"])():undefined;},'_miniBuffer',function(){return this._miniBuffer=WebAudioSound.ctx.createBuffer(1,1,22050);},'e',function(){return this.e=new EventDispatcher();}
	]);
	return WebAudioSound;
})(EventDispatcher)


/**
*<p> <code>HttpRequest</code> 通过封装 HTML <code>XMLHttpRequest</code> 对象提供了对 HTTP 协议的完全的访问，包括做出 POST 和 HEAD 请求以及普通的 GET 请求的能力。 <code>HttpRequest</code> 只提供以异步的形式返回 Web 服务器的响应，并且能够以文本或者二进制的形式返回内容。</p>
*<p><b>注意：</b>建议每次请求都使用新的 <code>HttpRequest</code> 对象，因为每次调用该对象的send方法时，都会清空之前设置的数据，并重置 HTTP 请求的状态，这会导致之前还未返回响应的请求被重置，从而得不到之前请求的响应结果。</p>
*/
//class laya.net.HttpRequest extends laya.events.EventDispatcher
var HttpRequest=(function(_super){
	function HttpRequest(){
		/**@private */
		this._responseType=null;
		/**@private */
		this._data=null;
		HttpRequest.__super.call(this);
		this._http=new Browser.window.XMLHttpRequest();
	}

	__class(HttpRequest,'laya.net.HttpRequest',_super);
	var __proto=HttpRequest.prototype;
	/**
	*发送 HTTP 请求。
	*@param url 请求的地址。大多数浏览器实施了一个同源安全策略，并且要求这个 URL 与包含脚本的文本具有相同的主机名和端口。
	*@param data (default=null)发送的数据。
	*@param method (default="get")用于请求的 HTTP 方法。值包括 "get"、"post"、"head"。
	*@param responseType (default="text")Web 服务器的响应类型，可设置为 "text"、"json"、"xml"、"arraybuffer"。
	*@param headers (default=null)HTTP 请求的头部信息。参数形如key-value数组：key是头部的名称，不应该包括空白、冒号或换行；value是头部的值，不应该包括换行。比如["Content-Type","application/json"]。
	*/
	__proto.send=function(url,data,method,responseType,headers){
		(method===void 0)&& (method="get");
		(responseType===void 0)&& (responseType="text");
		this._responseType=responseType;
		this._data=null;
		var _this=this;
		var http=this._http;
		http.open(method,url,true);
		if (headers){
			for (var i=0;i < headers.length;i++){
				http.setRequestHeader(headers[i++],headers[i]);
			}
			}else if (!Render.isConchApp){
			if (!data || (typeof data=='string'))http.setRequestHeader("Content-Type","application/x-www-form-urlencoded");
			else http.setRequestHeader("Content-Type","application/json");
		}
		http.responseType=responseType!=="arraybuffer" ? "text" :"arraybuffer";
		http.onerror=function (e){
			_this._onError(e);
		}
		http.onabort=function (e){
			_this._onAbort(e);
		}
		http.onprogress=function (e){
			_this._onProgress(e);
		}
		http.onload=function (e){
			_this._onLoad(e);
		}
		http.send(data);
	}

	/**
	*@private
	*请求进度的侦听处理函数。
	*@param e 事件对象。
	*/
	__proto._onProgress=function(e){
		if (e && e.lengthComputable)this.event(/*laya.events.Event.PROGRESS*/"progress",e.loaded / e.total);
	}

	/**
	*@private
	*请求中断的侦听处理函数。
	*@param e 事件对象。
	*/
	__proto._onAbort=function(e){
		this.error("Request was aborted by user");
	}

	/**
	*@private
	*请求出错侦的听处理函数。
	*@param e 事件对象。
	*/
	__proto._onError=function(e){
		this.error("Request failed Status:"+this._http.status+" text:"+this._http.statusText);
	}

	/**
	*@private
	*请求消息返回的侦听处理函数。
	*@param e 事件对象。
	*/
	__proto._onLoad=function(e){
		var http=this._http;
		var status=http.status!==undefined ? http.status :200;
		if (status===200 || status===204 || status===0){
			this.complete();
			}else {
			this.error("["+http.status+"]"+http.statusText+":"+http.responseURL);
		}
	}

	/**
	*@private
	*请求错误的处理函数。
	*@param message 错误信息。
	*/
	__proto.error=function(message){
		this.clear();
		this.event(/*laya.events.Event.ERROR*/"error",message);
	}

	/**
	*@private
	*请求成功完成的处理函数。
	*/
	__proto.complete=function(){
		this.clear();
		var flag=true;
		try {
			if (this._responseType==="json"){
				this._data=JSON.parse(this._http.responseText);
				}else if (this._responseType==="xml"){
				this._data=Utils.parseXMLFromString(this._http.responseText);
				}else {
				this._data=this._http.response || this._http.responseText;
			}
			}catch (e){
			flag=false;
			this.error(e.message);
		}
		flag && this.event(/*laya.events.Event.COMPLETE*/"complete",(this._data instanceof Array)? [this._data] :this._data);
	}

	/**
	*@private
	*清除当前请求。
	*/
	__proto.clear=function(){
		var http=this._http;
		http.onerror=http.onabort=http.onprogress=http.onload=null;
	}

	/**请求的地址。*/
	__getset(0,__proto,'url',function(){
		return this._http.responseURL;
	});

	/**
	*本对象所封装的原生 XMLHttpRequest 引用。
	*/
	__getset(0,__proto,'http',function(){
		return this._http;
	});

	/**返回的数据。*/
	__getset(0,__proto,'data',function(){
		return this._data;
	});

	return HttpRequest;
})(EventDispatcher)


/**
*<code>Loader</code> 类可用来加载文本、JSON、XML、二进制、图像等资源。
*/
//class laya.net.Loader extends laya.events.EventDispatcher
var Loader=(function(_super){
	function Loader(){
		/**@private 加载后的数据对象，只读*/
		this._data=null;
		/**@private */
		this._class=null;
		/**@private */
		this._url=null;
		/**@private */
		this._type=null;
		/**@private */
		this._cache=false;
		/**@private */
		this._http=null;
		/**@private 自定义解析不派发complete事件，但会派发loaded事件，手动调用endLoad方法再派发complete事件*/
		this._customParse=false;
		Loader.__super.call(this);
	}

	__class(Loader,'laya.net.Loader',_super);
	var __proto=Loader.prototype;
	/**
	*加载资源。加载错误会派发 Event.ERROR 事件，参数为错误信息。
	*@param url 资源地址。
	*@param type (default=null)资源类型。可选值为：Loader.TEXT、Loader.JSON、Loader.XML、Loader.BUFFER、Loader.IMAGE、Loader.SOUND、Loader.ATLAS、Loader.FONT。如果为null，则根据文件后缀分析类型。
	*@param cache (default=true)是否缓存数据。
	*@param group (default=null)分组名称。
	*@param ignoreCache (default=false)是否忽略缓存，强制重新加载。
	*/
	__proto.load=function(url,type,cache,group,ignoreCache){
		(cache===void 0)&& (cache=true);
		(ignoreCache===void 0)&& (ignoreCache=false);
		this._url=url;
		if (url.indexOf("data:image")===0)this._type=type="image";
		else {
			this._type=type || (type=this.getTypeFromUrl(url));
			url=URL.formatURL(url);
		}
		this._cache=cache;
		this._data=null;
		if (!ignoreCache && Loader.loadedMap[url]){
			this._data=Loader.loadedMap[url];
			this.event(/*laya.events.Event.PROGRESS*/"progress",1);
			this.event(/*laya.events.Event.COMPLETE*/"complete",this._data);
			return;
		}
		if (group)Loader.setGroup(url,group);
		if (Loader.parserMap[type] !=null){
			this._customParse=true;
			if (((Loader.parserMap[type])instanceof laya.utils.Handler ))Loader.parserMap[type].runWith(this);
			else Loader.parserMap[type].call(null,this);
			return;
		}
		if (type==="image" || type==="htmlimage" || type==="nativeimage")return this._loadImage(url);
		if (type==="sound")return this._loadSound(url);
		if (type==="ttf")return this._loadTTF(url);
		var contentType;
		switch (type){
			case "atlas":
			case "plf":
				contentType="json";
				break ;
			case "font":
				contentType="xml";
				break ;
			case "pkm":
				contentType="arraybuffer";
				break
			default :
				contentType=type;
			}
		if (Loader.preLoadedMap[url]){
			this.onLoaded(Loader.preLoadedMap[url]);
			}else{
			if (!this._http){
				this._http=new HttpRequest();
				this._http.on(/*laya.events.Event.PROGRESS*/"progress",this,this.onProgress);
				this._http.on(/*laya.events.Event.ERROR*/"error",this,this.onError);
				this._http.on(/*laya.events.Event.COMPLETE*/"complete",this,this.onLoaded);
			}
			this._http.send(url,null,"get",contentType);
		}
	}

	/**
	*获取指定资源地址的数据类型。
	*@param url 资源地址。
	*@return 数据类型。
	*/
	__proto.getTypeFromUrl=function(url){
		var type=Utils.getFileExtension(url);
		if (type)return Loader.typeMap[type];
		console.warn("Not recognize the resources suffix",url);
		return "text";
	}

	/**
	*@private
	*加载TTF资源。
	*@param url 资源地址。
	*/
	__proto._loadTTF=function(url){
		url=URL.formatURL(url);
		var ttfLoader=new TTFLoader();
		ttfLoader.complete=Handler.create(this,this.onLoaded);
		ttfLoader.load(url);
	}

	/**
	*@private
	*加载图片资源。
	*@param url 资源地址。
	*/
	__proto._loadImage=function(url){
		url=URL.formatURL(url);
		var _this=this;
		var image;
		function clear (){
			image.onload=null;
			image.onerror=null;
			delete Loader.imgCache[url]
		};
		var onload=function (){
			clear();
			_this.onLoaded(image);
		};
		var onerror=function (){
			clear();
			_this.event(/*laya.events.Event.ERROR*/"error","Load image failed");
		}
		if (this._type==="nativeimage"){
			image=new Browser.window.Image();
			image.crossOrigin="";
			image.onload=onload;
			image.onerror=onerror;
			image.src=url;
			Loader.imgCache[url]=image;
			}else {
			new HTMLImage.create(url,{onload:onload,onerror:onerror,onCreate:function (img){
					image=img;
					Loader.imgCache[url]=img;
			}});
		}
	}

	/**
	*@private
	*加载声音资源。
	*@param url 资源地址。
	*/
	__proto._loadSound=function(url){
		var sound=(new SoundManager._soundClass());
		var _this=this;
		sound.on(/*laya.events.Event.COMPLETE*/"complete",this,soundOnload);
		sound.on(/*laya.events.Event.ERROR*/"error",this,soundOnErr);
		sound.load(url);
		function soundOnload (){
			clear();
			_this.onLoaded(sound);
		}
		function soundOnErr (){
			clear();
			sound.dispose();
			_this.event(/*laya.events.Event.ERROR*/"error","Load sound failed");
		}
		function clear (){
			sound.offAll();
		}
	}

	/**@private */
	__proto.onProgress=function(value){
		if (this._type==="atlas")this.event(/*laya.events.Event.PROGRESS*/"progress",value *0.3);
		else this.event(/*laya.events.Event.PROGRESS*/"progress",value);
	}

	/**@private */
	__proto.onError=function(message){
		this.event(/*laya.events.Event.ERROR*/"error",message);
	}

	/**
	*资源加载完成的处理函数。
	*@param data 数据。
	*/
	__proto.onLoaded=function(data){
		var type=this._type;
		if (type=="plf"){
			this.parsePLFData(data);
			this.complete(data);
		}else
		if (type==="image"){
			var tex=new Texture(data);
			tex.url=this._url;
			this.complete(tex);
			}else if (type==="sound" || type==="htmlimage" || type==="nativeimage"){
			this.complete(data);
			}else if (type==="atlas"){
			if (!data.src && !data._setContext){
				if (!this._data){
					this._data=data;
					if (data.meta && data.meta.image){
						var toloadPics=data.meta.image.split(",");
						var split=this._url.indexOf("/")>=0 ? "/" :"\\";
						var idx=this._url.lastIndexOf(split);
						var folderPath=idx >=0 ? this._url.substr(0,idx+1):"";
						for (var i=0,len=toloadPics.length;i < len;i++){
							toloadPics[i]=folderPath+toloadPics[i];
						}
						}else {
						toloadPics=[this._url.replace(".json",".png")];
					}
					toloadPics.reverse();
					data.toLoads=toloadPics;
					data.pics=[];
				}
				this.event(/*laya.events.Event.PROGRESS*/"progress",0.3+1 / toloadPics.length *0.6);
				return this._loadImage(toloadPics.pop());
				}else {
				this._data.pics.push(data);
				if (this._data.toLoads.length > 0){
					this.event(/*laya.events.Event.PROGRESS*/"progress",0.3+1 / this._data.toLoads.length *0.6);
					return this._loadImage(this._data.toLoads.pop());
				};
				var frames=this._data.frames;
				var cleanUrl=this._url.split("?")[0];
				var directory=(this._data.meta && this._data.meta.prefix)? this._data.meta.prefix :cleanUrl.substring(0,cleanUrl.lastIndexOf("."))+"/";
				var pics=this._data.pics;
				var atlasURL=URL.formatURL(this._url);
				var map=Loader.atlasMap[atlasURL] || (Loader.atlasMap[atlasURL]=[]);
				map.dir=directory;
				var scaleRate=1;
				if (this._data.meta && this._data.meta.scale && this._data.meta.scale !=1){
					scaleRate=parseFloat(this._data.meta.scale);
					for (var name in frames){
						var obj=frames[name];
						var tPic=pics[obj.frame.idx ? obj.frame.idx :0];
						var url=URL.formatURL(directory+name);
						tPic.scaleRate=scaleRate;
						Loader.cacheRes(url,Texture.create(tPic,obj.frame.x,obj.frame.y,obj.frame.w,obj.frame.h,obj.spriteSourceSize.x,obj.spriteSourceSize.y,obj.sourceSize.w,obj.sourceSize.h));
						Loader.loadedMap[url].url=url;
						map.push(url);
					}
					}else{
					for (name in frames){
						obj=frames[name];
						tPic=pics[obj.frame.idx ? obj.frame.idx :0];
						url=URL.formatURL(directory+name);
						Loader.cacheRes(url,Texture.create(tPic,obj.frame.x,obj.frame.y,obj.frame.w,obj.frame.h,obj.spriteSourceSize.x,obj.spriteSourceSize.y,obj.sourceSize.w,obj.sourceSize.h));
						Loader.loadedMap[url].url=url;
						map.push(url);
					}
				}
				delete this._data.pics;
				this.complete(this._data);
			}
			}else if (type=="font"){
			if (!data.src){
				this._data=data;
				this.event(/*laya.events.Event.PROGRESS*/"progress",0.5);
				return this._loadImage(this._url.replace(".fnt",".png"));
				}else {
				var bFont=new BitmapFont();
				bFont.parseFont(this._data,data);
				var tArr=this._url.split(".fnt")[0].split("/");
				var fontName=tArr[tArr.length-1];
				Text.registerBitmapFont(fontName,bFont);
				this._data=bFont;
				this.complete(this._data);
			}
			}else if (type=="pkm"){
			var image=HTMLImage.create(data,this._url);
			var tex1=new Texture(image);
			tex1.url=this._url;
			this.complete(tex1);
			}else {
			this.complete(data);
		}
	}

	__proto.parsePLFData=function(plfData){
		var type;
		var filePath;
		var fileDic;
		for (type in plfData){
			fileDic=plfData[type];
			switch(type){
				case "json":
				case "text":
					for (filePath in fileDic){
						Loader.preLoadedMap[URL.formatURL(filePath)]=fileDic[filePath]
					}
					break ;
				default :
					for (filePath in fileDic){
						Loader.preLoadedMap[URL.formatURL(filePath)]=fileDic[filePath]
					}
				}
		}
	}

	/**
	*加载完成。
	*@param data 加载的数据。
	*/
	__proto.complete=function(data){
		this._data=data;
		if (this._customParse){
			this.event(/*laya.events.Event.LOADED*/"loaded",(data instanceof Array)? [data] :data);
			}else {
			Loader._loaders.push(this);
			if (!Loader._isWorking)Loader.checkNext();
		}
	}

	/**
	*结束加载，处理是否缓存及派发完成事件 <code>Event.COMPLETE</code> 。
	*@param content 加载后的数据
	*/
	__proto.endLoad=function(content){
		content && (this._data=content);
		if (this._cache)Loader.cacheRes(this._url,this._data);
		this.event(/*laya.events.Event.PROGRESS*/"progress",1);
		this.event(/*laya.events.Event.COMPLETE*/"complete",(this.data instanceof Array)? [this.data] :this.data);
	}

	/**加载地址。*/
	__getset(0,__proto,'url',function(){
		return this._url;
	});

	/**返回的数据。*/
	__getset(0,__proto,'data',function(){
		return this._data;
	});

	/**是否缓存。*/
	__getset(0,__proto,'cache',function(){
		return this._cache;
	});

	/**加载类型。*/
	__getset(0,__proto,'type',function(){
		return this._type;
	});

	Loader.checkNext=function(){
		Loader._isWorking=true;
		var startTimer=Browser.now();
		var thisTimer=startTimer;
		while (Loader._startIndex < Loader._loaders.length){
			thisTimer=Browser.now();
			Loader._loaders[Loader._startIndex].endLoad();
			Loader._startIndex++;
			if (Browser.now()-startTimer > Loader.maxTimeOut){
				console.warn("loader callback cost a long time:"+(Browser.now()-startTimer)+" url="+Loader._loaders[Loader._startIndex-1].url);
				Laya.timer.frameOnce(1,null,Loader.checkNext);
				return;
			}
		}
		Loader._loaders.length=0;
		Loader._startIndex=0;
		Loader._isWorking=false;
	}

	Loader.clearRes=function(url,forceDispose){
		(forceDispose===void 0)&& (forceDispose=false);
		url=URL.formatURL(url);
		var arr=Loader.getAtlas(url);
		if (arr){
			for (var i=0,n=arr.length;i < n;i++){
				var resUrl=arr[i];
				var tex=Loader.getRes(resUrl);
				delete Loader.loadedMap[resUrl];
				if (tex)tex.destroy(forceDispose);
			}
			arr.length=0;
			delete Loader.atlasMap[url];
			delete Loader.loadedMap[url];
			}else {
			var res=Loader.loadedMap[url];
			if (res){
				delete Loader.loadedMap[url];
				if ((res instanceof laya.resource.Texture )&& res.bitmap)(res).destroy(forceDispose);
			}
		}
	}

	Loader.clearTextureRes=function(url){
		url=URL.formatURL(url);
		var arr=laya.net.Loader.getAtlas(url);
		var res=(arr && arr.length>0)? laya.net.Loader.getRes(arr[0]):laya.net.Loader.getRes(url);
		if (res && res.bitmap){
			if (Render.isConchApp){
				if (res.bitmap.source.releaseTexture){
					res.bitmap.source.releaseTexture();
				}
				}else if (res.bitmap._atlaser==null){
				res.bitmap.releaseResource(true);
			}
		}
	}

	Loader.getRes=function(url){
		return Loader.loadedMap[URL.formatURL(url)];
	}

	Loader.getAtlas=function(url){
		return Loader.atlasMap[URL.formatURL(url)];
	}

	Loader.cacheRes=function(url,data){
		url=URL.formatURL(url);
		if (Loader.loadedMap[url] !=null){
			console.warn("Resources already exist,is repeated loading:",url);
			}else {
			Loader.loadedMap[url]=data;
		}
	}

	Loader.setGroup=function(url,group){
		if (!Loader.groupMap[group])Loader.groupMap[group]=[];
		Loader.groupMap[group].push(url);
	}

	Loader.clearResByGroup=function(group){
		if (!Loader.groupMap[group])return;
		var arr=Loader.groupMap[group],i=0,len=arr.length;
		for (i=0;i < len;i++){
			Loader.clearRes(arr[i]);
		}
		arr.length=0;
	}

	Loader.TEXT="text";
	Loader.JSON="json";
	Loader.XML="xml";
	Loader.BUFFER="arraybuffer";
	Loader.IMAGE="image";
	Loader.SOUND="sound";
	Loader.ATLAS="atlas";
	Loader.FONT="font";
	Loader.TTF="ttf";
	Loader.PLF="plf";
	Loader.PKM="pkm";
	Loader.typeMap={"png":"image","jpg":"image","jpeg":"image","txt":"text","json":"json","xml":"xml","als":"atlas","atlas":"atlas","mp3":"sound","ogg":"sound","wav":"sound","part":"json","fnt":"font","pkm":"pkm","ttf":"ttf","plf":"plf"};
	Loader.parserMap={};
	Loader.groupMap={};
	Loader.maxTimeOut=100;
	Loader.loadedMap={};
	Loader.preLoadedMap={};
	Loader.atlasMap={};
	Loader._loaders=[];
	Loader._isWorking=false;
	Loader._startIndex=0;
	Loader.imgCache={};
	return Loader;
})(EventDispatcher)


/**
*<p> <code>LoaderManager</code> 类用于用于批量加载资源。此类是单例，不要手动实例化此类，请通过Laya.loader访问。</p>
*<p>全部队列加载完成，会派发 Event.COMPLETE 事件；如果队列中任意一个加载失败，会派发 Event.ERROR 事件，事件回调参数值为加载出错的资源地址。</p>
*<p> <code>LoaderManager</code> 类提供了以下几种功能：<br/>
*多线程：默认5个加载线程，可以通过maxLoader属性修改线程数量；<br/>
*多优先级：有0-4共5个优先级，优先级高的优先加载。0最高，4最低；<br/>
*重复过滤：自动过滤重复加载（不会有多个相同地址的资源同时加载）以及复用缓存资源，防止重复加载；<br/>
*错误重试：资源加载失败后，会重试加载（以最低优先级插入加载队列），retryNum设定加载失败后重试次数，retryDelay设定加载重试的时间间隔。</p>
*@see laya.net.Loader
*/
//class laya.net.LoaderManager extends laya.events.EventDispatcher
var LoaderManager=(function(_super){
	var ResInfo;
	function LoaderManager(){
		/**加载出错后的重试次数，默认重试一次*/
		this.retryNum=1;
		/**延迟时间多久再进行错误重试，默认立即重试*/
		this.retryDelay=0;
		/**最大下载线程，默认为5个*/
		this.maxLoader=5;
		/**@private */
		this._loaders=[];
		/**@private */
		this._loaderCount=0;
		/**@private */
		this._resInfos=[];
		/**@private */
		this._infoPool=[];
		/**@private */
		this._maxPriority=5;
		/**@private */
		this._failRes={};
		LoaderManager.__super.call(this);
		for (var i=0;i < this._maxPriority;i++)this._resInfos[i]=[];
	}

	__class(LoaderManager,'laya.net.LoaderManager',_super);
	var __proto=LoaderManager.prototype;
	/**
	*<p>根据clas类型创建一个未初始化资源的对象，随后进行异步加载，资源加载完成后，初始化对象的资源，并通过此对象派发 Event.LOADED 事件，事件回调参数值为此对象本身。套嵌资源的子资源会保留资源路径"?"后的部分。</p>
	*<p>如果url为数组，返回true；否则返回指定的资源类对象，可以通过侦听此对象的 Event.LOADED 事件来判断资源是否已经加载完毕。</p>
	*<p><b>注意：</b>cache参数只能对文件后缀为atlas的资源进行缓存控制，其他资源会忽略缓存，强制重新加载。</p>
	*@param url 资源地址或者数组。如果url和clas同时指定了资源类型，优先使用url指定的资源类型。参数形如：[{url:xx,clas:xx,priority:xx,params:xx},{url:xx,clas:xx,priority:xx,params:xx}]。
	*@param complete 加载结束回调。根据url类型不同分为2种情况：1. url为String类型，也就是单个资源地址，如果加载成功，则回调参数值为加载完成的资源，否则为null；2. url为数组类型，指定了一组要加载的资源，如果全部加载成功，则回调参数值为true，否则为false。
	*@param progress 资源加载进度回调，回调参数值为当前资源加载的进度信息(0-1)。
	*@param clas 资源类名。如果url和clas同时指定了资源类型，优先使用url指定的资源类型。参数形如：Texture。
	*@param params 资源构造参数。
	*@param priority (default=1)加载的优先级，优先级高的优先加载。有0-4共5个优先级，0最高，4最低。
	*@param cache 是否缓存加载的资源。
	*@return 如果url为数组，返回true；否则返回指定的资源类对象。
	*/
	__proto.create=function(url,complete,progress,clas,params,priority,cache,group){
		(priority===void 0)&& (priority=1);
		(cache===void 0)&& (cache=true);
		if ((url instanceof Array)){
			var items=url;
			var itemCount=items.length;
			var loadedCount=0;
			if (progress){
				var progress2=Handler.create(progress.caller,progress.method,progress.args,false);
			}
			for (var i=0;i < itemCount;i++){
				var item=items[i];
				if ((typeof item=='string'))
					item=items[i]={url:item};
				item.progress=0;
			}
			for (i=0;i < itemCount;i++){
				item=items[i];
				var progressHandler=progress ? Handler.create(null,onProgress,[item],false):null;
				var completeHandler=(progress || complete)? Handler.create(null,onComplete,[item]):null;
				this._create(item.url,completeHandler,progressHandler,item.clas || clas,item.params || params,item.priority || priority,cache,item.group || group);
			}
			function onComplete (item,content){
				loadedCount++;
				item.progress=1;
				if (loadedCount===itemCount && complete){
					complete.run();
				}
			}
			function onProgress (item,value){
				item.progress=value;
				var num=0;
				for (var j=0;j < itemCount;j++){
					var item1=items[j];
					num+=item1.progress;
				};
				var v=num / itemCount;
				progress2.runWith(v);
			}
			return true;
		}else return this._create(url,complete,progress,clas,params,priority,cache,group);
	}

	__proto._create=function(url,complete,progress,clas,params,priority,cache,group){
		(priority===void 0)&& (priority=1);
		(cache===void 0)&& (cache=true);
		var formarUrl=URL.formatURL(url);
		var item=this.getRes(formarUrl);
		if (!item){
			var extension=Utils.getFileExtension(url);
			var creatItem=LoaderManager.createMap[extension];
			if (!creatItem)
				throw new Error("LoaderManager:unknown file("+url+") extension with: "+extension+".");
			if (!clas)clas=creatItem[0];
			var type=creatItem[1];
			if (extension=="atlas"){
				this.load(url,complete,progress,type,priority,cache);
				}else {
				if (clas===Texture)type="htmlimage";
				item=clas ? new clas():null;
				if (item.hasOwnProperty("_loaded"))
					item._loaded=false;
				item._setUrl(url);
				(group)&& (item._setGroup(group));
				this._createLoad(item,url,Handler.create(null,onLoaded),progress,type,priority,false,group,true);
				function onLoaded (data){
					(item && !item.destroyed && data)&& (item.onAsynLoaded.call(item,url,data,params));
					if (complete)complete.run();
					Laya.loader.event(url);
				}
				(cache)&& (this.cacheRes(formarUrl,item));
			}
			}else {
			if (!item.hasOwnProperty("loaded")|| item.loaded){
				progress && progress.runWith(1);
				complete && complete.run();
				}else if (complete){
				Laya.loader._createListener(url,complete.caller,complete.method,complete.args,true,false);
			}
		}
		return item;
	}

	/**
	*<p>加载资源。资源加载错误时，本对象会派发 Event.ERROR 事件，事件回调参数值为加载出错的资源地址。</p>
	*<p>因为返回值为 LoaderManager 对象本身，所以可以使用如下语法：Laya.loader.load(...).load(...);</p>
	*@param url 要加载的单个资源地址或资源信息数组。比如：简单数组：["a.png","b.png"]；复杂数组[{url:"a.png",type:Loader.IMAGE,size:100,priority:1},{url:"b.json",type:Loader.JSON,size:50,priority:1}]。
	*@param complete 加载结束回调。根据url类型不同分为2种情况：1. url为String类型，也就是单个资源地址，如果加载成功，则回调参数值为加载完成的资源，否则为null；2. url为数组类型，指定了一组要加载的资源，如果全部加载成功，则回调参数值为true，否则为false。
	*@param progress 加载进度回调。回调参数值为当前资源的加载进度信息(0-1)。
	*@param type 资源类型。比如：Loader.IMAGE。
	*@param priority (default=1)加载的优先级，优先级高的优先加载。有0-4共5个优先级，0最高，4最低。
	*@param cache 是否缓存加载结果。
	*@param group 分组，方便对资源进行管理。
	*@param ignoreCache 是否忽略缓存，强制重新加载。
	*@return 此 LoaderManager 对象本身。
	*/
	__proto.load=function(url,complete,progress,type,priority,cache,group,ignoreCache){
		var _$this=this;
		(priority===void 0)&& (priority=1);
		(cache===void 0)&& (cache=true);
		(ignoreCache===void 0)&& (ignoreCache=false);
		if ((url instanceof Array))return this._loadAssets(url,complete,progress,type,priority,cache,group);
		var content=Loader.getRes(url);
		if (content !=null){
			Laya.timer.frameOnce(1,null,function(){
				progress && progress.runWith(1);
				complete && complete.runWith(content);
				_$this._loaderCount || _$this.event(/*laya.events.Event.COMPLETE*/"complete");
			});
			}else {
			var info=LoaderManager._resMap[url];
			if (!info){
				info=this._infoPool.length ? this._infoPool.pop():new ResInfo();
				info.url=url;
				info.type=type;
				info.cache=cache;
				info.group=group;
				info.ignoreCache=ignoreCache;
				complete && info.on(/*laya.events.Event.COMPLETE*/"complete",complete.caller,complete.method,complete.args);
				progress && info.on(/*laya.events.Event.PROGRESS*/"progress",progress.caller,progress.method,progress.args);
				LoaderManager._resMap[url]=info;
				priority=priority < this._maxPriority ? priority :this._maxPriority-1;
				this._resInfos[priority].push(info);
				this._next();
				}else {
				complete && info._createListener(/*laya.events.Event.COMPLETE*/"complete",complete.caller,complete.method,complete.args,false,false);
				progress && info._createListener(/*laya.events.Event.PROGRESS*/"progress",progress.caller,progress.method,progress.args,false,false);
			}
		}
		return this;
	}

	/**
	*@private
	*/
	__proto._createLoad=function(item,url,complete,progress,type,priority,cache,group,ignoreCache){
		var _$this=this;
		(priority===void 0)&& (priority=1);
		(cache===void 0)&& (cache=true);
		(ignoreCache===void 0)&& (ignoreCache=false);
		if ((url instanceof Array))return this._loadAssets(url,complete,progress,type,priority,cache,group);
		var content=Loader.getRes(url);
		if (content !=null){
			Laya.timer.frameOnce(1,null,function(){
				progress && progress.runWith(1);
				complete && complete.runWith(content);
				_$this._loaderCount || _$this.event(/*laya.events.Event.COMPLETE*/"complete");
			});
			}else {
			var info=LoaderManager._resMap[url];
			if (!info){
				info=this._infoPool.length ? this._infoPool.pop():new ResInfo();
				info.url=url;
				info.clas=item;
				info.type=type;
				info.cache=cache;
				info.group=group;
				info.ignoreCache=ignoreCache;
				complete && info.on(/*laya.events.Event.COMPLETE*/"complete",complete.caller,complete.method,complete.args);
				progress && info.on(/*laya.events.Event.PROGRESS*/"progress",progress.caller,progress.method,progress.args);
				LoaderManager._resMap[url]=info;
				priority=priority < this._maxPriority ? priority :this._maxPriority-1;
				this._resInfos[priority].push(info);
				this._next();
				}else {
				complete && info._createListener(/*laya.events.Event.COMPLETE*/"complete",complete.caller,complete.method,complete.args,false,false);
				progress && info._createListener(/*laya.events.Event.PROGRESS*/"progress",progress.caller,progress.method,progress.args,false,false);
			}
		}
		return this;
	}

	__proto._next=function(){
		if (this._loaderCount >=this.maxLoader)return;
		for (var i=0;i < this._maxPriority;i++){
			var infos=this._resInfos[i];
			while (infos.length > 0){
				var info=infos.shift();
				if (info)return this._doLoad(info);
			}
		}
		this._loaderCount || this.event(/*laya.events.Event.COMPLETE*/"complete");
	}

	__proto._doLoad=function(resInfo){
		this._loaderCount++;
		var loader=this._loaders.length ? this._loaders.pop():new Loader();
		loader.on(/*laya.events.Event.COMPLETE*/"complete",null,onLoaded);
		loader.on(/*laya.events.Event.PROGRESS*/"progress",null,function(num){
			resInfo.event(/*laya.events.Event.PROGRESS*/"progress",num);
		});
		loader.on(/*laya.events.Event.ERROR*/"error",null,function(msg){
			onLoaded(null);
		});
		var _this=this;
		function onLoaded (data){
			loader.offAll();
			loader._data=null;
			loader._customParse=false;
			_this._loaders.push(loader);
			_this._endLoad(resInfo,(data instanceof Array)? [data] :data);
			_this._loaderCount--;
			_this._next();
		}
		loader._class=resInfo.clas;
		loader.load(resInfo.url,resInfo.type,resInfo.cache,resInfo.group,resInfo.ignoreCache);
	}

	__proto._endLoad=function(resInfo,content){
		var url=resInfo.url;
		if (content==null){
			var errorCount=this._failRes[url] || 0;
			if (errorCount < this.retryNum){
				console.warn("[warn]Retry to load:",url);
				this._failRes[url]=errorCount+1;
				Laya.timer.once(this.retryDelay,this,this._addReTry,[resInfo],false);
				return;
				}else {
				console.warn("[error]Failed to load:",url);
				this.event(/*laya.events.Event.ERROR*/"error",url);
			}
		}
		if (this._failRes[url])this._failRes[url]=0;
		delete LoaderManager._resMap[url];
		resInfo.event(/*laya.events.Event.COMPLETE*/"complete",content);
		resInfo.offAll();
		this._infoPool.push(resInfo);
	}

	__proto._addReTry=function(resInfo){
		this._resInfos[this._maxPriority-1].push(resInfo);
		this._next();
	}

	/**
	*清理指定资源地址缓存。
	*@param url 资源地址。
	*@param forceDispose 是否强制销毁，有些资源是采用引用计数方式销毁，如果forceDispose=true，则忽略引用计数，直接销毁，比如Texture，默认为false
	*/
	__proto.clearRes=function(url,forceDispose){
		(forceDispose===void 0)&& (forceDispose=false);
		Loader.clearRes(url,forceDispose);
	}

	/**
	*获取指定资源地址的资源。
	*@param url 资源地址。
	*@return 返回资源。
	*/
	__proto.getRes=function(url){
		return Loader.getRes(url);
	}

	/**
	*缓存资源。
	*@param url 资源地址。
	*@param data 要缓存的内容。
	*/
	__proto.cacheRes=function(url,data){
		Loader.cacheRes(url,data);
	}

	/**
	*销毁Texture使用的图片资源，保留texture壳，如果下次渲染的时候，发现texture使用的图片资源不存在，则会自动恢复
	*相比clearRes，clearTextureRes只是清理texture里面使用的图片资源，并不销毁texture，再次使用到的时候会自动恢复图片资源
	*而clearRes会彻底销毁texture，导致不能再使用；clearTextureRes能确保立即销毁图片资源，并且不用担心销毁错误，clearRes则采用引用计数方式销毁
	*【注意】如果图片本身在自动合集里面（默认图片小于512*512），内存是不能被销毁的，此图片被大图合集管理器管理
	*@param url 图集地址或者texture地址，比如 Loader.clearTextureRes("res/atlas/comp.atlas");Loader.clearTextureRes("hall/bg.jpg");
	*/
	__proto.clearTextureRes=function(url){
		Loader.clearTextureRes(url);
	}

	/**
	*设置资源分组。
	*@param url 资源地址。
	*@param group 分组名
	*/
	__proto.setGroup=function(url,group){
		Loader.setGroup(url,group);
	}

	/**
	*根据分组清理资源。
	*@param group 分组名
	*/
	__proto.clearResByGroup=function(group){
		Loader.clearResByGroup(group);
	}

	/**清理当前未完成的加载，所有未加载的内容全部停止加载。*/
	__proto.clearUnLoaded=function(){
		for (var i=0;i < this._maxPriority;i++){
			var infos=this._resInfos[i];
			for (var j=infos.length-1;j >-1;j--){
				var info=infos[j];
				if (info){
					info.offAll();
					this._infoPool.push(info);
				}
			}
			infos.length=0;
		}
		this._loaderCount=0;
		LoaderManager._resMap={};
	}

	/**
	*根据地址集合清理掉未加载的内容
	*@param urls 资源地址集合
	*/
	__proto.cancelLoadByUrls=function(urls){
		if (!urls)return;
		for (var i=0,n=urls.length;i < n;i++){
			this.cancelLoadByUrl(urls[i]);
		}
	}

	/**
	*根据地址清理掉未加载的内容
	*@param url 资源地址
	*/
	__proto.cancelLoadByUrl=function(url){
		for (var i=0;i < this._maxPriority;i++){
			var infos=this._resInfos[i];
			for (var j=infos.length-1;j >-1;j--){
				var info=infos[j];
				if (info && info.url===url){
					infos[j]=null;
					info.offAll();
					this._infoPool.push(info);
				}
			}
		}
		if (LoaderManager._resMap[url])delete LoaderManager._resMap[url];
	}

	/**
	*@private
	*加载数组里面的资源。
	*@param arr 简单：["a.png","b.png"]，复杂[{url:"a.png",type:Loader.IMAGE,size:100,priority:1},{url:"b.json",type:Loader.JSON,size:50,priority:1}]*/
	__proto._loadAssets=function(arr,complete,progress,type,priority,cache,group){
		(priority===void 0)&& (priority=1);
		(cache===void 0)&& (cache=true);
		var itemCount=arr.length;
		var loadedCount=0;
		var totalSize=0;
		var items=[];
		var success=true;
		for (var i=0;i < itemCount;i++){
			var item=arr[i];
			if ((typeof item=='string'))item={url:item,type:type,size:1,priority:priority};
			if (!item.size)item.size=1;
			item.progress=0;
			totalSize+=item.size;
			items.push(item);
			var progressHandler=progress ? Handler.create(null,loadProgress,[item],false):null;
			var completeHandler=(complete || progress)? Handler.create(null,loadComplete,[item]):null;
			this.load(item.url,completeHandler,progressHandler,item.type,item.priority || 1,cache,item.group || group);
		}
		function loadComplete (item,content){
			loadedCount++;
			item.progress=1;
			if (!content)success=false;
			if (loadedCount===itemCount && complete){
				complete.runWith(success);
			}
		}
		function loadProgress (item,value){
			if (progress !=null){
				item.progress=value;
				var num=0;
				for (var j=0;j < items.length;j++){
					var item1=items[j];
					num+=item1.size *item1.progress;
				};
				var v=num / totalSize;
				progress.runWith(v);
			}
		}
		return this;
	}

	LoaderManager.cacheRes=function(url,data){
		Loader.cacheRes(url,data);
	}

	LoaderManager._resMap={};
	__static(LoaderManager,
	['createMap',function(){return this.createMap={atlas:[null,/*laya.net.Loader.ATLAS*/"atlas"]};}
	]);
	LoaderManager.__init$=function(){
		//class ResInfo extends laya.events.EventDispatcher
		ResInfo=(function(_super){
			function ResInfo(){
				this.url=null;
				this.type=null;
				this.cache=false;
				this.group=null;
				this.ignoreCache=false;
				this.clas=null;
				ResInfo.__super.call(this);
			}
			__class(ResInfo,'',_super);
			return ResInfo;
		})(EventDispatcher)
	}

	return LoaderManager;
})(EventDispatcher)


/**
*<p><code>ColorFilter</code> 是颜色滤镜。使用 ColorFilter 类可以将 4 x 5 矩阵转换应用于输入图像上的每个像素的 RGBA 颜色和 Alpha 值，以生成具有一组新的 RGBA 颜色和 Alpha 值的结果。该类允许饱和度更改、色相旋转、亮度转 Alpha 以及各种其他效果。您可以将滤镜应用于任何显示对象（即，从 Sprite 类继承的对象）。</p>
*<p>注意：对于 RGBA 值，最高有效字节代表红色通道值，其后的有效字节分别代表绿色、蓝色和 Alpha 通道值。</p>
*/
//class laya.filters.ColorFilter extends laya.filters.Filter
var ColorFilter=(function(_super){
	function ColorFilter(mat){
		/**@private */
		//this._mat=null;
		/**@private */
		//this._alpha=null;
		ColorFilter.__super.call(this);
		if (!mat){
			mat=[0.3,0.59,0.11,0,0,0.3,0.59,0.11,0,0,0.3,0.59,0.11,0,0,0,0,0,1,0];
		}
		this._mat=new Float32Array(16);
		this._alpha=new Float32Array(4);
		var j=0;
		var z=0;
		for (var i=0;i < 20;i++){
			if (i % 5 !=4){
				this._mat[j++]=mat[i];
				}else {
				this._alpha[z++]=mat[i];
			}
		}
		this._action=RunDriver.createFilterAction(0x20);
		this._action.data=this;
	}

	__class(ColorFilter,'laya.filters.ColorFilter',_super);
	var __proto=ColorFilter.prototype;
	Laya.imps(__proto,{"laya.filters.IFilter":true})
	/**
	*@private 通知微端
	*/
	__proto.callNative=function(sp){
		var t=sp._$P.cf=this;
		sp.conchModel && sp.conchModel.setFilterMatrix && sp.conchModel.setFilterMatrix(this._mat,this._alpha);
	}

	/**@private */
	__getset(0,__proto,'type',function(){
		return 0x20;
	});

	/**@private */
	__getset(0,__proto,'action',function(){
		return this._action;
	});

	return ColorFilter;
})(Filter)


/**
*<p> <code>Socket</code> 封装了 HTML5 WebSocket ，允许服务器端与客户端进行全双工（full-duplex）的实时通信，并且允许跨域通信。在建立连接后，服务器和 Browser/Client Agent 都能主动的向对方发送或接收文本和二进制数据。</p>
*<p>要使用 <code>Socket</code> 类的方法，请先使用构造函数 <code>new Socket</code> 创建一个 <code>Socket</code> 对象。 <code>Socket</code> 以异步方式传输和接收数据。</p>
*/
//class laya.net.Socket extends laya.events.EventDispatcher
var Socket=(function(_super){
	function Socket(host,port,byteClass){
		/**@private */
		this._endian=null;
		/**@private */
		this._stamp=NaN;
		/**@private */
		this._socket=null;
		/**@private */
		this._connected=false;
		/**@private */
		this._addInputPosition=0;
		/**@private */
		this._input=null;
		/**@private */
		this._output=null;
		/**
		*@private
		*表示建立连接时需等待的毫秒数。
		*/
		this.timeout=0;
		/**
		*@private
		*在写入或读取对象时，控制所使用的 AMF 的版本。
		*/
		this.objectEncoding=0;
		/**
		*不再缓存服务端发来的数据。
		*/
		this.disableInput=false;
		/**
		*用来发送和接收数据的 <code>Byte</code> 类。
		*/
		this._byteClass=null;
		/**
		*<p>子协议名称。子协议名称字符串，或由多个子协议名称字符串构成的数组。必须在调用 connect 或者 connectByUrl 之前进行赋值，否则无效。</p>
		*<p>指定后，只有当服务器选择了其中的某个子协议，连接才能建立成功，否则建立失败，派发 Event.ERROR 事件。</p>
		*@see https://html.spec.whatwg.org/multipage/comms.html#dom-websocket
		*/
		this.protocols=[];
		(port===void 0)&& (port=0);
		Socket.__super.call(this);
		this._byteClass=byteClass ? byteClass :Byte;
		this.endian="bigEndian";
		this.timeout=20000;
		this._addInputPosition=0;
		if (host && port > 0 && port < 65535)
			this.connect(host,port);
	}

	__class(Socket,'laya.net.Socket',_super);
	var __proto=Socket.prototype;
	/**
	*<p>连接到指定的主机和端口。</p>
	*<p>连接成功派发 Event.OPEN 事件；连接失败派发 Event.ERROR 事件；连接被关闭派发 Event.CLOSE 事件；接收到数据派发 Event.MESSAGE 事件； 除了 Event.MESSAGE 事件参数为数据内容，其他事件参数都是原生的 HTML DOM Event 对象。</p>
	*@param host 服务器地址。
	*@param port 服务器端口。
	*/
	__proto.connect=function(host,port){
		var url="ws://"+host+":"+port;
		if (Browser.window.location.protocol=="https:"){
			url="wss://"+host+":"+port;
			}else {
			url="ws://"+host+":"+port;
		}
		this.connectByUrl(url);
	}

	/**
	*<p>连接到指定的服务端 WebSocket URL。 URL 类似 ws://yourdomain:port。</p>
	*<p>连接成功派发 Event.OPEN 事件；连接失败派发 Event.ERROR 事件；连接被关闭派发 Event.CLOSE 事件；接收到数据派发 Event.MESSAGE 事件； 除了 Event.MESSAGE 事件参数为数据内容，其他事件参数都是原生的 HTML DOM Event 对象。</p>
	*@param url 要连接的服务端 WebSocket URL。 URL 类似 ws://yourdomain:port。
	*/
	__proto.connectByUrl=function(url){
		var _$this=this;
		if (this._socket !=null)
			this.close();
		this._socket && this.cleanSocket();
		if (!this.protocols || this.protocols.length==0){
			this._socket=new Browser.window.WebSocket(url);
			}else {
			this._socket=new Browser.window.WebSocket(url,this.protocols);
		}
		this._socket.binaryType="arraybuffer";
		this._output=new this._byteClass();
		this._output.endian=this.endian;
		this._input=new this._byteClass();
		this._input.endian=this.endian;
		this._addInputPosition=0;
		this._socket.onopen=function (e){
			_$this._onOpen(e);
		};
		this._socket.onmessage=function (msg){
			_$this._onMessage(msg);
		};
		this._socket.onclose=function (e){
			_$this._onClose(e);
		};
		this._socket.onerror=function (e){
			_$this._onError(e);
		};
	}

	/**
	*清理socket。
	*/
	__proto.cleanSocket=function(){
		try {
			this._socket.close();
		}catch (e){}
		this._connected=false;
		this._socket.onopen=null;
		this._socket.onmessage=null;
		this._socket.onclose=null;
		this._socket.onerror=null;
		this._socket=null;
	}

	/**
	*关闭连接。
	*/
	__proto.close=function(){
		if (this._socket !=null){
			try {
				this._socket.close();
			}catch (e){}
		}
	}

	/**
	*@private
	*连接建立成功 。
	*/
	__proto._onOpen=function(e){
		this._connected=true;
		this.event(/*laya.events.Event.OPEN*/"open",e);
	}

	/**
	*@private
	*接收到数据处理方法。
	*@param msg 数据。
	*/
	__proto._onMessage=function(msg){
		if (!msg || !msg.data)return;
		var data=msg.data;
		if (this.disableInput && data){
			this.event(/*laya.events.Event.MESSAGE*/"message",data);
			return;
		}
		if (this._input.length > 0 && this._input.bytesAvailable < 1){
			this._input.clear();
			this._addInputPosition=0;
		};
		var pre=this._input.pos;
		!this._addInputPosition && (this._addInputPosition=0);
		this._input.pos=this._addInputPosition;
		if (data){
			if ((typeof data=='string')){
				this._input.writeUTFBytes(data);
				}else {
				this._input.writeArrayBuffer(data);
			}
			this._addInputPosition=this._input.pos;
			this._input.pos=pre;
		}
		this.event(/*laya.events.Event.MESSAGE*/"message",data);
	}

	/**
	*@private
	*连接被关闭处理方法。
	*/
	__proto._onClose=function(e){
		this._connected=false;
		this.event(/*laya.events.Event.CLOSE*/"close",e)
	}

	/**
	*@private
	*出现异常处理方法。
	*/
	__proto._onError=function(e){
		this.event(/*laya.events.Event.ERROR*/"error",e)
	}

	/**
	*发送数据到服务器。
	*@param data 需要发送的数据，可以是String或者ArrayBuffer。
	*/
	__proto.send=function(data){
		this._socket.send(data);
	}

	/**
	*发送缓冲区中的数据到服务器。
	*/
	__proto.flush=function(){
		if (this._output && this._output.length > 0){
			var evt;
			try {
				this._socket && this._socket.send(this._output.__getBuffer().slice(0,this._output.length));
				}catch (e){
				evt=e;
			}
			this._output.endian=this.endian;
			this._output.clear();
			if (evt)this.event(/*laya.events.Event.ERROR*/"error",evt);
		}
	}

	/**
	*缓存的服务端发来的数据。
	*/
	__getset(0,__proto,'input',function(){
		return this._input;
	});

	/**
	*表示需要发送至服务端的缓冲区中的数据。
	*/
	__getset(0,__proto,'output',function(){
		return this._output;
	});

	/**
	*表示此 Socket 对象目前是否已连接。
	*/
	__getset(0,__proto,'connected',function(){
		return this._connected;
	});

	/**
	*<p>主机字节序，是 CPU 存放数据的两种不同顺序，包括小端字节序和大端字节序。</p>
	*<p> LITTLE_ENDIAN ：小端字节序，地址低位存储值的低位，地址高位存储值的高位。</p>
	*<p> BIG_ENDIAN ：大端字节序，地址低位存储值的高位，地址高位存储值的低位。</p>
	*/
	__getset(0,__proto,'endian',function(){
		return this._endian;
		},function(value){
		this._endian=value;
		if (this._input !=null)this._input.endian=value;
		if (this._output !=null)this._output.endian=value;
	});

	Socket.LITTLE_ENDIAN="littleEndian";
	Socket.BIG_ENDIAN="bigEndian";
	return Socket;
})(EventDispatcher)


/**
*@private
*Worker Image加载器
*/
//class laya.net.WorkerLoader extends laya.events.EventDispatcher
var WorkerLoader=(function(_super){
	function WorkerLoader(){
		/**
		*使用的Worker对象。
		*/
		this.worker=null;
		WorkerLoader.__super.call(this);
		var _$this=this;
		this.worker=new Browser.window.Worker(WorkerLoader.workerPath);
		this.worker.onmessage=function (evt){
			_$this.workerMessage(evt.data);
		}
	}

	__class(WorkerLoader,'laya.net.WorkerLoader',_super);
	var __proto=WorkerLoader.prototype;
	/**
	*@private
	*/
	__proto.workerMessage=function(data){
		if (data){
			switch(data.type){
				case "Image":
					this.imageLoaded(data);
					break ;
				case "Msg":
					this.event("image_msg",data.msg);
					break ;
				}
		}
	}

	/**
	*@private
	*/
	__proto.imageLoaded=function(data){
		if (data && data.buffer && data.buffer.length < 10){
			WorkerLoader._enable=false;
			this._myTrace("buffer lost when postmessage ,disable workerloader");
			this.event(data.url,null);
			this.event("image_err",data.url+"\n"+data.msg);
			return;
		}
		if (!data.dataType){
			this.event(data.url,null);
			this.event("image_err",data.url+"\n"+data.msg);
			return;
		};
		var canvas,ctx;
		var imageData;
		switch(data.dataType){
			case "buffer":
				canvas=new HTMLCanvas("2D");
				ctx=canvas.source.getContext("2d");
				imageData=ctx.createImageData(data.width,data.height);
				imageData.data.set(data.buffer);
				canvas.size(imageData.width,imageData.height);
				ctx.putImageData(imageData,0,0);
				canvas.memorySize=0;
				break ;
			case "imagedata":
				canvas=new HTMLCanvas("2D");
				ctx=canvas.source.getContext("2d");
				imageData=data.imagedata;
				canvas.size(imageData.width,imageData.height);
				ctx.putImageData(imageData,0,0);
				imageData=data.imagedata;
				canvas.memorySize=0;
				break ;
			case "imageBitmap":
				imageData=data.imageBitmap;
				if (!Render.isWebGL){
					canvas=new HTMLCanvas("2D");
					ctx=canvas.source.getContext("2d");
					canvas.size(imageData.width,imageData.height);
					ctx.drawImage(imageData,0,0);
					canvas.src=data.url;
				}else
				canvas=imageData;
				break ;
			}
		if (Render.isWebGL)
			/*__JS__ */canvas=new laya.webgl.resource.WebGLImage(canvas,data.url);;
		this.event(data.url,canvas);
	}

	/**
	*@private
	*/
	__proto._myTrace=function(__arg){
		var arg=arguments;
		var rst=[];
		var i=0,len=arg.length;
		for(i=0;i<len;i++){
			rst.push(arg[i]);
		}
		this.event("image_msg",rst.join(" "));
	}

	/**
	*加载图片
	*@param url 图片地址
	*/
	__proto.loadImage=function(url){
		var data;
		data={};
		data.type="load";
		data.url=url;
		this.worker.postMessage(data);
	}

	/**
	*@private
	*加载图片资源。
	*@param url 资源地址。
	*/
	__proto._loadImage=function(url){
		var _this=this;
		if (!WorkerLoader._enable||url.toLowerCase().indexOf(".png")< 0){
			WorkerLoader._preLoadFun.call(_this,url);
			return;
		}
		url=URL.formatURL(url);
		function clear (){
			laya.net.WorkerLoader.I.off(url,_this,onload);
		};
		var onload=function (image){
			clear();
			if (image){
				_this["onLoaded"](image);
				}else{
				WorkerLoader._preLoadFun.call(_this,url);
			}
		};
		laya.net.WorkerLoader.I.on(url,_this,onload);
		laya.net.WorkerLoader.I.loadImage(url);
	}

	/**
	*是否启用。
	*/
	__getset(1,WorkerLoader,'enable',function(){
		return WorkerLoader._enable;
		},function(v){
		if (WorkerLoader.disableJSDecode && (!Browser.window.createImageBitmap))return;
		WorkerLoader._enable=v;
		if (WorkerLoader._enable && WorkerLoader._preLoadFun==null)WorkerLoader._enable=WorkerLoader.__init__();
	});

	WorkerLoader.__init__=function(){
		if (WorkerLoader._preLoadFun !=null)return false;
		if (!Browser.window.Worker)return false;
		WorkerLoader._preLoadFun=Loader["prototype"]["_loadImage"];
		Loader["prototype"]["_loadImage"]=WorkerLoader["prototype"]["_loadImage"];
		if (!WorkerLoader.I)WorkerLoader.I=new WorkerLoader();
		return true;
	}

	WorkerLoader.workerSupported=function(){
		return Browser.window.Worker?true:false;
	}

	WorkerLoader.IMAGE_LOADED="image_loaded";
	WorkerLoader.IMAGE_ERR="image_err";
	WorkerLoader.IMAGE_MSG="image_msg";
	WorkerLoader.I=null;
	WorkerLoader._preLoadFun=null;
	WorkerLoader._enable=false;
	WorkerLoader.workerPath="libs/worker.js";
	WorkerLoader.disableJSDecode=true;
	return WorkerLoader;
})(EventDispatcher)


/**
*@private
*<code>Resource</code> 资源存取类。
*/
//class laya.resource.Resource extends laya.events.EventDispatcher
var Resource=(function(_super){
	function Resource(){
		/**@private */
		//this.__loaded=false;
		/**@private */
		//this._id=0;
		/**@private */
		//this._memorySize=0;
		/**@private */
		//this._released=false;
		/**@private */
		//this._destroyed=false;
		/**@private */
		//this._referenceCount=0;
		/**@private */
		//this._group=null;
		/**@private */
		//this._url=null;
		/**@private */
		//this._resourceManager=null;
		/**@private */
		//this._lastUseFrameCount=0;
		/**是否加锁，如果true为不能使用自动释放机制。*/
		//this.lock=false;
		/**名称。 */
		//this.name=null;
		Resource.__super.call(this);
		this._$1__id=++Resource._uniqueIDCounter;
		this.__loaded=true;
		this._destroyed=false;
		this._referenceCount=0;
		Resource._idResourcesMap[this.id]=this;
		this._released=true;
		this.lock=false;
		this._memorySize=0;
		this._lastUseFrameCount=-1;
		(ResourceManager.currentResourceManager)&& (ResourceManager.currentResourceManager.addResource(this));
	}

	__class(Resource,'laya.resource.Resource',_super);
	var __proto=Resource.prototype;
	Laya.imps(__proto,{"laya.resource.ICreateResource":true,"laya.resource.IDispose":true})
	/**
	*@private
	*/
	__proto._setUrl=function(url){
		if (this._url!==url){
			var resList;
			if (this._url){
				resList=Resource._urlResourcesMap[this._url];
				resList.splice(resList.indexOf(this),1);
				(resList.length===0)&& (delete Resource._urlResourcesMap[this._url]);
			}
			if (url){
				resList=Resource._urlResourcesMap[url];
				(resList)|| (Resource._urlResourcesMap[url]=resList=[]);
				resList.push(this);
			}
			this._url=url;
		}
	}

	/**
	*@private
	*/
	__proto._getGroup=function(){
		return this._group;
	}

	/**
	*@private
	*/
	__proto._setGroup=function(value){
		if (this._group!==value){
			var groupList;
			if (this._group){
				groupList=Resource._groupResourcesMap[this._group];
				groupList.splice(groupList.indexOf(this),1);
				(groupList.length===0)&& (delete Resource._groupResourcesMap[this._group]);
			}
			if (value){
				groupList=Resource._groupResourcesMap[value];
				(groupList)|| (Resource._groupResourcesMap[value]=groupList=[]);
				groupList.push(this);
			}
			this._group=value;
		}
	}

	/**
	*@private
	*/
	__proto._addReference=function(){
		this._referenceCount++;
	}

	/**
	*@private
	*/
	__proto._removeReference=function(){
		this._referenceCount--;
	}

	/**
	*@private
	*/
	__proto._clearReference=function(){
		this._referenceCount=0;
	}

	/**
	*@private
	*/
	__proto._endLoaded=function(){
		this.__loaded=true;
		this.event(/*laya.events.Event.LOADED*/"loaded",this);
	}

	/**
	*@private
	*/
	__proto.recreateResource=function(){
		this.completeCreate();
	}

	/**
	*@private
	*/
	__proto.disposeResource=function(){}
	/**
	*激活资源，使用资源前应先调用此函数激活。
	*@param force 是否强制创建。
	*/
	__proto.activeResource=function(force){
		(force===void 0)&& (force=false);
		this._lastUseFrameCount=Stat.loopCount;
		if (!this._destroyed && this.__loaded && (this._released || force))
			this.recreateResource();
	}

	/**
	*释放资源。
	*@param force 是否强制释放。
	*@return 是否成功释放。
	*/
	__proto.releaseResource=function(force){
		(force===void 0)&& (force=false);
		if (!force && this.lock)
			return false;
		if (!this._released || force){
			this.disposeResource();
			this._released=true;
			this._lastUseFrameCount=-1;
			this.event(/*laya.events.Event.RELEASED*/"released",this);
			return true;
			}else {
			return false;
		}
	}

	/**
	*@private
	*/
	__proto.onAsynLoaded=function(url,data,params){
		throw new Error("Resource: must override this function!");
	}

	/**
	*<p>彻底处理资源，处理后不能恢复。</p>
	*<p><b>注意：</b>会强制解锁清理。</p>
	*/
	__proto.destroy=function(){
		if (this._destroyed)
			return;
		if (this._resourceManager!==null)
			this._resourceManager.removeResource(this);
		this._destroyed=true;
		this.lock=false;
		this.releaseResource();
		delete Resource._idResourcesMap[this.id];
		var resList;
		if (this._url){
			resList=Resource._urlResourcesMap[this._url];
			if (resList){
				resList.splice(resList.indexOf(this),1);
				(resList.length===0)&& (delete Resource._urlResourcesMap[this.url]);
			}
			Loader.clearRes(this._url);
			(this.__loaded)||(RunDriver.cancelLoadByUrl(this._url));
		}
		if (this._group){
			resList=Resource._groupResourcesMap[this._group];
			resList.splice(resList.indexOf(this),1);
			(resList.length===0)&& (delete Resource._groupResourcesMap[this.url]);
		}
	}

	/**完成资源激活。*/
	__proto.completeCreate=function(){
		this._released=false;
		this.event(/*laya.events.Event.RECOVERED*/"recovered",this);
	}

	/**
	*@private
	*/
	__proto.dispose=function(){
		this.destroy();
	}

	/**
	*@private
	*/
	/**
	*占用内存尺寸。
	*/
	__getset(0,__proto,'memorySize',function(){
		return this._memorySize;
		},function(value){
		var offsetValue=value-this._memorySize;
		this._memorySize=value;
		this.resourceManager && this.resourceManager.addSize(offsetValue);
	});

	/**
	*@private
	*/
	__getset(0,__proto,'_loaded',null,function(value){
		this.__loaded=value;
	});

	/**
	*获取是否已加载完成。
	*/
	__getset(0,__proto,'loaded',function(){
		return this.__loaded;
	});

	/**
	*获取唯一标识ID,通常用于识别。
	*/
	__getset(0,__proto,'id',function(){
		return this._$1__id;
	});

	/**
	*是否已处理。
	*/
	__getset(0,__proto,'destroyed',function(){
		return this._destroyed;
	});

	/**
	*设置资源组名。
	*/
	/**
	*获取资源组名。
	*/
	__getset(0,__proto,'group',function(){
		return this._getGroup();
		},function(value){
		this._setGroup(value);
	});

	/**
	*资源管理员。
	*/
	__getset(0,__proto,'resourceManager',function(){
		return this._resourceManager;
	});

	/**
	*获取资源的URL地址。
	*@return URL地址。
	*/
	__getset(0,__proto,'url',function(){
		return this._url;
	});

	/**
	*是否已释放。
	*/
	__getset(0,__proto,'released',function(){
		return this._released;
	});

	/**
	*获取资源的引用计数。
	*/
	__getset(0,__proto,'referenceCount',function(){
		return this._referenceCount;
	});

	Resource.getResourceByID=function(id){
		return Resource._idResourcesMap[id];
	}

	Resource.getResourceByURL=function(url,index){
		(index===void 0)&& (index=0);
		return Resource._urlResourcesMap[url][index];
	}

	Resource.getResourceCountByURL=function(url){
		return Resource._urlResourcesMap[url].length;
	}

	Resource.destroyUnusedResources=function(group){
		var res;
		if (group){
			var resouList=Resource._groupResourcesMap[group];
			if (resouList){
				var tempResouList=resouList.slice();
				for (var i=0,n=tempResouList.length;i < n;i++){
					res=tempResouList[i];
					if (!res.lock && res._referenceCount===0)
						res.destroy();
				}
			}
			}else {
			for (var k in Resource._idResourcesMap){
				res=Resource._idResourcesMap[k];
				if (!res.lock && res._referenceCount===0)
					res.destroy();
			}
		}
	}

	Resource._uniqueIDCounter=0;
	Resource._idResourcesMap={};
	Resource._urlResourcesMap={};
	Resource._groupResourcesMap={};
	return Resource;
})(EventDispatcher)


/**
*<code>Texture</code> 是一个纹理处理类。
*/
//class laya.resource.Texture extends laya.events.EventDispatcher
var Texture=(function(_super){
	function Texture(bitmap,uv){
		/**图片或者canvas 。*/
		//this.bitmap=null;
		/**UV信息。*/
		//this.uv=null;
		/**沿 X 轴偏移量。*/
		this.offsetX=0;
		/**沿 Y 轴偏移量。*/
		this.offsetY=0;
		/**原始宽度（包括被裁剪的透明区域）。*/
		this.sourceWidth=0;
		/**原始高度（包括被裁剪的透明区域）。*/
		this.sourceHeight=0;
		/**@private */
		//this._loaded=false;
		/**@private */
		this._w=0;
		/**@private */
		this._h=0;
		/**@private 唯一ID*/
		//this.$_GID=NaN;
		/**图片地址*/
		//this.url=null;
		/**@private */
		this._uvID=0;
		this._atlasID=-1;
		/**@private */
		this.scaleRate=1;
		Texture.__super.call(this);
		if (bitmap && bitmap._addReference!=null){
			bitmap._addReference();
		}
		this.setTo(bitmap,uv);
	}

	__class(Texture,'laya.resource.Texture',_super);
	var __proto=Texture.prototype;
	/**
	*@private
	*/
	__proto._setUrl=function(url){
		this.url=url;
	}

	/**
	*设置此对象的位图资源、UV数据信息。
	*@param bitmap 位图资源
	*@param uv UV数据信息
	*/
	__proto.setTo=function(bitmap,uv){
		if (/*__JS__ */bitmap instanceof window.HTMLElement){
			var canvas=HTMLCanvas.create("2D",bitmap);
			this.bitmap=canvas;
			}else{
			this.bitmap=bitmap;
		}
		this.uv=uv || Texture.DEF_UV;
		if (bitmap){
			this._w=bitmap.width;
			this._h=bitmap.height;
			this.sourceWidth=this.sourceWidth || this._w;
			this.sourceHeight=this.sourceHeight || this._h
			this._loaded=this._w > 0;
			var _this=this;
			if (this._loaded){
				RunDriver.addToAtlas && RunDriver.addToAtlas(_this);
				}else {
				var bm=bitmap;
				if ((bm instanceof laya.resource.HTMLImage )&& bm.image)
					bm.image.addEventListener('load',function(e){
					RunDriver.addToAtlas && RunDriver.addToAtlas(_this);
				},false);
			}
		}
	}

	/**@private 激活资源。*/
	__proto.active=function(){
		if (this.bitmap)this.bitmap.activeResource();
	}

	/**
	*销毁纹理（分直接销毁，跟计数销毁两种）。
	*@param forceDispose (default=false)true为强制销毁主纹理，false是通过计数销毁纹理。
	*/
	__proto.destroy=function(forceDispose){
		(forceDispose===void 0)&& (forceDispose=false);
		if (this.bitmap && (this.bitmap).referenceCount > 0){
			var temp=this.bitmap;
			if (forceDispose){
				if (Render.isConchApp && temp.source && temp.source.conchDestroy){
					this.bitmap.source.conchDestroy();
				}
				this.bitmap=null;
				temp.dispose();
				(temp)._clearReference();
				}else {
				(temp)._removeReference();
				if ((temp).referenceCount==0){
					if (Render.isConchApp && temp.source && temp.source.conchDestroy){
						this.bitmap.source.conchDestroy();
					}
					this.bitmap=null;
					temp.dispose();
				}
			}
			if (this.url && this===Laya.loader.getRes(this.url))Laya.loader.clearRes(this.url,forceDispose);
			this._loaded=false;
		}
	}

	/**
	*加载指定地址的图片。
	*@param url 图片地址。
	*/
	__proto.load=function(url){
		var _$this=this;
		this._loaded=false;
		url=URL.customFormat(url);
		var fileBitmap=(this.bitmap || (this.bitmap=HTMLImage.create(url)));
		if (fileBitmap)fileBitmap._addReference();
		var _this=this;
		fileBitmap.onload=function (){
			fileBitmap.onload=null;
			_this._loaded=true;
			_$this.sourceWidth=_$this._w=fileBitmap.width;
			_$this.sourceHeight=_$this._h=fileBitmap.height;
			_this.event(/*laya.events.Event.LOADED*/"loaded",this);
			(RunDriver.addToAtlas)&& (RunDriver.addToAtlas(_this));
		};
	}

	/**@private */
	__proto.addTextureToAtlas=function(e){
		RunDriver.addTextureToAtlas(this);
	}

	/**
	*获取Texture上的某个区域的像素点
	*@param x
	*@param y
	*@param width
	*@param height
	*@return 返回像素点集合
	*/
	__proto.getPixels=function(x,y,width,height){
		if (Render.isConchApp){
			var temp=this.bitmap;
			if (temp.source && temp.source.getImageData){
				var arraybuffer=temp.source.getImageData(x,y,width,height);
				var tUint8Array=new Uint8Array(arraybuffer);
				return /*__JS__ */Array.from(tUint8Array);
			}
			return null;
			}else if (Render.isWebGL){
			return RunDriver.getTexturePixels(this,x,y,width,height);
			}else {
			Browser.canvas.size(width,height);
			Browser.canvas.clear();
			Browser.context.drawTexture(this,-x,-y,this.width,this.height,0,0);
			var info=Browser.context.getImageData(0,0,width,height);
		}
		return info.data;
	}

	/**@private */
	__proto.onAsynLoaded=function(url,bitmap){
		if (bitmap)bitmap._addReference();
		this.setTo(bitmap,this.uv);
	}

	/**激活并获取资源。*/
	__getset(0,__proto,'source',function(){
		if (!this.bitmap)return null;
		this.bitmap.activeResource();
		return this.bitmap.source;
	});

	/**
	*表示是否加载成功，只能表示初次载入成功（通常包含下载和载入）,并不能完全表示资源是否可立即使用（资源管理机制释放影响等）。
	*/
	__getset(0,__proto,'loaded',function(){
		return this._loaded;
	});

	/**
	*表示资源是否已释放。
	*/
	__getset(0,__proto,'released',function(){
		if (!this.bitmap)return true;
		return this.bitmap.released;
	});

	/**实际宽度。*/
	__getset(0,__proto,'width',function(){
		if (this._w)return this._w;
		return (this.uv && this.uv!==Texture.DEF_UV)? (this.uv[2]-this.uv[0])*this.bitmap.width :this.bitmap.width;
		},function(value){
		this._w=value;
		this.sourceWidth || (this.sourceWidth=value);
	});

	/**
	*通过外部设置是否启用纹理平铺(后面要改成在着色器里计算)
	*/
	/**
	*获取当前纹理是否启用了纹理平铺
	*/
	__getset(0,__proto,'repeat',function(){
		if (Render.isWebGL && this.bitmap){
			return this.bitmap.repeat;
		}
		return true;
		},function(value){
		if (value){
			if (Render.isWebGL && this.bitmap){
				this.bitmap.repeat=value;
				if (value){
					this.bitmap.enableMerageInAtlas=false;
				}
			}
		}
	});

	/**实际高度。*/
	__getset(0,__proto,'height',function(){
		if (this._h)return this._h;
		return (this.uv && this.uv!==Texture.DEF_UV)? (this.uv[5]-this.uv[1])*this.bitmap.height :this.bitmap.height;
		},function(value){
		this._h=value;
		this.sourceHeight || (this.sourceHeight=value);
	});

	/**
	*设置线性采样的状态（目前只能第一次绘制前设置false生效,来关闭线性采样）。
	*/
	/**
	*获取当前纹理是否启用了线性采样。
	*/
	__getset(0,__proto,'isLinearSampling',function(){
		return Render.isWebGL ? (this.bitmap.minFifter !=0x2600):true;
		},function(value){
		if (!value && Render.isWebGL){
			if (!value && (this.bitmap.minFifter==-1)&& (this.bitmap.magFifter==-1)){
				this.bitmap.minFifter=0x2600;
				this.bitmap.magFifter=0x2600;
				this.bitmap.enableMerageInAtlas=false;
			}
		}
	});

	Texture.moveUV=function(offsetX,offsetY,uv){
		for (var i=0;i < 8;i+=2){
			uv[i]+=offsetX;
			uv[i+1]+=offsetY;
		}
		return uv;
	}

	Texture.create=function(source,x,y,width,height,offsetX,offsetY,sourceWidth,sourceHeight){
		(offsetX===void 0)&& (offsetX=0);
		(offsetY===void 0)&& (offsetY=0);
		(sourceWidth===void 0)&& (sourceWidth=0);
		(sourceHeight===void 0)&& (sourceHeight=0);
		var btex=(source instanceof laya.resource.Texture );
		var uv=btex ? source.uv :Texture.DEF_UV;
		var bitmap=btex ? source.bitmap :source;
		var bIsAtlas=RunDriver.isAtlas(bitmap);
		if (bIsAtlas){
			var atlaser=bitmap._atlaser;
			var nAtlasID=(source)._atlasID;
			if (nAtlasID==-1){
				throw new Error("create texture error");
			}
			bitmap=atlaser._inAtlasTextureBitmapValue[nAtlasID];
			uv=atlaser._inAtlasTextureOriUVValue[nAtlasID];
		};
		var tex=new Texture(bitmap,null);
		if (bitmap.width && (x+width)> bitmap.width)width=bitmap.width-x;
		if (bitmap.height && (y+height)> bitmap.height)height=bitmap.height-y;
		tex.width=width;
		tex.height=height;
		tex.offsetX=offsetX;
		tex.offsetY=offsetY;
		tex.sourceWidth=sourceWidth || width;
		tex.sourceHeight=sourceHeight || height;
		var dwidth=1 / bitmap.width;
		var dheight=1 / bitmap.height;
		x *=dwidth;
		y *=dheight;
		width *=dwidth;
		height *=dheight;
		var u1=tex.uv[0],v1=tex.uv[1],u2=tex.uv[4],v2=tex.uv[5];
		var inAltasUVWidth=(u2-u1),inAltasUVHeight=(v2-v1);
		var oriUV=Texture.moveUV(uv[0],uv[1],[x,y,x+width,y,x+width,y+height,x,y+height]);
		tex.uv=[u1+oriUV[0] *inAltasUVWidth,v1+oriUV[1] *inAltasUVHeight,u2-(1-oriUV[2])*inAltasUVWidth,v1+oriUV[3] *inAltasUVHeight,u2-(1-oriUV[4])*inAltasUVWidth,v2-(1-oriUV[5])*inAltasUVHeight,u1+oriUV[6] *inAltasUVWidth,v2-(1-oriUV[7])*inAltasUVHeight];
		if (bIsAtlas){
			tex.addTextureToAtlas();
		};
		var bitmapScale=bitmap.scaleRate;
		if (bitmapScale && bitmapScale !=1){
			tex.sourceWidth /=bitmapScale;
			tex.sourceHeight /=bitmapScale;
			tex.width /=bitmapScale;
			tex.height /=bitmapScale;
			tex.scaleRate=bitmapScale;
			tex.offsetX /=bitmapScale;
			tex.offsetY /=bitmapScale;
			}else{
			tex.scaleRate=1;
		}
		return tex;
	}

	Texture.createFromTexture=function(texture,x,y,width,height){
		var texScaleRate=texture.scaleRate;
		if (texScaleRate !=1){
			x *=texScaleRate;
			y *=texScaleRate;
			width *=texScaleRate;
			height *=texScaleRate;
		};
		var rect=Rectangle.TEMP.setTo(x-texture.offsetX,y-texture.offsetY,width,height);
		var result=rect.intersection(Texture._rect1.setTo(0,0,texture.width,texture.height),Texture._rect2);
		if (result)
			var tex=Texture.create(texture,result.x,result.y,result.width,result.height,result.x-rect.x,result.y-rect.y,width,height);
		else return null;
		tex.bitmap._removeReference();
		return tex;
	}

	Texture.DEF_UV=[0,0,1.0,0,1.0,1.0,0,1.0];
	Texture.INV_UV=[0,1,1.0,1,1.0,0.0,0,0.0];
	Texture._rect1=new Rectangle();
	Texture._rect2=new Rectangle();
	return Texture;
})(EventDispatcher)


/**
*<code>TimeLine</code> 是一个用来创建时间轴动画的类。
*/
//class laya.utils.TimeLine extends laya.events.EventDispatcher
var TimeLine=(function(_super){
	var tweenData;
	function TimeLine(){
		this._labelDic=null;
		this._tweenDic={};
		this._tweenDataList=[];
		this._endTweenDataList=null;
		//以结束时间进行排序
		this._currTime=0;
		this._lastTime=0;
		this._startTime=0;
		/**当前动画数据播放到第几个了*/
		this._index=0;
		/**为TWEEN创建属于自己的唯一标识，方便管理*/
		this._gidIndex=0;
		/**保留所有对象第一次注册动画时的状态（根据时间跳转时，需要把对象的回复，再计算接下来的状态）*/
		this._firstTweenDic={};
		/**是否需要排序*/
		this._startTimeSort=false;
		this._endTimeSort=false;
		/**是否循环*/
		this._loopKey=false;
		/**缩放动画播放的速度。*/
		this.scale=1;
		this._frameRate=60;
		this._frameIndex=0;
		this._total=0;
		TimeLine.__super.call(this);
	}

	__class(TimeLine,'laya.utils.TimeLine',_super);
	var __proto=TimeLine.prototype;
	/**
	*控制一个对象，从当前点移动到目标点。
	*@param target 要控制的对象。
	*@param props 要控制对象的属性。
	*@param duration 对象TWEEN的时间。
	*@param ease 缓动类型
	*@param offset 相对于上一个对象，偏移多长时间（单位：毫秒）。
	*/
	__proto.to=function(target,props,duration,ease,offset){
		(offset===void 0)&& (offset=0);
		return this._create(target,props,duration,ease,offset,true);
	}

	/**
	*从 props 属性，缓动到当前状态。
	*@param target target 目标对象(即将更改属性值的对象)
	*@param props 要控制对象的属性
	*@param duration 对象TWEEN的时间
	*@param ease 缓动类型
	*@param offset 相对于上一个对象，偏移多长时间（单位：毫秒）
	*/
	__proto.from=function(target,props,duration,ease,offset){
		(offset===void 0)&& (offset=0);
		return this._create(target,props,duration,ease,offset,false);
	}

	/**@private */
	__proto._create=function(target,props,duration,ease,offset,isTo){
		var tTweenData=Pool.getItemByClass("tweenData",tweenData);
		tTweenData.isTo=isTo;
		tTweenData.type=0;
		tTweenData.target=target;
		tTweenData.duration=duration;
		tTweenData.data=props;
		tTweenData.startTime=this._startTime+offset;
		tTweenData.endTime=tTweenData.startTime+tTweenData.duration;
		tTweenData.ease=ease;
		this._startTime=Math.max(tTweenData.endTime,this._startTime);
		this._tweenDataList.push(tTweenData);
		this._startTimeSort=true;
		this._endTimeSort=true;
		return this;
	}

	/**
	*在时间队列中加入一个标签。
	*@param label 标签名称。
	*@param offset 标签相对于上个动画的偏移时间(单位：毫秒)。
	*/
	__proto.addLabel=function(label,offset){
		var tTweenData=Pool.getItemByClass("tweenData",tweenData);
		tTweenData.type=1;
		tTweenData.data=label;
		tTweenData.endTime=tTweenData.startTime=this._startTime+offset;
		this._labelDic || (this._labelDic={});
		this._labelDic[label]=tTweenData;
		this._tweenDataList.push(tTweenData);
		return this;
	}

	/**
	*移除指定的标签
	*@param label
	*/
	__proto.removeLabel=function(label){
		if (this._labelDic && this._labelDic[label]){
			var tTweenData=this._labelDic[label];
			if (tTweenData){
				var tIndex=this._tweenDataList.indexOf(tTweenData);
				if (tIndex >-1){
					this._tweenDataList.splice(tIndex,1);
				}
			}
			delete this._labelDic[label];
		}
	}

	/**
	*动画从整个动画的某一时间开始。
	*@param time(单位：毫秒)。
	*/
	__proto.gotoTime=function(time){
		if (this._tweenDataList==null || this._tweenDataList.length==0)return;
		var tTween;
		var tObject;
		for (var p in this._firstTweenDic){
			tObject=this._firstTweenDic[p];
			if (tObject){
				for (var tDataP in tObject){
					if (tObject.diyTarget.hasOwnProperty(tDataP)){
						tObject.diyTarget[tDataP]=tObject[tDataP];
					}
				}
			}
		}
		for (p in this._tweenDic){
			tTween=this._tweenDic[p];
			tTween.clear();
			delete this._tweenDic[p];
		}
		this._index=0;
		this._gidIndex=0;
		this._currTime=time;
		this._lastTime=Browser.now();
		var tTweenDataCopyList;
		if (this._endTweenDataList==null || this._endTimeSort){
			this._endTimeSort=false;
			this._endTweenDataList=tTweenDataCopyList=this._tweenDataList.concat();
			function Compare (paraA,paraB){
				if (paraA.endTime > paraB.endTime){
					return 1;
					}else if (paraA.endTime < paraB.endTime){
					return-1;
					}else {
					return 0;
				}
			}
			tTweenDataCopyList.sort(Compare);
			}else {
			tTweenDataCopyList=this._endTweenDataList
		};
		var tTweenData;
		for (var i=0,n=tTweenDataCopyList.length;i < n;i++){
			tTweenData=tTweenDataCopyList[i];
			if (tTweenData.type==0){
				if (time >=tTweenData.endTime){
					this._index=Math.max(this._index,i+1);
					var props=tTweenData.data;
					if (tTweenData.isTo){
						for (var tP in props){
							tTweenData.target[tP]=props[tP];
						}
					}
					}else {
					break ;
				}
			}
		}
		for (i=0,n=this._tweenDataList.length;i < n;i++){
			tTweenData=this._tweenDataList[i];
			if (tTweenData.type==0){
				if (time >=tTweenData.startTime && time < tTweenData.endTime){
					this._index=Math.max(this._index,i+1);
					this._gidIndex++;
					tTween=Pool.getItemByClass("tween",Tween);
					tTween._create(tTweenData.target,tTweenData.data,tTweenData.duration,tTweenData.ease,Handler.create(this,this._animComplete,[this._gidIndex]),0,false,tTweenData.isTo,true,false);
					tTween.setStartTime(this._currTime-(time-tTweenData.startTime));
					tTween._updateEase(this._currTime);
					tTween.gid=this._gidIndex;
					this._tweenDic[this._gidIndex]=tTween;
				}
			}
		}
	}

	/**
	*从指定的标签开始播。
	*@param Label 标签名。
	*/
	__proto.gotoLabel=function(Label){
		if (this._labelDic==null)return;
		var tLabelData=this._labelDic[Label];
		if (tLabelData)this.gotoTime(tLabelData.startTime);
	}

	/**
	*暂停整个动画。
	*/
	__proto.pause=function(){
		Laya.timer.clear(this,this._update);
	}

	/**
	*恢复暂停动画的播放。
	*/
	__proto.resume=function(){
		this.play(this._currTime,this._loopKey);
	}

	/**
	*播放动画。
	*@param timeOrLabel 开启播放的时间点或标签名。
	*@param loop 是否循环播放。
	*/
	__proto.play=function(timeOrLabel,loop){
		(timeOrLabel===void 0)&& (timeOrLabel=0);
		(loop===void 0)&& (loop=false);
		if (!this._tweenDataList)return;
		if (this._startTimeSort){
			this._startTimeSort=false;
			function Compare (paraA,paraB){
				if (paraA.startTime > paraB.startTime){
					return 1;
					}else if (paraA.startTime < paraB.startTime){
					return-1;
					}else {
					return 0;
				}
			}
			this._tweenDataList.sort(Compare);
			for (var i=0,n=this._tweenDataList.length;i < n;i++){
				var tTweenData=this._tweenDataList[i];
				if (tTweenData !=null && tTweenData.type==0){
					var tTarget=tTweenData.target;
					var gid=(tTarget.$_GID || (tTarget.$_GID=Utils.getGID()));
					var tSrcData=null;
					if (this._firstTweenDic[gid]==null){
						tSrcData={};
						tSrcData.diyTarget=tTarget;
						this._firstTweenDic[gid]=tSrcData;
						}else {
						tSrcData=this._firstTweenDic[gid];
					}
					for (var p in tTweenData.data){
						if (tSrcData[p]==null){
							tSrcData[p]=tTarget[p];
						}
					}
				}
			}
		}
		if ((typeof timeOrLabel=='string')){
			this.gotoLabel(timeOrLabel);
			}else {
			this.gotoTime(timeOrLabel);
		}
		this._loopKey=loop;
		this._lastTime=Browser.now();
		Laya.timer.frameLoop(1,this,this._update);
	}

	/**
	*更新当前动画。
	*/
	__proto._update=function(){
		if (this._currTime >=this._startTime){
			if (this._loopKey){
				this._complete();
				if (!this._tweenDataList)return;
				this.gotoTime(0);
				}else {
				for (var p in this._tweenDic){
					tTween=this._tweenDic[p];
					tTween.complete();
				}
				this._complete();
				this.pause();
				return;
			}
		};
		var tNow=Browser.now();
		var tFrameTime=tNow-this._lastTime;
		var tCurrTime=this._currTime+=tFrameTime *this.scale;
		this._lastTime=tNow;
		for (p in this._tweenDic){
			tTween=this._tweenDic[p];
			tTween._updateEase(tCurrTime);
		};
		var tTween;
		if (this._tweenDataList.length !=0 && this._index < this._tweenDataList.length){
			var tTweenData=this._tweenDataList[this._index];
			if (tCurrTime >=tTweenData.startTime){
				this._index++;
				if (tTweenData.type==0){
					this._gidIndex++;
					tTween=Pool.getItemByClass("tween",Tween);
					tTween._create(tTweenData.target,tTweenData.data,tTweenData.duration,tTweenData.ease,Handler.create(this,this._animComplete,[this._gidIndex]),0,false,tTweenData.isTo,true,false);
					tTween.setStartTime(tCurrTime);
					tTween.gid=this._gidIndex;
					this._tweenDic[this._gidIndex]=tTween;
					tTween._updateEase(tCurrTime);
					}else {
					this.event(/*laya.events.Event.LABEL*/"label",tTweenData.data);
				}
			}
		}
	}

	/**
	*指定的动画索引处的动画播放完成后，把此动画从列表中删除。
	*@param index
	*/
	__proto._animComplete=function(index){
		var tTween=this._tweenDic[index];
		if (tTween)delete this._tweenDic[index];
	}

	/**@private */
	__proto._complete=function(){
		this.event(/*laya.events.Event.COMPLETE*/"complete");
	}

	/**
	*重置所有对象，复用对象的时候使用。
	*/
	__proto.reset=function(){
		var p;
		if (this._labelDic){
			for (p in this._labelDic){
				delete this._labelDic[p];
			}
		};
		var tTween;
		for (p in this._tweenDic){
			tTween=this._tweenDic[p];
			tTween.clear();
			delete this._tweenDic[p];
		}
		for (p in this._firstTweenDic){
			delete this._firstTweenDic[p];
		}
		this._endTweenDataList=null;
		if (this._tweenDataList && this._tweenDataList.length){
			var i=0,len=0;
			len=this._tweenDataList.length;
			for (i=0;i < len;i++){
				if(this._tweenDataList[i])
					this._tweenDataList[i].destroy();
			}
		}
		this._tweenDataList.length=0;
		this._currTime=0;
		this._lastTime=0;
		this._startTime=0;
		this._index=0;
		this._gidIndex=0;
		this.scale=1;
		Laya.timer.clear(this,this._update);
	}

	/**
	*彻底销毁此对象。
	*/
	__proto.destroy=function(){
		this.reset();
		this._labelDic=null;
		this._tweenDic=null;
		this._tweenDataList=null;
		this._firstTweenDic=null;
	}

	/**
	*@private
	*设置帧索引
	*/
	/**
	*@private
	*得到帧索引
	*/
	__getset(0,__proto,'index',function(){
		return this._frameIndex;
		},function(value){
		this._frameIndex=value;
		this.gotoTime(this._frameIndex / this._frameRate *1000);
	});

	/**
	*得到总帧数。
	*/
	__getset(0,__proto,'total',function(){
		this._total=Math.floor(this._startTime / 1000 *this._frameRate);
		return this._total;
	});

	TimeLine.to=function(target,props,duration,ease,offset){
		(offset===void 0)&& (offset=0);
		return (new TimeLine()).to(target,props,duration,ease,offset);
	}

	TimeLine.from=function(target,props,duration,ease,offset){
		(offset===void 0)&& (offset=0);
		return (new TimeLine()).from(target,props,duration,ease,offset);
	}

	TimeLine.__init$=function(){
		//class tweenData
		tweenData=(function(){
			function tweenData(){
				this.type=0;
				//0代表TWEEN,1代表标签
				this.isTo=true;
				this.startTime=NaN;
				this.endTime=NaN;
				this.target=null;
				this.duration=NaN;
				this.ease=null;
				this.data=null;
			}
			__class(tweenData,'');
			var __proto=tweenData.prototype;
			__proto.destroy=function(){
				this.target=null;
				this.ease=null;
				this.data=null;
				this.isTo=true;
				this.type=0;
				Pool.recover("tweenData",this);
			}
			return tweenData;
		})()
	}

	return TimeLine;
})(EventDispatcher)


/**
*<p> <code>Sprite</code> 是基本的显示图形的显示列表节点。 <code>Sprite</code> 默认没有宽高，默认不接受鼠标事件。通过 <code>graphics</code> 可以绘制图片或者矢量图，支持旋转，缩放，位移等操作。<code>Sprite</code>同时也是容器类，可用来添加多个子节点。</p>
*<p>注意： <code>Sprite</code> 默认没有宽高，可以通过<code>getBounds</code>函数获取；也可手动设置宽高；还可以设置<code>autoSize=true</code>，然后再获取宽高。<code>Sprite</code>的宽高一般用于进行碰撞检测和排版，并不影响显示图像大小，如果需要更改显示图像大小，请使用 <code>scaleX</code> ， <code>scaleY</code> ， <code>scale</code>。</p>
*<p> <code>Sprite</code> 默认不接受鼠标事件，即<code>mouseEnabled=false</code>，但是只要对其监听任意鼠标事件，会自动打开自己以及所有父对象的<code>mouseEnabled=true</code>。所以一般也无需手动设置<code>mouseEnabled</code>。</p>
*<p>LayaAir引擎API设计精简巧妙。核心显示类只有一个<code>Sprite</code>。<code>Sprite</code>针对不同的情况做了渲染优化，所以保证一个类实现丰富功能的同时，又达到高性能。</p>
*
*@example <caption>创建了一个 <code>Sprite</code> 实例。</caption>
*package
*{
	*import laya.display.Sprite;
	*import laya.events.Event;
	*
	*public class Sprite_Example
	*{
		*private var sprite:Sprite;
		*private var shape:Sprite
		*public function Sprite_Example()
		*{
			*Laya.init(640,800);//设置游戏画布宽高、渲染模式。
			*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
			*onInit();
			*}
		*private function onInit():void
		*{
			*sprite=new Sprite();//创建一个 Sprite 类的实例对象 sprite 。
			*sprite.loadImage("resource/ui/bg.png");//加载并显示图片。
			*sprite.x=200;//设置 sprite 对象相对于父容器的水平方向坐标值。
			*sprite.y=200;//设置 sprite 对象相对于父容器的垂直方向坐标值。
			*sprite.pivotX=0;//设置 sprite 对象的水平方法轴心点坐标。
			*sprite.pivotY=0;//设置 sprite 对象的垂直方法轴心点坐标。
			*Laya.stage.addChild(sprite);//将此 sprite 对象添加到显示列表。
			*sprite.on(Event.CLICK,this,onClickSprite);//给 sprite 对象添加点击事件侦听。
			*shape=new Sprite();//创建一个 Sprite 类的实例对象 sprite 。
			*shape.graphics.drawRect(0,0,100,100,"#ccff00","#ff0000",2);//绘制一个有边框的填充矩形。
			*shape.x=400;//设置 shape 对象相对于父容器的水平方向坐标值。
			*shape.y=200;//设置 shape 对象相对于父容器的垂直方向坐标值。
			*shape.width=100;//设置 shape 对象的宽度。
			*shape.height=100;//设置 shape 对象的高度。
			*shape.pivotX=50;//设置 shape 对象的水平方法轴心点坐标。
			*shape.pivotY=50;//设置 shape 对象的垂直方法轴心点坐标。
			*Laya.stage.addChild(shape);//将此 shape 对象添加到显示列表。
			*shape.on(Event.CLICK,this,onClickShape);//给 shape 对象添加点击事件侦听。
			*}
		*private function onClickSprite():void
		*{
			*trace("点击 sprite 对象。");
			*sprite.rotation+=5;//旋转 sprite 对象。
			*}
		*private function onClickShape():void
		*{
			*trace("点击 shape 对象。");
			*shape.rotation+=5;//旋转 shape 对象。
			*}
		*}
	*}
*
*@example
*var sprite;
*var shape;
*Sprite_Example();
*function Sprite_Example()
*{
	*Laya.init(640,800);//设置游戏画布宽高、渲染模式。
	*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
	*onInit();
	*}
*function onInit()
*{
	*sprite=new laya.display.Sprite();//创建一个 Sprite 类的实例对象 sprite 。
	*sprite.loadImage("resource/ui/bg.png");//加载并显示图片。
	*sprite.x=200;//设置 sprite 对象相对于父容器的水平方向坐标值。
	*sprite.y=200;//设置 sprite 对象相对于父容器的垂直方向坐标值。
	*sprite.pivotX=0;//设置 sprite 对象的水平方法轴心点坐标。
	*sprite.pivotY=0;//设置 sprite 对象的垂直方法轴心点坐标。
	*Laya.stage.addChild(sprite);//将此 sprite 对象添加到显示列表。
	*sprite.on(Event.CLICK,this,onClickSprite);//给 sprite 对象添加点击事件侦听。
	*shape=new laya.display.Sprite();//创建一个 Sprite 类的实例对象 sprite 。
	*shape.graphics.drawRect(0,0,100,100,"#ccff00","#ff0000",2);//绘制一个有边框的填充矩形。
	*shape.x=400;//设置 shape 对象相对于父容器的水平方向坐标值。
	*shape.y=200;//设置 shape 对象相对于父容器的垂直方向坐标值。
	*shape.width=100;//设置 shape 对象的宽度。
	*shape.height=100;//设置 shape 对象的高度。
	*shape.pivotX=50;//设置 shape 对象的水平方法轴心点坐标。
	*shape.pivotY=50;//设置 shape 对象的垂直方法轴心点坐标。
	*Laya.stage.addChild(shape);//将此 shape 对象添加到显示列表。
	*shape.on(laya.events.Event.CLICK,this,onClickShape);//给 shape 对象添加点击事件侦听。
	*}
*function onClickSprite()
*{
	*console.log("点击 sprite 对象。");
	*sprite.rotation+=5;//旋转 sprite 对象。
	*}
*function onClickShape()
*{
	*console.log("点击 shape 对象。");
	*shape.rotation+=5;//旋转 shape 对象。
	*}
*
*@example
*import Sprite=laya.display.Sprite;
*class Sprite_Example {
	*private sprite:Sprite;
	*private shape:Sprite
	*public Sprite_Example(){
		*Laya.init(640,800);//设置游戏画布宽高、渲染模式。
		*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
		*this.onInit();
		*}
	*private onInit():void {
		*this.sprite=new Sprite();//创建一个 Sprite 类的实例对象 sprite 。
		*this.sprite.loadImage("resource/ui/bg.png");//加载并显示图片。
		*this.sprite.x=200;//设置 sprite 对象相对于父容器的水平方向坐标值。
		*this.sprite.y=200;//设置 sprite 对象相对于父容器的垂直方向坐标值。
		*this.sprite.pivotX=0;//设置 sprite 对象的水平方法轴心点坐标。
		*this.sprite.pivotY=0;//设置 sprite 对象的垂直方法轴心点坐标。
		*Laya.stage.addChild(this.sprite);//将此 sprite 对象添加到显示列表。
		*this.sprite.on(laya.events.Event.CLICK,this,this.onClickSprite);//给 sprite 对象添加点击事件侦听。
		*this.shape=new Sprite();//创建一个 Sprite 类的实例对象 sprite 。
		*this.shape.graphics.drawRect(0,0,100,100,"#ccff00","#ff0000",2);//绘制一个有边框的填充矩形。
		*this.shape.x=400;//设置 shape 对象相对于父容器的水平方向坐标值。
		*this.shape.y=200;//设置 shape 对象相对于父容器的垂直方向坐标值。
		*this.shape.width=100;//设置 shape 对象的宽度。
		*this.shape.height=100;//设置 shape 对象的高度。
		*this.shape.pivotX=50;//设置 shape 对象的水平方法轴心点坐标。
		*this.shape.pivotY=50;//设置 shape 对象的垂直方法轴心点坐标。
		*Laya.stage.addChild(this.shape);//将此 shape 对象添加到显示列表。
		*this.shape.on(laya.events.Event.CLICK,this,this.onClickShape);//给 shape 对象添加点击事件侦听。
		*}
	*private onClickSprite():void {
		*console.log("点击 sprite 对象。");
		*this.sprite.rotation+=5;//旋转 sprite 对象。
		*}
	*private onClickShape():void {
		*console.log("点击 shape 对象。");
		*this.shape.rotation+=5;//旋转 shape 对象。
		*}
	*}
*/
//class laya.display.Sprite extends laya.display.Node
var Sprite=(function(_super){
	function Sprite(){
		/**@private 矩阵变换信息。*/
		this._transform=null;
		/**@private */
		this._tfChanged=false;
		/**@private */
		this._x=0;
		/**@private */
		this._y=0;
		/**@private */
		this._width=0;
		/**@private */
		this._height=0;
		/**@private */
		this._repaint=1;
		/**@private 鼠标状态，0:auto,1:mouseEnabled=false,2:mouseEnabled=true。*/
		this._mouseEnableState=0;
		/**@private Z排序，数值越大越靠前。*/
		this._zOrder=0;
		/**@private */
		this._graphics=null;
		/**@private */
		this._renderType=0;
		/**@private */
		this._optimizeScrollRect=false;
		/**@private */
		this._texture=null;
		/**
		*<p>鼠标事件与此对象的碰撞检测是否可穿透。碰撞检测发生在鼠标事件的捕获阶段，此阶段引擎会从stage开始递归检测stage及其子对象，直到找到命中的目标对象或者未命中任何对象。</p>
		*<p>穿透表示鼠标事件发生的位置处于本对象绘图区域内时，才算命中，而与对象宽高和值为Rectangle对象的hitArea属性无关。如果sprite.hitArea值是HitArea对象，表示显式声明了此对象的鼠标事件响应区域，而忽略对象的宽高、mouseThrough属性。</p>
		*<p>影响对象鼠标事件响应区域的属性为：width、height、hitArea，优先级顺序为：hitArea(type:HitArea)>hitArea(type:Rectangle)>width/height。</p>
		*@default false 不可穿透，此对象的鼠标响应区域由width、height、hitArea属性决定。</p>
		*/
		this.mouseThrough=false;
		/**
		*<p>指定是否自动计算宽高数据。默认值为 false 。</p>
		*<p>Sprite宽高默认为0，并且不会随着绘制内容的变化而变化，如果想根据绘制内容获取宽高，可以设置本属性为true，或者通过getBounds方法获取。设置为true，对性能有一定影响。</p>
		*/
		this.autoSize=false;
		/**
		*<p>指定鼠标事件检测是优先检测自身，还是优先检测其子对象。鼠标事件检测发生在鼠标事件的捕获阶段，此阶段引擎会从stage开始递归检测stage及其子对象，直到找到命中的目标对象或者未命中任何对象。</p>
		*<p>如果为false，优先检测子对象，当有子对象被命中时，中断检测，获得命中目标。如果未命中任何子对象，最后再检测此对象；如果为true，则优先检测本对象，如果本对象没有被命中，直接中断检测，表示没有命中目标；如果本对象被命中，则进一步递归检测其子对象，以确认最终的命中目标。</p>
		*<p>合理使用本属性，能减少鼠标事件检测的节点，提高性能。可以设置为true的情况：开发者并不关心此节点的子节点的鼠标事件检测结果，也就是以此节点作为其子节点的鼠标事件检测依据。</p>
		*<p>Stage对象和UI的View组件默认为true。</p>
		*@default false 优先检测此对象的子对象，当递归检测完所有子对象后，仍然没有找到目标对象，最后再检测此对象。
		*/
		this.hitTestPrior=false;
		/**
		*<p>视口大小，视口外的子对象，将不被渲染(如果想实现裁剪效果，请使用srollRect)，合理使用能提高渲染性能。比如由一个个小图片拼成的地图块，viewport外面的小图片将不渲染</p>
		*<p>srollRect和viewport的区别：<br/>
		*1. srollRect自带裁剪效果，viewport只影响子对象渲染是否渲染，不具有裁剪效果（性能更高）。<br/>
		*2. 设置rect的x,y属性均能实现区域滚动效果，但scrollRect会保持0,0点位置不变。</p>
		*@default null
		*/
		this.viewport=null;
		Sprite.__super.call(this);
		this._style=Style.EMPTY;
	}

	__class(Sprite,'laya.display.Sprite',_super);
	var __proto=Sprite.prototype;
	Laya.imps(__proto,{"laya.display.ILayout":true})
	/**@private */
	__proto.createConchModel=function(){
		return /*__JS__ */new ConchNode();
	}

	/**@inheritDoc */
	__proto.destroy=function(destroyChild){
		(destroyChild===void 0)&& (destroyChild=true);
		this._releaseMem();
		_super.prototype.destroy.call(this,destroyChild);
		this._style && this._style.destroy();
		this._transform && this._transform.destroy();
		this._transform=null;
		this._style=null;
		this._graphics=null;
	}

	/**根据zOrder进行重新排序。*/
	__proto.updateZOrder=function(){
		Utils.updateOrder(this._childs)&& this.repaint();
	}

	/**在设置cacheAs的情况下，调用此方法会重新刷新缓存。*/
	__proto.reCache=function(){
		if (this._$P.cacheCanvas)this._$P.cacheCanvas.reCache=true;
		this._repaint=1;
	}

	/**
	*<p>设置对象在自身坐标系下的边界范围。与 <code>getSelfBounds</code> 对应。当 autoSize==true 时，会影响对象宽高。设置后，当需要获取自身边界范围时，就不再需要计算，合理使用能提高性能。比如 <code>getBounds</code> 会优先使用 <code>setBounds</code> 指定的值，如果没有指定则进行计算，此计算会对性能消耗比较大。</p>
	*<p><b>注意：</b> <code>setBounds</code> 与 <code>getBounds</code> 并非对应相等关系， <code>getBounds</code> 获取的是本对象在父容器坐标系下的边界范围，通过设置 <code>setBounds</code> 会影响 <code>getBounds</code> 的结果。</p>
	*@param bound bounds矩形区域
	*/
	__proto.setBounds=function(bound){
		this._set$P("uBounds",bound);
	}

	/**
	*<p>获取本对象在父容器坐标系的矩形显示区域。</p>
	*<p><b>注意：</b> 1.计算量较大，尽量少用，如果需要频繁使用，可以通过手动设置 <code>setBounds</code> 来缓存自身边界信息，从而避免比较消耗性能的计算。2. <code>setBounds</code> 与 <code>getBounds</code> 并非对应相等关系， <code>getBounds</code> 获取的是本对象在父容器坐标系下的边界范围，通过设置 <code>setBounds</code> 会影响 <code>getBounds</code> 的结果。</p>
	*@return 矩形区域。
	*/
	__proto.getBounds=function(){
		if (!this._$P.mBounds)this._set$P("mBounds",new Rectangle());
		return Rectangle._getWrapRec(this._boundPointsToParent(),this._$P.mBounds);
	}

	/**
	*获取对象在自身坐标系的边界范围。与 <code>setBounds</code> 对应。
	*<p><b>注意：</b>计算量较大，尽量少用，如果需要频繁使用，可以提前手动设置 <code>setBounds</code> 来缓存自身边界信息，从而避免比较消耗性能的计算。</p>
	*@return 矩形区域。
	*/
	__proto.getSelfBounds=function(){
		if (this._$P.uBounds)return this._$P.uBounds;
		if (!this._$P.mBounds)this._set$P("mBounds",new Rectangle());
		return Rectangle._getWrapRec(this._getBoundPointsM(false),this._$P.mBounds);
	}

	/**
	*@private
	*获取本对象在父容器坐标系的显示区域多边形顶点列表。
	*当显示对象链中有旋转时，返回多边形顶点列表，无旋转时返回矩形的四个顶点。
	*@param ifRotate （可选）之前的对象链中是否有旋转。
	*@return 顶点列表。结构：[x1,y1,x2,y2,x3,y3,...]。
	*/
	__proto._boundPointsToParent=function(ifRotate){
		(ifRotate===void 0)&& (ifRotate=false);
		var pX=0,pY=0;
		if (this._style){
			pX=this._style._tf.translateX;
			pY=this._style._tf.translateY;
			ifRotate=ifRotate || (this._style._tf.rotate!==0);
			if (this._style.scrollRect){
				pX+=this._style.scrollRect.x;
				pY+=this._style.scrollRect.y;
			}
		};
		var pList=this._getBoundPointsM(ifRotate);
		if (!pList || pList.length < 1)return pList;
		if (pList.length !=8){
			pList=ifRotate ? GrahamScan.scanPList(pList):Rectangle._getWrapRec(pList,Rectangle.TEMP)._getBoundPoints();
		}
		if (!this.transform){
			Utils.transPointList(pList,this._x-pX,this._y-pY);
			return pList;
		};
		var tPoint=Point.TEMP;
		var i=0,len=pList.length;
		for (i=0;i < len;i+=2){
			tPoint.x=pList[i];
			tPoint.y=pList[i+1];
			this.toParentPoint(tPoint);
			pList[i]=tPoint.x;
			pList[i+1]=tPoint.y;
		}
		return pList;
	}

	/**
	*返回此实例中的绘图对象（ <code>Graphics</code> ）的显示区域，不包括子对象。
	*@param realSize （可选）使用图片的真实大小，默认为false
	*@return 一个 Rectangle 对象，表示获取到的显示区域。
	*/
	__proto.getGraphicBounds=function(realSize){
		(realSize===void 0)&& (realSize=false);
		if (!this._graphics)return Rectangle.TEMP.setTo(0,0,0,0);
		return this._graphics.getBounds(realSize);
	}

	/**
	*@private
	*获取自己坐标系的显示区域多边形顶点列表
	*@param ifRotate （可选）当前的显示对象链是否由旋转
	*@return 顶点列表。结构：[x1,y1,x2,y2,x3,y3,...]。
	*/
	__proto._getBoundPointsM=function(ifRotate){
		(ifRotate===void 0)&& (ifRotate=false);
		if (this._$P.uBounds)return this._$P.uBounds._getBoundPoints();
		if (!this._$P.temBM)this._set$P("temBM",[]);
		if (this.scrollRect){
			var rst=Utils.clearArray(this._$P.temBM);
			var rec=Rectangle.TEMP;
			rec.copyFrom(this.scrollRect);
			Utils.concatArray(rst,rec._getBoundPoints());
			return rst;
		};
		var pList=this._graphics ? this._graphics.getBoundPoints():Utils.clearArray(this._$P.temBM);
		var child;
		var cList;
		var __childs;
		__childs=this._childs;
		for (var i=0,n=__childs.length;i < n;i++){
			child=__childs [i];
			if ((child instanceof laya.display.Sprite )&& child.visible==true){
				cList=child._boundPointsToParent(ifRotate);
				if (cList)
					pList=pList ? Utils.concatArray(pList,cList):cList;
			}
		}
		return pList;
	}

	/**
	*@private
	*获取样式。
	*@return 样式 Style 。
	*/
	__proto.getStyle=function(){
		this._style===Style.EMPTY && (this._style=new Style());
		return this._style;
	}

	/**
	*@private
	*设置样式。
	*@param value 样式。
	*/
	__proto.setStyle=function(value){
		this._style=value;
	}

	/**@private */
	__proto._adjustTransform=function(){
		this._tfChanged=false;
		var style=this._style;
		var tf=style._tf;
		var sx=tf.scaleX,sy=tf.scaleY;
		var m;
		if (tf.rotate || sx!==1 || sy!==1 || tf.skewX || tf.skewY){
			m=this._transform || (this._transform=Matrix.create());
			m.bTransform=true;
			var skx=(tf.rotate-tf.skewX)*0.0174532922222222;
			var sky=(tf.rotate+tf.skewY)*0.0174532922222222;
			var cx=Math.cos(sky);
			var ssx=Math.sin(sky);
			var cy=Math.sin(skx);
			var ssy=Math.cos(skx);
			m.a=sx *cx;
			m.b=sx *ssx;
			m.c=-sy *cy;
			m.d=sy *ssy;
			m.tx=m.ty=0;
			return m;
			}else {
			this._transform && this._transform.destroy();
			this._transform=null;
			this._renderType &=~ /*laya.renders.RenderSprite.TRANSFORM*/0x04;
		}
		return m;
	}

	/**
	*<p>设置坐标位置。相当于分别设置x和y属性。</p>
	*<p>因为返回值为Sprite对象本身，所以可以使用如下语法：spr.pos(...).scale(...);</p>
	*@param x X轴坐标。
	*@param y Y轴坐标。
	*@param speedMode （可选）是否极速模式，正常是调用this.x=value进行赋值，极速模式直接调用内部函数处理，如果未重写x,y属性，建议设置为急速模式性能更高。
	*@return 返回对象本身。
	*/
	__proto.pos=function(x,y,speedMode){
		(speedMode===void 0)&& (speedMode=false);
		if (this._x!==x || this._y!==y){
			if (this.destroyed)return this;
			if (speedMode){
				this._x=x;
				this._y=y;
				this.conchModel && this.conchModel.pos(this._x,this._y);
				var p=this._parent;
				if (p && p._repaint===0){
					p._repaint=1;
					p.parentRepaint();
				}
				if (this._$P.maskParent && this._$P.maskParent._repaint===0){
					this._$P.maskParent._repaint=1;
					this._$P.maskParent.parentRepaint();
				}
				}else {
				this.x=x;
				this.y=y;
			}
		}
		return this;
	}

	/**
	*<p>设置轴心点。相当于分别设置pivotX和pivotY属性。</p>
	*<p>因为返回值为Sprite对象本身，所以可以使用如下语法：spr.pivot(...).pos(...);</p>
	*@param x X轴心点。
	*@param y Y轴心点。
	*@return 返回对象本身。
	*/
	__proto.pivot=function(x,y){
		this.pivotX=x;
		this.pivotY=y;
		return this;
	}

	/**
	*<p>设置宽高。相当于分别设置width和height属性。</p>
	*<p>因为返回值为Sprite对象本身，所以可以使用如下语法：spr.size(...).pos(...);</p>
	*@param width 宽度值。
	*@param hegiht 高度值。
	*@return 返回对象本身。
	*/
	__proto.size=function(width,height){
		this.width=width;
		this.height=height;
		return this;
	}

	/**
	*<p>设置缩放。相当于分别设置scaleX和scaleY属性。</p>
	*<p>因为返回值为Sprite对象本身，所以可以使用如下语法：spr.scale(...).pos(...);</p>
	*@param scaleX X轴缩放比例。
	*@param scaleY Y轴缩放比例。
	*@param speedMode （可选）是否极速模式，正常是调用this.scaleX=value进行赋值，极速模式直接调用内部函数处理，如果未重写scaleX,scaleY属性，建议设置为急速模式性能更高。
	*@return 返回对象本身。
	*/
	__proto.scale=function(scaleX,scaleY,speedMode){
		(speedMode===void 0)&& (speedMode=false);
		var style=this.getStyle();
		var _tf=style._tf;
		if (_tf.scaleX !=scaleX || _tf.scaleY !=scaleY){
			if (this.destroyed)return this;
			if (speedMode){
				style.setScale(scaleX,scaleY);
				this._tfChanged=true;
				this.conchModel && this.conchModel.scale(scaleX,scaleY);
				this._renderType |=/*laya.renders.RenderSprite.TRANSFORM*/0x04;
				var p=this._parent;
				if (p && p._repaint===0){
					p._repaint=1;
					p.parentRepaint();
				}
				}else {
				this.scaleX=scaleX;
				this.scaleY=scaleY;
			}
		}
		return this;
	}

	/**
	*<p>设置倾斜角度。相当于分别设置skewX和skewY属性。</p>
	*<p>因为返回值为Sprite对象本身，所以可以使用如下语法：spr.skew(...).pos(...);</p>
	*@param skewX 水平倾斜角度。
	*@param skewY 垂直倾斜角度。
	*@return 返回对象本身
	*/
	__proto.skew=function(skewX,skewY){
		this.skewX=skewX;
		this.skewY=skewY;
		return this;
	}

	/**
	*更新、呈现显示对象。由系统调用。
	*@param context 渲染的上下文引用。
	*@param x X轴坐标。
	*@param y Y轴坐标。
	*/
	__proto.render=function(context,x,y){
		Stat.spriteCount++;
		RenderSprite.renders[this._renderType]._fun(this,context,x+this._x,y+this._y);
		this._repaint=0;
	}

	/**
	*<p>绘制 当前<code>Sprite</code> 到 <code>Canvas</code> 上，并返回一个HtmlCanvas。</p>
	*<p>绘制的结果可以当作图片源，再次绘制到其他Sprite里面，示例：</p>
	*
	*var htmlCanvas:HTMLCanvas=sprite.drawToCanvas(100,100,0,0);//把精灵绘制到canvas上面
	*var texture:Texture=new Texture(htmlCanvas);//使用htmlCanvas创建Texture
	*var sp:Sprite=new Sprite().pos(0,200);//创建精灵并把它放倒200位置
	*sp.graphics.drawTexture(texture);//把截图绘制到精灵上
	*Laya.stage.addChild(sp);//把精灵显示到舞台
	*
	*<p>也可以获取原始图片数据，分享到网上，从而实现截图效果，示例：</p>
	*
	*var htmlCanvas:HTMLCanvas=sprite.drawToCanvas(100,100,0,0);//把精灵绘制到canvas上面
	*
	*htmlCanvas.toBase64("image/png",0.92,function(base64){//webgl和canvas模式下为同步方法，加速器下是异步方法
		*trace(base64);//打印图片base64信息，可以发给服务器或者保存为图片
		*});
	*
	*@param canvasWidth 画布宽度。
	*@param canvasHeight 画布高度。
	*@param x 绘制的 X 轴偏移量。
	*@param y 绘制的 Y 轴偏移量。
	*@return HTMLCanvas 对象。
	*/
	__proto.drawToCanvas=function(canvasWidth,canvasHeight,offsetX,offsetY){
		if (Render.isConchNode){
			var canvas=HTMLCanvas.create("2D");
			var context=new RenderContext(canvasWidth,canvasHeight,canvas);
			context.ctx.setCanvasType(1);
			this.conchModel.drawToCanvas(canvas.source,offsetX,offsetY);
			return canvas;
			}else {
			return RunDriver.drawToCanvas(this,this._renderType,canvasWidth,canvasHeight,offsetX,offsetY);
		}
	}

	/**
	*<p>自定义更新、呈现显示对象。一般用来扩展渲染模式，请合理使用，可能会导致在加速器上无法渲染。</p>
	*<p><b>注意</b>不要在此函数内增加或删除树节点，否则会对树节点遍历造成影响。</p>
	*@param context 渲染的上下文引用。
	*@param x X轴坐标。
	*@param y Y轴坐标。
	*/
	__proto.customRender=function(context,x,y){
		this._renderType |=/*laya.renders.RenderSprite.CUSTOM*/0x400;
	}

	/**
	*@private
	*应用滤镜。
	*/
	__proto._applyFilters=function(){
		if (Render.isWebGL)return;
		var _filters;
		_filters=this._$P.filters;
		if (!_filters || _filters.length < 1)return;
		for (var i=0,n=_filters.length;i < n;i++){
			_filters[i].action.apply(this._$P.cacheCanvas);
		}
	}

	/**
	*@private
	*查看当前原件中是否包含发光滤镜。
	*@return 一个 Boolean 值，表示当前原件中是否包含发光滤镜。
	*/
	__proto._isHaveGlowFilter=function(){
		var i=0,len=0;
		if (this.filters){
			for (i=0;i < this.filters.length;i++){
				if (this.filters[i].type==/*laya.filters.Filter.GLOW*/0x08){
					return true;
				}
			}
		}
		for (i=0,len=this._childs.length;i < len;i++){
			if (this._childs[i]._isHaveGlowFilter()){
				return true;
			}
		}
		return false;
	}

	/**
	*把本地坐标转换为相对stage的全局坐标。
	*@param point 本地坐标点。
	*@param createNewPoint （可选）是否创建一个新的Point对象作为返回值，默认为false，使用输入的point对象返回，减少对象创建开销。
	*@return 转换后的坐标的点。
	*/
	__proto.localToGlobal=function(point,createNewPoint){
		(createNewPoint===void 0)&& (createNewPoint=false);
		if (createNewPoint===true){
			point=new Point(point.x,point.y);
		};
		var ele=this;
		while (ele){
			if (ele==Laya.stage)break ;
			point=ele.toParentPoint(point);
			ele=ele.parent;
		}
		return point;
	}

	/**
	*把stage的全局坐标转换为本地坐标。
	*@param point 全局坐标点。
	*@param createNewPoint （可选）是否创建一个新的Point对象作为返回值，默认为false，使用输入的point对象返回，减少对象创建开销。
	*@return 转换后的坐标的点。
	*/
	__proto.globalToLocal=function(point,createNewPoint){
		(createNewPoint===void 0)&& (createNewPoint=false);
		if (createNewPoint){
			point=new Point(point.x,point.y);
		};
		var ele=this;
		var list=[];
		while (ele){
			if (ele==Laya.stage)break ;
			list.push(ele);
			ele=ele.parent;
		};
		var i=list.length-1;
		while (i >=0){
			ele=list[i];
			point=ele.fromParentPoint(point);
			i--;
		}
		return point;
	}

	/**
	*将本地坐标系坐标转转换到父容器坐标系。
	*@param point 本地坐标点。
	*@return 转换后的点。
	*/
	__proto.toParentPoint=function(point){
		if (!point)return point;
		point.x-=this.pivotX;
		point.y-=this.pivotY;
		if (this.transform){
			this._transform.transformPoint(point);
		}
		point.x+=this._x;
		point.y+=this._y;
		var scroll=this._style.scrollRect;
		if (scroll){
			point.x-=scroll.x;
			point.y-=scroll.y;
		}
		return point;
	}

	/**
	*将父容器坐标系坐标转换到本地坐标系。
	*@param point 父容器坐标点。
	*@return 转换后的点。
	*/
	__proto.fromParentPoint=function(point){
		if (!point)return point;
		point.x-=this._x;
		point.y-=this._y;
		var scroll=this._style.scrollRect;
		if (scroll){
			point.x+=scroll.x;
			point.y+=scroll.y;
		}
		if (this.transform){
			this._transform.invertTransformPoint(point);
		}
		point.x+=this.pivotX;
		point.y+=this.pivotY;
		return point;
	}

	/**
	*<p>增加事件侦听器，以使侦听器能够接收事件通知。</p>
	*<p>如果侦听鼠标事件，则会自动设置自己和父亲节点的属性 mouseEnabled 的值为 true(如果父节点mouseEnabled=false，则停止设置父节点mouseEnabled属性)。</p>
	*@param type 事件的类型。
	*@param caller 事件侦听函数的执行域。
	*@param listener 事件侦听函数。
	*@param args （可选）事件侦听函数的回调参数。
	*@return 此 EventDispatcher 对象。
	*/
	__proto.on=function(type,caller,listener,args){
		if (this._mouseEnableState!==1 && this.isMouseEvent(type)){
			this.mouseEnabled=true;
			this._setBit(/*laya.display.Node.MOUSEENABLE*/0x2,true);
			if (this._parent){
				this._$2__onDisplay();
			}
			return this._createListener(type,caller,listener,args,false);
		}
		return _super.prototype.on.call(this,type,caller,listener,args);
	}

	/**
	*<p>增加事件侦听器，以使侦听器能够接收事件通知，此侦听事件响应一次后则自动移除侦听。</p>
	*<p>如果侦听鼠标事件，则会自动设置自己和父亲节点的属性 mouseEnabled 的值为 true(如果父节点mouseEnabled=false，则停止设置父节点mouseEnabled属性)。</p>
	*@param type 事件的类型。
	*@param caller 事件侦听函数的执行域。
	*@param listener 事件侦听函数。
	*@param args （可选）事件侦听函数的回调参数。
	*@return 此 EventDispatcher 对象。
	*/
	__proto.once=function(type,caller,listener,args){
		if (this._mouseEnableState!==1 && this.isMouseEvent(type)){
			this.mouseEnabled=true;
			this._setBit(/*laya.display.Node.MOUSEENABLE*/0x2,true);
			if (this._parent){
				this._$2__onDisplay();
			}
			return this._createListener(type,caller,listener,args,true);
		}
		return _super.prototype.once.call(this,type,caller,listener,args);
	}

	/**@private */
	__proto._$2__onDisplay=function(){
		if (this._mouseEnableState!==1){
			var ele=this;
			ele=ele.parent;
			while (ele && ele._mouseEnableState!==1){
				if (ele._getBit(/*laya.display.Node.MOUSEENABLE*/0x2))break ;
				ele.mouseEnabled=true;
				ele._setBit(/*laya.display.Node.MOUSEENABLE*/0x2,true);
				ele=ele.parent;
			}
		}
	}

	/**
	*<p>加载并显示一个图片。功能等同于graphics.loadImage方法。支持异步加载。</p>
	*<p>注意：多次调用loadImage绘制不同的图片，会同时显示。</p>
	*@param url 图片地址。
	*@param x （可选）显示图片的x位置。
	*@param y （可选）显示图片的y位置。
	*@param width （可选）显示图片的宽度，设置为0表示使用图片默认宽度。
	*@param height （可选）显示图片的高度，设置为0表示使用图片默认高度。
	*@param complete （可选）加载完成回调。
	*@return 返回精灵对象本身。
	*/
	__proto.loadImage=function(url,x,y,width,height,complete){
		var _$this=this;
		(x===void 0)&& (x=0);
		(y===void 0)&& (y=0);
		(width===void 0)&& (width=0);
		(height===void 0)&& (height=0);
		function loaded (tex){
			if (!_$this.destroyed){
				_$this.size(x+(width || tex.width),y+(height || tex.height));
				_$this.repaint();
				complete && complete.runWith(tex);
			}
		}
		this.graphics.loadImage(url,x,y,width,height,loaded);
		return this;
	}

	/**cacheAs后，设置自己和父对象缓存失效。*/
	__proto.repaint=function(){
		this.conchModel && this.conchModel.repaint && this.conchModel.repaint();
		if (this._repaint===0){
			this._repaint=1;
			this.parentRepaint();
		}
		if (this._$P && this._$P.maskParent){
			this._$P.maskParent.repaint();
		}
	}

	/**
	*@private
	*获取是否重新缓存。
	*@return 如果重新缓存值为 true，否则值为 false。
	*/
	__proto._needRepaint=function(){
		return (this._repaint!==0)&& this._$P.cacheCanvas && this._$P.cacheCanvas.reCache;
	}

	/**@private */
	__proto._childChanged=function(child){
		if (this._childs.length)this._renderType |=/*laya.renders.RenderSprite.CHILDS*/0x800;
		else this._renderType &=~ /*laya.renders.RenderSprite.CHILDS*/0x800;
		if (child && this._get$P("hasZorder"))Laya.timer.callLater(this,this.updateZOrder);
		this.repaint();
	}

	/**cacheAs时，设置所有父对象缓存失效。 */
	__proto.parentRepaint=function(){
		var p=this._parent;
		if (p && p._repaint===0){
			p._repaint=1;
			p.parentRepaint();
		}
	}

	/**
	*开始拖动此对象。
	*@param area （可选）拖动区域，此区域为当前对象注册点活动区域（不包括对象宽高），可选。
	*@param hasInertia （可选）鼠标松开后，是否还惯性滑动，默认为false，可选。
	*@param elasticDistance （可选）橡皮筋效果的距离值，0为无橡皮筋效果，默认为0，可选。
	*@param elasticBackTime （可选）橡皮筋回弹时间，单位为毫秒，默认为300毫秒，可选。
	*@param data （可选）拖动事件携带的数据，可选。
	*@param disableMouseEvent （可选）禁用其他对象的鼠标检测，默认为false，设置为true能提高性能。
	*@param ratio （可选）惯性阻尼系数，影响惯性力度和时长。
	*/
	__proto.startDrag=function(area,hasInertia,elasticDistance,elasticBackTime,data,disableMouseEvent,ratio){
		(hasInertia===void 0)&& (hasInertia=false);
		(elasticDistance===void 0)&& (elasticDistance=0);
		(elasticBackTime===void 0)&& (elasticBackTime=300);
		(disableMouseEvent===void 0)&& (disableMouseEvent=false);
		(ratio===void 0)&& (ratio=0.92);
		this._$P.dragging || (this._set$P("dragging",new Dragging()));
		this._$P.dragging.start(this,area,hasInertia,elasticDistance,elasticBackTime,data,disableMouseEvent,ratio);
	}

	/**停止拖动此对象。*/
	__proto.stopDrag=function(){
		this._$P.dragging && this._$P.dragging.stop();
	}

	__proto._releaseMem=function(){
		if (!this._$P)return;
		var cc=this._$P.cacheCanvas;
		if (cc && cc.ctx){
			Pool.recover("RenderContext",cc.ctx);
			cc.ctx.canvas.size(0,0);
			cc.ctx=null;
		};
		var fc=this._$P._filterCache;
		if (fc){
			fc.destroy();
			fc.recycle();
			this._set$P('_filterCache',null);
		}
		this._$P._isHaveGlowFilter && this._set$P('_isHaveGlowFilter',false);
		this._$P._isHaveGlowFilter=null;
	}

	/**@private */
	__proto._setDisplay=function(value){
		if (!value)this._releaseMem();
		_super.prototype._setDisplay.call(this,value);
	}

	/**
	*检测某个点是否在此对象内。
	*@param x 全局x坐标。
	*@param y 全局y坐标。
	*@return 表示是否在对象内。
	*/
	__proto.hitTestPoint=function(x,y){
		var point=this.globalToLocal(Point.TEMP.setTo(x,y));
		x=point.x;
		y=point.y;
		var rect=this._$P.hitArea ? this._$P.hitArea :(this._width > 0 && this._height > 0)? Rectangle.TEMP.setTo(0,0,this._width,this._height):this.getSelfBounds();
		return rect.contains(x,y);
	}

	/**获得相对于本对象上的鼠标坐标信息。*/
	__proto.getMousePoint=function(){
		return this.globalToLocal(Point.TEMP.setTo(Laya.stage.mouseX,Laya.stage.mouseY));
	}

	/**@private */
	__proto._getWords=function(){
		return null;
	}

	/**@private */
	__proto._addChildsToLayout=function(out){
		var words=this._getWords();
		if (words==null && this._childs.length==0)return false;
		if (words){
			for (var i=0,n=words.length;i < n;i++){
				out.push(words[i]);
			}
		}
		this._childs.forEach(function(o,index,array){
			o._style._enableLayout()&& o._addToLayout(out);
		});
		return true;
	}

	/**@private */
	__proto._addToLayout=function(out){
		if (this._style.absolute)return;
		this._style.block ? out.push(this):(this._addChildsToLayout(out)&& (this.x=this.y=0));
	}

	/**@private */
	__proto._isChar=function(){
		return false;
	}

	/**@private */
	__proto._getCSSStyle=function(){
		return this._style.getCSSStyle();
	}

	/**
	*@private
	*设置指定属性名的属性值。
	*@param name 属性名。
	*@param value 属性值。
	*/
	__proto._setAttributes=function(name,value){
		switch (name){
			case 'x':
				this.x=parseFloat(value);
				break ;
			case 'y':
				this.y=parseFloat(value);
				break ;
			case 'width':
				this.width=parseFloat(value);
				break ;
			case 'height':
				this.height=parseFloat(value);
				break ;
			default :
				this[name]=value;
			}
	}

	/**
	*@private
	*/
	__proto._layoutLater=function(){
		this.parent && (this.parent)._layoutLater();
	}

	/**
	*<p>指定是否对使用了 scrollRect 的显示对象进行优化处理。默认为false(不优化)。</p>
	*<p>当值为ture时：将对此对象使用了scrollRect 设定的显示区域以外的显示内容不进行渲染，以提高性能(如果子对象有旋转缩放或者中心点偏移，则显示筛选会不精确)。</p>
	*/
	__getset(0,__proto,'optimizeScrollRect',function(){
		return this._optimizeScrollRect;
		},function(b){
		if (this._optimizeScrollRect !=b){
			this._optimizeScrollRect=b;
			this.conchModel && this.conchModel.optimizeScrollRect(b);
		}
	});

	/**
	*设置是否开启自定义渲染，只有开启自定义渲染，才能使用customRender函数渲染。
	*/
	__getset(0,__proto,'customRenderEnable',null,function(b){
		if (b){
			this._renderType |=/*laya.renders.RenderSprite.CUSTOM*/0x400;
			if (Render.isConchNode){
				Sprite.CustomList.push(this);
				var canvas=new HTMLCanvas("2d");
				canvas._setContext(/*__JS__ */new CanvasRenderingContext2D());
				/*__JS__ */this.customContext=new RenderContext(0,0,canvas);
				canvas.context.setCanvasType && canvas.context.setCanvasType(2);
				this.conchModel.custom(canvas.context);
			}
		}
	});

	/**
	*指定显示对象是否缓存为静态图像。功能同cacheAs的normal模式。建议优先使用cacheAs代替。
	*/
	__getset(0,__proto,'cacheAsBitmap',function(){
		return this.cacheAs!=="none";
		},function(value){
		this.cacheAs=value ? (this._$P["hasFilter"] ? "none" :"normal"):"none";
	});

	/**
	*<p>指定显示对象是否缓存为静态图像，cacheAs时，子对象发生变化，会自动重新缓存，同时也可以手动调用reCache方法更新缓存。</p>
	*<p>建议把不经常变化的“复杂内容”缓存为静态图像，能极大提高渲染性能。cacheAs有"none"，"normal"和"bitmap"三个值可选。
	*<li>默认为"none"，不做任何缓存。</li>
	*<li>当值为"normal"时，canvas模式下进行画布缓存，webgl模式下进行命令缓存。</li>
	*<li>当值为"bitmap"时，canvas模式下进行依然是画布缓存，webgl模式下使用renderTarget缓存。</li></p>
	*<p>webgl下renderTarget缓存模式缺点：会额外创建renderTarget对象，增加内存开销，缓存面积有最大2048限制，不断重绘时会增加CPU开销。优点：大幅减少drawcall，渲染性能最高。
	*webgl下命令缓存模式缺点：只会减少节点遍历及命令组织，不会减少drawcall数，性能中等。优点：没有额外内存开销，无需renderTarget支持。</p>
	*/
	__getset(0,__proto,'cacheAs',function(){
		return this._$P.cacheCanvas==null ? "none" :this._$P.cacheCanvas.type;
		},function(value){
		var cacheCanvas=this._$P.cacheCanvas;
		if (value===(cacheCanvas ? cacheCanvas.type :"none"))return;
		if (value!=="none"){
			if (!this._getBit(/*laya.display.Node.NOTICE_DISPLAY*/0x1))this._setUpNoticeType(/*laya.display.Node.NOTICE_DISPLAY*/0x1);
			cacheCanvas || (cacheCanvas=this._set$P("cacheCanvas",Pool.getItemByClass("cacheCanvas",Object)));
			cacheCanvas.type=value;
			cacheCanvas.reCache=true;
			this._renderType |=/*laya.renders.RenderSprite.CANVAS*/0x10;
			if (value=="bitmap")this.conchModel && this.conchModel.cacheAs(1);
			this._set$P("cacheForFilters",false);
			}else {
			if (this._$P["_mask"]){
			}else
			if (this._$P["hasFilter"]){
				this._set$P("cacheForFilters",true);
				}else {
				if (cacheCanvas){
					var cc=cacheCanvas;
					if (cc && cc.ctx){
						Pool.recover("RenderContext",cc.ctx);
						cc.ctx.canvas.size(0,0);
						cc.ctx=null;
					}
					Pool.recover("cacheCanvas",cacheCanvas);
				}
				this._$P.cacheCanvas=null;
				this._renderType &=~ /*laya.renders.RenderSprite.CANVAS*/0x10;
				this.conchModel && this.conchModel.cacheAs(0);
			}
		}
		this.repaint();
	});

	/**z排序，更改此值，则会按照值的大小对同一容器的所有对象重新排序。值越大，越靠上。默认为0，则根据添加顺序排序。*/
	__getset(0,__proto,'zOrder',function(){
		return this._zOrder;
		},function(value){
		if (this._zOrder !=value){
			this._zOrder=value;
			this.conchModel && this.conchModel.setZOrder && this.conchModel.setZOrder(value);
			if (this._parent){
				value && this._parent._set$P("hasZorder",true);
				Laya.timer.callLater(this._parent,this.updateZOrder);
			}
		}
	});

	/**旋转角度，默认值为0。以角度为单位。*/
	__getset(0,__proto,'rotation',function(){
		return this._style._tf.rotate;
		},function(value){
		var style=this.getStyle();
		if (style._tf.rotate!==value){
			style.setRotate(value);
			this._tfChanged=true;
			this.conchModel && this.conchModel.rotate(value);
			this._renderType |=/*laya.renders.RenderSprite.TRANSFORM*/0x04;
			var p=this._parent;
			if (p && p._repaint===0){
				p._repaint=1;
				p.parentRepaint();
			}
		}
	});

	/**
	*<p>显示对象的宽度，单位为像素，默认为0。</p>
	*<p>此宽度用于鼠标碰撞检测，并不影响显示对象图像大小。需要对显示对象的图像进行缩放，请使用scale、scaleX、scaleY。</p>
	*<p>可以通过getbounds获取显示对象图像的实际宽度。</p>
	*/
	__getset(0,__proto,'width',function(){
		if (!this.autoSize)return this._width;
		return this.getSelfBounds().width;
		},function(value){
		if (this._width!==value){
			this._width=value;
			this.conchModel && this.conchModel.size(value,this._height)
			this.repaint();
		}
	});

	/**表示显示对象相对于父容器的水平方向坐标值。*/
	__getset(0,__proto,'x',function(){
		return this._x;
		},function(value){
		if (this._x!==value){
			if (this.destroyed)return;
			this._x=value;
			this.conchModel && this.conchModel.pos(value,this._y);
			var p=this._parent;
			if (p && p._repaint===0){
				p._repaint=1;
				p.parentRepaint();
			}
			if (this._$P.maskParent && this._$P.maskParent._repaint===0){
				this._$P.maskParent._repaint=1;
				this._$P.maskParent.parentRepaint();
			}
		}
	});

	/**
	*获得相对于stage的全局Y轴缩放值（会叠加父亲节点的缩放值）。
	*/
	__getset(0,__proto,'globalScaleY',function(){
		var scale=1;
		var ele=this;
		while (ele){
			if (ele===Laya.stage)break ;
			scale *=ele.scaleY;
			ele=ele.parent;
		}
		return scale;
	});

	/**
	*<p>可以设置一个Rectangle区域作为点击区域，或者设置一个<code>HitArea</code>实例作为点击区域，HitArea内可以设置可点击和不可点击区域。</p>
	*<p>如果不设置hitArea，则根据宽高形成的区域进行碰撞。</p>
	*/
	__getset(0,__proto,'hitArea',function(){
		return this._$P.hitArea;
		},function(value){
		this._set$P("hitArea",value);
	});

	/**
	*是否静态缓存此对象的当前帧的最终属性。为 true 时，子对象变化时不会自动更新缓存，但是可以通过调用 reCache 方法手动刷新。
	*<b>注意：</b> 1. 设置 cacheAs 为非空和非"none"时才有效。 2. 由于渲染的时机在脚本执行之后，也就是说当前帧渲染的是对象的最终属性，所以如果在当前帧渲染之前、设置静态缓存之后改变对象属性，则最终渲染结果表现的是对象的最终属性。
	*/
	__getset(0,__proto,'staticCache',function(){
		return this._$P.staticCache;
		},function(value){
		this._set$P("staticCache",value);
		if (!value)this.reCache();
	});

	/**设置一个Texture实例，并显示此图片（如果之前有其他绘制，则会被清除掉）。等同于graphics.clear();graphics.drawTexture()*/
	__getset(0,__proto,'texture',function(){
		return this._texture;
		},function(value){
		if (this._texture !=value){
			this._texture=value;
			this.graphics.cleanByTexture(value,0,0);
		}
	});

	/**表示显示对象相对于父容器的垂直方向坐标值。*/
	__getset(0,__proto,'y',function(){
		return this._y;
		},function(value){
		if (this._y!==value){
			if (this.destroyed)return;
			this._y=value;
			this.conchModel && this.conchModel.pos(this._x,value);
			var p=this._parent;
			if (p && p._repaint===0){
				p._repaint=1;
				p.parentRepaint();
			}
			if (this._$P.maskParent && this._$P.maskParent._repaint===0){
				this._$P.maskParent._repaint=1;
				this._$P.maskParent.parentRepaint();
			}
		}
	});

	/**
	*<p>显示对象的高度，单位为像素，默认为0。</p>
	*<p>此高度用于鼠标碰撞检测，并不影响显示对象图像大小。需要对显示对象的图像进行缩放，请使用scale、scaleX、scaleY。</p>
	*<p>可以通过getbounds获取显示对象图像的实际高度。</p>
	*/
	__getset(0,__proto,'height',function(){
		if (!this.autoSize)return this._height;
		return this.getSelfBounds().height;
		},function(value){
		if (this._height!==value){
			this._height=value;
			this.conchModel && this.conchModel.size(this._width,value);
			this.repaint();
		}
	});

	/**指定要使用的混合模式。目前只支持"lighter"。*/
	__getset(0,__proto,'blendMode',function(){
		return this._style.blendMode;
		},function(value){
		this.getStyle().blendMode=value;
		this.conchModel && this.conchModel.blendMode(value);
		if (value && value !="source-over")this._renderType |=/*laya.renders.RenderSprite.BLEND*/0x08;
		else this._renderType &=~ /*laya.renders.RenderSprite.BLEND*/0x08;
		this.parentRepaint();
	});

	/**X轴缩放值，默认值为1。设置为负数，可以实现水平反转效果，比如scaleX=-1。*/
	__getset(0,__proto,'scaleX',function(){
		return this._style._tf.scaleX;
		},function(value){
		var style=this.getStyle();
		if (style._tf.scaleX!==value){
			style.setScaleX(value);
			this._tfChanged=true;
			this.conchModel && this.conchModel.scale(value,style._tf.scaleY);
			this._renderType |=/*laya.renders.RenderSprite.TRANSFORM*/0x04;
			var p=this._parent;
			if (p && p._repaint===0){
				p._repaint=1;
				p.parentRepaint();
			}
		}
	});

	/**Y轴缩放值，默认值为1。设置为负数，可以实现垂直反转效果，比如scaleX=-1。*/
	__getset(0,__proto,'scaleY',function(){
		return this._style._tf.scaleY;
		},function(value){
		var style=this.getStyle();
		if (style._tf.scaleY!==value){
			style.setScaleY(value);
			this._tfChanged=true;
			this.conchModel && this.conchModel.scale(style._tf.scaleX,value);
			this._renderType |=/*laya.renders.RenderSprite.TRANSFORM*/0x04;
			var p=this._parent;
			if (p && p._repaint===0){
				p._repaint=1;
				p.parentRepaint();
			}
		}
	});

	/**对舞台 <code>stage</code> 的引用。*/
	__getset(0,__proto,'stage',function(){
		return Laya.stage;
	});

	/**水平倾斜角度，默认值为0。以角度为单位。*/
	__getset(0,__proto,'skewX',function(){
		return this._style._tf.skewX;
		},function(value){
		var style=this.getStyle();
		if (style._tf.skewX!==value){
			style.setSkewX(value);
			this._tfChanged=true;
			this.conchModel && this.conchModel.skew(value,style._tf.skewY);
			this._renderType |=/*laya.renders.RenderSprite.TRANSFORM*/0x04;
			var p=this._parent;
			if (p && p._repaint===0){
				p._repaint=1;
				p.parentRepaint();
			}
		}
	});

	/**
	*<p>显示对象的滚动矩形范围，具有裁剪效果(如果只想限制子对象渲染区域，请使用viewport)，设置optimizeScrollRect=true，可以优化裁剪区域外的内容不进行渲染。</p>
	*<p> srollRect和viewport的区别：<br/>
	*1.srollRect自带裁剪效果，viewport只影响子对象渲染是否渲染，不具有裁剪效果（性能更高）。<br/>
	*2.设置rect的x,y属性均能实现区域滚动效果，但scrollRect会保持0,0点位置不变。</p>
	*/
	__getset(0,__proto,'scrollRect',function(){
		return this._style.scrollRect;
		},function(value){
		this.getStyle().scrollRect=value;
		this.repaint();
		if (value){
			this._renderType |=/*laya.renders.RenderSprite.CLIP*/0x80;
			this.conchModel && this.conchModel.scrollRect(value.x,value.y,value.width,value.height);
			}else {
			this._renderType &=~ /*laya.renders.RenderSprite.CLIP*/0x80;
			if (this.conchModel){
				if (Sprite.RUNTIMEVERION < "0.9.1")
					this.conchModel.removeType(0x40);
				else
				this.conchModel.removeType(/*laya.renders.RenderSprite.CLIP*/0x80);
			}
		}
	});

	/**垂直倾斜角度，默认值为0。以角度为单位。*/
	__getset(0,__proto,'skewY',function(){
		return this._style._tf.skewY;
		},function(value){
		var style=this.getStyle();
		if (style._tf.skewY!==value){
			style.setSkewY(value);
			this._tfChanged=true;
			this.conchModel && this.conchModel.skew(style._tf.skewX,value);
			this._renderType |=/*laya.renders.RenderSprite.TRANSFORM*/0x04;
			var p=this._parent;
			if (p && p._repaint===0){
				p._repaint=1;
				p.parentRepaint();
			}
		}
	});

	/**
	*<p>对象的矩阵信息。通过设置矩阵可以实现节点旋转，缩放，位移效果。</p>
	*<p>矩阵更多信息请参考 <code>Matrix</code></p>
	*/
	__getset(0,__proto,'transform',function(){
		return this._tfChanged ? this._adjustTransform():this._transform;
		},function(value){
		this._tfChanged=false;
		this._transform=value;
		if (value){
			this._x=value.tx;
			this._y=value.ty;
			value.tx=value.ty=0;
			this.conchModel && this.conchModel.transform(value.a,value.b,value.c,value.d,this._x,this._y);
		}
		if (value)this._renderType |=/*laya.renders.RenderSprite.TRANSFORM*/0x04;
		else {
			this._renderType &=~ /*laya.renders.RenderSprite.TRANSFORM*/0x04;
			this.conchModel && this.conchModel.removeType(/*laya.renders.RenderSprite.TRANSFORM*/0x04);
		}
		this.parentRepaint();
	});

	/**X轴 轴心点的位置，单位为像素，默认为0。轴心点会影响对象位置，缩放中心，旋转中心。*/
	__getset(0,__proto,'pivotX',function(){
		return this._style._tf.translateX;
		},function(value){
		this.getStyle().setTranslateX(value);
		this.conchModel && this.conchModel.pivot(value,this._style._tf.translateY);
		this.repaint();
	});

	/**Y轴 轴心点的位置，单位为像素，默认为0。轴心点会影响对象位置，缩放中心，旋转中心。*/
	__getset(0,__proto,'pivotY',function(){
		return this._style._tf.translateY;
		},function(value){
		this.getStyle().setTranslateY(value);
		this.conchModel && this.conchModel.pivot(this._style._tf.translateX,value);
		this.repaint();
	});

	/**透明度，值为0-1，默认值为1，表示不透明。更改alpha值会影响drawcall。*/
	__getset(0,__proto,'alpha',function(){
		return this._style.alpha;
		},function(value){
		if (this._style && this._style.alpha!==value){
			value=value < 0 ? 0 :(value > 1 ? 1 :value);
			this.getStyle().alpha=value;
			this.conchModel && this.conchModel.alpha(value);
			if (value!==1)this._renderType |=/*laya.renders.RenderSprite.ALPHA*/0x02;
			else this._renderType &=~ /*laya.renders.RenderSprite.ALPHA*/0x02;
			this.parentRepaint();
		}
	});

	/**表示是否可见，默认为true。如果设置不可见，节点将不被渲染。*/
	__getset(0,__proto,'visible',function(){
		return this._style.visible;
		},function(value){
		if (this._style && this._style.visible!==value){
			this.getStyle().visible=value;
			this.conchModel && this.conchModel.visible(value);
			this.parentRepaint();
		}
	});

	/**绘图对象。封装了绘制位图和矢量图的接口，Sprite所有的绘图操作都通过Graphics来实现的。*/
	__getset(0,__proto,'graphics',function(){
		return this._graphics || (this.graphics=RunDriver.createGraphics());
		},function(value){
		if (this._graphics)this._graphics._sp=null;
		this._graphics=value;
		if (value){
			this._renderType &=~ /*laya.renders.RenderSprite.IMAGE*/0x01;
			this._renderType |=/*laya.renders.RenderSprite.GRAPHICS*/0x200;
			value._sp=this;
			this.conchModel && this.conchModel.graphics(this._graphics);
			}else {
			this._renderType &=~ /*laya.renders.RenderSprite.GRAPHICS*/0x200;
			this._renderType &=~ /*laya.renders.RenderSprite.IMAGE*/0x01;
			if (this.conchModel){
				if (Sprite.RUNTIMEVERION < "0.9.1")
					this.conchModel.removeType(0x100);
				else
				this.conchModel.removeType(/*laya.renders.RenderSprite.GRAPHICS*/0x200);
			}
		}
		this.repaint();
	});

	/**滤镜集合。可以设置多个滤镜组合。*/
	__getset(0,__proto,'filters',function(){
		return this._$P.filters;
		},function(value){
		value && value.length===0 && (value=null);
		if (this._$P.filters==value)return;
		this._set$P("filters",value ? value.slice():null);
		if (Render.isConchApp){
			if (this.conchModel){
				if (Sprite.RUNTIMEVERION < "0.9.1")
					this.conchModel.removeType(0x10);
				else
				this.conchModel.removeType(/*laya.renders.RenderSprite.FILTERS*/0x20);
			}
			if (this._$P.filters && this._$P.filters.length==1){
				this._$P.filters[0].callNative(this);
			}
		}
		if (Render.isWebGL){
			if (value && value.length){
				this._renderType |=/*laya.renders.RenderSprite.FILTERS*/0x20;
				}else {
				this._renderType &=~ /*laya.renders.RenderSprite.FILTERS*/0x20;
			}
		}
		if (value && value.length > 0){
			if (!this._getBit(/*laya.display.Node.NOTICE_DISPLAY*/0x1))this._setUpNoticeType(/*laya.display.Node.NOTICE_DISPLAY*/0x1);
			if (!(Render.isWebGL && value.length==1 && (((value[0])instanceof laya.filters.ColorFilter )))){
				if (this.cacheAs !="bitmap"){
					if (!Render.isConchNode)this.cacheAs="bitmap";
					this._set$P("cacheForFilters",true);
				}
				this._set$P("hasFilter",true);
			}
			}else {
			this._set$P("hasFilter",false);
			if (this._$P["cacheForFilters"] && this.cacheAs=="bitmap"){
				this.cacheAs="none";
			}
		}
		this.repaint();
	});

	__getset(0,__proto,'parent',_super.prototype._$get_parent,function(value){
		Laya.superSet(Node,this,'parent',value);
		if (value && this._getBit(/*laya.display.Node.MOUSEENABLE*/0x2)){
			this._$2__onDisplay();
		}
	});

	/**
	*<p>遮罩，可以设置一个对象(支持位图和矢量图)，根据对象形状进行遮罩显示。</p>
	*<p>【注意】遮罩对象坐标系是相对遮罩对象本身的，和Flash机制不同</p>
	*/
	__getset(0,__proto,'mask',function(){
		return this._$P._mask;
		},function(value){
		if (value && this.mask && this.mask._$P.maskParent)return;
		if (value){
			this.cacheAs="bitmap";
			this._set$P("_mask",value);
			value._set$P("maskParent",this);
			}else {
			this.mask && this.mask._set$P("maskParent",null);
			this._set$P("_mask",value);
			this.cacheAs="none";
		}
		this.conchModel && this.conchModel.mask(value ? value.conchModel :null);
		this._renderType |=/*laya.renders.RenderSprite.MASK*/0x40;
		this.parentRepaint();
	});

	/**
	*是否接受鼠标事件。
	*默认为false，如果监听鼠标事件，则会自动设置本对象及父节点的属性 mouseEnable 的值都为 true（如果父节点手动设置为false，则不会更改）。
	**/
	__getset(0,__proto,'mouseEnabled',function(){
		return this._mouseEnableState > 1;
		},function(value){
		this._mouseEnableState=value ? 2 :1;
	});

	/**
	*获得相对于stage的全局X轴缩放值（会叠加父亲节点的缩放值）。
	*/
	__getset(0,__proto,'globalScaleX',function(){
		var scale=1;
		var ele=this;
		while (ele){
			if (ele===Laya.stage)break ;
			scale *=ele.scaleX;
			ele=ele.parent;
		}
		return scale;
	});

	/**
	*返回鼠标在此对象坐标系上的 X 轴坐标信息。
	*/
	__getset(0,__proto,'mouseX',function(){
		return this.getMousePoint().x;
	});

	/**
	*返回鼠标在此对象坐标系上的 Y 轴坐标信息。
	*/
	__getset(0,__proto,'mouseY',function(){
		return this.getMousePoint().y;
	});

	Sprite.fromImage=function(url){
		return new Sprite().loadImage(url);
	}

	Sprite.CustomList=[];
	__static(Sprite,
	['RUNTIMEVERION',function(){return this.RUNTIMEVERION=/*__JS__ */window.conch?conchConfig.getRuntimeVersion().substr(conchConfig.getRuntimeVersion().lastIndexOf('-')+1):'';}
	]);
	return Sprite;
})(Node)


/**
*@private
*audio标签播放声音的音轨控制
*/
//class laya.media.h5audio.AudioSoundChannel extends laya.media.SoundChannel
var AudioSoundChannel=(function(_super){
	function AudioSoundChannel(audio){
		/**
		*播放用的audio标签
		*/
		this._audio=null;
		this._onEnd=null;
		this._resumePlay=null;
		AudioSoundChannel.__super.call(this);
		this._onEnd=Utils.bind(this.__onEnd,this);
		this._resumePlay=Utils.bind(this.__resumePlay,this);
		audio.addEventListener("ended",this._onEnd);
		this._audio=audio;
	}

	__class(AudioSoundChannel,'laya.media.h5audio.AudioSoundChannel',_super);
	var __proto=AudioSoundChannel.prototype;
	__proto.__onEnd=function(){
		if (this.loops==1){
			if (this.completeHandler){
				Laya.timer.once(10,this,this.__runComplete,[this.completeHandler],false);
				this.completeHandler=null;
			}
			this.stop();
			this.event(/*laya.events.Event.COMPLETE*/"complete");
			return;
		}
		if (this.loops > 0){
			this.loops--;
		}
		this.startTime=0;
		this.play();
	}

	__proto.__resumePlay=function(){
		if(this._audio)this._audio.removeEventListener("canplay",this._resumePlay);
		try {
			this._audio.currentTime=this.startTime;
			Browser.container.appendChild(this._audio);
			this._audio.play();
			}catch (e){
			this.event(/*laya.events.Event.ERROR*/"error");
		}
	}

	/**
	*播放
	*/
	__proto.play=function(){
		this.isStopped=false;
		try {
			this._audio.playbackRate=SoundManager.playbackRate;
			this._audio.currentTime=this.startTime;
			}catch (e){
			this._audio.addEventListener("canplay",this._resumePlay);
			return;
		}
		SoundManager.addChannel(this);
		Browser.container.appendChild(this._audio);
		if("play" in this._audio)
			this._audio.play();
	}

	/**
	*停止播放
	*
	*/
	__proto.stop=function(){
		this.isStopped=true;
		SoundManager.removeChannel(this);
		this.completeHandler=null;
		if (!this._audio)
			return;
		if ("pause" in this._audio)
			if (Render.isConchApp){
			this._audio.stop();
		}
		this._audio.pause();
		this._audio.removeEventListener("ended",this._onEnd);
		this._audio.removeEventListener("canplay",this._resumePlay);
		if (!Browser.onIE){
			if (this._audio!=AudioSound._musicAudio){
				Pool.recover("audio:"+this.url,this._audio);
			}
		}
		Browser.removeElement(this._audio);
		this._audio=null;
	}

	__proto.pause=function(){
		this.isStopped=true;
		SoundManager.removeChannel(this);
		if("pause" in this._audio)
			this._audio.pause();
	}

	__proto.resume=function(){
		if (!this._audio)
			return;
		this.isStopped=false;
		SoundManager.addChannel(this);
		if("play" in this._audio)
			this._audio.play();
	}

	/**
	*当前播放到的位置
	*@return
	*
	*/
	__getset(0,__proto,'position',function(){
		if (!this._audio)
			return 0;
		return this._audio.currentTime;
	});

	/**
	*获取总时间。
	*/
	__getset(0,__proto,'duration',function(){
		if (!this._audio)
			return 0;
		return this._audio.duration;
	});

	/**
	*设置音量
	*@param v
	*
	*/
	/**
	*获取音量
	*@return
	*
	*/
	__getset(0,__proto,'volume',function(){
		if (!this._audio)return 1;
		return this._audio.volume;
		},function(v){
		if (!this._audio)return;
		this._audio.volume=v;
	});

	return AudioSoundChannel;
})(SoundChannel)


/**
*@private
*web audio api方式播放声音的音轨控制
*/
//class laya.media.webaudio.WebAudioSoundChannel extends laya.media.SoundChannel
var WebAudioSoundChannel=(function(_super){
	function WebAudioSoundChannel(){
		/**
		*声音原始文件数据
		*/
		this.audioBuffer=null;
		/**
		*gain节点
		*/
		this.gain=null;
		/**
		*播放用的数据
		*/
		this.bufferSource=null;
		/**
		*当前时间
		*/
		this._currentTime=0;
		/**
		*当前音量
		*/
		this._volume=1;
		/**
		*播放开始时的时间戳
		*/
		this._startTime=0;
		this._pauseTime=0;
		this._onPlayEnd=null;
		this.context=WebAudioSound.ctx;
		WebAudioSoundChannel.__super.call(this);
		this._onPlayEnd=Utils.bind(this.__onPlayEnd,this);
		if (this.context["createGain"]){
			this.gain=this.context["createGain"]();
			}else {
			this.gain=this.context["createGainNode"]();
		}
	}

	__class(WebAudioSoundChannel,'laya.media.webaudio.WebAudioSoundChannel',_super);
	var __proto=WebAudioSoundChannel.prototype;
	/**
	*播放声音
	*/
	__proto.play=function(){
		SoundManager.addChannel(this);
		this.isStopped=false;
		this._clearBufferSource();
		if (!this.audioBuffer)return;
		var context=this.context;
		var gain=this.gain;
		var bufferSource=context.createBufferSource();
		this.bufferSource=bufferSource;
		bufferSource.buffer=this.audioBuffer;
		bufferSource.connect(gain);
		if (gain)
			gain.disconnect();
		gain.connect(context.destination);
		bufferSource.onended=this._onPlayEnd;
		if (this.startTime >=this.duration)this.startTime=0;
		this._startTime=Browser.now();
		if (this.gain.gain.setTargetAtTime){
			this.gain.gain.setTargetAtTime(this._volume,this.context.currentTime,0.1);
		}else
		this.gain.gain.value=this._volume;
		if (this.loops==0){
			bufferSource.loop=true;
		}
		if (bufferSource.playbackRate.setTargetAtTime){
			bufferSource.playbackRate.setTargetAtTime(SoundManager.playbackRate,this.context.currentTime,0.1)
		}else
		bufferSource.playbackRate.value=SoundManager.playbackRate;
		bufferSource.start(0,this.startTime);
		this._currentTime=0;
	}

	__proto.__onPlayEnd=function(){
		if (this.loops==1){
			if (this.completeHandler){
				Laya.timer.once(10,this,this.__runComplete,[this.completeHandler],false);
				this.completeHandler=null;
			}
			this.stop();
			this.event(/*laya.events.Event.COMPLETE*/"complete");
			return;
		}
		if (this.loops > 0){
			this.loops--;
		}
		this.startTime=0;
		this.play();
	}

	__proto._clearBufferSource=function(){
		if (this.bufferSource){
			var sourceNode=this.bufferSource;
			if (sourceNode.stop){
				sourceNode.stop(0);
				}else {
				sourceNode.noteOff(0);
			}
			sourceNode.disconnect(0);
			sourceNode.onended=null;
			if (!WebAudioSoundChannel._tryCleanFailed)this._tryClearBuffer(sourceNode);
			this.bufferSource=null;
		}
	}

	__proto._tryClearBuffer=function(sourceNode){
		if (!Browser.onMac){
			try{
				sourceNode.buffer=null;
				}catch (e){
				WebAudioSoundChannel._tryCleanFailed=true;
			}
			return;
		}
		try {sourceNode.buffer=WebAudioSound._miniBuffer;}catch (e){WebAudioSoundChannel._tryCleanFailed=true;}
	}

	/**
	*停止播放
	*/
	__proto.stop=function(){
		this._clearBufferSource();
		this.audioBuffer=null;
		if (this.gain)
			this.gain.disconnect();
		this.isStopped=true;
		SoundManager.removeChannel(this);
		this.completeHandler=null;
		if(SoundManager.autoReleaseSound)
			Laya.timer.once(5000,null,SoundManager.disposeSoundIfNotUsed,[this.url],false);
	}

	__proto.pause=function(){
		if (!this.isStopped){
			this._pauseTime=this.position;
		}
		this._clearBufferSource();
		if (this.gain)
			this.gain.disconnect();
		this.isStopped=true;
		SoundManager.removeChannel(this);
		if(SoundManager.autoReleaseSound)
			Laya.timer.once(5000,null,SoundManager.disposeSoundIfNotUsed,[this.url],false);
	}

	__proto.resume=function(){
		this.startTime=this._pauseTime;
		this.play();
	}

	/**
	*获取当前播放位置
	*/
	__getset(0,__proto,'position',function(){
		if (this.bufferSource){
			return (Browser.now()-this._startTime)/ 1000+this.startTime;
		}
		return 0;
	});

	__getset(0,__proto,'duration',function(){
		if (this.audioBuffer){
			return this.audioBuffer.duration;
		}
		return 0;
	});

	/**
	*设置音量
	*/
	/**
	*获取音量
	*/
	__getset(0,__proto,'volume',function(){
		return this._volume;
		},function(v){
		if (this.isStopped){
			return;
		}
		this._volume=v;
		if (this.gain.gain.setTargetAtTime){
			this.gain.gain.setTargetAtTime(v,this.context.currentTime,0.1);
		}else
		this.gain.gain.value=v;
	});

	WebAudioSoundChannel._tryCleanFailed=false;
	return WebAudioSoundChannel;
})(SoundChannel)


/**
*@private
*<code>Bitmap</code> 是图片资源类。
*/
//class laya.resource.Bitmap extends laya.resource.Resource
var Bitmap=(function(_super){
	function Bitmap(){
		/**@private
		*HTML Image或HTML Canvas或WebGL Texture。
		**/
		//this._source=null;
		/**@private 宽度*/
		//this._w=NaN;
		/**@private 高度*/
		//this._h=NaN;
		Bitmap.__super.call(this);
		this._w=0;
		this._h=0;
	}

	__class(Bitmap,'laya.resource.Bitmap',_super);
	var __proto=Bitmap.prototype;
	/***
	*宽度。
	*/
	__getset(0,__proto,'width',function(){
		return this._w;
	});

	/***
	*高度。
	*/
	__getset(0,__proto,'height',function(){
		return this._h;
	});

	/***
	*HTML Image 或 HTML Canvas 或 WebGL Texture 。
	*/
	__getset(0,__proto,'source',function(){
		return this._source;
	});

	return Bitmap;
})(Resource)


/**
*<p>动画播放基类，提供了基础的动画播放控制方法和帧标签事件相关功能。</p>
*<p>可以继承此类，但不要直接实例化此类，因为有些方法需要由子类实现。</p>
*/
//class laya.display.AnimationPlayerBase extends laya.display.Sprite
var AnimationPlayerBase=(function(_super){
	function AnimationPlayerBase(){
		/**
		*是否循环播放，调用play(...)方法时，会将此值设置为指定的参数值。
		*/
		this.loop=false;
		/**
		*<p>播放顺序类型：AnimationPlayerBase.WRAP_POSITIVE为正序播放，AnimationPlayerBase.WRAP_REVERSE为倒序播放，AnimationPlayerBase.WRAP_PINGPONG为pingpong播放(当按指定顺序播放完结尾后，如果继续播发，则会改变播放顺序)。</p>
		*<p>默认为正序播放。</p>
		*/
		this.wrapMode=0;
		/**@private */
		this._index=0;
		/**@private */
		this._count=0;
		/**@private */
		this._isPlaying=false;
		/**@private */
		this._labels=null;
		/**是否是逆序播放*/
		this._isReverse=false;
		/**@private */
		this._frameRateChanged=false;
		/**@private */
		this._controlNode=null;
		/**@private */
		this._actionName=null;
		AnimationPlayerBase.__super.call(this);
		this._interval=Config.animationInterval;
		this._setUpNoticeType(/*laya.display.Node.NOTICE_DISPLAY*/0x1);
	}

	__class(AnimationPlayerBase,'laya.display.AnimationPlayerBase',_super);
	var __proto=AnimationPlayerBase.prototype;
	/**
	*<p>开始播放动画。play(...)方法被设计为在创建实例后的任何时候都可以被调用，当相应的资源加载完毕、调用动画帧填充方法(set frames)或者将实例显示在舞台上时，会判断是否正在播放中，如果是，则进行播放。</p>
	*<p>配合wrapMode属性，可设置动画播放顺序类型。</p>
	*@param start （可选）指定动画播放开始的索引(int)或帧标签(String)。帧标签可以通过addLabel(...)和removeLabel(...)进行添加和删除。
	*@param loop （可选）是否循环播放。
	*@param name （可选）动画名称。
	*@param showWarn（可选）是否动画不存在时打印警告
	*/
	__proto.play=function(start,loop,name,showWarn){
		(start===void 0)&& (start=0);
		(loop===void 0)&& (loop=true);
		(name===void 0)&& (name="");
		(showWarn===void 0)&& (showWarn=true);
		this._isPlaying=true;
		this.index=((typeof start=='string'))? this._getFrameByLabel(start):start;
		this.loop=loop;
		this._actionName=name;
		this._isReverse=this.wrapMode==1;
		if (this.interval > 0){
			this.timerLoop(this.interval,this,this._frameLoop,null,true,true);
		}
	}

	/**@private */
	__proto._getFrameByLabel=function(label){
		var i=0;
		for (i=0;i < this._count;i++){
			if (this._labels[i] && (this._labels [i]).indexOf(label)>=0)return i;
		}
		return 0;
	}

	/**@private */
	__proto._frameLoop=function(){
		if (this._isReverse){
			this._index--;
			if (this._index < 0){
				if (this.loop){
					if (this.wrapMode==2){
						this._index=this._count > 0 ? 1 :0;
						this._isReverse=false;
						}else {
						this._index=this._count-1;
					}
					this.event(/*laya.events.Event.COMPLETE*/"complete");
					}else {
					this._index=0;
					this.stop();
					this.event(/*laya.events.Event.COMPLETE*/"complete");
					return;
				}
			}
			}else {
			this._index++;
			if (this._index >=this._count){
				if (this.loop){
					if (this.wrapMode==2){
						this._index=this._count-2 >=0 ? this._count-2 :0;
						this._isReverse=true;
						}else {
						this._index=0;
					}
					this.event(/*laya.events.Event.COMPLETE*/"complete");
					}else {
					this._index--;
					this.stop();
					this.event(/*laya.events.Event.COMPLETE*/"complete");
					return;
				}
			}
		}
		this.index=this._index;
	}

	/**@private */
	__proto._setControlNode=function(node){
		if (this._controlNode){
			this._controlNode.off(/*laya.events.Event.DISPLAY*/"display",this,this._checkResumePlaying);
			this._controlNode.off(/*laya.events.Event.UNDISPLAY*/"undisplay",this,this._checkResumePlaying);
		}
		this._controlNode=node;
		if (node && node !=this){
			node.on(/*laya.events.Event.DISPLAY*/"display",this,this._checkResumePlaying);
			node.on(/*laya.events.Event.UNDISPLAY*/"undisplay",this,this._checkResumePlaying);
		}
	}

	/**@private */
	__proto._setDisplay=function(value){
		_super.prototype._setDisplay.call(this,value);
		this._checkResumePlaying();
	}

	/**@private */
	__proto._checkResumePlaying=function(){
		if (this._isPlaying){
			if (this._controlNode.displayedInStage)this.play(this._index,this.loop,this._actionName);
			else this.clearTimer(this,this._frameLoop);
		}
	}

	/**
	*停止动画播放。
	*/
	__proto.stop=function(){
		this._isPlaying=false;
		this.clearTimer(this,this._frameLoop);
	}

	/**
	*增加一个帧标签到指定索引的帧上。当动画播放到此索引的帧时会派发Event.LABEL事件，派发事件是在完成当前帧画面更新之后。
	*@param label 帧标签名称
	*@param index 帧索引
	*/
	__proto.addLabel=function(label,index){
		if (!this._labels)this._labels={};
		if (!this._labels[index])this._labels[index]=[];
		this._labels[index].push(label);
	}

	/**
	*删除指定的帧标签。
	*@param label 帧标签名称。注意：如果为空，则删除所有帧标签！
	*/
	__proto.removeLabel=function(label){
		if (!label)this._labels=null;
		else if (this._labels){
			for (var name in this._labels){
				this._removeLabelFromLabelList(this._labels[name],label);
			}
		}
	}

	/**@private */
	__proto._removeLabelFromLabelList=function(list,label){
		if (!list)return;
		for (var i=list.length-1;i >=0;i--){
			if (list[i]==label){
				list.splice(i,1);
			}
		}
	}

	/**
	*将动画切换到指定帧并停在那里。
	*@param position 帧索引或帧标签
	*/
	__proto.gotoAndStop=function(position){
		this.index=((typeof position=='string'))? this._getFrameByLabel(position):position;
		this.stop();
	}

	/**
	*@private
	*显示到某帧
	*@param value 帧索引
	*/
	__proto._displayToIndex=function(value){}
	/**
	*停止动画播放，并清理对象属性。之后可存入对象池，方便对象复用。
	*/
	__proto.clear=function(){
		this.stop();
		this._labels=null;
	}

	/**
	*<p>动画播放的帧间隔时间(单位：毫秒)。默认值依赖于Config.animationInterval=50，通过Config.animationInterval可以修改默认帧间隔时间。</p>
	*<p>要想为某动画设置独立的帧间隔时间，可以使用set interval，注意：如果动画正在播放，设置后会重置帧循环定时器的起始时间为当前时间，也就是说，如果频繁设置interval，会导致动画帧更新的时间间隔会比预想的要慢，甚至不更新。</p>
	*/
	__getset(0,__proto,'interval',function(){
		return this._interval;
		},function(value){
		if (this._interval !=value){
			this._frameRateChanged=true;
			this._interval=value;
			if (this._isPlaying && value > 0){
				this.timerLoop(value,this,this._frameLoop,null,true,true);
			}
		}
	});

	/**
	*是否正在播放中。
	*/
	__getset(0,__proto,'isPlaying',function(){
		return this._isPlaying;
	});

	/**
	*动画当前帧的索引。
	*/
	__getset(0,__proto,'index',function(){
		return this._index;
		},function(value){
		this._index=value;
		this._displayToIndex(value);
		if (this._labels && this._labels[value]){
			var tArr=this._labels[value];
			for (var i=0,len=tArr.length;i < len;i++){
				this.event(/*laya.events.Event.LABEL*/"label",tArr[i]);
			}
		}
	});

	/**
	*当前动画中帧的总数。
	*/
	__getset(0,__proto,'count',function(){
		return this._count;
	});

	AnimationPlayerBase.WRAP_POSITIVE=0;
	AnimationPlayerBase.WRAP_REVERSE=1;
	AnimationPlayerBase.WRAP_PINGPONG=2;
	return AnimationPlayerBase;
})(Sprite)


/**
*<p> <code>Text</code> 类用于创建显示对象以显示文本。</p>
*<p>
*注意：如果运行时系统找不到设定的字体，则用系统默认的字体渲染文字，从而导致显示异常。(通常电脑上显示正常，在一些移动端因缺少设置的字体而显示异常)。
*</p>
*@example
*package
*{
	*import laya.display.Text;
	*public class Text_Example
	*{
		*public function Text_Example()
		*{
			*Laya.init(640,800);//设置游戏画布宽高、渲染模式。
			*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
			*onInit();
			*}
		*private function onInit():void
		*{
			*var text:Text=new Text();//创建一个 Text 类的实例对象 text 。
			*text.text="这个是一个 Text 文本示例。";
			*text.color="#008fff";//设置 text 的文本颜色。
			*text.font="Arial";//设置 text 的文本字体。
			*text.bold=true;//设置 text 的文本显示为粗体。
			*text.fontSize=30;//设置 text 的字体大小。
			*text.wordWrap=true;//设置 text 的文本自动换行。
			*text.x=100;//设置 text 对象的属性 x 的值，用于控制 text 对象的显示位置。
			*text.y=100;//设置 text 对象的属性 y 的值，用于控制 text 对象的显示位置。
			*text.width=300;//设置 text 的宽度。
			*text.height=200;//设置 text 的高度。
			*text.italic=true;//设置 text 的文本显示为斜体。
			*text.borderColor="#fff000";//设置 text 的文本边框颜色。
			*Laya.stage.addChild(text);//将 text 添加到显示列表。
			*}
		*}
	*}
*@example
*Text_Example();
*function Text_Example()
*{
	*Laya.init(640,800);//设置游戏画布宽高、渲染模式。
	*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
	*onInit();
	*}
*function onInit()
*{
	*var text=new laya.display.Text();//创建一个 Text 类的实例对象 text 。
	*text.text="这个是一个 Text 文本示例。";
	*text.color="#008fff";//设置 text 的文本颜色。
	*text.font="Arial";//设置 text 的文本字体。
	*text.bold=true;//设置 text 的文本显示为粗体。
	*text.fontSize=30;//设置 text 的字体大小。
	*text.wordWrap=true;//设置 text 的文本自动换行。
	*text.x=100;//设置 text 对象的属性 x 的值，用于控制 text 对象的显示位置。
	*text.y=100;//设置 text 对象的属性 y 的值，用于控制 text 对象的显示位置。
	*text.width=300;//设置 text 的宽度。
	*text.height=200;//设置 text 的高度。
	*text.italic=true;//设置 text 的文本显示为斜体。
	*text.borderColor="#fff000";//设置 text 的文本边框颜色。
	*Laya.stage.addChild(text);//将 text 添加到显示列表。
	*}
*@example
*class Text_Example {
	*constructor(){
		*Laya.init(640,800);//设置游戏画布宽高、渲染模式。
		*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
		*this.onInit();
		*}
	*private onInit():void {
		*var text:laya.display.Text=new laya.display.Text();//创建一个 Text 类的实例对象 text 。
		*text.text="这个是一个 Text 文本示例。";
		*text.color="#008fff";//设置 text 的文本颜色。
		*text.font="Arial";//设置 text 的文本字体。
		*text.bold=true;//设置 text 的文本显示为粗体。
		*text.fontSize=30;//设置 text 的字体大小。
		*text.wordWrap=true;//设置 text 的文本自动换行。
		*text.x=100;//设置 text 对象的属性 x 的值，用于控制 text 对象的显示位置。
		*text.y=100;//设置 text 对象的属性 y 的值，用于控制 text 对象的显示位置。
		*text.width=300;//设置 text 的宽度。
		*text.height=200;//设置 text 的高度。
		*text.italic=true;//设置 text 的文本显示为斜体。
		*text.borderColor="#fff000";//设置 text 的文本边框颜色。
		*Laya.stage.addChild(text);//将 text 添加到显示列表。
		*}
	*}
*/
//class laya.display.Text extends laya.display.Sprite
var Text=(function(_super){
	function Text(){
		/**@private */
		this._clipPoint=null;
		/**当前使用的位置字体。*/
		this._currBitmapFont=null;
		/**@private 表示文本内容字符串。*/
		this._text=null;
		/**@private 表示文本内容是否发生改变。*/
		this._isChanged=false;
		/**@private 表示文本的宽度，以像素为单位。*/
		this._textWidth=0;
		/**@private 表示文本的高度，以像素为单位。*/
		this._textHeight=0;
		/**@private 存储文字行数信息。*/
		this._lines=[];
		/**@private 保存每行宽度*/
		this._lineWidths=[];
		/**@private 文本的内容位置 X 轴信息。*/
		this._startX=NaN;
		/**@private 文本的内容位置X轴信息。 */
		this._startY=NaN;
		/**@private 当前可视行索引。*/
		this._lastVisibleLineIndex=-1;
		/**@private 当前可视行索引。*/
		this._words=null;
		/**@private */
		this._charSize={};
		/**
		*是否显示下划线。
		*/
		this.underline=false;
		/**
		*下划线的颜色，为null则使用字体颜色。
		*/
		this._underlineColor=null;
		Text.__super.call(this);
		this.overflow=Text.VISIBLE;
		this._style=new CSSStyle(this);
		(this._style).wordWrap=false;
	}

	__class(Text,'laya.display.Text',_super);
	var __proto=Text.prototype;
	/**@inheritDoc */
	__proto.destroy=function(destroyChild){
		(destroyChild===void 0)&& (destroyChild=true);
		_super.prototype.destroy.call(this,destroyChild);
		this._lines=null;
		if (this._words){
			this._words.length=0;
			this._words=null;
		}
	}

	/**
	*@private
	*@inheritDoc
	*/
	__proto._getBoundPointsM=function(ifRotate){
		(ifRotate===void 0)&& (ifRotate=false);
		var rec=Rectangle.TEMP;
		rec.setTo(0,0,this.width,this.height);
		return rec._getBoundPoints();
	}

	/**
	*@inheritDoc
	*/
	__proto.getGraphicBounds=function(realSize){
		(realSize===void 0)&& (realSize=false);
		var rec=Rectangle.TEMP;
		rec.setTo(0,0,this.width,this.height);
		return rec;
	}

	/**
	*@private
	*@inheritDoc
	*/
	__proto._getCSSStyle=function(){
		return this._style;
	}

	/**
	*<p>根据指定的文本，从语言包中取当前语言的文本内容。并对此文本中的{i}文本进行替换。</p>
	*<p>设置Text.langPacks语言包后，即可使用lang获取里面的语言</p>
	*<p>例如：
	*<li>（1）text 的值为“我的名字”，先取到这个文本对应的当前语言版本里的值“My name”，将“My name”设置为当前文本的内容。</li>
	*<li>（2）text 的值为“恭喜你赢得{0}个钻石，{1}经验。”，arg1 的值为100，arg2 的值为200。
	*则先取到这个文本对应的当前语言版本里的值“Congratulations on your winning {0}diamonds,{1}experience.”，
	*然后将文本里的{0}、{1}，依据括号里的数字从0开始替换为 arg1、arg2 的值。
	*将替换处理后的文本“Congratulations on your winning 100 diamonds,200 experience.”设置为当前文本的内容。
	*</li>
	*</p>
	*@param text 文本内容。
	*@param ...args 文本替换参数。
	*/
	__proto.lang=function(text,arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10){
		text=Text.langPacks && Text.langPacks[text] ? Text.langPacks[text] :text;
		if (arguments.length < 2){
			this._text=text;
			}else {
			for (var i=0,n=arguments.length;i < n;i++){
				text=text.replace("{"+i+"}",arguments[i+1]);
			}
			this._text=text;
		}
	}

	/**
	*@private
	*/
	__proto._isPassWordMode=function(){
		var style=this._style;
		var password=style.password;
		if (("prompt" in this)&& this['prompt']==this._text)
			password=false;
		return password;
	}

	/**
	*@private
	*/
	__proto._getPassWordTxt=function(txt){
		var len=txt.length;
		var word;
		word="";
		for (var j=len;j > 0;j--){
			word+="●";
		}
		return word;
	}

	/**
	*渲染文字。
	*@param begin 开始渲染的行索引。
	*@param visibleLineCount 渲染的行数。
	*/
	__proto.renderText=function(begin,visibleLineCount){
		var graphics=this.graphics;
		graphics.clear(true);
		var ctxFont=(this.italic ? "italic " :"")+(this.bold ? "bold " :"")+this.fontSize+"px "+(Browser.onIPhone ? (laya.display.Text._fontFamilyMap[this.font] || this.font):this.font);
		Browser.context.font=ctxFont;
		var padding=this.padding;
		var startX=padding[3];
		var textAlgin="left";
		var lines=this._lines;
		var lineHeight=this.leading+this._charSize.height;
		var tCurrBitmapFont=this._currBitmapFont;
		if (tCurrBitmapFont){
			lineHeight=this.leading+tCurrBitmapFont.getMaxHeight();
		};
		var startY=padding[0];
		if ((!tCurrBitmapFont)&& this._width > 0 && this._textWidth <=this._width){
			if (this.align=="right"){
				textAlgin="right";
				startX=this._width-padding[1];
				}else if (this.align=="center"){
				textAlgin="center";
				startX=this._width *0.5+padding[3]-padding[1];
			}
		}
		if (this._height > 0){
			var tempVAlign=(this._textHeight > this._height)? "top" :this.valign;
			if (tempVAlign==="middle")
				startY=(this._height-visibleLineCount *lineHeight)*0.5+padding[0]-padding[2];
			else if (tempVAlign==="bottom")
			startY=this._height-visibleLineCount *lineHeight-padding[2];
		};
		var style=this._style;
		if (tCurrBitmapFont && tCurrBitmapFont.autoScaleSize){
			var bitmapScale=tCurrBitmapFont.fontSize / this.fontSize;
		}
		if (this._clipPoint){
			graphics.save();
			if (tCurrBitmapFont && tCurrBitmapFont.autoScaleSize){
				var tClipWidth=0;
				var tClipHeight=0;
				this._width ? tClipWidth=(this._width-padding[3]-padding[1]):tClipWidth=this._textWidth;
				this._height ? tClipHeight=(this._height-padding[0]-padding[2]):tClipHeight=this._textHeight;
				tClipWidth *=bitmapScale;
				tClipHeight *=bitmapScale;
				graphics.clipRect(padding[3],padding[0],tClipWidth,tClipHeight);
				}else {
				graphics.clipRect(padding[3],padding[0],this._width ? (this._width-padding[3]-padding[1]):this._textWidth,this._height ? (this._height-padding[0]-padding[2]):this._textHeight);
			}
		};
		var password=style.password;
		if (("prompt" in this)&& this['prompt']==this._text)
			password=false;
		var x=0,y=0;
		var end=Math.min(this._lines.length,visibleLineCount+begin)|| 1;
		for (var i=begin;i < end;i++){
			var word=lines[i];
			var _word;
			if (password){
				var len=word.length;
				word="";
				for (var j=len;j > 0;j--){
					word+="●";
				}
			}
			x=startX-(this._clipPoint ? this._clipPoint.x :0);
			y=startY+lineHeight *i-(this._clipPoint ? this._clipPoint.y :0);
			this.underline && this.drawUnderline(textAlgin,x,y,i);
			if (tCurrBitmapFont){
				var tWidth=this.width;
				if (tCurrBitmapFont.autoScaleSize){
					tWidth=this.width *bitmapScale;
				}
				tCurrBitmapFont.drawText(word,this,x,y,this.align,tWidth);
				}else {
				if (Render.isWebGL){
					this._words || (this._words=[]);
					_word=this._words.length > (i-begin)? this._words[i-begin] :new WordText();
					_word.setText(word);
					}else {
					_word=word;
				}
				style.stroke ? graphics.fillBorderText(_word,x,y,ctxFont,this.color,style.strokeColor,style.stroke,textAlgin):graphics.fillText(_word,x,y,ctxFont,this.color,textAlgin);
			}
		}
		if (tCurrBitmapFont && tCurrBitmapFont.autoScaleSize){
			var tScale=1 / bitmapScale;
			this.scale(tScale,tScale);
		}
		if (this._clipPoint)
			graphics.restore();
		this._startX=startX;
		this._startY=startY;
	}

	/**
	*绘制下划线
	*@param x 本行坐标
	*@param y 本行坐标
	*@param lineIndex 本行索引
	*/
	__proto.drawUnderline=function(align,x,y,lineIndex){
		var lineWidth=this._lineWidths[lineIndex];
		switch (align){
			case 'center':
				x-=lineWidth / 2;
				break ;
			case 'right':
				x-=lineWidth;
				break ;
			case 'left':
			default :
				break ;
			}
		y+=this._charSize.height;
		this._graphics.drawLine(x,y,x+lineWidth,y,this.underlineColor || this.color,1);
	}

	/**
	*<p>排版文本。</p>
	*<p>进行宽高计算，渲染、重绘文本。</p>
	*/
	__proto.typeset=function(){
		this._isChanged=false;
		if (!this._text){
			this._clipPoint=null;
			this._textWidth=this._textHeight=0;
			this.graphics.clear(true);
			return;
		}
		Browser.context.font=this._getCSSStyle().font;
		this._lines.length=0;
		this._lineWidths.length=0;
		if (this._isPassWordMode()){
			this.parseLines(this._getPassWordTxt(this._text));
		}else
		this.parseLines(this._text);
		this.evalTextSize();
		if (this.checkEnabledViewportOrNot())
			this._clipPoint || (this._clipPoint=new Point(0,0));
		else
		this._clipPoint=null;
		var lineCount=this._lines.length;
		if (this.overflow !=Text.VISIBLE){
			var func=this.overflow==Text.HIDDEN ? Math.floor :Math.ceil;
			lineCount=Math.min(lineCount,func((this.height-this.padding[0]-this.padding[2])/ (this.leading+this._charSize.height)));
		};
		var startLine=this.scrollY / (this._charSize.height+this.leading)| 0;
		this.renderText(startLine,lineCount);
		this.repaint();
	}

	__proto.evalTextSize=function(){
		var nw=NaN,nh=NaN;
		nw=Math.max.apply(this,this._lineWidths);
		if (this._currBitmapFont)
			nh=this._lines.length *(this._currBitmapFont.getMaxHeight()+this.leading)+this.padding[0]+this.padding[2];
		else
		nh=this._lines.length *(this._charSize.height+this.leading)+this.padding[0]+this.padding[2];
		if (nw !=this._textWidth || nh !=this._textHeight){
			this._textWidth=nw;
			this._textHeight=nh;
			if (!this._width || !this._height)
				this.conchModel && this.conchModel.size(this._width || this._textWidth,this._height || this._textHeight);
		}
	}

	__proto.checkEnabledViewportOrNot=function(){
		return this.overflow==Text.SCROLL && ((this._width > 0 && this._textWidth > this._width)|| (this._height > 0 && this._textHeight > this._height));
	}

	/**
	*<p>快速更改显示文本。不进行排版计算，效率较高。</p>
	*<p>如果只更改文字内容，不更改文字样式，建议使用此接口，能提高效率。</p>
	*@param text 文本内容。
	*/
	__proto.changeText=function(text){
		if (this._text!==text){
			this.lang(text+"");
			if (this._graphics && this._graphics.replaceText(this._text)){
				}else {
				this.typeset();
			}
		}
	}

	/**
	*@private
	*分析文本换行。
	*/
	__proto.parseLines=function(text){
		var needWordWrapOrTruncate=this.wordWrap || this.overflow==Text.HIDDEN;
		if (needWordWrapOrTruncate){
			var wordWrapWidth=this.getWordWrapWidth();
		}
		if (this._currBitmapFont){
			this._charSize.width=this._currBitmapFont.getMaxWidth();
			this._charSize.height=this._currBitmapFont.getMaxHeight();
			}else {
			var measureResult=Browser.context.measureText(Text._testWord);
			this._charSize.width=measureResult.width;
			this._charSize.height=(measureResult.height || this.fontSize);
		};
		var lines=text.replace(/\r\n/g,"\n").split("\n");
		for (var i=0,n=lines.length;i < n;i++){
			var line=lines[i];
			if (needWordWrapOrTruncate)
				this.parseLine(line,wordWrapWidth);
			else {
				this._lineWidths.push(this.getTextWidth(line));
				this._lines.push(line);
			}
		}
	}

	/**
	*@private
	*解析行文本。
	*@param line 某行的文本。
	*@param wordWrapWidth 文本的显示宽度。
	*/
	__proto.parseLine=function(line,wordWrapWidth){
		var ctx=Browser.context;
		var lines=this._lines;
		var maybeIndex=0;
		var execResult;
		var charsWidth=NaN;
		var wordWidth=NaN;
		var startIndex=0;
		charsWidth=this.getTextWidth(line);
		if (charsWidth <=wordWrapWidth){
			lines.push(line);
			this._lineWidths.push(charsWidth);
			return;
		}
		charsWidth=this._charSize.width;
		maybeIndex=Math.floor(wordWrapWidth / charsWidth);
		(maybeIndex==0)&& (maybeIndex=1);
		charsWidth=this.getTextWidth(line.substring(0,maybeIndex));
		wordWidth=charsWidth;
		for (var j=maybeIndex,m=line.length;j < m;j++){
			charsWidth=this.getTextWidth(line.charAt(j));
			wordWidth+=charsWidth;
			if (wordWidth > wordWrapWidth){
				if (this.wordWrap){
					var newLine=line.substring(startIndex,j);
					if (newLine.charCodeAt(newLine.length-1)< 255){
						execResult=/(?:\w|-)+$/.exec(newLine);
						if (execResult){
							j=execResult.index+startIndex;
							if (execResult.index==0)
								j+=newLine.length;
							else
							newLine=line.substring(startIndex,j);
						}
					}else
					if (Text.RightToLeft){
						execResult=/([\u0600-\u06FF])+$/.exec(newLine);
						if(execResult){
							j=execResult.index+startIndex;
							if (execResult.index==0)
								j+=newLine.length;
							else
							newLine=line.substring(startIndex,j);
						}
					}
					lines.push(newLine);
					this._lineWidths.push(wordWidth-charsWidth);
					startIndex=j;
					if (j+maybeIndex < m){
						j+=maybeIndex;
						charsWidth=this.getTextWidth(line.substring(startIndex,j));
						wordWidth=charsWidth;
						j--;
						}else {
						lines.push(line.substring(startIndex,m));
						this._lineWidths.push(this.getTextWidth(lines[lines.length-1]));
						startIndex=-1;
						break ;
					}
					}else if (this.overflow==Text.HIDDEN){
					lines.push(line.substring(0,j));
					this._lineWidths.push(this.getTextWidth(lines[lines.length-1]));
					return;
				}
			}
		}
		if (this.wordWrap && startIndex !=-1){
			lines.push(line.substring(startIndex,m));
			this._lineWidths.push(this.getTextWidth(lines[lines.length-1]));
		}
	}

	__proto.getTextWidth=function(text){
		if (this._currBitmapFont)
			return this._currBitmapFont.getTextWidth(text);
		else
		return Browser.context.measureText(text).width;
	}

	/**
	*获取换行所需的宽度。
	*/
	__proto.getWordWrapWidth=function(){
		var p=this.padding;
		var w=NaN;
		if (this._currBitmapFont && this._currBitmapFont.autoScaleSize)
			w=this._width *(this._currBitmapFont.fontSize / this.fontSize);
		else
		w=this._width;
		if (w <=0){
			w=this.wordWrap ? 100 :Browser.width;
		}
		w <=0 && (w=100);
		return w-p[3]-p[1];
	}

	/**
	*返回字符在本类实例的父坐标系下的坐标。
	*@param charIndex 索引位置。
	*@param out （可选）输出的Point引用。
	*@return Point 字符在本类实例的父坐标系下的坐标。如果out参数不为空，则将结果赋值给指定的Point对象，否则创建一个新的Point对象返回。建议使用Point.TEMP作为out参数，可以省去Point对象创建和垃圾回收的开销，尤其是在需要频繁执行的逻辑中，比如帧循环和MOUSE_MOVE事件回调函数里面。
	*/
	__proto.getCharPoint=function(charIndex,out){
		this._isChanged && Laya.timer.runCallLater(this,this.typeset);
		var len=0,lines=this._lines,startIndex=0;
		for (var i=0,n=lines.length;i < n;i++){
			len+=lines[i].length;
			if (charIndex < len){
				var line=i;
				break ;
			}
			startIndex=len;
		};
		var ctxFont=(this.italic ? "italic " :"")+(this.bold ? "bold " :"")+this.fontSize+"px "+this.font;
		Browser.context.font=ctxFont;
		var width=this.getTextWidth(this._text.substring(startIndex,charIndex));
		var point=out || new Point();
		return point.setTo(this._startX+width-(this._clipPoint ? this._clipPoint.x :0),this._startY+line *(this._charSize.height+this.leading)-(this._clipPoint ? this._clipPoint.y :0));
	}

	/**
	*@inheritDoc
	*/
	__getset(0,__proto,'width',function(){
		if (this._width)
			return this._width;
		return this.textWidth+this.padding[1]+this.padding[3];
		},function(value){
		if (value !=this._width){
			Laya.superSet(Sprite,this,'width',value);
			this.isChanged=true;
		}
	});

	/**
	*表示文本的宽度，以像素为单位。
	*/
	__getset(0,__proto,'textWidth',function(){
		this._isChanged && Laya.timer.runCallLater(this,this.typeset);
		return this._textWidth;
	});

	/**
	*@inheritDoc
	*/
	__getset(0,__proto,'height',function(){
		if (this._height)return this._height;
		return this.textHeight+this.padding[0]+this.padding[2];
		},function(value){
		if (value !=this._height){
			Laya.superSet(Sprite,this,'height',value);
			this.isChanged=true;
		}
	});

	/**
	*表示文本的高度，以像素为单位。
	*/
	__getset(0,__proto,'textHeight',function(){
		this._isChanged && Laya.timer.runCallLater(this,this.typeset);
		return this._textHeight;
	});

	/**
	*<p>边距信息。</p>
	*<p>数据格式：[上边距，右边距，下边距，左边距]（边距以像素为单位）。</p>
	*/
	__getset(0,__proto,'padding',function(){
		return this._getCSSStyle().padding;
		},function(value){
		this._getCSSStyle().padding=value;
		this.isChanged=true;
	});

	/**
	*<p>指定文本是否为粗体字。</p>
	*<p>默认值为 false，这意味着不使用粗体字。如果值为 true，则文本为粗体字。</p>
	*/
	__getset(0,__proto,'bold',function(){
		return this._getCSSStyle().bold;
		},function(value){
		this._getCSSStyle().bold=value;
		this.isChanged=true;
	});

	/**当前文本的内容字符串。*/
	__getset(0,__proto,'text',function(){
		return this._text || "";
		},function(value){
		if (this._text!==value){
			this.lang(value+"");
			this.isChanged=true;
			this.event(/*laya.events.Event.CHANGE*/"change");
		}
	});

	/**
	*<p>表示文本的颜色值。可以通过 <code>Text.defaultColor</code> 设置默认颜色。</p>
	*<p>默认值为黑色。</p>
	*/
	__getset(0,__proto,'color',function(){
		return this._getCSSStyle().color;
		},function(value){
		if (this._getCSSStyle().color !=value){
			this._getCSSStyle().color=value;
			if (!this._isChanged && this._graphics){
				this._graphics.replaceTextColor(this.color)
				}else {
				this.isChanged=true;
			}
		}
	});

	/**
	*<p>文本的字体名称，以字符串形式表示。</p>
	*<p>默认值为："Arial"，可以通过Font.defaultFont设置默认字体。</p>
	*<p>如果运行时系统找不到设定的字体，则用系统默认的字体渲染文字，从而导致显示异常。(通常电脑上显示正常，在一些移动端因缺少设置的字体而显示异常)。</p>
	*@see laya.display.css.Font#defaultFamily
	*/
	__getset(0,__proto,'font',function(){
		return this._getCSSStyle().fontFamily;
		},function(value){
		if (this._currBitmapFont){
			this._currBitmapFont=null;
			this.scale(1,1);
		}
		if (Text._bitmapFonts && Text._bitmapFonts[value]){
			this._currBitmapFont=Text._bitmapFonts[value];
		}
		this._getCSSStyle().fontFamily=value;
		this.isChanged=true;
	});

	/**
	*<p>指定文本的字体大小（以像素为单位）。</p>
	*<p>默认为20像素，可以通过 <code>Text.defaultSize</code> 设置默认大小。</p>
	*/
	__getset(0,__proto,'fontSize',function(){
		return this._getCSSStyle().fontSize;
		},function(value){
		this._getCSSStyle().fontSize=value;
		this.isChanged=true;
	});

	/**
	*<p>表示使用此文本格式的文本是否为斜体。</p>
	*<p>默认值为 false，这意味着不使用斜体。如果值为 true，则文本为斜体。</p>
	*/
	__getset(0,__proto,'italic',function(){
		return this._getCSSStyle().italic;
		},function(value){
		this._getCSSStyle().italic=value;
		this.isChanged=true;
	});

	/**
	*<p>表示文本的水平显示方式。</p>
	*<p><b>取值：</b>
	*<li>"left"： 居左对齐显示。</li>
	*<li>"center"： 居中对齐显示。</li>
	*<li>"right"： 居右对齐显示。</li>
	*</p>
	*/
	__getset(0,__proto,'align',function(){
		return this._getCSSStyle().align;
		},function(value){
		this._getCSSStyle().align=value;
		this.isChanged=true;
	});

	/**
	*<p>表示文本的垂直显示方式。</p>
	*<p><b>取值：</b>
	*<li>"top"： 居顶部对齐显示。</li>
	*<li>"middle"： 居中对齐显示。</li>
	*<li>"bottom"： 居底部对齐显示。</li>
	*</p>
	*/
	__getset(0,__proto,'valign',function(){
		return this._getCSSStyle().valign;
		},function(value){
		this._getCSSStyle().valign=value;
		this.isChanged=true;
	});

	/**
	*<p>表示文本是否自动换行，默认为false。</p>
	*<p>若值为true，则自动换行；否则不自动换行。</p>
	*/
	__getset(0,__proto,'wordWrap',function(){
		return this._getCSSStyle().wordWrap;
		},function(value){
		this._getCSSStyle().wordWrap=value;
		this.isChanged=true;
	});

	/**
	*垂直行间距（以像素为单位）。
	*/
	__getset(0,__proto,'leading',function(){
		return this._getCSSStyle().leading;
		},function(value){
		this._getCSSStyle().leading=value;
		this.isChanged=true;
	});

	/**
	*文本背景颜色，以字符串表示。
	*/
	__getset(0,__proto,'bgColor',function(){
		return this._getCSSStyle().backgroundColor;
		},function(value){
		this._getCSSStyle().backgroundColor=value;
		this.isChanged=true;
	});

	/**
	*文本边框背景颜色，以字符串表示。
	*/
	__getset(0,__proto,'borderColor',function(){
		return this._getCSSStyle().borderColor;
		},function(value){
		this._getCSSStyle().borderColor=value;
		this.isChanged=true;
	});

	/**
	*<p>描边宽度（以像素为单位）。</p>
	*<p>默认值0，表示不描边。</p>
	*/
	__getset(0,__proto,'stroke',function(){
		return this._getCSSStyle().stroke;
		},function(value){
		this._getCSSStyle().stroke=value;
		this.isChanged=true;
	});

	/**
	*<p>描边颜色，以字符串表示。</p>
	*<p>默认值为 "#000000"（黑色）;</p>
	*/
	__getset(0,__proto,'strokeColor',function(){
		return this._getCSSStyle().strokeColor;
		},function(value){
		this._getCSSStyle().strokeColor=value;
		this.isChanged=true;
	});

	/**
	*一个布尔值，表示文本的属性是否有改变。若为true表示有改变。
	*/
	__getset(0,__proto,'isChanged',null,function(value){
		if (this._isChanged!==value){
			this._isChanged=value;
			value && Laya.timer.callLater(this,this.typeset);
		}
	});

	/**
	*<p>设置横向滚动量。</p>
	*<p>即使设置超出滚动范围的值，也会被自动限制在可能的最大值处。</p>
	*/
	/**
	*获取横向滚动量。
	*/
	__getset(0,__proto,'scrollX',function(){
		if (!this._clipPoint)
			return 0;
		return this._clipPoint.x;
		},function(value){
		if (this.overflow !=Text.SCROLL || (this.textWidth < this._width || !this._clipPoint))
			return;
		value=value < this.padding[3] ? this.padding[3] :value;
		var maxScrollX=this._textWidth-this._width;
		value=value > maxScrollX ? maxScrollX :value;
		var visibleLineCount=this._height / (this._charSize.height+this.leading)| 0+1;
		this._clipPoint.x=value;
		this.renderText(this._lastVisibleLineIndex,visibleLineCount);
	});

	/**
	*设置纵向滚动量（px)。即使设置超出滚动范围的值，也会被自动限制在可能的最大值处。
	*/
	/**
	*获取纵向滚动量。
	*/
	__getset(0,__proto,'scrollY',function(){
		if (!this._clipPoint)
			return 0;
		return this._clipPoint.y;
		},function(value){
		if (this.overflow !=Text.SCROLL || (this.textHeight < this._height || !this._clipPoint))
			return;
		value=value < this.padding[0] ? this.padding[0] :value;
		var maxScrollY=this._textHeight-this._height;
		value=value > maxScrollY ? maxScrollY :value;
		var startLine=value / (this._charSize.height+this.leading)| 0;
		this._lastVisibleLineIndex=startLine;
		var visibleLineCount=(this._height / (this._charSize.height+this.leading)| 0)+1;
		this._clipPoint.y=value;
		this.renderText(startLine,visibleLineCount);
	});

	/**
	*获取横向可滚动最大值。
	*/
	__getset(0,__proto,'maxScrollX',function(){
		return (this.textWidth < this._width)? 0 :this._textWidth-this._width;
	});

	/**
	*获取纵向可滚动最大值。
	*/
	__getset(0,__proto,'maxScrollY',function(){
		return (this.textHeight < this._height)? 0 :this._textHeight-this._height;
	});

	__getset(0,__proto,'lines',function(){
		if (this._isChanged)
			this.typeset();
		return this._lines;
	});

	__getset(0,__proto,'underlineColor',function(){
		return this._underlineColor;
		},function(value){
		this._underlineColor=value;
		this._isChanged=true;
		this.typeset();
	});

	Text.registerBitmapFont=function(name,bitmapFont){
		Text._bitmapFonts || (Text._bitmapFonts={});
		Text._bitmapFonts[name]=bitmapFont;
	}

	Text.unregisterBitmapFont=function(name,destroy){
		(destroy===void 0)&& (destroy=true);
		if (Text._bitmapFonts && Text._bitmapFonts[name]){
			var tBitmapFont=Text._bitmapFonts[name];
			if (destroy){
				tBitmapFont.destroy();
			}
			delete Text._bitmapFonts[name];
		}
	}

	Text.setTextRightToLeft=function(){
		var style;
		style=Browser.canvas.source.style;
		style.display="none";
		style.position="absolute";
		style.direction="rtl";
		Render._mainCanvas.source.style.direction="rtl";
		laya.display.Text.RightToLeft=true;
		Browser.document.body.appendChild(Browser.canvas.source);
	}

	Text.supportFont=function(font){
		Browser.context.font="10px sans-serif";
		var defaultFontWidth=Browser.context.measureText("abcji").width;
		Browser.context.font="10px "+font;
		var customFontWidth=Browser.context.measureText("abcji").width;
		console.log(defaultFontWidth,customFontWidth);
		if (defaultFontWidth===customFontWidth)return false;
		else return true;
	}

	Text._testWord="游";
	Text.langPacks=null;
	Text.VISIBLE="visible";
	Text.SCROLL="scroll";
	Text.HIDDEN="hidden";
	Text.CharacterCache=true;
	Text.RightToLeft=false;
	Text._bitmapFonts=null;
	__static(Text,
	['_fontFamilyMap',function(){return this._fontFamilyMap={"报隶" :"报隶-简","黑体" :"黑体-简","楷体" :"楷体-简","兰亭黑" :"兰亭黑-简","隶变" :"隶变-简","凌慧体" :"凌慧体-简","翩翩体" :"翩翩体-简","苹方" :"苹方-简","手札体" :"手札体-简","宋体" :"宋体-简","娃娃体" :"娃娃体-简","魏碑" :"魏碑-简","行楷" :"行楷-简","雅痞" :"雅痞-简","圆体" :"圆体-简"};}
	]);
	return Text;
})(Sprite)


/**
*<p> <code>Stage</code> 是舞台类，显示列表的根节点，所有显示对象都在舞台上显示。通过 Laya.stage 单例访问。</p>
*<p>Stage提供几种适配模式，不同的适配模式会产生不同的画布大小，画布越大，渲染压力越大，所以要选择合适的适配方案。</p>
*<p>Stage提供不同的帧率模式，帧率越高，渲染压力越大，越费电，合理使用帧率甚至动态更改帧率有利于改进手机耗电。</p>
*/
//class laya.display.Stage extends laya.display.Sprite
var Stage=(function(_super){
	function Stage(){
		/**当前焦点对象，此对象会影响当前键盘事件的派发主体。*/
		this.focus=null;
		/**设计宽度（初始化时设置的宽度Laya.init(width,height)）*/
		this.designWidth=0;
		/**设计高度（初始化时设置的高度Laya.init(width,height)）*/
		this.designHeight=0;
		/**画布是否发生翻转。*/
		this.canvasRotation=false;
		/**画布的旋转角度。*/
		this.canvasDegree=0;
		/**
		*<p>设置是否渲染，设置为false，可以停止渲染，画面会停留到最后一次渲染上，减少cpu消耗，此设置不影响时钟。</p>
		*<p>比如非激活状态，可以设置renderingEnabled=false以节省消耗。</p>
		**/
		this.renderingEnabled=true;
		/**是否启用屏幕适配，可以适配后，在某个时候关闭屏幕适配，防止某些操作导致的屏幕以外改变*/
		this.screenAdaptationEnabled=true;
		/**@private */
		this._screenMode="none";
		/**@private */
		this._scaleMode="noscale";
		/**@private */
		this._alignV="top";
		/**@private */
		this._alignH="left";
		/**@private */
		this._bgColor="black";
		/**@private */
		this._mouseMoveTime=0;
		/**@private */
		this._renderCount=0;
		/**@private */
		this._frameStartTime=NaN;
		/**@private */
		this._isFocused=false;
		/**@private */
		this._isVisibility=false;
		/**@private 3D场景*/
		this._scenes=null;
		/**@private */
		this._frameRate="fast";
		Stage.__super.call(this);
		this.offset=new Point();
		this._canvasTransform=new Matrix();
		this._previousOrientation=Browser.window.orientation;
		var _$this=this;
		this.transform=Matrix.create();
		this._scenes=[];
		this.mouseEnabled=true;
		this.hitTestPrior=true;
		this.autoSize=false;
		this._displayedInStage=true;
		this._isFocused=true;
		this._isVisibility=true;
		var window=Browser.window;
		var _this=this;
		window.addEventListener("focus",function(){
			_$this._isFocused=true;
			_this.event(/*laya.events.Event.FOCUS*/"focus");
			_this.event(/*laya.events.Event.FOCUS_CHANGE*/"focuschange");
		});
		window.addEventListener("blur",function(){
			_$this._isFocused=false;
			_this.event(/*laya.events.Event.BLUR*/"blur");
			_this.event(/*laya.events.Event.FOCUS_CHANGE*/"focuschange");
			if (_this._isInputting())Input["inputElement"].target.focus=false;
		});
		var hidden="hidden",state="visibilityState",visibilityChange="visibilitychange";
		var document=window.document;
		if (typeof document.hidden!=="undefined"){
			visibilityChange="visibilitychange";
			state="visibilityState";
			}else if (typeof document.mozHidden!=="undefined"){
			visibilityChange="mozvisibilitychange";
			state="mozVisibilityState";
			}else if (typeof document.msHidden!=="undefined"){
			visibilityChange="msvisibilitychange";
			state="msVisibilityState";
			}else if (typeof document.webkitHidden!=="undefined"){
			visibilityChange="webkitvisibilitychange";
			state="webkitVisibilityState";
		}
		window.document.addEventListener(visibilityChange,visibleChangeFun);
		function visibleChangeFun (){
			if (Browser.document[state]=="hidden"){
				_this._setStageVisible(false);
				}else {
				_this._setStageVisible(true);
			}
		}
		window.document.addEventListener("qbrowserVisibilityChange",qbroserVisibleChangeFun);
		function qbroserVisibleChangeFun (e){
			_this._setStageVisible(!e.hidden);
		}
		window.addEventListener("resize",function(){
			var orientation=Browser.window.orientation;
			if (orientation !=null && orientation !=_$this._previousOrientation && _this._isInputting()){
				Input["inputElement"].target.focus=false;
			}
			_$this._previousOrientation=orientation;
			if (_this._isInputting())return;
			_this._resetCanvas();
		});
		window.addEventListener("orientationchange",function(e){
			_this._resetCanvas();
		});
		this.on(/*laya.events.Event.MOUSE_MOVE*/"mousemove",this,this._onmouseMove);
		if (Browser.onMobile)this.on(/*laya.events.Event.MOUSE_DOWN*/"mousedown",this,this._onmouseMove);
	}

	__class(Stage,'laya.display.Stage',_super);
	var __proto=Stage.prototype;
	__proto._setStageVisible=function(value){
		if (this._isVisibility==value)return;
		this._isVisibility=value;
		if (!this._isVisibility)if (this._isInputting())Input["inputElement"].target.focus=false;
		this.event(/*laya.events.Event.VISIBILITY_CHANGE*/"visibilitychange");
	}

	/**
	*@private
	*在移动端输入时，输入法弹出期间不进行画布尺寸重置。
	*/
	__proto._isInputting=function(){
		return (Browser.onMobile && Input.isInputting);
	}

	/**@private */
	__proto._changeCanvasSize=function(){
		this.setScreenSize(Browser.clientWidth *Browser.pixelRatio,Browser.clientHeight *Browser.pixelRatio);
	}

	/**@private */
	__proto._resetCanvas=function(){
		if (!this.screenAdaptationEnabled)return;
		var canvas=Render._mainCanvas;
		var canvasStyle=canvas.source.style;
		canvas.size(1,1);
		Laya.timer.once(100,this,this._changeCanvasSize);
	}

	/**
	*设置屏幕大小，场景会根据屏幕大小进行适配。可以动态调用此方法，来更改游戏显示的大小。
	*@param screenWidth 屏幕宽度。
	*@param screenHeight 屏幕高度。
	*/
	__proto.setScreenSize=function(screenWidth,screenHeight){
		var rotation=false;
		if (this._screenMode!=="none"){
			var screenType=screenWidth / screenHeight < 1 ? "vertical" :"horizontal";
			rotation=screenType!==this._screenMode;
			if (rotation){
				var temp=screenHeight;
				screenHeight=screenWidth;
				screenWidth=temp;
			}
		}
		this.canvasRotation=rotation;
		var canvas=Render._mainCanvas;
		var canvasStyle=canvas.source.style;
		var mat=this._canvasTransform.identity();
		var scaleMode=this._scaleMode;
		var scaleX=screenWidth / this.designWidth;
		var scaleY=screenHeight / this.designHeight;
		var canvasWidth=this.designWidth;
		var canvasHeight=this.designHeight;
		var realWidth=screenWidth;
		var realHeight=screenHeight;
		var pixelRatio=Browser.pixelRatio;
		this._width=this.designWidth;
		this._height=this.designHeight;
		switch (scaleMode){
			case "noscale":
				scaleX=scaleY=1;
				realWidth=this.designWidth;
				realHeight=this.designHeight;
				break ;
			case "showall":
				scaleX=scaleY=Math.min(scaleX,scaleY);
				canvasWidth=realWidth=Math.round(this.designWidth *scaleX);
				canvasHeight=realHeight=Math.round(this.designHeight *scaleY);
				break ;
			case "noborder":
				scaleX=scaleY=Math.max(scaleX,scaleY);
				realWidth=Math.round(this.designWidth *scaleX);
				realHeight=Math.round(this.designHeight *scaleY);
				break ;
			case "full":
				scaleX=scaleY=1;
				this._width=canvasWidth=screenWidth;
				this._height=canvasHeight=screenHeight;
				break ;
			case "fixedwidth":
				scaleY=scaleX;
				this._height=canvasHeight=Math.round(screenHeight / scaleX);
				break ;
			case "fixedheight":
				scaleX=scaleY;
				this._width=canvasWidth=Math.round(screenWidth / scaleY);
				break ;
			case "fixedauto":
				if ((screenWidth / screenHeight)< (this.designWidth / this.designHeight)){
					scaleY=scaleX;
					this._height=canvasHeight=Math.round(screenHeight / scaleX);
					}else {
					scaleX=scaleY;
					this._width=canvasWidth=Math.round(screenWidth / scaleY);
				}
				break ;
			}
		if (this.conchModel)this.conchModel.size(this._width,this._height);
		scaleX *=this.scaleX;
		scaleY *=this.scaleY;
		if (scaleX===1 && scaleY===1){
			this.transform.identity();
			}else {
			this.transform.a=this._formatData(scaleX / (realWidth / canvasWidth));
			this.transform.d=this._formatData(scaleY / (realHeight / canvasHeight));
			this.conchModel && this.conchModel.scale(this.transform.a,this.transform.d);
		}
		canvas.size(canvasWidth,canvasHeight);
		RunDriver.changeWebGLSize(canvasWidth,canvasHeight);
		mat.scale(realWidth / canvasWidth / pixelRatio,realHeight / canvasHeight / pixelRatio);
		if (this._alignH==="left")this.offset.x=0;
		else if (this._alignH==="right")this.offset.x=(screenWidth-realWidth)/pixelRatio;
		else this.offset.x=(screenWidth-realWidth)*0.5 / pixelRatio;
		if (this._alignV==="top")this.offset.y=0;
		else if (this._alignV==="bottom")this.offset.y=(screenHeight-realHeight)/pixelRatio;
		else this.offset.y=(screenHeight-realHeight)*0.5 / pixelRatio;
		this.offset.x=Math.round(this.offset.x);
		this.offset.y=Math.round(this.offset.y);
		mat.translate(this.offset.x,this.offset.y);
		this.canvasDegree=0;
		if (rotation){
			if (this._screenMode==="horizontal"){
				mat.rotate(Math.PI / 2);
				mat.translate(screenHeight / pixelRatio,0);
				this.canvasDegree=90;
				}else {
				mat.rotate(-Math.PI / 2);
				mat.translate(0,screenWidth / pixelRatio);
				this.canvasDegree=-90;
			}
		}
		mat.a=this._formatData(mat.a);
		mat.d=this._formatData(mat.d);
		mat.tx=this._formatData(mat.tx);
		mat.ty=this._formatData(mat.ty);
		canvasStyle.transformOrigin=canvasStyle.webkitTransformOrigin=canvasStyle.msTransformOrigin=canvasStyle.mozTransformOrigin=canvasStyle.oTransformOrigin="0px 0px 0px";
		canvasStyle.transform=canvasStyle.webkitTransform=canvasStyle.msTransform=canvasStyle.mozTransform=canvasStyle.oTransform="matrix("+mat.toString()+")";
		mat.translate(parseInt(canvasStyle.left)|| 0,parseInt(canvasStyle.top)|| 0);
		this.visible=true;
		this._repaint=1;
		this.event(/*laya.events.Event.RESIZE*/"resize");
	}

	/**@private */
	__proto._formatData=function(value){
		if (Math.abs(value)< 0.000001)return 0;
		if (Math.abs(1-value)< 0.001)return value > 0 ? 1 :-1;
		return value;
	}

	/**@inheritDoc */
	__proto.getMousePoint=function(){
		return Point.TEMP.setTo(this.mouseX,this.mouseY);
	}

	/**@inheritDoc */
	__proto.repaint=function(){
		this._repaint=1;
	}

	/**@inheritDoc */
	__proto.parentRepaint=function(){}
	/**@private */
	__proto._loop=function(){
		this.render(Render.context,0,0);
		return true;
	}

	/**@private */
	__proto._onmouseMove=function(e){
		this._mouseMoveTime=Browser.now();
	}

	/**
	*<p>获得距当前帧开始后，过了多少时间，单位为毫秒。</p>
	*<p>可以用来判断函数内时间消耗，通过合理控制每帧函数处理消耗时长，避免一帧做事情太多，对复杂计算分帧处理，能有效降低帧率波动。</p>
	*/
	__proto.getTimeFromFrameStart=function(){
		return Browser.now()-this._frameStartTime;
	}

	/**@inheritDoc */
	__proto.render=function(context,x,y){
		if (this._frameRate==="sleep" && !Render.isConchApp){
			var now=Browser.now();
			if (now-this._frameStartTime >=1000)this._frameStartTime=now;
			else return;
		}
		this._renderCount++;
		Render.isFlash && this.repaint();
		if (!this._style.visible){
			if (this._renderCount % 5===0){
				Stat.loopCount++;
				MouseManager.instance.runEvent();
				Laya.timer._update();
			}
			return;
		}
		this._frameStartTime=Browser.now();
		var frameMode=this._frameRate==="mouse" ? (((this._frameStartTime-this._mouseMoveTime)< 2000)? "fast" :"slow"):this._frameRate;
		var isFastMode=(frameMode!=="slow");
		var isDoubleLoop=(this._renderCount % 2===0);
		Stat.renderSlow=!isFastMode;
		if (isFastMode || isDoubleLoop || Render.isConchApp){
			Stat.loopCount++;
			MouseManager.instance.runEvent();
			Laya.timer._update();
			RunDriver.update3DLoop();
			var scene;
			var i=0,n=0;
			if (Render.isConchNode){
				for (i=0,n=this._scenes.length;i < n;i++){
					scene=this._scenes[i];
					(scene)&& (scene._updateSceneConch());
				}
				}else {
				for (i=0,n=this._scenes.length;i < n;i++){
					scene=this._scenes[i];
					(scene)&& (scene._updateScene());
				}
			}
			if (Render.isConchNode){
				var customList=Sprite["CustomList"];
				for (i=0,n=customList.length;i < n;i++){
					var customItem=customList[i];
					customItem.customRender(customItem.customContext,0,0);
				}
				return;
			}
		}
		if (Render.isConchNode)return;
		if (this.renderingEnabled && (isFastMode || !isDoubleLoop)){
			if (Render.isWebGL){
				context.clear();
				_super.prototype.render.call(this,context,x,y);
				Stat._show&& Stat._sp && Stat._sp.render(context,x,y);
				RunDriver.clear(this._bgColor);
				RunDriver.beginFlush();
				context.flush();
				RunDriver.endFinish();
				VectorGraphManager.instance && VectorGraphManager.getInstance().endDispose();
				}else {
				RunDriver.clear(this._bgColor);
				_super.prototype.render.call(this,context,x,y);
				Stat._show&& Stat._sp && Stat._sp.render(context,x,y);
			}
		}
	}

	/**@private */
	__proto._requestFullscreen=function(){
		var element=Browser.document.documentElement;
		if (element.requestFullscreen){
			element.requestFullscreen();
			}else if (element.mozRequestFullScreen){
			element.mozRequestFullScreen();
			}else if (element.webkitRequestFullscreen){
			element.webkitRequestFullscreen();
			}else if (element.msRequestFullscreen){
			element.msRequestFullscreen();
		}
	}

	/**@private */
	__proto._fullScreenChanged=function(){
		Laya.stage.event(/*laya.events.Event.FULL_SCREEN_CHANGE*/"fullscreenchange");
	}

	/**退出全屏模式*/
	__proto.exitFullscreen=function(){
		var document=Browser.document;
		if (document.exitFullscreen){
			document.exitFullscreen();
			}else if (document.mozCancelFullScreen){
			document.mozCancelFullScreen();
			}else if (document.webkitExitFullscreen){
			document.webkitExitFullscreen();
		}
	}

	/**当前视窗由缩放模式导致的 X 轴缩放系数。*/
	__getset(0,__proto,'clientScaleX',function(){
		return this._transform ? this._transform.getScaleX():1;
	});

	//[Deprecated]
	__getset(0,__proto,'desginHeight',function(){
		console.debug("desginHeight已经弃用，请使用designHeight代替");
		return this.designHeight;
	});

	/**帧率类型，支持三种模式：fast-60帧(默认)，slow-30帧，mouse-30帧（鼠标活动后会自动加速到60，鼠标不动2秒后降低为30帧，以节省消耗），sleep-1帧。*/
	__getset(0,__proto,'frameRate',function(){
		return this._frameRate;
		},function(value){
		this._frameRate=value;
		if (Render.isConchApp){
			switch (this._frameRate){
				case "slow":
					Browser.window.conch && Browser.window.conchConfig.setSlowFrame && Browser.window.conchConfig.setSlowFrame(true);
					break ;
				case "fast":
					Browser.window.conch && Browser.window.conchConfig.setSlowFrame && Browser.window.conchConfig.setSlowFrame(false);
					break ;
				case "mouse":
					Browser.window.conch && Browser.window.conchConfig.setMouseFrame && Browser.window.conchConfig.setMouseFrame(2000);
					break ;
				case "sleep":
					Browser.window.conch && Browser.window.conchConfig.setLimitFPS && Browser.window.conchConfig.setLimitFPS(1);
					break ;
				default :
					throw new Error("Stage:frameRate invalid.");
					break ;
				}
		}
	});

	/**当前视窗由缩放模式导致的 Y 轴缩放系数。*/
	__getset(0,__proto,'clientScaleY',function(){
		return this._transform ? this._transform.getScaleY():1;
	});

	__getset(0,__proto,'width',_super.prototype._$get_width,function(value){
		this.designWidth=value;
		Laya.superSet(Sprite,this,'width',value);
		Laya.timer.callLater(this,this._changeCanvasSize);
	});

	/**
	*<p>水平对齐方式。默认值为"left"。</p>
	*<p><ul>取值范围：
	*<li>"left" ：居左对齐；</li>
	*<li>"center" ：居中对齐；</li>
	*<li>"right" ：居右对齐；</li>
	*</ul></p>
	*/
	__getset(0,__proto,'alignH',function(){
		return this._alignH;
		},function(value){
		this._alignH=value;
		Laya.timer.callLater(this,this._changeCanvasSize);
	});

	/**
	*舞台是否获得焦点。
	*/
	__getset(0,__proto,'isFocused',function(){
		return this._isFocused;
	});

	__getset(0,__proto,'height',_super.prototype._$get_height,function(value){
		this.designHeight=value;
		Laya.superSet(Sprite,this,'height',value);
		Laya.timer.callLater(this,this._changeCanvasSize);
	});

	__getset(0,__proto,'transform',function(){
		if (this._tfChanged)this._adjustTransform();
		return this._transform=this._transform|| Matrix.create();
	},_super.prototype._$set_transform);

	/**
	*舞台是否处于可见状态(是否进入后台)。
	*/
	__getset(0,__proto,'isVisibility',function(){
		return this._isVisibility;
	});

	//[Deprecated]
	__getset(0,__proto,'desginWidth',function(){
		console.debug("desginWidth已经弃用，请使用designWidth代替");
		return this.designWidth;
	});

	/**
	*<p>缩放模式。默认值为 "noscale"。</p>
	*<p><ul>取值范围：
	*<li>"noscale" ：不缩放；</li>
	*<li>"exactfit" ：全屏不等比缩放；</li>
	*<li>"showall" ：最小比例缩放；</li>
	*<li>"noborder" ：最大比例缩放；</li>
	*<li>"full" ：不缩放，stage的宽高等于屏幕宽高；</li>
	*<li>"fixedwidth" ：宽度不变，高度根据屏幕比缩放；</li>
	*<li>"fixedheight" ：高度不变，宽度根据屏幕比缩放；</li>
	*<li>"fixedauto" ：根据宽高比，自动选择使用fixedwidth或fixedheight；</li>
	*</ul></p>
	*/
	__getset(0,__proto,'scaleMode',function(){
		return this._scaleMode;
		},function(value){
		this._scaleMode=value;
		Laya.timer.callLater(this,this._changeCanvasSize);
	});

	/**
	*<p>垂直对齐方式。默认值为"top"。</p>
	*<p><ul>取值范围：
	*<li>"top" ：居顶部对齐；</li>
	*<li>"middle" ：居中对齐；</li>
	*<li>"bottom" ：居底部对齐；</li>
	*</ul></p>
	*/
	__getset(0,__proto,'alignV',function(){
		return this._alignV;
		},function(value){
		this._alignV=value;
		Laya.timer.callLater(this,this._changeCanvasSize);
	});

	/**舞台的背景颜色，默认为黑色，null为透明。*/
	__getset(0,__proto,'bgColor',function(){
		return this._bgColor;
		},function(value){
		this._bgColor=value;
		this.conchModel && this.conchModel.bgColor(value);
		if (Render.isWebGL){
			if (value){
				Stage._wgColor=Color.create(value)._color;
				}else {
				if (!Browser.onMiniGame)Stage._wgColor=null;
			}
		}
		if (Browser.onLimixiu){
			Stage._wgColor=Color.create(value)._color;
		}else
		if (value){
			Render.canvas.style.background=value;
			}else {
			Render.canvas.style.background="none";
		}
	});

	/**鼠标在 Stage 上的 X 轴坐标。*/
	__getset(0,__proto,'mouseX',function(){
		return Math.round(MouseManager.instance.mouseX / this.clientScaleX);
	});

	/**鼠标在 Stage 上的 Y 轴坐标。*/
	__getset(0,__proto,'mouseY',function(){
		return Math.round(MouseManager.instance.mouseY / this.clientScaleY);
	});

	/**
	*<p>场景布局类型。</p>
	*<p><ul>取值范围：
	*<li>"none" ：不更改屏幕</li>
	*<li>"horizontal" ：自动横屏</li>
	*<li>"vertical" ：自动竖屏</li>
	*</ul></p>
	*/
	__getset(0,__proto,'screenMode',function(){
		return this._screenMode;
		},function(value){
		this._screenMode=value;
	});

	__getset(0,__proto,'visible',_super.prototype._$get_visible,function(value){
		if (this.visible!==value){
			Laya.superSet(Sprite,this,'visible',value);
			var style=Render._mainCanvas.source.style;
			style.visibility=value ? "visible" :"hidden";
		}
	});

	/**
	*<p>是否开启全屏，用户点击后进入全屏。</p>
	*<p>兼容性提示：部分浏览器不允许点击进入全屏，比如Iphone等。</p>
	*/
	__getset(0,__proto,'fullScreenEnabled',null,function(value){
		var document=Browser.document;
		var canvas=Render.canvas;
		if (value){
			canvas.addEventListener('mousedown',this._requestFullscreen);
			canvas.addEventListener('touchstart',this._requestFullscreen);
			document.addEventListener("fullscreenchange",this._fullScreenChanged);
			document.addEventListener("mozfullscreenchange",this._fullScreenChanged);
			document.addEventListener("webkitfullscreenchange",this._fullScreenChanged);
			document.addEventListener("msfullscreenchange",this._fullScreenChanged);
			}else {
			canvas.removeEventListener('mousedown',this._requestFullscreen);
			canvas.removeEventListener('touchstart',this._requestFullscreen);
			document.removeEventListener("fullscreenchange",this._fullScreenChanged);
			document.removeEventListener("mozfullscreenchange",this._fullScreenChanged);
			document.removeEventListener("webkitfullscreenchange",this._fullScreenChanged);
			document.removeEventListener("msfullscreenchange",this._fullScreenChanged);
		}
	});

	Stage.SCALE_NOSCALE="noscale";
	Stage.SCALE_EXACTFIT="exactfit";
	Stage.SCALE_SHOWALL="showall";
	Stage.SCALE_NOBORDER="noborder";
	Stage.SCALE_FULL="full";
	Stage.SCALE_FIXED_WIDTH="fixedwidth";
	Stage.SCALE_FIXED_HEIGHT="fixedheight";
	Stage.SCALE_FIXED_AUTO="fixedauto";
	Stage.ALIGN_LEFT="left";
	Stage.ALIGN_RIGHT="right";
	Stage.ALIGN_CENTER="center";
	Stage.ALIGN_TOP="top";
	Stage.ALIGN_MIDDLE="middle";
	Stage.ALIGN_BOTTOM="bottom";
	Stage.SCREEN_NONE="none";
	Stage.SCREEN_HORIZONTAL="horizontal";
	Stage.SCREEN_VERTICAL="vertical";
	Stage.FRAME_FAST="fast";
	Stage.FRAME_SLOW="slow";
	Stage.FRAME_MOUSE="mouse";
	Stage.FRAME_SLEEP="sleep";
	Stage.FRAME_MOUSE_THREDHOLD=2000;
	__static(Stage,
	['_wgColor',function(){return this._wgColor=[0,0,0,1];}
	]);
	return Stage;
})(Sprite)


/**
*@private
*/
//class laya.media.SoundNode extends laya.display.Sprite
var SoundNode=(function(_super){
	function SoundNode(){
		this.url=null;
		this._channel=null;
		this._tar=null;
		this._playEvents=null;
		this._stopEvents=null;
		SoundNode.__super.call(this);
		this.visible=false;
		this.on(/*laya.events.Event.ADDED*/"added",this,this._onParentChange);
		this.on(/*laya.events.Event.REMOVED*/"removed",this,this._onParentChange);
	}

	__class(SoundNode,'laya.media.SoundNode',_super);
	var __proto=SoundNode.prototype;
	/**@private */
	__proto._onParentChange=function(){
		this.target=this.parent;
	}

	/**
	*播放
	*@param loops 循环次数
	*@param complete 完成回调
	*
	*/
	__proto.play=function(loops,complete){
		(loops===void 0)&& (loops=1);
		if (isNaN(loops)){
			loops=1;
		}
		if (!this.url)return;
		this.stop();
		this._channel=SoundManager.playSound(this.url,loops,complete);
	}

	/**
	*停止播放
	*
	*/
	__proto.stop=function(){
		if (this._channel && !this._channel.isStopped){
			this._channel.stop();
		}
		this._channel=null;
	}

	/**@private */
	__proto._setPlayAction=function(tar,event,action,add){
		(add===void 0)&& (add=true);
		if (!this[action])return;
		if (!tar)return;
		if (add){
			tar.on(event,this,this[action]);
			}else {
			tar.off(event,this,this[action]);
		}
	}

	/**@private */
	__proto._setPlayActions=function(tar,events,action,add){
		(add===void 0)&& (add=true);
		if (!tar)return;
		if (!events)return;
		var eventArr=events.split(",");
		var i=0,len=0;
		len=eventArr.length;
		for (i=0;i < len;i++){
			this._setPlayAction(tar,eventArr[i],action,add);
		}
	}

	/**
	*设置触发播放的事件
	*@param events
	*
	*/
	__getset(0,__proto,'playEvent',null,function(events){
		this._playEvents=events;
		if (!events)return;
		if (this._tar){
			this._setPlayActions(this._tar,events,"play");
		}
	});

	/**
	*设置控制播放的对象
	*@param tar
	*
	*/
	__getset(0,__proto,'target',null,function(tar){
		if (this._tar){
			this._setPlayActions(this._tar,this._playEvents,"play",false);
			this._setPlayActions(this._tar,this._stopEvents,"stop",false);
		}
		this._tar=tar;
		if (this._tar){
			this._setPlayActions(this._tar,this._playEvents,"play",true);
			this._setPlayActions(this._tar,this._stopEvents,"stop",true);
		}
	});

	/**
	*设置触发停止的事件
	*@param events
	*
	*/
	__getset(0,__proto,'stopEvent',null,function(events){
		this._stopEvents=events;
		if (!events)return;
		if (this._tar){
			this._setPlayActions(this._tar,events,"stop");
		}
	});

	return SoundNode;
})(Sprite)


/**
*@private
*<code>FileBitmap</code> 是图片文件资源类。
*/
//class laya.resource.FileBitmap extends laya.resource.Bitmap
var FileBitmap=(function(_super){
	function FileBitmap(){
		/**@private 文件路径全名。*/
		this._src=null;
		/**@private onload触发函数*/
		this._onload=null;
		/**@private onerror触发函数*/
		this._onerror=null;
		FileBitmap.__super.call(this);
	}

	__class(FileBitmap,'laya.resource.FileBitmap',_super);
	var __proto=FileBitmap.prototype;
	/**
	*文件路径全名。
	*/
	__getset(0,__proto,'src',function(){
		return this._src;
		},function(value){
		this._src=value;
	});

	/**
	*载入完成处理函数。
	*/
	__getset(0,__proto,'onload',null,function(value){
	});

	/**
	*错误处理函数。
	*/
	__getset(0,__proto,'onerror',null,function(value){
	});

	return FileBitmap;
})(Bitmap)


/**
*<code>HTMLCanvas</code> 是 Html Canvas 的代理类，封装了 Canvas 的属性和方法。。请不要直接使用 new HTMLCanvas！
*/
//class laya.resource.HTMLCanvas extends laya.resource.Bitmap
var HTMLCanvas=(function(_super){
	function HTMLCanvas(type,canvas){
		//this._ctx=null;
		this._is2D=false;
		HTMLCanvas.__super.call(this);
		var _$this=this;
		this._source=this;
		if (type==="2D" || (type==="AUTO" && !Render.isWebGL)){
			this._is2D=true;
			this._source=canvas || Browser.createElement("canvas");
			this._w=this._source.width;
			this._h=this._source.height;
			var o=this;
			o.getContext=function (contextID,other){
				if (_$this._ctx)return _$this._ctx;
				var ctx=_$this._ctx=_$this._source.getContext(contextID,other);
				if (ctx){
					ctx._canvas=o;
					if(!Render.isFlash&&!Browser.onLimixiu)ctx.size=function (w,h){
					};
				}
				return ctx;
			}
		}
		this.lock=true;
	}

	__class(HTMLCanvas,'laya.resource.HTMLCanvas',_super);
	var __proto=HTMLCanvas.prototype;
	/**
	*清空画布内容。
	*/
	__proto.clear=function(){
		this._ctx && this._ctx.clear();
	}

	/**
	*销毁。
	*/
	__proto.destroy=function(){
		this._ctx && this._ctx.destroy();
		this._ctx=null;
		laya.resource.Resource.prototype.destroy.call(this);
	}

	/**
	*释放。
	*/
	__proto.release=function(){}
	/**
	*@private
	*设置 Canvas 渲染上下文。
	*@param context Canvas 渲染上下文。
	*/
	__proto._setContext=function(context){
		this._ctx=context;
	}

	/**
	*获取 Canvas 渲染上下文。
	*@param contextID 上下文ID.
	*@param other
	*@return Canvas 渲染上下文 Context 对象。
	*/
	__proto.getContext=function(contextID,other){
		return this._ctx ? this._ctx :(this._ctx=HTMLCanvas._createContext(this));
	}

	/**
	*获取内存大小。
	*@return 内存大小。
	*/
	__proto.getMemSize=function(){
		return 0;
	}

	/**
	*设置宽高。
	*@param w 宽度。
	*@param h 高度。
	*/
	__proto.size=function(w,h){
		if (this._w !=w || this._h !=h ||(this._source && (this._source.width!=w || this._source.height!=h))){
			this._w=w;
			this._h=h;
			this.memorySize=this._w *this._h *4;
			this._ctx && this._ctx.size(w,h);
			this._source && (this._source.height=h,this._source.width=w);
		}
	}

	__proto.getCanvas=function(){
		return this._source;
	}

	__proto.toBase64=function(type,encoderOptions,callBack){
		if (this._source){
			if (Render.isConchApp && this._source.toBase64){
				this._source.toBase64(type,encoderOptions,callBack);
			}
			else {
				var base64Data=this._source.toDataURL(type,encoderOptions);
				callBack.call(this,base64Data);
			}
		}
	}

	/**
	*Canvas 渲染上下文。
	*/
	__getset(0,__proto,'context',function(){
		return this._ctx;
	});

	/**
	*是否当作 Bitmap 对象。
	*/
	__getset(0,__proto,'asBitmap',null,function(value){
	});

	HTMLCanvas.create=function(type,canvas){
		return new HTMLCanvas(type,canvas);
	}

	HTMLCanvas.TYPE2D="2D";
	HTMLCanvas.TYPE3D="3D";
	HTMLCanvas.TYPEAUTO="AUTO";
	HTMLCanvas._createContext=null;
	return HTMLCanvas;
})(Bitmap)


/**
*@private
*/
//class laya.resource.HTMLSubImage extends laya.resource.Bitmap
var HTMLSubImage=(function(_super){
	//请不要直接使用new HTMLSubImage
	function HTMLSubImage(canvas,offsetX,offsetY,width,height,atlasImage,src,allowMerageInAtlas){
		HTMLSubImage.__super.call(this);
		throw new Error("不允许new！");
	}

	__class(HTMLSubImage,'laya.resource.HTMLSubImage',_super);
	HTMLSubImage.create=function(canvas,offsetX,offsetY,width,height,atlasImage,src,allowMerageInAtlas){
		(allowMerageInAtlas===void 0)&& (allowMerageInAtlas=false);
		return new HTMLSubImage(canvas,offsetX,offsetY,width,height,atlasImage,src,allowMerageInAtlas);
	}

	return HTMLSubImage;
})(Bitmap)


/**
*<p> <code>Animation</code> 是Graphics动画类。实现了基于Graphics的动画创建、播放、控制接口。</p>
*<p>本类使用了动画模版缓存池，它以一定的内存开销来节省CPU开销，当相同的动画模版被多次使用时，相比于每次都创建新的动画模版，使用动画模版缓存池，只需创建一次，缓存之后多次复用，从而节省了动画模版创建的开销。</p>
*<p>动画模版缓存池，以key-value键值对存储，key可以自定义，也可以从指定的配置文件中读取，value为对应的动画模版，是一个Graphics对象数组，每个Graphics对象对应一个帧图像，动画的播放实质就是定时切换Graphics对象。</p>
*<p>使用set source、loadImages(...)、loadAtlas(...)、loadAnimation(...)方法可以创建动画模版。使用play(...)可以播放指定动画。</p>
*@example <caption>以下示例代码，创建了一个 <code>Text</code> 实例。</caption>
*package
*{
	*import laya.display.Animation;
	*import laya.net.Loader;
	*import laya.utils.Handler;
	*public class Animation_Example
	*{
		*public function Animation_Example()
		*{
			*Laya.init(640,800);//设置游戏画布宽高、渲染模式。
			*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
			*init();//初始化
			*}
		*private function init():void
		*{
			*var animation:Animation=new Animation();//创建一个 Animation 类的实例对象 animation 。
			*animation.loadAtlas("resource/ani/fighter.json");//加载图集并播放
			*animation.x=200;//设置 animation 对象的属性 x 的值，用于控制 animation 对象的显示位置。
			*animation.y=200;//设置 animation 对象的属性 x 的值，用于控制 animation 对象的显示位置。
			*animation.interval=50;//设置 animation 对象的动画播放间隔时间，单位：毫秒。
			*animation.play();//播放动画。
			*Laya.stage.addChild(animation);//将 animation 对象添加到显示列表。
			*}
		*}
	*}
*
*@example
*Animation_Example();
*function Animation_Example(){
	*Laya.init(640,800);//设置游戏画布宽高、渲染模式。
	*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
	*init();//初始化
	*}
*function init()
*{
	*var animation=new Laya.Animation();//创建一个 Animation 类的实例对象 animation 。
	*animation.loadAtlas("resource/ani/fighter.json");//加载图集并播放
	*animation.x=200;//设置 animation 对象的属性 x 的值，用于控制 animation 对象的显示位置。
	*animation.y=200;//设置 animation 对象的属性 x 的值，用于控制 animation 对象的显示位置。
	*animation.interval=50;//设置 animation 对象的动画播放间隔时间，单位：毫秒。
	*animation.play();//播放动画。
	*Laya.stage.addChild(animation);//将 animation 对象添加到显示列表。
	*}
*
*@example
*import Animation=laya.display.Animation;
*class Animation_Example {
	*constructor(){
		*Laya.init(640,800);//设置游戏画布宽高、渲染模式。
		*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
		*this.init();
		*}
	*private init():void {
		*var animation:Animation=new Laya.Animation();//创建一个 Animation 类的实例对象 animation 。
		*animation.loadAtlas("resource/ani/fighter.json");//加载图集并播放
		*animation.x=200;//设置 animation 对象的属性 x 的值，用于控制 animation 对象的显示位置。
		*animation.y=200;//设置 animation 对象的属性 x 的值，用于控制 animation 对象的显示位置。
		*animation.interval=50;//设置 animation 对象的动画播放间隔时间，单位：毫秒。
		*animation.play();//播放动画。
		*Laya.stage.addChild(animation);//将 animation 对象添加到显示列表。
		*}
	*}
*new Animation_Example();
*/
//class laya.display.Animation extends laya.display.AnimationPlayerBase
var Animation=(function(_super){
	function Animation(){
		/**@private */
		this._frames=null;
		/**@private */
		this._url=null;
		Animation.__super.call(this);
		this._setControlNode(this);
	}

	__class(Animation,'laya.display.Animation',_super);
	var __proto=Animation.prototype;
	/**@inheritDoc */
	__proto.destroy=function(destroyChild){
		(destroyChild===void 0)&& (destroyChild=true);
		this.stop();
		laya.display.Sprite.prototype.destroy.call(this,destroyChild);
		this._frames=null;
		this._labels=null;
	}

	/**
	*<p>开始播放动画。会在动画模版缓存池中查找key值为name的动画模版，存在则用此动画模版初始化当前序列帧， 如果不存在，则使用当前序列帧。</p>
	*<p>play(...)方法被设计为在创建实例后的任何时候都可以被调用，调用后就处于播放状态，当相应的资源加载完毕、调用动画帧填充方法(set frames)或者将实例显示在舞台上时，会判断是否处于播放状态，如果是，则开始播放。</p>
	*<p>配合wrapMode属性，可设置动画播放顺序类型。</p>
	*@param start （可选）指定动画播放开始的索引(int)或帧标签(String)。帧标签可以通过addLabel(...)和removeLabel(...)进行添加和删除。
	*@param loop （可选）是否循环播放。
	*@param name （可选）动画模板在动画模版缓存池中的key，也可认为是动画名称。如果name为空，则播放当前动画序列帧；如果不为空，则在动画模版缓存池中寻找key值为name的动画模版，如果存在则用此动画模版初始化当前序列帧并播放，如果不存在，则仍然播放当前动画序列帧；如果没有当前动画的帧数据，则不播放，但该实例仍然处于播放状态。
	*@param showWarn（可选）是否动画不存在时打印警告
	*/
	__proto.play=function(start,loop,name,showWarn){
		(start===void 0)&& (start=0);
		(loop===void 0)&& (loop=true);
		(name===void 0)&& (name="");
		(showWarn===void 0)&& (showWarn=true);
		if (name)this._setFramesFromCache(name,showWarn);
		this._isPlaying=true;
		this.index=((typeof start=='string'))? this._getFrameByLabel(start):start;
		this.loop=loop;
		this._actionName=name;
		this._isReverse=this.wrapMode==1;
		if (this._frames && this.interval > 0){
			this.timerLoop(this.interval,this,this._frameLoop,null,true,true);
		}
	}

	/**@private */
	__proto._setFramesFromCache=function(name,showWarn){
		(showWarn===void 0)&& (showWarn=false);
		if (this._url)name=this._url+"#"+name;
		if (name && Animation.framesMap[name]){
			var tAniO;
			tAniO=Animation.framesMap[name];
			if ((tAniO instanceof Array)){
				this._frames=Animation.framesMap[name];
				this._count=this._frames.length;
				}else {
				if (tAniO.nodeRoot){
					Animation.framesMap[name]=this._parseGraphicAnimationByData(tAniO);
					tAniO=Animation.framesMap[name];
				}
				this._frames=tAniO.frames;
				this._count=this._frames.length;
				if (!this._frameRateChanged)this._interval=tAniO.interval;
				this._labels=this._copyLabels(tAniO.labels);
			}
			return true;
			}else {
			if (showWarn)console.log("ani not found:",name);
		}
		return false;
	}

	/**@private */
	__proto._copyLabels=function(labels){
		if (!labels)return null;
		var rst;
		rst={};
		var key;
		for (key in labels){
			rst[key]=Utils.copyArray([],labels[key]);
		}
		return rst;
	}

	/**@private */
	__proto._frameLoop=function(){
		if (this._style.visible && this._style.alpha > 0.01){
			_super.prototype._frameLoop.call(this);
		}
	}

	/**@private */
	__proto._displayToIndex=function(value){
		if (this._frames)this.graphics=this._frames[value];
	}

	/**
	*停止动画播放，并清理对象属性。之后可存入对象池，方便对象复用。
	*/
	__proto.clear=function(){
		this.stop();
		this.graphics=null;
		this._frames=null;
		this._labels=null;
	}

	/**
	*<p>根据指定的动画模版初始化当前动画序列帧。选择动画模版的过程如下：1. 动画模版缓存池中key为cacheName的动画模版；2. 如果不存在，则加载指定的图片集合并创建动画模版。注意：只有指定不为空的cacheName，才能将创建好的动画模版以此为key缓存到动画模版缓存池，否则不进行缓存。</p>
	*<p>动画模版缓存池是以一定的内存开销来节省CPU开销，当相同的动画模版被多次使用时，相比于每次都创建新的动画模版，使用动画模版缓存池，只需创建一次，缓存之后多次复用，从而节省了动画模版创建的开销。</p>
	*<p>因为返回值为Animation对象本身，所以可以使用如下语法：ani.loadImages(...).loadImages(...).play(...);。</p>
	*@param urls 图片路径集合。需要创建动画模版时，会以此为数据源。参数形如：[url1,url2,url3,...]。
	*@param cacheName （可选）动画模板在动画模版缓存池中的key。如果此参数不为空，表示使用动画模版缓存池。如果动画模版缓存池中存在key为cacheName的动画模版，则使用此模版。否则，创建新的动画模版，如果cacheName不为空，则以cacheName为key缓存到动画模版缓存池中，如果cacheName为空，不进行缓存。
	*@return 返回Animation对象本身。
	*/
	__proto.loadImages=function(urls,cacheName){
		(cacheName===void 0)&& (cacheName="");
		this._url="";
		if (!this._setFramesFromCache(cacheName)){
			this.frames=Animation.framesMap[cacheName] ? Animation.framesMap[cacheName] :Animation.createFrames(urls,cacheName);
		}
		return this;
	}

	/**
	*<p>根据指定的动画模版初始化当前动画序列帧。选择动画模版的过程如下：1. 动画模版缓存池中key为cacheName的动画模版；2. 如果不存在，则加载指定的图集并创建动画模版。</p>
	*<p>注意：只有指定不为空的cacheName，才能将创建好的动画模版以此为key缓存到动画模版缓存池，否则不进行缓存。</p>
	*<p>动画模版缓存池是以一定的内存开销来节省CPU开销，当相同的动画模版被多次使用时，相比于每次都创建新的动画模版，使用动画模版缓存池，只需创建一次，缓存之后多次复用，从而节省了动画模版创建的开销。</p>
	*<p>因为返回值为Animation对象本身，所以可以使用如下语法：ani.loadAtlas(...).loadAtlas(...).play(...);。</p>
	*@param url 图集路径。需要创建动画模版时，会以此为数据源。
	*@param loaded （可选）使用指定图集初始化动画完毕的回调。
	*@param cacheName （可选）动画模板在动画模版缓存池中的key。如果此参数不为空，表示使用动画模版缓存池。如果动画模版缓存池中存在key为cacheName的动画模版，则使用此模版。否则，创建新的动画模版，如果cacheName不为空，则以cacheName为key缓存到动画模版缓存池中，如果cacheName为空，不进行缓存。
	*@return 返回动画本身。
	*/
	__proto.loadAtlas=function(url,loaded,cacheName){
		(cacheName===void 0)&& (cacheName="");
		this._url="";
		var _this_=this;
		function onLoaded (loadUrl){
			if (url===loadUrl){
				_this_.frames=Animation.framesMap[cacheName] ? Animation.framesMap[cacheName] :Animation.createFrames(url,cacheName);
				if (loaded)loaded.run();
			}
		}
		if (!_this_._setFramesFromCache(cacheName)){
			if (Loader.getAtlas(url))onLoaded(url);
			else Laya.loader.load(url,Handler.create(null,onLoaded,[url]),null,/*laya.net.Loader.ATLAS*/"atlas");
		}
		return this;
	}

	/**
	*<p>加载并解析由LayaAir IDE制作的动画文件，此文件中可能包含多个动画。默认帧率为在IDE中设计的帧率，如果调用过set interval，则使用此帧间隔对应的帧率。加载后创建动画模版，并缓存到动画模版缓存池，key "url#动画名称" 对应相应动画名称的动画模板，key "url#" 对应动画模版集合的默认动画模版。</p>
	*<p>注意：如果调用本方法前，还没有预加载动画使用的图集，请将atlas参数指定为对应的图集路径，否则会导致动画创建失败。</p>
	*<p>动画模版缓存池是以一定的内存开销来节省CPU开销，当相同的动画模版被多次使用时，相比于每次都创建新的动画模版，使用动画模版缓存池，只需创建一次，缓存之后多次复用，从而节省了动画模版创建的开销。</p>
	*<p>因为返回值为Animation对象本身，所以可以使用如下语法：ani.loadAnimation(...).loadAnimation(...).play(...);。</p>
	*@param url 动画文件路径。可由LayaAir IDE创建并发布。
	*@param loaded （可选）使用指定动画资源初始化动画完毕的回调。
	*@param atlas （可选）动画用到的图集地址（可选）。
	*@return 返回动画本身。
	*/
	__proto.loadAnimation=function(url,loaded,atlas){
		this._url=url;
		var _this_=this;
		if (!this._actionName)this._actionName="";
		if (!_this_._setFramesFromCache("")){
			if (!atlas || Loader.getAtlas(atlas)){
				this._loadAnimationData(url,loaded,atlas);
				}else {
				Laya.loader.load(atlas,Handler.create(this,this._loadAnimationData,[url,loaded,atlas]),null,/*laya.net.Loader.ATLAS*/"atlas")
			}
			}else {
			_this_._setFramesFromCache(this._actionName,true);
			this.index=0;
			if (loaded)loaded.run();
		}
		return this;
	}

	/**@private */
	__proto._loadAnimationData=function(url,loaded,atlas){
		var _$this=this;
		if (atlas && !Loader.getAtlas(atlas)){
			console.warn("atlas load fail:"+atlas);
			return;
		};
		var _this_=this;
		function onLoaded (loadUrl){
			if (!Loader.getRes(loadUrl))return;
			if (url===loadUrl){
				var tAniO;
				if (!Animation.framesMap[url+"#"]){
					var aniData=_this_._parseGraphicAnimation(Loader.getRes(url));
					if (!aniData)return;
					var aniList=aniData.animationList;
					var i=0,len=aniList.length;
					var defaultO;
					for (i=0;i < len;i++){
						tAniO=aniList[i];
						Animation.framesMap[url+"#"+tAniO.name]=tAniO;
						if (!defaultO)defaultO=tAniO;
					}
					if (defaultO){
						Animation.framesMap[url+"#"]=defaultO;
						_this_._setFramesFromCache(_$this._actionName,true);
						_$this.index=0;
					}
					_$this._checkResumePlaying();
					}else {
					_this_._setFramesFromCache(_$this._actionName,true);
					_$this.index=0;
					_$this._checkResumePlaying();
				}
				if (loaded)loaded.run();
			}
		}
		if (Loader.getRes(url))onLoaded(url);
		else Laya.loader.load(url,Handler.create(null,onLoaded,[url]),null,/*laya.net.Loader.JSON*/"json");
		Loader.clearRes(url);
	}

	/**@private */
	__proto._parseGraphicAnimation=function(animationData){
		return GraphicAnimation.parseAnimationData(animationData);
	}

	/**@private */
	__proto._parseGraphicAnimationByData=function(animationObject){
		return GraphicAnimation.parseAnimationByData(animationObject);
	}

	/**
	*当前动画的帧图像数组。本类中，每个帧图像是一个Graphics对象，而动画播放就是定时切换Graphics对象的过程。
	*/
	__getset(0,__proto,'frames',function(){
		return this._frames;
		},function(value){
		this._frames=value;
		if (value){
			this._count=value.length;
			if (this._isPlaying)this.play(this._index,this.loop,this._actionName);
			else this.index=this._index;
		}
	});

	/**
	*是否自动播放，默认为false。如果设置为true，则动画被创建并添加到舞台后自动播放。
	*/
	__getset(0,__proto,'autoPlay',null,function(value){
		if (value)this.play();
		else this.stop();
	});

	/**
	*<p>动画数据源。</p>
	*<p>类型如下：<br/>
	*1. LayaAir IDE动画文件路径：使用此类型需要预加载所需的图集资源，否则会创建失败，如果不想预加载或者需要创建完毕的回调，请使用loadAnimation(...)方法；<br/>
	*2. 图集路径：使用此类型创建的动画模版不会被缓存到动画模版缓存池中，如果需要缓存或者创建完毕的回调，请使用loadAtlas(...)方法；<br/>
	*3. 图片路径集合：使用此类型创建的动画模版不会被缓存到动画模版缓存池中，如果需要缓存，请使用loadImages(...)方法。</p>
	*@param value 数据源。比如：图集："xx/a1.atlas"；图片集合："a1.png,a2.png,a3.png"；LayaAir IDE动画"xx/a1.ani"。
	*/
	__getset(0,__proto,'source',null,function(value){
		if (value.indexOf(".ani")>-1)this.loadAnimation(value);
		else if (value.indexOf(".json")>-1 || value.indexOf("als")>-1 || value.indexOf("atlas")>-1)this.loadAtlas(value);
		else this.loadImages(value.split(","));
	});

	/**
	*设置自动播放的动画名称，在LayaAir IDE中可以创建的多个动画组成的动画集合，选择其中一个动画名称进行播放。
	*/
	__getset(0,__proto,'autoAnimation',null,function(value){
		this.play(0,true,value,false);
	});

	Animation.createFrames=function(url,name){
		var arr,i=0,n=0,g;
		if ((typeof url=='string')){
			var atlas=Loader.getAtlas(url);
			if (atlas && atlas.length){
				arr=[];
				for (i=0,n=atlas.length;i < n;i++){
					g=new RunDriver.createGraphics();
					g.drawTexture(Loader.getRes(atlas[i]),0,0);
					arr.push(g);
				}
			}
			}else if ((url instanceof Array)){
			arr=[];
			for (i=0,n=url.length;i < n;i++){
				g=new RunDriver.createGraphics();
				g.loadImage(url[i],0,0);
				arr.push(g);
			}
		}
		if (name)Animation.framesMap[name]=arr;
		return arr;
	}

	Animation.clearCache=function(key){
		var cache=Animation.framesMap;
		var val;
		var key2=key+"#";
		for (val in cache){
			if (val===key || val.indexOf(key2)==0){
				delete Animation.framesMap[val];
			}
		}
	}

	Animation.framesMap={};
	return Animation;
})(AnimationPlayerBase)


/**
*关键帧动画播放类。
*/
//class laya.display.FrameAnimation extends laya.display.AnimationPlayerBase
var FrameAnimation=(function(_super){
	function FrameAnimation(){
		/**
		*@private
		*id对象表
		*/
		this._targetDic=null;
		/**
		*@private
		*动画数据
		*/
		this._animationData=null;
		/**@private */
		this._animationNewFrames=null;
		FrameAnimation.__super.call(this);
		if (FrameAnimation._sortIndexFun==null){
			FrameAnimation._sortIndexFun=MathUtil.sortByKey("index",false,true);
		}
	}

	__class(FrameAnimation,'laya.display.FrameAnimation',_super);
	var __proto=FrameAnimation.prototype;
	/**
	*@private
	*初始化动画数据
	*@param targetDic 对象表
	*@param animationData 动画数据
	*
	*/
	__proto._setUp=function(targetDic,animationData){
		this._labels=null;
		this._animationNewFrames=null;
		this._targetDic=targetDic;
		this._animationData=animationData;
		this.interval=1000 / animationData.frameRate;
		if (animationData.parsed){
			this._count=animationData.count;
			this._labels=animationData.labels;
			this._animationNewFrames=animationData.animationNewFrames;
			}else {
			this._animationNewFrames=[];
			this._calculateDatas();
		}
		animationData.parsed=true;
		animationData.labels=this._labels;
		animationData.count=this._count;
		animationData.animationNewFrames=this._animationNewFrames;
	}

	/**@inheritDoc */
	__proto.clear=function(){
		_super.prototype.clear.call(this);
		this._targetDic=null;
		this._animationData=null;
	}

	/**@inheritDoc */
	__proto._displayToIndex=function(value){
		if (!this._animationData)return;
		if (value < 0)value=0;
		if (value > this._count)value=this._count;
		var nodes=this._animationData.nodes,i=0,len=nodes.length;
		for (i=0;i < len;i++){
			this._displayNodeToFrame(nodes[i],value);
		}
	}

	/**
	*@private
	*将节点设置到某一帧的状态
	*@param node 节点ID
	*@param frame
	*@param targetDic 节点表
	*
	*/
	__proto._displayNodeToFrame=function(node,frame,targetDic){
		if (!targetDic)targetDic=this._targetDic;
		var target=targetDic[node.target];
		if (!target){
			return;
		};
		var frames=node.frames,key,propFrames,value;
		var keys=node.keys,i=0,len=keys.length;
		for (i=0;i < len;i++){
			key=keys[i];
			propFrames=frames[key];
			if (propFrames.length > frame){
				value=propFrames[frame];
				}else {
				value=propFrames[propFrames.length-1];
			}
			target[key]=value;
		}
	}

	/**
	*@private
	*计算帧数据
	*
	*/
	__proto._calculateDatas=function(){
		if (!this._animationData)return;
		var nodes=this._animationData.nodes,i=0,len=nodes.length,tNode;
		this._count=0;
		for (i=0;i < len;i++){
			tNode=nodes[i];
			this._calculateNodeKeyFrames(tNode);
		}
		this._count+=1;
	}

	/**
	*@private
	*计算某个节点的帧数据
	*@param node
	*
	*/
	__proto._calculateNodeKeyFrames=function(node){
		var keyFrames=node.keyframes,key,tKeyFrames,target=node.target;
		if (!node.frames){
			node.frames={};
		}
		if (!node.keys){
			node.keys=[];
			}else {
			node.keys.length=0;
		}
		if (!node.initValues){
			node.initValues={};
		}
		for (key in keyFrames){
			tKeyFrames=keyFrames[key];
			if (!node.frames[key]){
				node.frames[key]=[];
			}
			if (this._targetDic && this._targetDic[target]){
				node.initValues[key]=this._targetDic[target][key];
			}
			tKeyFrames.sort(FrameAnimation._sortIndexFun);
			node.keys.push(key);
			this._calculateNodePropFrames(tKeyFrames,node.frames[key],key,target);
		}
	}

	/**
	*将动画控制对象还原到动画控制之前的状态
	*/
	__proto.resetToInitState=function(){
		if (!this._targetDic)return;
		if (!this._animationData)return;
		var nodes=this._animationData.nodes,i=0,len=nodes.length;
		var tNode;
		var initValues;
		for (i=0;i < len;i++){
			tNode=nodes[i];
			initValues=tNode.initValues;
			if (!initValues)continue ;
			var target=this._targetDic[tNode.target];
			if (!target)continue ;
			var key;
			for (key in initValues){
				target[key]=initValues[key];
			}
		}
	}

	/**
	*@private
	*计算节点某个属性的帧数据
	*@param keyframes
	*@param frames
	*@param key
	*@param target
	*
	*/
	__proto._calculateNodePropFrames=function(keyframes,frames,key,target){
		var i=0,len=keyframes.length-1;
		frames.length=keyframes[len].index+1;
		for (i=0;i < len;i++){
			this._dealKeyFrame(keyframes[i]);
			this._calculateFrameValues(keyframes[i],keyframes[i+1],frames);
		}
		if (len==0){
			frames[0]=keyframes[0].value;
			if (this._animationNewFrames)
				this._animationNewFrames[keyframes[0].index]=true;
		}
		this._dealKeyFrame(keyframes[i]);
	}

	/**
	*@private
	*
	*/
	__proto._dealKeyFrame=function(keyFrame){
		if (keyFrame.label && keyFrame.label !="")this.addLabel(keyFrame.label,keyFrame.index);
	}

	/**
	*@private
	*计算两个关键帧直接的帧数据
	*@param startFrame
	*@param endFrame
	*@param result
	*
	*/
	__proto._calculateFrameValues=function(startFrame,endFrame,result){
		var i=0,easeFun;
		var start=startFrame.index,end=endFrame.index;
		var startValue=startFrame.value;
		var dValue=endFrame.value-startFrame.value;
		var dLen=end-start;
		if (end > this._count)this._count=end;
		if (startFrame.tween){
			easeFun=Ease[startFrame.tweenMethod];
			if (easeFun==null){
				easeFun=Ease.linearNone;
			}
			for (i=start;i < end;i++){
				result[i]=easeFun(i-start,startValue,dValue,dLen);
				if (this._animationNewFrames){
					this._animationNewFrames[i]=true;
				}
			}
			}else {
			for (i=start;i < end;i++){
				result[i]=startValue;
			}
		}
		if (this._animationNewFrames){
			this._animationNewFrames[startFrame.index]=true;
			this._animationNewFrames[endFrame.index]=true;
		}
		result[endFrame.index]=endFrame.value;
	}

	FrameAnimation._sortIndexFun=null;
	return FrameAnimation;
})(AnimationPlayerBase)


/**
*<p><code>Input</code> 类用于创建显示对象以显示和输入文本。</p>
*<p>Input 类封装了原生的文本输入框，由于不同浏览器的差异，会导致此对象的默认文本的位置与用户点击输入时的文本的位置有少许的偏差。</p>
*/
//class laya.display.Input extends laya.display.Text
var Input=(function(_super){
	function Input(){
		/**@private */
		this._focus=false;
		/**@private */
		this._multiline=false;
		/**@private */
		this._editable=true;
		/**@private */
		this._restrictPattern=null;
		this._type="text";
		/**输入提示符。*/
		this._prompt='';
		/**输入提示符颜色。*/
		this._promptColor="#A9A9A9";
		this._originColor="#000000";
		this._content='';
		Input.__super.call(this);
		this._maxChars=1E5;
		this._width=100;
		this._height=20;
		this.multiline=false;
		this.overflow=Text.SCROLL;
		this.on(/*laya.events.Event.MOUSE_DOWN*/"mousedown",this,this._onMouseDown);
		this.on(/*laya.events.Event.UNDISPLAY*/"undisplay",this,this._onUnDisplay);
	}

	__class(Input,'laya.display.Input',_super);
	var __proto=Input.prototype;
	/**
	*设置光标位置和选取字符。
	*@param startIndex 光标起始位置。
	*@param endIndex 光标结束位置。
	*/
	__proto.setSelection=function(startIndex,endIndex){
		this.focus=true;
		laya.display.Input.inputElement.selectionStart=startIndex;
		laya.display.Input.inputElement.selectionEnd=endIndex;
	}

	__proto._onUnDisplay=function(e){
		this.focus=false;
	}

	__proto._onMouseDown=function(e){
		this.focus=true;
	}

	/**
	*在输入期间，如果 Input 实例的位置改变，调用_syncInputTransform同步输入框的位置。
	*/
	__proto._syncInputTransform=function(){
		var inputElement=this.nativeInput;
		var transform=Utils.getTransformRelativeToWindow(this,this.padding[3],this.padding[0]);
		var inputWid=this._width-this.padding[1]-this.padding[3];
		var inputHei=this._height-this.padding[0]-this.padding[2];
		if (Render.isConchApp){
			inputElement.setScale(transform.scaleX,transform.scaleY);
			inputElement.setSize(inputWid,inputHei);
			inputElement.setPos(transform.x,transform.y);
			}else {
			Input.inputContainer.style.transform=Input.inputContainer.style.webkitTransform="scale("+transform.scaleX+","+transform.scaleY+") rotate("+(Laya.stage.canvasDegree)+"deg)";
			inputElement.style.width=inputWid+'px';
			inputElement.style.height=inputHei+'px';
			Input.inputContainer.style.left=transform.x+'px';
			Input.inputContainer.style.top=transform.y+'px';
		}
	}

	/**选中当前实例的所有文本。*/
	__proto.select=function(){
		this.nativeInput.select();
	}

	__proto._setInputMethod=function(){
		Input.input.parentElement && (Input.inputContainer.removeChild(Input.input));
		Input.area.parentElement && (Input.inputContainer.removeChild(Input.area));
		Input.inputElement=(this._multiline ? Input.area :Input.input);
		Input.inputContainer.appendChild(Input.inputElement);
		if (Text.RightToLeft){
			Input.inputElement.style.direction="rtl";
		}
	}

	__proto._focusIn=function(){
		laya.display.Input.isInputting=true;
		var input=this.nativeInput;
		this._focus=true;
		var cssStyle=input.style;
		cssStyle.whiteSpace=(this.wordWrap ? "pre-wrap" :"nowrap");
		this._setPromptColor();
		input.readOnly=!this._editable;
		if (Render.isConchApp){
			input.setType(this._type);
			input.setForbidEdit(!this._editable);
		}
		input.maxLength=this._maxChars;
		var padding=this.padding;
		input.type=this._type;
		input.value=this._content;
		input.placeholder=this._prompt;
		Laya.stage.off(/*laya.events.Event.KEY_DOWN*/"keydown",this,this._onKeyDown);
		Laya.stage.on(/*laya.events.Event.KEY_DOWN*/"keydown",this,this._onKeyDown);
		Laya.stage.focus=this;
		this.event(/*laya.events.Event.FOCUS*/"focus");
		if (Browser.onPC)input.focus();
		if(!Browser.onMiniGame){
			var temp=this._text;
			this._text=null;
		}
		this.typeset();
		input.setColor(this._originColor);
		input.setFontSize(this.fontSize);
		input.setFontFace(Browser.onIPhone ? (Text._fontFamilyMap[this.font] || this.font):this.font);
		if (Render.isConchApp){
			input.setMultiAble && input.setMultiAble(this._multiline);
		}
		cssStyle.lineHeight=(this.leading+this.fontSize)+"px";
		cssStyle.fontStyle=(this.italic ? "italic" :"normal");
		cssStyle.fontWeight=(this.bold ? "bold" :"normal");
		cssStyle.textAlign=this.align;
		cssStyle.padding="0 0";
		this._syncInputTransform();
		if (!Render.isConchApp && Browser.onPC)
			Laya.timer.frameLoop(1,this,this._syncInputTransform);
	}

	// 设置DOM输入框提示符颜色。
	__proto._setPromptColor=function(){
		Input.promptStyleDOM=Browser.getElementById("promptStyle");
		if (!Input.promptStyleDOM){
			Input.promptStyleDOM=Browser.createElement("style");
			Input.promptStyleDOM.setAttribute("id","promptStyle");
			Browser.document.head.appendChild(Input.promptStyleDOM);
		}
		Input.promptStyleDOM.innerText="input::-webkit-input-placeholder, textarea::-webkit-input-placeholder {"+"color:"+this._promptColor+"}"+"input:-moz-placeholder, textarea:-moz-placeholder {"+"color:"+this._promptColor+"}"+"input::-moz-placeholder, textarea::-moz-placeholder {"+"color:"+this._promptColor+"}"+"input:-ms-input-placeholder, textarea:-ms-input-placeholder {"+"color:"+this._promptColor+"}";
	}

	/**@private */
	__proto._focusOut=function(){
		laya.display.Input.isInputting=false;
		this._focus=false;
		this._text=null;
		this._content=this.nativeInput.value;
		if (!this._content){
			Laya.superSet(Text,this,'text',this._prompt);
			Laya.superSet(Text,this,'color',this._promptColor);
			}else {
			Laya.superSet(Text,this,'text',this._content);
			Laya.superSet(Text,this,'color',this._originColor);
		}
		Laya.stage.off(/*laya.events.Event.KEY_DOWN*/"keydown",this,this._onKeyDown);
		Laya.stage.focus=null;
		this.event(/*laya.events.Event.BLUR*/"blur");
		if (Render.isConchApp)this.nativeInput.blur();
		Browser.onPC && Laya.timer.clear(this,this._syncInputTransform);
	}

	/**@private */
	__proto._onKeyDown=function(e){
		if (e.keyCode===13){
			if (Browser.onMobile && !this._multiline)
				this.focus=false;
			this.event(/*laya.events.Event.ENTER*/"enter");
		}
	}

	__proto.changeText=function(text){
		this._content=text;
		if (this._focus){
			this.nativeInput.value=text || '';
			this.event(/*laya.events.Event.CHANGE*/"change");
		}else
		_super.prototype.changeText.call(this,text);
	}

	/**@inheritDoc */
	__getset(0,__proto,'color',_super.prototype._$get_color,function(value){
		if (this._focus)
			this.nativeInput.setColor(value);
		Laya.superSet(Text,this,'color',this._content?value:this._promptColor);
		this._originColor=value;
	});

	//[Deprecated]
	__getset(0,__proto,'inputElementYAdjuster',function(){
		console.warn("deprecated: 由于即使设置了该值，在各平台和浏览器之间也不一定一致，inputElementYAdjuster已弃用。");
		return 0;
		},function(value){
		console.warn("deprecated: 由于即使设置了该值，在各平台和浏览器之间也不一定一致，inputElementYAdjuster已弃用。");
	});

	/**表示是否是多行输入框。*/
	__getset(0,__proto,'multiline',function(){
		return this._multiline;
		},function(value){
		this._multiline=value;
		this.valign=value ? "top" :"middle";
	});

	/**
	*<p>字符数量限制，默认为10000。</p>
	*<p>设置字符数量限制时，小于等于0的值将会限制字符数量为10000。</p>
	*/
	__getset(0,__proto,'maxChars',function(){
		return this._maxChars;
		},function(value){
		if (value <=0)
			value=1E5;
		this._maxChars=value;
	});

	/**@inheritDoc */
	__getset(0,__proto,'text',function(){
		if (this._focus)
			return this.nativeInput.value;
		else
		return this._content || "";
		},function(value){
		Laya.superSet(Text,this,'color',this._originColor);
		value+='';
		if (this._focus){
			this.nativeInput.value=value || '';
			this.event(/*laya.events.Event.CHANGE*/"change");
			}else {
			if (!this._multiline)
				value=value.replace(/\r?\n/g,'');
			this._content=value;
			if (value)
				Laya.superSet(Text,this,'text',value);
			else {
				Laya.superSet(Text,this,'text',this._prompt);
				Laya.superSet(Text,this,'color',this.promptColor);
			}
		}
	});

	/**
	*获取对输入框的引用实例。
	*/
	__getset(0,__proto,'nativeInput',function(){
		return this._multiline ? Input.area :Input.input;
	});

	/**
	*设置输入提示符。
	*/
	__getset(0,__proto,'prompt',function(){
		return this._prompt;
		},function(value){
		if (!this._text && value)
			Laya.superSet(Text,this,'color',this._promptColor);
		this.promptColor=this._promptColor;
		if (this._text)
			Laya.superSet(Text,this,'text',(this._text==this._prompt)?value:this._text);
		else
		Laya.superSet(Text,this,'text',value);
		this._prompt=Text.langPacks && Text.langPacks[value] ? Text.langPacks[value] :value;
	});

	// 因此 调用focus接口是无法都在移动平台立刻弹出键盘的
	/**
	*表示焦点是否在此实例上。
	*/
	__getset(0,__proto,'focus',function(){
		return this._focus;
		},function(value){
		var input=this.nativeInput;
		if (this._focus!==value){
			if (value){
				if (input.target){
					input.target._focusOut();
					}else {
					this._setInputMethod();
				}
				input.target=this;
				this._focusIn();
				}else {
				input.target=null;
				this._focusOut();
				Browser.document.body.scrollTop=0;
				input.blur();
				if (Render.isConchApp){
					input.setPos(-10000,-10000);
				}else if (Input.inputContainer.contains(input))
				Input.inputContainer.removeChild(input);
			}
		}
	});

	/**限制输入的字符。*/
	__getset(0,__proto,'restrict',function(){
		if (this._restrictPattern){
			return this._restrictPattern.source;
		}
		return "";
		},function(pattern){
		if (pattern){
			pattern="[^"+pattern+"]";
			if (pattern.indexOf("^^")>-1)
				pattern=pattern.replace("^^","");
			this._restrictPattern=new RegExp(pattern,"g");
		}else
		this._restrictPattern=null;
	});

	/**
	*是否可编辑。
	*/
	__getset(0,__proto,'editable',function(){
		return this._editable;
		},function(value){
		this._editable=value;
		if (Render.isConchApp){
			Input.input.setForbidEdit(!value);
		}
	});

	/**
	*设置输入提示符颜色。
	*/
	__getset(0,__proto,'promptColor',function(){
		return this._promptColor;
		},function(value){
		this._promptColor=value;
		if (!this._content)Laya.superSet(Text,this,'color',value);
	});

	/**
	*<p>输入框类型为Input静态常量之一。</p>
	*<ul>
	*<li>TYPE_TEXT</li>
	*<li>TYPE_PASSWORD</li>
	*<li>TYPE_EMAIL</li>
	*<li>TYPE_URL</li>
	*<li>TYPE_NUMBER</li>
	*<li>TYPE_RANGE</li>
	*<li>TYPE_DATE</li>
	*<li>TYPE_MONTH</li>
	*<li>TYPE_WEEK</li>
	*<li>TYPE_TIME</li>
	*<li>TYPE_DATE_TIME</li>
	*<li>TYPE_DATE_TIME_LOCAL</li>
	*</ul>
	*<p>平台兼容性参见http://www.w3school.com.cn/html5/html_5_form_input_types.asp。</p>
	*/
	__getset(0,__proto,'type',function(){
		return this._type;
		},function(value){
		if (value=="password")
			this._getCSSStyle().password=true;
		else
		this._getCSSStyle().password=false;
		this._type=value;
		if (Render.isConchApp){
			this.nativeInput.setType(value);
		}
	});

	/**
	*<p>原生输入框 X 轴调整值，用来调整输入框坐标。</p>
	*<p>由于即使设置了该值，在各平台和浏览器之间也不一定一致，inputElementXAdjuster已弃用。</p>
	*@deprecated
	*/
	__getset(0,__proto,'inputElementXAdjuster',function(){
		console.warn("deprecated: 由于即使设置了该值，在各平台和浏览器之间也不一定一致，inputElementXAdjuster已弃用。");
		return 0;
		},function(value){
		console.warn("deprecated: 由于即使设置了该值，在各平台和浏览器之间也不一定一致，inputElementXAdjuster已弃用。");
	});

	//[Deprecated(replacement="Input.type")]
	__getset(0,__proto,'asPassword',function(){
		return this._getCSSStyle().password;
		},function(value){
		this._getCSSStyle().password=value;
		this._type=/*CLASS CONST:laya.display.Input.TYPE_PASSWORD*/"password";
		console.warn("deprecated: 使用type=\"password\"替代设置asPassword, asPassword将在下次重大更新时删去");
		this.isChanged=true;
	});

	Input.__init__=function(){
		Input._createInputElement();
		if (Browser.onMobile)
			Render.canvas.addEventListener(Input.IOS_IFRAME ?(Browser.onMiniGame ? "touchend" :"click"):"touchend",Input._popupInputMethod);
	}

	Input._popupInputMethod=function(e){
		if (!laya.display.Input.isInputting)return;
		var input=laya.display.Input.inputElement;
		input.focus();
	}

	Input._createInputElement=function(){
		Input._initInput(Input.area=Browser.createElement("textarea"));
		Input._initInput(Input.input=Browser.createElement("input"));
		Input.inputContainer=Browser.createElement("div");
		Input.inputContainer.style.position="absolute";
		Input.inputContainer.style.zIndex=1E5;
		Browser.container.appendChild(Input.inputContainer);
		Input.inputContainer.setPos=function (x,y){Input.inputContainer.style.left=x+'px';Input.inputContainer.style.top=y+'px';};
	}

	Input._initInput=function(input){
		var style=input.style;
		style.cssText="position:absolute;overflow:hidden;resize:none;transform-origin:0 0;-webkit-transform-origin:0 0;-moz-transform-origin:0 0;-o-transform-origin:0 0;";
		style.resize='none';
		style.backgroundColor='transparent';
		style.border='none';
		style.outline='none';
		style.zIndex=1;
		input.addEventListener('input',Input._processInputting);
		input.addEventListener('mousemove',Input._stopEvent);
		input.addEventListener('mousedown',Input._stopEvent);
		input.addEventListener('touchmove',Input._stopEvent);
		input.setFontFace=function (fontFace){input.style.fontFamily=fontFace;};
		if(!Render.isConchApp){
			input.setColor=function (color){input.style.color=color;};
			input.setFontSize=function (fontSize){input.style.fontSize=fontSize+'px';};
		}
	}

	Input._processInputting=function(e){
		var input=laya.display.Input.inputElement.target;
		if (!input)return;
		var value=laya.display.Input.inputElement.value;
		if (input._restrictPattern){
			value=value.replace(/\u2006|\x27/g,"");
			if (input._restrictPattern.test(value)){
				value=value.replace(input._restrictPattern,"");
				laya.display.Input.inputElement.value=value;
			}
		}
		input._text=value;
		input.event(/*laya.events.Event.INPUT*/"input");
	}

	Input._stopEvent=function(e){
		if (e.type=='touchmove')
			e.preventDefault();
		e.stopPropagation && e.stopPropagation();
	}

	Input.TYPE_TEXT="text";
	Input.TYPE_PASSWORD="password";
	Input.TYPE_EMAIL="email";
	Input.TYPE_URL="url";
	Input.TYPE_NUMBER="number";
	Input.TYPE_RANGE="range";
	Input.TYPE_DATE="date";
	Input.TYPE_MONTH="month";
	Input.TYPE_WEEK="week";
	Input.TYPE_TIME="time";
	Input.TYPE_DATE_TIME="datetime";
	Input.TYPE_DATE_TIME_LOCAL="datetime-local";
	Input.TYPE_SEARCH="search";
	Input.input=null;
	Input.area=null;
	Input.inputElement=null;
	Input.inputContainer=null;
	Input.confirmButton=null;
	Input.promptStyleDOM=null;
	Input.inputHeight=45;
	Input.isInputting=false;
	Input.stageMatrix=null;
	__static(Input,
	['IOS_IFRAME',function(){return this.IOS_IFRAME=(Browser.onIOS && Browser.window.top !=Browser.window.self);}
	]);
	return Input;
})(Text)


/**
*@private
*<p> <code>HTMLImage</code> 用于创建 HTML Image 元素。</p>
*<p>请使用 <code>HTMLImage.create()<code>获取新实例，不要直接使用 <code>new HTMLImage<code> 。</p>
*/
//class laya.resource.HTMLImage extends laya.resource.FileBitmap
var HTMLImage=(function(_super){
	function HTMLImage(src,def){
		/**异步加载锁*/
		this._recreateLock=false;
		/**异步加载完成后是否需要释放（有可能在恢复过程中,再次被释放，用此变量做标记）*/
		this._needReleaseAgain=false;
		this._enableMerageInAtlas=true;
		HTMLImage.__super.call(this);
		this._init_(src,def);
	}

	__class(HTMLImage,'laya.resource.HTMLImage',_super);
	var __proto=HTMLImage.prototype;
	__proto._init_=function(src,def){
		this._src=src;
		this._source=new Browser.window.Image();
		if (def){
			def.onload && (this.onload=def.onload);
			def.onerror && (this.onerror=def.onerror);
			def.onCreate && def.onCreate(this);
		}
		if (src.indexOf("data:image")!=0)this._source.crossOrigin="";
		(src)&& (this._source.src=src);
	}

	/**
	*@inheritDoc
	*/
	__proto.recreateResource=function(){
		var _$this=this;
		if (this._src==="")
			throw new Error("src no null！");
		this._needReleaseAgain=false;
		if (!this._source){
			this._recreateLock=true;
			var _this=this;
			this._source=new Browser.window.Image();
			this._source.crossOrigin="";
			this._source.onload=function (){
				if (_this._needReleaseAgain){
					_this._needReleaseAgain=false;
					_this._source.onload=null;
					_this._source=null;
					return;
				}
				_this._source.onload=null;
				_this.memorySize=_$this._w *_$this._h *4;
				_this._recreateLock=false;
				_this.completeCreate();
			};
			this._source.src=this._src;
			}else {
			if (this._recreateLock)
				return;
			this.memorySize=this._w *this._h *4;
			this._recreateLock=false;
			this.completeCreate();
		}
	}

	/**
	*@inheritDoc
	*/
	__proto.disposeResource=function(){
		if (this._recreateLock)
			this._needReleaseAgain=true;
		(this._source)&& (this._source=null,this.memorySize=0);
	}

	/***调整尺寸。*/
	__proto.onresize=function(){
		this._w=this._source.width;
		this._h=this._source.height;
	}

	/**
	*@inheritDoc
	*/
	__getset(0,__proto,'onload',null,function(value){
		var _$this=this;
		this._onload=value;
		this._source && (this._source.onload=this._onload !=null ? (function(){
			_$this.onresize();
			_$this._onload();
		}):null);
	});

	/**
	*@inheritDoc
	*/
	__getset(0,__proto,'onerror',null,function(value){
		var _$this=this;
		this._onerror=value;
		this._source && (this._source.onerror=this._onerror !=null ? (function(){
			_$this._onerror()
		}):null);
	});

	__getset(0,__proto,'enableMerageInAtlas',function(){
		return this._enableMerageInAtlas;
		},function(value){
		this._enableMerageInAtlas=value;
		if (Render.isConchApp){
			if (this._source)this._source.enableMerageInAtlas=value;
		}
	});

	HTMLImage.create=function(src,def){
		return new HTMLImage(src,def);
	}

	return HTMLImage;
})(FileBitmap)


/**
*<p> 动效模板。用于为指定目标对象添加动画效果。每个动效有唯一的目标对象，而同一个对象可以添加多个动效。 当一个动效开始播放时，其他动效会自动停止播放。</p>
*<p> 可以通过LayaAir IDE创建。 </p>
*/
//class laya.display.EffectAnimation extends laya.display.FrameAnimation
var EffectAnimation=(function(_super){
	function EffectAnimation(){
		/**@private */
		this._target=null;
		/**@private */
		this._playEvents=null;
		/**@private */
		this._initData={};
		/**@private */
		this._aniKeys=null;
		/**@private */
		this._effectClass=null;
		EffectAnimation.__super.call(this);
	}

	__class(EffectAnimation,'laya.display.EffectAnimation',_super);
	var __proto=EffectAnimation.prototype;
	/**@private */
	__proto._onOtherBegin=function(effect){
		if (effect==this)
			return;
		this.stop();
	}

	/**@private */
	__proto.addEvent=function(){
		if (!this._target || !this._playEvents)
			return;
		this._setControlNode(this._target);
		this._target.on(this._playEvents,this,this._onPlayAction);
	}

	/**@private */
	__proto._onPlayAction=function(){
		this.play(0,false);
	}

	__proto.play=function(start,loop,name,showWarn){
		(start===void 0)&& (start=0);
		(loop===void 0)&& (loop=true);
		(name===void 0)&& (name="");
		(showWarn===void 0)&& (showWarn=true);
		if (!this._target)
			return;
		this._target.event("effectanimationbegin",[this]);
		this._recordInitData();
		laya.display.AnimationPlayerBase.prototype.play.call(this,start,loop,name,showWarn);
	}

	/**@private */
	__proto._recordInitData=function(){
		if (!this._aniKeys)
			return;
		var i=0,len=0;
		len=this._aniKeys.length;
		var key;
		for (i=0;i < len;i++){
			key=this._aniKeys[i];
			this._initData[key]=this._target[key];
		}
	}

	/**@private */
	__proto._displayToIndex=function(value){
		if (!this._animationData)
			return;
		if (value < 0)
			value=0;
		if (value > this._count)
			value=this._count;
		var nodes=this._animationData.nodes,i=0,len=nodes.length;
		len=len > 1 ? 1 :len;
		for (i=0;i < len;i++){
			this._displayNodeToFrame(nodes[i],value);
		}
	}

	/**@private */
	__proto._displayNodeToFrame=function(node,frame,targetDic){
		if (!this._target)
			return;
		var target;
		target=this._target;
		var frames=node.frames,key,propFrames,value;
		var keys=node.keys,i=0,len=keys.length;
		var secondFrames;
		secondFrames=node.secondFrames;
		var tSecondFrame=0;
		var easeFun;
		var tKeyFrames;
		var startFrame;
		var endFrame;
		for (i=0;i < len;i++){
			key=keys[i];
			propFrames=frames[key];
			tSecondFrame=secondFrames[key];
			if (tSecondFrame==-1){
				value=this._initData[key];
				}else {
				if (frame < tSecondFrame){
					tKeyFrames=node.keyframes[key];
					startFrame=tKeyFrames[0];
					if (startFrame.tween){
						easeFun=Ease[startFrame.tweenMethod];
						if (easeFun==null){
							easeFun=Ease.linearNone;
						}
						endFrame=tKeyFrames[1];
						value=easeFun(frame,this._initData[key],endFrame.value-this._initData[key],endFrame.index);
						}else {
						value=this._initData[key];
					}
					}else {
					if (propFrames.length > frame){
						value=propFrames[frame];
						}else {
						value=propFrames[propFrames.length-1];
					}
				}
			}
			target[key]=value;
		}
	}

	/**@private */
	__proto._calculateNodeKeyFrames=function(node){
		_super.prototype._calculateNodeKeyFrames.call(this,node);
		var keyFrames=node.keyframes,key,tKeyFrames,target=node.target;
		var secondFrames;
		secondFrames={};
		node.secondFrames=secondFrames;
		for (key in keyFrames){
			tKeyFrames=keyFrames[key];
			if (tKeyFrames.length <=1){
				secondFrames[key]=-1;
				}else {
				secondFrames[key]=tKeyFrames[1].index;
			}
		}
	}

	/**
	*本实例的目标对象。通过本实例控制目标对象的属性变化。
	*@param v 指定的目标对象。
	*/
	__getset(0,__proto,'target',function(){
		return this._target;
		},function(v){
		if (this._target){
			this._target.off("effectanimationbegin",this,this._onOtherBegin);
		}
		this._target=v;
		if (this._target){
			this._target.on("effectanimationbegin",this,this._onOtherBegin);
		}
		this.addEvent();
	});

	/**
	*设置开始播放的事件。本实例会侦听目标对象的指定事件，触发后播放相应动画效果。
	*@param event
	*/
	__getset(0,__proto,'playEvent',null,function(event){
		this._playEvents=event;
		if (!event)
			return;
		this.addEvent();
	});

	/**
	*设置动画数据。
	*@param uiData
	*/
	__getset(0,__proto,'effectData',null,function(uiData){
		if (uiData){
			var aniData;
			aniData=uiData["animations"];
			if (aniData && aniData[0]){
				this._setUp({},aniData[0]);
				if (aniData[0].nodes && aniData[0].nodes[0]){
					this._aniKeys=aniData[0].nodes[0].keys;
				}
			}
		}
	});

	/**
	*设置提供数据的类。
	*@param classStr 类路径
	*/
	__getset(0,__proto,'effectClass',null,function(classStr){
		this._effectClass=ClassUtils.getClass(classStr);
		if (this._effectClass){
			var uiData;
			uiData=this._effectClass["uiView"];
			if (uiData){
				var aniData;
				aniData=uiData["animations"];
				if (aniData && aniData[0]){
					this._setUp({},aniData[0]);
					if (aniData[0].nodes && aniData[0].nodes[0]){
						this._aniKeys=aniData[0].nodes[0].keys;
					}
				}
			}
		}
	});

	EffectAnimation.EffectAnimationBegin="effectanimationbegin";
	return EffectAnimation;
})(FrameAnimation)


/**
*@private
*/
//class laya.utils.GraphicAnimation extends laya.display.FrameAnimation
var GraphicAnimation=(function(_super){
	var GraphicNode;
	function GraphicAnimation(){
		/**
		*@private
		*/
		this.animationList=null;
		/**
		*@private
		*/
		this.animationDic=null;
		/**
		*@private
		*/
		this._nodeList=null;
		/**
		*@private
		*/
		this._nodeDefaultProps=null;
		/**
		*@private
		*/
		this._gList=null;
		/**
		*@private
		*/
		this._nodeIDAniDic={};
		this._rootNode=null;
		this._nodeGDic=null;
		GraphicAnimation.__super.call(this);
	}

	__class(GraphicAnimation,'laya.utils.GraphicAnimation',_super);
	var __proto=GraphicAnimation.prototype;
	/**
	*@private
	*/
	__proto._parseNodeList=function(uiView){
		if (!this._nodeList){
			this._nodeList=[];
		}
		this._nodeDefaultProps[uiView.compId]=uiView.props;
		if (uiView.compId)
			this._nodeList.push(uiView.compId);
		var childs=uiView.child;
		if (childs){
			var i=0,len=childs.length;
			for (i=0;i < len;i++){
				this._parseNodeList(childs[i]);
			}
		}
	}

	/**
	*@private
	*/
	__proto._calGraphicData=function(aniData){
		this._setUp(null,aniData);
		this._createGraphicData();
		if (this._nodeIDAniDic){
			var key;
			for (key in this._nodeIDAniDic){
				this._nodeIDAniDic[key]=null;
			}
		}
	}

	/**
	*@private
	*/
	__proto._createGraphicData=function(){
		var gList=[];
		var i=0,len=this.count;
		var animationDataNew=this._animationNewFrames;
		if (!animationDataNew)animationDataNew=[];
		var preGraphic;
		for (i=0;i < len;i++){
			if (animationDataNew[i] || !preGraphic){
				preGraphic=this._createFrameGraphic(i);
			}
			gList.push(preGraphic);
		}
		this._gList=gList;
	}

	/**
	*@private
	*/
	__proto._createFrameGraphic=function(frame){
		var g=RunDriver.createGraphics();
		if (!GraphicAnimation._rootMatrix)
			GraphicAnimation._rootMatrix=new Matrix();
		this._updateNodeGraphic(this._rootNode,frame,GraphicAnimation._rootMatrix,g);
		return g;
	}

	__proto._updateNodeGraphic=function(node,frame,parentTransfrom,g,alpha){
		(alpha===void 0)&& (alpha=1);
		var tNodeG;
		tNodeG=this._nodeGDic[node.compId]=this._getNodeGraphicData(node.compId,frame,this._nodeGDic[node.compId]);
		var tGraphicAlpha=tNodeG.alpha *alpha;
		if (tGraphicAlpha < 0.01)return;
		if (!tNodeG.resultTransform){
			tNodeG.resultTransform=Matrix.create();
		};
		var tResultTransform;
		tResultTransform=tNodeG.resultTransform;
		Matrix.mul(tNodeG.transform,parentTransfrom,tResultTransform);
		var tTex;
		if (tNodeG.skin){
			tTex=this._getTextureByUrl(tNodeG.skin);
			if (tTex){
				if (tResultTransform._checkTransform()){
					g.drawTexture(tTex,0,0,tNodeG.width,tNodeG.height,tResultTransform,tGraphicAlpha);
					tNodeG.resultTransform=null;
					}else {
					g.drawTexture(tTex,tResultTransform.tx,tResultTransform.ty,tNodeG.width,tNodeG.height,null,tGraphicAlpha);
				}
			}
		};
		var childs;
		childs=node.child;
		if (!childs)
			return;
		var i=0,len=0;
		len=childs.length;
		for (i=0;i < len;i++){
			this._updateNodeGraphic(childs[i],frame,tResultTransform,g,tGraphicAlpha);
		}
	}

	__proto._updateNoChilds=function(tNodeG,g){
		if (!tNodeG.skin)
			return;
		var tTex=this._getTextureByUrl(tNodeG.skin);
		if (!tTex)
			return;
		var tTransform=tNodeG.transform;
		tTransform._checkTransform();
		var onlyTranslate=false;
		onlyTranslate=!tTransform.bTransform;
		if (!onlyTranslate){
			g.drawTexture(tTex,0,0,tNodeG.width,tNodeG.height,tTransform.clone(),tNodeG.alpha);
			}else {
			g.drawTexture(tTex,tTransform.tx,tTransform.ty,tNodeG.width,tNodeG.height,null,tNodeG.alpha);
		}
	}

	__proto._updateNodeGraphic2=function(node,frame,g){
		var tNodeG;
		tNodeG=this._nodeGDic[node.compId]=this._getNodeGraphicData(node.compId,frame,this._nodeGDic[node.compId]);
		if (!node.child){
			this._updateNoChilds(tNodeG,g);
			return;
		};
		var tTransform=tNodeG.transform;
		tTransform._checkTransform();
		var onlyTranslate=false;
		onlyTranslate=!tTransform.bTransform;
		var hasTrans=false;
		hasTrans=onlyTranslate && (tTransform.tx !=0 || tTransform.ty !=0);
		var ifSave=false;
		ifSave=(tTransform.bTransform)|| tNodeG.alpha !=1;
		if (ifSave){
			g.save();
		}
		if (tNodeG.alpha !=1){
			g.alpha(tNodeG.alpha);
		}
		if (!onlyTranslate){
			g.transform(tTransform.clone());
			}else if (hasTrans){
			g.translate(tTransform.tx,tTransform.ty);
		};
		var childs;
		childs=node.child;
		var tTex;
		if (tNodeG.skin){
			tTex=this._getTextureByUrl(tNodeG.skin);
			if (tTex){
				g.drawTexture(tTex,0,0,tNodeG.width,tNodeG.height);
			}
		}
		if (childs){
			var i=0,len=0;
			len=childs.length;
			for (i=0;i < len;i++){
				this._updateNodeGraphic2(childs[i],frame,g);
			}
		}
		if (ifSave){
			g.restore();
			}else {
			if (!onlyTranslate){
				g.transform(tTransform.clone().invert());
				}else if (hasTrans){
				g.translate(-tTransform.tx,-tTransform.ty);
			}
		}
	}

	/**
	*@private
	*/
	__proto._calculateNodeKeyFrames=function(node){
		_super.prototype._calculateNodeKeyFrames.call(this,node);
		this._nodeIDAniDic[node.target]=node;
	}

	/**
	*@private
	*/
	__proto.getNodeDataByID=function(nodeID){
		return this._nodeIDAniDic[nodeID];
	}

	/**
	*@private
	*/
	__proto._getParams=function(obj,params,frame,obj2){
		var rst=GraphicAnimation._temParam;
		rst.length=params.length;
		var i=0,len=params.length;
		for (i=0;i < len;i++){
			rst[i]=this._getObjVar(obj,params[i][0],frame,params[i][1],obj2);
		}
		return rst;
	}

	/**
	*@private
	*/
	__proto._getObjVar=function(obj,key,frame,noValue,obj2){
		if (obj.hasOwnProperty(key)){
			var vArr=obj[key];
			if (frame >=vArr.length)
				frame=vArr.length-1;
			return obj[key][frame];
		}
		if (obj2.hasOwnProperty(key)){
			return obj2[key];
		}
		return noValue;
	}

	__proto._getNodeGraphicData=function(nodeID,frame,rst){
		if (!rst)
			rst=GraphicNode.create();
		if (!rst.transform){
			rst.transform=Matrix.create();
			}else{
			rst.transform.identity();
		};
		var node=this.getNodeDataByID(nodeID);
		if (!node)
			return rst;
		var frameData=node.frames;
		var params=this._getParams(frameData,GraphicAnimation._drawTextureCmd,frame,this._nodeDefaultProps[nodeID]);
		var url=params[0];
		var width=NaN,height=NaN;
		var px=params[5],py=params[6];
		var aX=params[13],aY=params[14];
		var sx=params[7],sy=params[8];
		var rotate=params[9];
		var skewX=params[11],skewY=params[12]
		width=params[3];
		height=params[4];
		if (width==0 || height==0)url=null;
		if (width==-1)width=0;
		if (height==-1)height=0;
		var tex;
		rst.skin=url;
		rst.width=width;
		rst.height=height;
		if (url){
			tex=this._getTextureByUrl(url);
			if (tex){
				if (!width)
					width=tex.sourceWidth;
				if (!height)
					height=tex.sourceHeight;
				}else {
				console.warn("lost skin:",url,",you may load pics first");
			}
		}
		rst.alpha=params[10];
		var m;
		m=rst.transform;
		if (aX !=0){
			px=aX *width;
		}
		if (aY !=0){
			py=aY *height;
		}
		if (px !=0 || py !=0){
			m.translate(-px,-py);
		};
		var tm=null;
		if (rotate || sx!==1 || sy!==1 || skewX || skewY){
			tm=GraphicAnimation._tempMt;
			tm.identity();
			tm.bTransform=true;
			var skx=(rotate-skewX)*0.0174532922222222;
			var sky=(rotate+skewY)*0.0174532922222222;
			var cx=Math.cos(sky);
			var ssx=Math.sin(sky);
			var cy=Math.sin(skx);
			var ssy=Math.cos(skx);
			tm.a=sx *cx;
			tm.b=sx *ssx;
			tm.c=-sy *cy;
			tm.d=sy *ssy;
			tm.tx=tm.ty=0;
		}
		if (tm){
			m=Matrix.mul(m,tm,m);
		}
		m.translate(params[1],params[2]);
		return rst;
	}

	/**
	*@private
	*/
	__proto._getTextureByUrl=function(url){
		return Loader.getRes(url);
	}

	/**
	*@private
	*/
	__proto.setAniData=function(uiView,aniName){
		if (uiView.animations){
			this._nodeDefaultProps={};
			this._nodeGDic={};
			if (this._nodeList)
				this._nodeList.length=0;
			this._rootNode=uiView;
			this._parseNodeList(uiView);
			var aniDic={};
			var anilist=[];
			var animations=uiView.animations;
			var i=0,len=animations.length;
			var tAniO;
			for (i=0;i < len;i++){
				tAniO=animations[i];
				this._labels=null;
				if (aniName && aniName !=tAniO.name){
					continue ;
				}
				if (!tAniO)
					continue ;
				try {
					this._calGraphicData(tAniO);
					}catch (e){
					console.warn("parse animation fail:"+tAniO.name+",empty animation created");
					this._gList=[];
				};
				var frameO={};
				frameO.interval=1000 / tAniO["frameRate"];
				frameO.frames=this._gList;
				frameO.labels=this._labels;
				frameO.name=tAniO.name;
				anilist.push(frameO);
				aniDic[tAniO.name]=frameO;
			}
			this.animationList=anilist;
			this.animationDic=aniDic;
		}
		GraphicAnimation._temParam.length=0;
	}

	__proto.parseByData=function(aniData){
		var rootNode,aniO;
		rootNode=aniData.nodeRoot;
		aniO=aniData.aniO;
		delete aniData.nodeRoot;
		delete aniData.aniO;
		this._nodeDefaultProps={};
		this._nodeGDic={};
		if (this._nodeList)
			this._nodeList.length=0;
		this._rootNode=rootNode;
		this._parseNodeList(rootNode);
		this._labels=null;
		try {
			this._calGraphicData(aniO);
			}catch (e){
			console.warn("parse animation fail:"+aniO.name+",empty animation created");
			this._gList=[];
		};
		var frameO=aniData;
		frameO.interval=1000 / aniO["frameRate"];
		frameO.frames=this._gList;
		frameO.labels=this._labels;
		frameO.name=aniO.name;
		return frameO;
	}

	/**
	*@private
	*/
	__proto.setUpAniData=function(uiView){
		if (uiView.animations){
			var aniDic={};
			var anilist=[];
			var animations=uiView.animations;
			var i=0,len=animations.length;
			var tAniO;
			for (i=0;i < len;i++){
				tAniO=animations[i];
				if (!tAniO)
					continue ;
				var frameO={};
				frameO.name=tAniO.name;
				frameO.aniO=tAniO;
				frameO.nodeRoot=uiView;
				anilist.push(frameO);
				aniDic[tAniO.name]=frameO;
			}
			this.animationList=anilist;
			this.animationDic=aniDic;
		}
	}

	/**
	*@private
	*/
	__proto._clear=function(){
		this.animationList=null;
		this.animationDic=null;
		this._gList=null;
		if (this._nodeGDic){
			var key;
			var tGNode;
			for (key in this._nodeGDic){
				tGNode=this._nodeGDic[key];
				if (tGNode)tGNode.recover();
			}
		}
		this._nodeGDic=null;
	}

	GraphicAnimation.parseAnimationByData=function(animationObject){
		if (!GraphicAnimation._I)
			GraphicAnimation._I=new GraphicAnimation();
		var rst;
		rst=GraphicAnimation._I.parseByData(animationObject);
		GraphicAnimation._I._clear();
		return rst;
	}

	GraphicAnimation.parseAnimationData=function(aniData){
		if (!GraphicAnimation._I)
			GraphicAnimation._I=new GraphicAnimation();
		GraphicAnimation._I.setUpAniData(aniData);
		var rst;
		rst={};
		rst.animationList=GraphicAnimation._I.animationList;
		rst.animationDic=GraphicAnimation._I.animationDic;
		GraphicAnimation._I._clear();
		return rst;
	}

	GraphicAnimation._drawTextureCmd=[["skin",null],["x",0],["y",0],["width",-1],["height",-1],["pivotX",0],["pivotY",0],["scaleX",1],["scaleY",1],["rotation",0],["alpha",1],["skewX",0],["skewY",0],["anchorX",0],["anchorY",0]];
	GraphicAnimation._temParam=[];
	GraphicAnimation._I=null;
	GraphicAnimation._rootMatrix=null;
	__static(GraphicAnimation,
	['_tempMt',function(){return this._tempMt=new Matrix();}
	]);
	GraphicAnimation.__init$=function(){
		//class GraphicNode
		GraphicNode=(function(){
			function GraphicNode(){
				this.skin=null;
				this.transform=null;
				this.resultTransform=null;
				this.width=NaN;
				this.height=NaN;
				this.alpha=1;
			}
			__class(GraphicNode,'');
			var __proto=GraphicNode.prototype;
			__proto.recover=function(){
				this.skin=null;
				this.width=0;
				this.height=0;
				this.alpha=1;
				if (this.transform){
					this.transform.destroy();
					this.transform=null;
				}
				if (this.resultTransform){
					this.resultTransform.destroy();
					this.resultTransform=null;
				}
				Pool.recover("GraphicNode",this);
			}
			GraphicNode.create=function(){
				return Pool.getItemByClass("GraphicNode",GraphicNode);
			}
			return GraphicNode;
		})()
	}

	return GraphicAnimation;
})(FrameAnimation)


	Laya.__init([EventDispatcher,LoaderManager,Render,Browser,Timer,LocalStorage,TimeLine,GraphicAnimation]);
})(window,document,Laya);

(function(window,document,Laya){
	var __un=Laya.un,__uns=Laya.uns,__static=Laya.static,__class=Laya.class,__getset=Laya.getset,__newvec=Laya.__newvec;
//class LayaMain
var LayaMain=(function(){
	/*[COMPILER OPTIONS:normal]*/
	function LayaMain(){}
	__class(LayaMain,'LayaMain');
	return LayaMain;
})()



	/**LayaGameStart**/
	new LayaMain();

})(window,document,Laya);

if (typeof define === 'function' && define.amd){
	define('laya.core', ['require', "exports"], function(require, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        for (var i in Laya) {
			var o = Laya[i];
            o && o.__isclass && (exports[i] = o);
        }
    });
}

(function(window,document,Laya){
	var __un=Laya.un,__uns=Laya.uns,__static=Laya.static,__class=Laya.class,__getset=Laya.getset,__newvec=Laya.__newvec;

	var Browser=laya.utils.Browser,Event=laya.events.Event,EventDispatcher=laya.events.EventDispatcher;
	var HTMLImage=laya.resource.HTMLImage,Handler=laya.utils.Handler,Input=laya.display.Input,Loader=laya.net.Loader;
	var LocalStorage=laya.net.LocalStorage,Matrix=laya.maths.Matrix,Render=laya.renders.Render,RunDriver=laya.utils.RunDriver;
	var SoundChannel=laya.media.SoundChannel,SoundManager=laya.media.SoundManager,URL=laya.net.URL,Utils=laya.utils.Utils;
//class laya.wx.mini.MiniAdpter
var MiniAdpter=(function(){
	function MiniAdpter(){}
	__class(MiniAdpter,'laya.wx.mini.MiniAdpter');
	MiniAdpter.getJson=function(data){
		return JSON.parse(data);
	}

	MiniAdpter.init=function(isPosMsg,isSon){
		(isPosMsg===void 0)&& (isPosMsg=false);
		(isSon===void 0)&& (isSon=false);
		if (MiniAdpter._inited)return;
		MiniAdpter._inited=true;
		MiniAdpter.window=/*__JS__ */window;
		if(MiniAdpter.window.navigator.userAgent.indexOf('MiniGame')<0)return;
		MiniAdpter.isZiYu=isSon;
		MiniAdpter.isPosMsgYu=isPosMsg;
		MiniAdpter.EnvConfig={};
		try{
			/*__JS__ */laya.webgl.resource.WebGLCanvas.premulAlpha=true;
			}catch(e){
		}
		if(!MiniAdpter.isZiYu){
			MiniFileMgr.setNativeFileDir("/layaairGame");
			MiniFileMgr.existDir(MiniFileMgr.fileNativeDir,Handler.create(MiniAdpter,MiniAdpter.onMkdirCallBack));
		}
		MiniAdpter.systemInfo=/*__JS__ */wx.getSystemInfoSync();
		MiniAdpter.window.focus=function (){
		};
		Laya['getUrlPath']=function (){
		};
		MiniAdpter.window.logtime=function (str){
		};
		MiniAdpter.window.alertTimeLog=function (str){
		};
		MiniAdpter.window.resetShareInfo=function (){
		};
		MiniAdpter.window.CanvasRenderingContext2D=function (){
		};
		MiniAdpter.window.CanvasRenderingContext2D.prototype=MiniAdpter.window.wx.createCanvas().getContext('2d').__proto__;
		MiniAdpter.window.document.body.appendChild=function (){
		};
		MiniAdpter.EnvConfig.pixelRatioInt=0;
		RunDriver.getPixelRatio=MiniAdpter.pixelRatio;
		MiniAdpter._preCreateElement=Browser.createElement;
		Browser["createElement"]=MiniAdpter.createElement;
		RunDriver.createShaderCondition=MiniAdpter.createShaderCondition;
		Utils['parseXMLFromString']=MiniAdpter.parseXMLFromString;
		Input['_createInputElement']=MiniInput['_createInputElement'];
		MiniAdpter.EnvConfig.load=Loader.prototype.load;
		Loader.prototype.load=MiniLoader.prototype.load;
		Loader.prototype._loadImage=MiniImage.prototype._loadImage;
		MiniLocalStorage.__init__();
		LocalStorage._baseClass=MiniLocalStorage;
	}

	MiniAdpter.getUrlEncode=function(url,type){
		if(url.indexOf(".fnt")!=-1)
			return "utf8";
		else if(type=="arraybuffer")
		return "";
		return "ascii";
	}

	MiniAdpter.downLoadFile=function(fileUrl,fileType,callBack,encoding){
		(fileType===void 0)&& (fileType="");
		(encoding===void 0)&& (encoding="ascii");
		var fileObj=MiniFileMgr.getFileInfo(fileUrl);
		if(!fileObj)
			MiniFileMgr.downLoadFile(fileUrl,fileType,callBack,encoding);
		else{
			callBack !=null && callBack.runWith([0]);
		}
	}

	MiniAdpter.remove=function(fileUrl,callBack){
		MiniFileMgr.deleteFile("",fileUrl,callBack,"",0);
	}

	MiniAdpter.removeAll=function(){
		MiniFileMgr.deleteAll();
	}

	MiniAdpter.hasNativeFile=function(fileUrl){
		return MiniFileMgr.isLocalNativeFile(fileUrl);
	}

	MiniAdpter.getFileInfo=function(fileUrl){
		return MiniFileMgr.getFileInfo(fileUrl);
	}

	MiniAdpter.getFileList=function(){
		return MiniFileMgr.filesListObj;
	}

	MiniAdpter.exitMiniProgram=function(){
		MiniAdpter.window["wx"].exitMiniProgram();
	}

	MiniAdpter.onMkdirCallBack=function(errorCode,data){
		if (!errorCode)
			MiniFileMgr.filesListObj=JSON.parse(data.data);
	}

	MiniAdpter.pixelRatio=function(){
		if (!MiniAdpter.EnvConfig.pixelRatioInt){
			try {
				MiniAdpter.EnvConfig.pixelRatioInt=MiniAdpter.systemInfo.pixelRatio;
				return MiniAdpter.systemInfo.pixelRatio;
			}catch (error){}
		}
		return MiniAdpter.EnvConfig.pixelRatioInt;
	}

	MiniAdpter.createElement=function(type){
		if (type=="canvas"){
			var _source;
			if (MiniAdpter.idx==1){
				if(MiniAdpter.isZiYu){
					_source=/*__JS__ */sharedCanvas;
					_source.style={};
					}else{
					_source=/*__JS__ */window.canvas;
				}
				}else {
				_source=/*__JS__ */window.wx.createCanvas();
			}
			MiniAdpter.idx++;
			return _source;
			}else if (type=="textarea" || type=="input"){
			return MiniAdpter.onCreateInput(type);
			}else if (type=="div"){
			var node=MiniAdpter._preCreateElement(type);
			node.contains=function (value){
				return null
			};
			node.removeChild=function (value){
			};
			return node;
			}else {
			return MiniAdpter._preCreateElement(type);
		}
	}

	MiniAdpter.onCreateInput=function(type){
		var node=MiniAdpter._preCreateElement(type);
		node.focus=MiniInput.wxinputFocus;
		node.blur=MiniInput.wxinputblur;
		node.style={};
		node.value=0;
		node.parentElement={};
		node.placeholder={};
		node.type={};
		node.setColor=function (value){
		};
		node.setType=function (value){
		};
		node.setFontFace=function (value){
		};
		node.addEventListener=function (value){
		};
		node.contains=function (value){
			return null
		};
		node.removeChild=function (value){
		};
		return node;
	}

	MiniAdpter.createShaderCondition=function(conditionScript){
		var _$this=this;
		var func=function (){
			var abc=conditionScript;
			return _$this[conditionScript.replace("this.","")];
		}
		return func;
	}

	MiniAdpter.EnvConfig=null;
	MiniAdpter.window=null;
	MiniAdpter._preCreateElement=null;
	MiniAdpter._inited=false;
	MiniAdpter.systemInfo=null;
	MiniAdpter.isZiYu=false;
	MiniAdpter.isPosMsgYu=false;
	MiniAdpter.autoCacheFile=true;
	MiniAdpter.minClearSize=(5 *1024 *1024);
	MiniAdpter.parseXMLFromString=function(value){
		var rst;
		var Parser;
		value=value.replace(/>\s+</g,'><');
		try {
			/*__JS__ */rst=(new window.Parser.DOMParser()).parseFromString(value,'text/xml');
			}catch (error){
			throw "需要引入xml解析库文件";
		}
		return rst;
	}

	MiniAdpter.idx=1;
	__static(MiniAdpter,
	['nativefiles',function(){return this.nativefiles=["layaNativeDir","wxlocal"];}
	]);
	return MiniAdpter;
})()


/**@private **/
//class laya.wx.mini.MiniFileMgr
var MiniFileMgr=(function(){
	function MiniFileMgr(){}
	__class(MiniFileMgr,'laya.wx.mini.MiniFileMgr');
	MiniFileMgr.isLocalNativeFile=function(url){
		for(var i=0,sz=MiniAdpter.nativefiles.length;i<sz;i++){
			if(url.indexOf(MiniAdpter.nativefiles[i])!=-1)
				return true;
		}
		return false;
	}

	MiniFileMgr.getFileInfo=function(fileUrl){
		var fileNativePath=fileUrl.split("?")[0];
		var fileObj=MiniFileMgr.filesListObj[fileNativePath];
		if (fileObj==null)
			return null;
		else
		return fileObj;
		return null;
	}

	MiniFileMgr.read=function(filePath,encoding,callBack,readyUrl,isSaveFile,fileType){
		(encoding===void 0)&& (encoding="ascill");
		(readyUrl===void 0)&& (readyUrl="");
		(isSaveFile===void 0)&& (isSaveFile=false);
		(fileType===void 0)&& (fileType="");
		var fileUrl;
		if(readyUrl!="" && (readyUrl.indexOf("http://")!=-1 || readyUrl.indexOf("https://")!=-1)){
			fileUrl=MiniFileMgr.getFileNativePath(filePath)
			}else{
			fileUrl=filePath;
		}
		MiniFileMgr.fs.readFile({filePath:fileUrl,encoding:encoding,success:function (data){
				callBack !=null && callBack.runWith([0,data]);
				},fail:function (data){
				if (data && readyUrl !="")
					MiniFileMgr.downFiles(readyUrl,encoding,callBack,readyUrl,isSaveFile,fileType);
				else
				callBack !=null && callBack.runWith([1]);
		}});
	}

	MiniFileMgr.downFiles=function(fileUrl,encoding,callBack,readyUrl,isSaveFile,fileType){
		(encoding===void 0)&& (encoding="ascii");
		(readyUrl===void 0)&& (readyUrl="");
		(isSaveFile===void 0)&& (isSaveFile=false);
		(fileType===void 0)&& (fileType="");
		var downloadTask=MiniFileMgr.wxdown({url:fileUrl,success:function (data){
				if (data.statusCode===200)
					MiniFileMgr.readFile(data.tempFilePath,encoding,callBack,readyUrl,isSaveFile,fileType);
				},fail:function (data){
				callBack !=null && callBack.runWith([1,data]);
		}});
		downloadTask.onProgressUpdate(function(data){
			callBack !=null && callBack.runWith([2,data.progress]);
		});
	}

	MiniFileMgr.readFile=function(filePath,encoding,callBack,readyUrl,isSaveFile,fileType){
		(encoding===void 0)&& (encoding="ascill");
		(readyUrl===void 0)&& (readyUrl="");
		(isSaveFile===void 0)&& (isSaveFile=false);
		(fileType===void 0)&& (fileType="");
		MiniFileMgr.fs.readFile({filePath:filePath,encoding:encoding,success:function (data){
				if (filePath.indexOf("http://")!=-1 || filePath.indexOf("https://")!=-1){
					if(MiniAdpter.autoCacheFile || isSaveFile){
						MiniFileMgr.copyFile(filePath,readyUrl,callBack,encoding);
					}
				}
				else
				callBack !=null && callBack.runWith([0,data]);
				},fail:function (data){
				if (data)
					callBack !=null && callBack.runWith([1,data]);
		}});
	}

	MiniFileMgr.downOtherFiles=function(fileUrl,callBack,readyUrl,isSaveFile){
		(readyUrl===void 0)&& (readyUrl="");
		(isSaveFile===void 0)&& (isSaveFile=false);
		MiniFileMgr.wxdown({url:fileUrl,success:function (data){
				if (data.statusCode===200){
					if((MiniAdpter.autoCacheFile || isSaveFile)&& readyUrl.indexOf("wx.qlogo.cn")==-1)
						MiniFileMgr.copyFile(data.tempFilePath,readyUrl,callBack);
					else
					callBack !=null && callBack.runWith([0,data.tempFilePath]);
				}
				},fail:function (data){
				callBack !=null && callBack.runWith([1,data]);
		}});
	}

	MiniFileMgr.downLoadFile=function(fileUrl,fileType,callBack,encoding){
		(fileType===void 0)&& (fileType="");
		(encoding===void 0)&& (encoding="ascii");
		if(fileType==/*laya.net.Loader.IMAGE*/"image" || fileType==/*laya.net.Loader.SOUND*/"sound")
			MiniFileMgr.downOtherFiles(fileUrl,callBack,fileUrl,true);
		else
		MiniFileMgr.downFiles(fileUrl,encoding,callBack,fileUrl,true,fileType);
	}

	MiniFileMgr.copyFile=function(tempFilePath,readyUrl,callBack,encoding){
		(encoding===void 0)&& (encoding="");
		var temp=tempFilePath.split("/");
		var tempFileName=temp[temp.length-1];
		var fileurlkey=readyUrl.split("?")[0];
		var fileObj=MiniFileMgr.getFileInfo(readyUrl);
		var saveFilePath=MiniFileMgr.getFileNativePath(tempFileName);
		var totalSize=50 *1024 *1024;
		var chaSize=4 *1024 *1024;
		var fileUseSize=MiniFileMgr.getCacheUseSize();
		if (fileObj){
			if (fileObj.readyUrl !=readyUrl){
				MiniFileMgr.fs.getFileInfo({
					filePath:tempFilePath,
					success:function (data){
						if((fileUseSize+chaSize+data.size)>=totalSize){
							if(data.size > MiniAdpter.minClearSize)
								MiniAdpter.minClearSize=data.size;
							MiniFileMgr.onClearCacheRes();
						}
						MiniFileMgr.deleteFile(tempFileName,readyUrl,callBack,encoding,data.size);
					},
					fail:function (data){
						callBack !=null && callBack.runWith([1,data]);
					}
				});
			}
			else
			callBack !=null && callBack.runWith([0]);
			}else{
			MiniFileMgr.fs.getFileInfo({
				filePath:tempFilePath,
				success:function (data){
					if((fileUseSize+chaSize+data.size)>=totalSize){
						if(data.size > MiniAdpter.minClearSize)
							MiniAdpter.minClearSize=data.size;
						MiniFileMgr.onClearCacheRes();
					}
					MiniFileMgr.fs.copyFile({srcPath:tempFilePath,destPath:saveFilePath,success:function (data2){
							MiniFileMgr.onSaveFile(readyUrl,tempFileName,true,encoding,callBack,data.size);
							},fail:function (data){
							callBack !=null && callBack.runWith([1,data]);
					}});
				},
				fail:function (data){
					callBack !=null && callBack.runWith([1,data]);
				}
			});
		}
	}

	MiniFileMgr.onClearCacheRes=function(){
		var memSize=MiniAdpter.minClearSize;
		var tempFileListArr=[];
		for(var key in MiniFileMgr.filesListObj){
			tempFileListArr.push(MiniFileMgr.filesListObj[key]);
		}
		MiniFileMgr.sortOn(tempFileListArr,"time",16);
		var clearSize=0;
		for(var i=1,sz=tempFileListArr.length;i<sz;i++){
			var fileObj=tempFileListArr[i];
			if(clearSize >=memSize)
				break ;
			clearSize+=fileObj.size;
			MiniFileMgr.deleteFile("",fileObj.readyUrl);
		}
	}

	MiniFileMgr.sortOn=function(array,name,options){
		(options===void 0)&& (options=0);
		if (options==16)return array.sort(function(a,b){return a[name]-b[name];});
		if (options==(16 | 2))return array.sort(function(a,b){return b[name]-a[name];});
		return array.sort(function(a,b){return a[name]-b[name] });
	}

	MiniFileMgr.getFileNativePath=function(fileName){
		return laya.wx.mini.MiniFileMgr.fileNativeDir+"/"+fileName;
	}

	MiniFileMgr.deleteFile=function(tempFileName,readyUrl,callBack,encoding,fileSize){
		(readyUrl===void 0)&& (readyUrl="");
		(encoding===void 0)&& (encoding="");
		(fileSize===void 0)&& (fileSize=0);
		var fileObj=MiniFileMgr.getFileInfo(readyUrl);
		var deleteFileUrl=MiniFileMgr.getFileNativePath(fileObj.md5);
		MiniFileMgr.fs.unlink({filePath:deleteFileUrl,success:function (data){
				var isAdd=tempFileName !="" ? true :false;
				if(tempFileName !=""){
					var saveFilePath=MiniFileMgr.getFileNativePath(tempFileName);
					MiniFileMgr.fs.copyFile({srcPath:tempFileName,destPath:saveFilePath,success:function (data){
							MiniFileMgr.onSaveFile(readyUrl,tempFileName,isAdd,encoding,callBack,data.size);
							},fail:function (data){
							callBack !=null && callBack.runWith([1,data]);
					}});
					}else{
					MiniFileMgr.onSaveFile(readyUrl,tempFileName,isAdd,encoding,callBack,fileSize);
				}
				},fail:function (data){
		}});
	}

	MiniFileMgr.deleteAll=function(){
		var tempFileListArr=[];
		for(var key in MiniFileMgr.filesListObj){
			tempFileListArr.push(MiniFileMgr.filesListObj[key]);
		}
		for(var i=1,sz=tempFileListArr.length;i<sz;i++){
			var fileObj=tempFileListArr[i];
			MiniFileMgr.deleteFile("",fileObj.readyUrl);
		}
	}

	MiniFileMgr.onSaveFile=function(readyUrl,md5Name,isAdd,encoding,callBack,fileSize){
		(isAdd===void 0)&& (isAdd=true);
		(encoding===void 0)&& (encoding="");
		(fileSize===void 0)&& (fileSize=0);
		var fileurlkey=readyUrl.split("?")[0];
		if(MiniFileMgr.filesListObj['fileUsedSize']==null)
			MiniFileMgr.filesListObj['fileUsedSize']=0;
		if(isAdd){
			var fileNativeName=MiniFileMgr.getFileNativePath(md5Name);
			MiniFileMgr.filesListObj[fileurlkey]={md5:md5Name,readyUrl:readyUrl,size:fileSize,times:Browser.now(),encoding:encoding};
			MiniFileMgr.filesListObj['fileUsedSize']=parseInt(MiniFileMgr.filesListObj['fileUsedSize'])+fileSize;
			MiniFileMgr.writeFilesList(fileurlkey,JSON.stringify(MiniFileMgr.filesListObj),true);
			callBack !=null && callBack.runWith([0]);
			}else{
			if(MiniFileMgr.filesListObj[fileurlkey]){
				var deletefileSize=parseInt(MiniFileMgr.filesListObj[fileurlkey].size);
				MiniFileMgr.filesListObj['fileUsedSize']=parseInt(MiniFileMgr.filesListObj['fileUsedSize'])-deletefileSize;
				delete MiniFileMgr.filesListObj[fileurlkey];
				MiniFileMgr.writeFilesList(fileurlkey,JSON.stringify(MiniFileMgr.filesListObj),false);
				callBack !=null && callBack.runWith([0]);
			}
		}
	}

	MiniFileMgr.writeFilesList=function(fileurlkey,filesListStr,isAdd){
		var listFilesPath=MiniFileMgr.fileNativeDir+"/"+MiniFileMgr.fileListName;
		MiniFileMgr.fs.writeFile({filePath:listFilesPath,encoding:'utf8',data:filesListStr,success:function (data){
				},fail:function (data){
		}});
		if(!MiniAdpter.isZiYu &&MiniAdpter.isPosMsgYu){
			/*__JS__ */wx.postMessage({url:fileurlkey,data:MiniFileMgr.filesListObj[fileurlkey],isLoad:"filenative",isAdd:isAdd});
		}
	}

	MiniFileMgr.getCacheUseSize=function(){
		if(MiniFileMgr.filesListObj && MiniFileMgr.filesListObj['fileUsedSize'])
			return MiniFileMgr.filesListObj['fileUsedSize'];
		return 0;
	}

	MiniFileMgr.existDir=function(dirPath,callBack){
		MiniFileMgr.fs.mkdir({dirPath:dirPath,success:function (data){
				callBack !=null && callBack.runWith([0,{data:JSON.stringify({})}]);
				},fail:function (data){
				if (data.errMsg.indexOf("file already exists")!=-1)
					MiniFileMgr.readSync(MiniFileMgr.fileListName,"utf8",callBack);
				else
				callBack !=null && callBack.runWith([1,data]);
		}});
	}

	MiniFileMgr.readSync=function(filePath,encoding,callBack,readyUrl){
		(encoding===void 0)&& (encoding="ascill");
		(readyUrl===void 0)&& (readyUrl="");
		var fileUrl=MiniFileMgr.getFileNativePath(filePath);
		var filesListStr
		try{
			filesListStr=MiniFileMgr.fs.readFileSync(fileUrl,encoding);
			callBack !=null && callBack.runWith([0,{data:filesListStr}]);
		}
		catch(error){
			callBack !=null && callBack.runWith([1]);
		}
	}

	MiniFileMgr.setNativeFileDir=function(value){
		MiniFileMgr.fileNativeDir=/*__JS__ */wx.env.USER_DATA_PATH+value;
	}

	MiniFileMgr.filesListObj={};
	MiniFileMgr.fileNativeDir=null;
	MiniFileMgr.fileListName="layaairfiles.txt";
	MiniFileMgr.ziyuFileData={};
	MiniFileMgr.loadPath="";
	MiniFileMgr.DESCENDING=2;
	MiniFileMgr.NUMERIC=16;
	__static(MiniFileMgr,
	['fs',function(){return this.fs=/*__JS__ */wx.getFileSystemManager();},'wxdown',function(){return this.wxdown=/*__JS__ */wx.downloadFile;}
	]);
	return MiniFileMgr;
})()


/**@private **/
//class laya.wx.mini.MiniImage
var MiniImage=(function(){
	function MiniImage(){}
	__class(MiniImage,'laya.wx.mini.MiniImage');
	var __proto=MiniImage.prototype;
	/**@private **/
	__proto._loadImage=function(url){
		var thisLoader=this;
		if (MiniAdpter.isZiYu){
			MiniImage.onCreateImage(url,thisLoader,true);
			return;
		};
		var isTransformUrl=false;
		if (!MiniFileMgr.isLocalNativeFile(url)){
			isTransformUrl=true;
			url=URL.formatURL(url);
			}else{
			if (url.indexOf("http://")!=-1 || url.indexOf("https://")!=-1){
				if(MiniFileMgr.loadPath !=""){
					url=url.split(MiniFileMgr.loadPath)[1];
					}else{
					var tempStr=URL.rootPath !="" ? URL.rootPath :URL.basePath;
					if(tempStr !="")
						url=url.split(tempStr)[1];
				}
			}
		}
		if (!MiniFileMgr.getFileInfo(url)){
			if (url.indexOf("http://")!=-1 || url.indexOf("https://")!=-1){
				if(MiniAdpter.isZiYu){
					MiniImage.onCreateImage(url,thisLoader,true);
					}else{
					MiniFileMgr.downOtherFiles(url,new Handler(MiniImage,MiniImage.onDownImgCallBack,[url,thisLoader]),url);
				}
			}
			else
			MiniImage.onCreateImage(url,thisLoader,true);
			}else {
			MiniImage.onCreateImage(url,thisLoader,!isTransformUrl);
		}
	}

	MiniImage.onDownImgCallBack=function(sourceUrl,thisLoader,errorCode,tempFilePath){
		(tempFilePath===void 0)&& (tempFilePath="");
		if (!errorCode)
			MiniImage.onCreateImage(sourceUrl,thisLoader,false,tempFilePath);
		else {
			thisLoader.onError(null);
		}
	}

	MiniImage.onCreateImage=function(sourceUrl,thisLoader,isLocal,tempFilePath){
		(isLocal===void 0)&& (isLocal=false);
		(tempFilePath===void 0)&& (tempFilePath="");
		var fileNativeUrl;
		if(MiniAdpter.autoCacheFile){
			if (!isLocal){
				if(tempFilePath !=""){
					fileNativeUrl=tempFilePath;
					}else{
					var fileObj=MiniFileMgr.getFileInfo(sourceUrl);
					var fileMd5Name=fileObj.md5;
					fileNativeUrl=MiniFileMgr.getFileNativePath(fileMd5Name);
				}
			}else
			fileNativeUrl=sourceUrl;
			}else{
			if(!isLocal)
				fileNativeUrl=tempFilePath;
			else
			fileNativeUrl=sourceUrl;
		}
		if (thisLoader.imgCache==null)
			thisLoader.imgCache={};
		var image;
		function clear (){
			image.onload=null;
			image.onerror=null;
			delete thisLoader.imgCache[sourceUrl]
		};
		var onload=function (){
			clear();
			thisLoader._url=URL.formatURL(thisLoader._url);
			thisLoader.onLoaded(image);
		};
		var onerror=function (){
			clear();
			thisLoader.event(/*laya.events.Event.ERROR*/"error","Load image failed");
		}
		if (thisLoader._type=="nativeimage"){
			image=new Browser.window.Image();
			image.crossOrigin="";
			image.onload=onload;
			image.onerror=onerror;
			image.src=fileNativeUrl;
			thisLoader.imgCache[sourceUrl]=image;
			}else {
			new HTMLImage.create(fileNativeUrl,{onload:onload,onerror:onerror,onCreate:function (img){
					image=img;
					thisLoader.imgCache[sourceUrl]=img;
			}});
		}
	}

	return MiniImage;
})()


/**@private **/
//class laya.wx.mini.MiniInput
var MiniInput=(function(){
	function MiniInput(){}
	__class(MiniInput,'laya.wx.mini.MiniInput');
	MiniInput._createInputElement=function(){
		Input['_initInput'](Input['area']=Browser.createElement("textarea"));
		Input['_initInput'](Input['input']=Browser.createElement("input"));
		Input['inputContainer']=Browser.createElement("div");
		Input['inputContainer'].style.position="absolute";
		Input['inputContainer'].style.zIndex=1E5;
		Browser.container.appendChild(Input['inputContainer']);
		Input['inputContainer'].setPos=function (x,y){Input['inputContainer'].style.left=x+'px';Input['inputContainer'].style.top=y+'px';};
		Laya.stage.on("resize",null,MiniInput._onStageResize);
		/*__JS__ */wx.onWindowResize && /*__JS__ */wx.onWindowResize(function(res){
			/*__JS__ */window.dispatchEvent && /*__JS__ */window.dispatchEvent("resize");
		});
		SoundManager._soundClass=MiniSound;
		SoundManager._musicClass=MiniSound;
		var model=MiniAdpter.systemInfo.model;
		var system=MiniAdpter.systemInfo.system;
		if(model.indexOf("iPhone")!=-1){
			Browser.onIPhone=true;
			Browser.onIOS=true;
			Browser.onIPad=true;
			Browser.onAndroid=false;
		}
		if(system.indexOf("Android")!=-1 || system.indexOf("Adr")!=-1){
			Browser.onAndroid=true;
			Browser.onIPhone=false;
			Browser.onIOS=false;
			Browser.onIPad=false;
		}
	}

	MiniInput._onStageResize=function(){
		var ts=Laya.stage._canvasTransform.identity();
		ts.scale((Browser.width / Render.canvas.width / RunDriver.getPixelRatio()),Browser.height / Render.canvas.height / RunDriver.getPixelRatio());
	}

	MiniInput.wxinputFocus=function(e){
		var _inputTarget=Input['inputElement'].target;
		if (_inputTarget && !_inputTarget.editable){
			return;
		}
		MiniAdpter.window.wx.offKeyboardConfirm();
		MiniAdpter.window.wx.offKeyboardInput();
		MiniAdpter.window.wx.showKeyboard({defaultValue:_inputTarget.text,maxLength:_inputTarget.maxChars,multiple:_inputTarget.multiline,confirmHold:true,confirmType:'done',success:function (res){
				},fail:function (res){
		}});
		MiniAdpter.window.wx.onKeyboardConfirm(function(res){
			var str=res ? res.value :"";
			_inputTarget.text=str;
			_inputTarget.event(/*laya.events.Event.INPUT*/"input");
			laya.wx.mini.MiniInput.inputEnter();
		})
		MiniAdpter.window.wx.onKeyboardInput(function(res){
			var str=res ? res.value :"";
			if (!_inputTarget.multiline){
				if (str.indexOf("\n")!=-1){
					laya.wx.mini.MiniInput.inputEnter();
					return;
				}
			}
			_inputTarget.text=str;
			_inputTarget.event(/*laya.events.Event.INPUT*/"input");
		});
	}

	MiniInput.inputEnter=function(){
		Input['inputElement'].target.focus=false;
	}

	MiniInput.wxinputblur=function(){
		MiniInput.hideKeyboard();
	}

	MiniInput.hideKeyboard=function(){
		MiniAdpter.window.wx.offKeyboardConfirm();
		MiniAdpter.window.wx.offKeyboardInput();
		MiniAdpter.window.wx.hideKeyboard({success:function (res){
				console.log('隐藏键盘')
				},fail:function (res){
				console.log("隐藏键盘出错:"+(res ? res.errMsg :""));
		}});
	}

	return MiniInput;
})()


/**@private **/
//class laya.wx.mini.MiniLocalStorage
var MiniLocalStorage=(function(){
	function MiniLocalStorage(){}
	__class(MiniLocalStorage,'laya.wx.mini.MiniLocalStorage');
	MiniLocalStorage.__init__=function(){
		MiniLocalStorage.items=MiniLocalStorage;
	}

	MiniLocalStorage.setItem=function(key,value){
		/*__JS__ */wx.setStorageSync(key,value);
	}

	MiniLocalStorage.getItem=function(key){
		return /*__JS__ */wx.getStorageSync(key);
	}

	MiniLocalStorage.setJSON=function(key,value){
		MiniLocalStorage.setItem(key,value);
	}

	MiniLocalStorage.getJSON=function(key){
		return MiniLocalStorage.getItem(key);
	}

	MiniLocalStorage.removeItem=function(key){
		/*__JS__ */wx.removeStorageSync(key);
	}

	MiniLocalStorage.clear=function(){
		/*__JS__ */wx.clearStorageSync();
	}

	MiniLocalStorage.getStorageInfoSync=function(){
		try {
			var res=/*__JS__ */wx.getStorageInfoSync()
			console.log(res.keys)
			console.log(res.currentSize)
			console.log(res.limitSize)
			return res;
		}catch (e){}
		return null;
	}

	MiniLocalStorage.support=true;
	MiniLocalStorage.items=null;
	return MiniLocalStorage;
})()


/**@private **/
//class laya.wx.mini.MiniLocation
var MiniLocation=(function(){
	function MiniLocation(){}
	__class(MiniLocation,'laya.wx.mini.MiniLocation');
	MiniLocation.__init__=function(){
		MiniAdpter.window.navigator.geolocation.getCurrentPosition=MiniLocation.getCurrentPosition;
		MiniAdpter.window.navigator.geolocation.watchPosition=MiniLocation.watchPosition;
		MiniAdpter.window.navigator.geolocation.clearWatch=MiniLocation.clearWatch;
	}

	MiniLocation.getCurrentPosition=function(success,error,options){
		var paramO;
		paramO={};
		paramO.success=getSuccess;
		paramO.fail=error;
		MiniAdpter.window.wx.getLocation(paramO);
		function getSuccess (res){
			if (success !=null){
				success(res);
			}
		}
	}

	MiniLocation.watchPosition=function(success,error,options){
		MiniLocation._curID++;
		var curWatchO;
		curWatchO={};
		curWatchO.success=success;
		curWatchO.error=error;
		MiniLocation._watchDic[MiniLocation._curID]=curWatchO;
		Laya.timer.loop(1000,null,MiniLocation._myLoop);
		return MiniLocation._curID;
	}

	MiniLocation.clearWatch=function(id){
		delete MiniLocation._watchDic[id];
		if (!MiniLocation._hasWatch()){
			Laya.timer.clear(null,MiniLocation._myLoop);
		}
	}

	MiniLocation._hasWatch=function(){
		var key;
		for (key in MiniLocation._watchDic){
			if (MiniLocation._watchDic[key])return true;
		}
		return false;
	}

	MiniLocation._myLoop=function(){
		MiniLocation.getCurrentPosition(MiniLocation._mySuccess,MiniLocation._myError);
	}

	MiniLocation._mySuccess=function(res){
		var rst={};
		rst.coords=res;
		rst.timestamp=Browser.now();
		var key;
		for (key in MiniLocation._watchDic){
			if (MiniLocation._watchDic[key].success){
				MiniLocation._watchDic[key].success(rst);
			}
		}
	}

	MiniLocation._myError=function(res){
		var key;
		for (key in MiniLocation._watchDic){
			if (MiniLocation._watchDic[key].error){
				MiniLocation._watchDic[key].error(res);
			}
		}
	}

	MiniLocation._watchDic={};
	MiniLocation._curID=0;
	return MiniLocation;
})()


/**@private **/
//class laya.wx.mini.MiniAccelerator extends laya.events.EventDispatcher
var MiniAccelerator=(function(_super){
	function MiniAccelerator(){
		MiniAccelerator.__super.call(this);
	}

	__class(MiniAccelerator,'laya.wx.mini.MiniAccelerator',_super);
	var __proto=MiniAccelerator.prototype;
	/**
	*侦听加速器运动。
	*@param observer 回调函数接受4个参数，见类说明。
	*/
	__proto.on=function(type,caller,listener,args){
		_super.prototype.on.call(this,type,caller,listener,args);
		MiniAccelerator.startListen(this["onDeviceOrientationChange"]);
		return this;
	}

	/**
	*取消侦听加速器。
	*@param handle 侦听加速器所用处理器。
	*/
	__proto.off=function(type,caller,listener,onceOnly){
		(onceOnly===void 0)&& (onceOnly=false);
		if (!this.hasListener(type))
			MiniAccelerator.stopListen();
		return _super.prototype.off.call(this,type,caller,listener,onceOnly);
	}

	MiniAccelerator.__init__=function(){
		try{
			var Acc;
			Acc=/*__JS__ */laya.device.motion.Accelerator;
			if (!Acc)return;
			Acc["prototype"]["on"]=MiniAccelerator["prototype"]["on"];
			Acc["prototype"]["off"]=MiniAccelerator["prototype"]["off"];
			}catch (e){
		}
	}

	MiniAccelerator.startListen=function(callBack){
		MiniAccelerator._callBack=callBack;
		if (MiniAccelerator._isListening)return;
		MiniAccelerator._isListening=true;
		try{
			/*__JS__ */wx.onAccelerometerChange(MiniAccelerator.onAccelerometerChange);
		}catch(e){}
	}

	MiniAccelerator.stopListen=function(){
		MiniAccelerator._isListening=false;
		try{
			/*__JS__ */wx.stopAccelerometer({});
		}catch(e){}
	}

	MiniAccelerator.onAccelerometerChange=function(res){
		var e;
		e={};
		e.acceleration=res;
		e.accelerationIncludingGravity=res;
		e.rotationRate={};
		if (MiniAccelerator._callBack !=null){
			MiniAccelerator._callBack(e);
		}
	}

	MiniAccelerator._isListening=false;
	MiniAccelerator._callBack=null;
	return MiniAccelerator;
})(EventDispatcher)


/**@private **/
//class laya.wx.mini.MiniLoader extends laya.events.EventDispatcher
var MiniLoader=(function(_super){
	function MiniLoader(){
		MiniLoader.__super.call(this);
	}

	__class(MiniLoader,'laya.wx.mini.MiniLoader',_super);
	var __proto=MiniLoader.prototype;
	/**
	*@private
	*@param url
	*@param type
	*@param cache
	*@param group
	*@param ignoreCache
	*/
	__proto.load=function(url,type,cache,group,ignoreCache){
		(cache===void 0)&& (cache=true);
		(ignoreCache===void 0)&& (ignoreCache=false);
		var thisLoader=this;
		thisLoader._url=url;
		if (url.indexOf("data:image")===0)thisLoader._type=type=/*laya.net.Loader.IMAGE*/"image";
		else {
			thisLoader._type=type || (type=thisLoader.getTypeFromUrl(url));
		}
		thisLoader._cache=cache;
		thisLoader._data=null;
		if (!ignoreCache && Loader.loadedMap[URL.formatURL(url)]){
			thisLoader._data=Loader.loadedMap[URL.formatURL(url)];
			this.event(/*laya.events.Event.PROGRESS*/"progress",1);
			this.event(/*laya.events.Event.COMPLETE*/"complete",thisLoader._data);
			return;
		}
		if (Loader.parserMap[type] !=null){
			thisLoader._customParse=true;
			if (((Loader.parserMap[type])instanceof laya.utils.Handler ))Loader.parserMap[type].runWith(this);
			else Loader.parserMap[type].call(null,this);
			return;
		};
		var encoding=MiniAdpter.getUrlEncode(url,type);
		var urlType=Utils.getFileExtension(url);
		if ((MiniLoader._fileTypeArr.indexOf(urlType)!=-1)){
			MiniAdpter.EnvConfig.load.call(this,url,type,cache,group,ignoreCache);
			}else {
			if(MiniAdpter.isZiYu && MiniFileMgr.ziyuFileData[url]){
				var tempData=MiniFileMgr.ziyuFileData[url];
				thisLoader.onLoaded(tempData);
				return;
			}
			if (!MiniFileMgr.getFileInfo(url)){
				if (MiniFileMgr.isLocalNativeFile(url)){
					MiniFileMgr.read(url,encoding,new Handler(MiniLoader,MiniLoader.onReadNativeCallBack,[encoding,url,type,cache,group,ignoreCache,thisLoader]));
					return;
				};
				var tempUrl=url;
				url=URL.formatURL(url);
				if (url.indexOf("http://")!=-1 || url.indexOf("https://")!=-1){
					MiniAdpter.EnvConfig.load.call(thisLoader,tempUrl,type,cache,group,ignoreCache);
					}else {
					MiniFileMgr.readFile(url,encoding,new Handler(MiniLoader,MiniLoader.onReadNativeCallBack,[encoding,url,type,cache,group,ignoreCache,thisLoader]),url);
				}
				}else {
				var fileObj=MiniFileMgr.getFileInfo(url);
				fileObj.encoding=fileObj.encoding==null ? "ascii" :fileObj.encoding;
				MiniFileMgr.readFile(url,fileObj.encoding,new Handler(MiniLoader,MiniLoader.onReadNativeCallBack,[encoding,url,type,cache,group,ignoreCache,thisLoader]),url);
			}
		}
	}

	MiniLoader.onReadNativeCallBack=function(encoding,url,type,cache,group,ignoreCache,thisLoader,errorCode,data){
		(cache===void 0)&& (cache=true);
		(ignoreCache===void 0)&& (ignoreCache=false);
		(errorCode===void 0)&& (errorCode=0);
		if (!errorCode){
			var tempData;
			if (type==/*laya.net.Loader.JSON*/"json" || type==/*laya.net.Loader.ATLAS*/"atlas"){
				tempData=MiniAdpter.getJson(data.data);
				}else if (type==/*laya.net.Loader.XML*/"xml"){
				tempData=Utils.parseXMLFromString(data.data);
				}else {
				tempData=data.data;
			}
			if(!MiniAdpter.isZiYu &&MiniAdpter.isPosMsgYu && type !=/*laya.net.Loader.BUFFER*/"arraybuffer"){
				/*__JS__ */wx.postMessage({url:url,data:tempData,isLoad:"filedata"});
			}
			thisLoader.onLoaded(tempData);
			}else if (errorCode==1){
			MiniAdpter.EnvConfig.load.call(thisLoader,url,type,cache,group,ignoreCache);
		}
	}

	__static(MiniLoader,
	['_fileTypeArr',function(){return this._fileTypeArr=['png','jpg','bmp','jpeg','gif'];}
	]);
	return MiniLoader;
})(EventDispatcher)


/**@private **/
//class laya.wx.mini.MiniSound extends laya.events.EventDispatcher
var MiniSound=(function(_super){
	function MiniSound(){
		/**@private **/
		this._sound=null;
		/**
		*@private
		*声音URL
		*/
		this.url=null;
		/**
		*@private
		*是否已加载完成
		*/
		this.loaded=false;
		/**@private **/
		this.readyUrl=null;
		MiniSound.__super.call(this);
	}

	__class(MiniSound,'laya.wx.mini.MiniSound',_super);
	var __proto=MiniSound.prototype;
	/**
	*@private
	*加载声音。
	*@param url 地址。
	*
	*/
	__proto.load=function(url){
		url=URL.formatURL(url);
		this.url=url;
		this.readyUrl=url;
		if (MiniSound._audioCache[this.readyUrl]){
			this.event(/*laya.events.Event.COMPLETE*/"complete");
			return;
		}
		if(MiniAdpter.autoCacheFile&&MiniFileMgr.getFileInfo(url)){
			this.onDownLoadCallBack(url,0);
			}else{
			if(!MiniAdpter.autoCacheFile){
				this.onDownLoadCallBack(url,0);
				}else{
				MiniFileMgr.downOtherFiles(url,Handler.create(this,this.onDownLoadCallBack,[url]),url);
			}
		}
	}

	/**@private **/
	__proto.onDownLoadCallBack=function(sourceUrl,errorCode){
		if (!errorCode){
			var fileNativeUrl;
			if(MiniAdpter.autoCacheFile){
				var fileObj=MiniFileMgr.getFileInfo(sourceUrl);
				var fileMd5Name=fileObj.md5;
				fileNativeUrl=MiniFileMgr.getFileNativePath(fileMd5Name);
				this._sound=MiniSound._createSound();
				this._sound.src=this.url=fileNativeUrl;
				}else{
				this._sound=MiniSound._createSound();
				this._sound.src=sourceUrl;
			}
			this._sound.onCanplay(MiniSound.bindToThis(this.onCanPlay,this));
			this._sound.onError(MiniSound.bindToThis(this.onError,this));
			}else{
			this.event(/*laya.events.Event.ERROR*/"error");
		}
	}

	/**@private **/
	__proto.onError=function(error){
		try{
			console.log("-----1---------------minisound-----id:"+MiniSound._id);
			console.log(error);
		}
		catch(error){
			console.log("-----2---------------minisound-----id:"+MiniSound._id);
			console.log(error);
		}
		this.event(/*laya.events.Event.ERROR*/"error");
		this._sound.offError(null);
	}

	/**@private **/
	__proto.onCanPlay=function(){
		this.loaded=true;
		this.event(/*laya.events.Event.COMPLETE*/"complete");
		MiniSound._audioCache[this.readyUrl]=this;
		this._sound.offCanplay(null);
	}

	/**
	*@private
	*播放声音。
	*@param startTime 开始时间,单位秒
	*@param loops 循环次数,0表示一直循环
	*@return 声道 SoundChannel 对象。
	*
	*/
	__proto.play=function(startTime,loops){
		(startTime===void 0)&& (startTime=0);
		(loops===void 0)&& (loops=0);
		var tSound;
		if (this.url==SoundManager._tMusic){
			if (!MiniSound._musicAudio)MiniSound._musicAudio=MiniSound._createSound();
			tSound=MiniSound._musicAudio;
			}else {
			if(MiniSound._audioCache[this.readyUrl]){
				tSound=MiniSound._audioCache[this.readyUrl]._sound;
				}else{
				tSound=MiniSound._createSound();
			}
		}
		if(MiniAdpter.autoCacheFile&&MiniFileMgr.getFileInfo(this.url)){
			var fileNativeUrl;
			var fileObj=MiniFileMgr.getFileInfo(this.url);
			var fileMd5Name=fileObj.md5;
			tSound.src=this.url=MiniFileMgr.getFileNativePath(fileMd5Name);
			}else{
			tSound.src=this.url;
		};
		var channel=new MiniSoundChannel(tSound,this);
		channel.url=this.url;
		channel.loops=loops;
		channel.loop=(loops===0 ? true :false);
		channel.startTime=startTime;
		channel.play();
		SoundManager.addChannel(channel);
		return channel;
	}

	/**
	*@private
	*释放声音资源。
	*
	*/
	__proto.dispose=function(){
		var ad=MiniSound._audioCache[this.readyUrl];
		if (ad){
			ad.src="";
			if(ad._sound){
				ad._sound.destroy();
				ad._sound=null;
				ad=null;
			}
			delete MiniSound._audioCache[this.readyUrl];
		}
	}

	/**
	*@private
	*获取总时间。
	*/
	__getset(0,__proto,'duration',function(){
		return this._sound.duration;
	});

	MiniSound._createSound=function(){
		MiniSound._id++;
		return MiniAdpter.window.wx.createInnerAudioContext();
	}

	MiniSound.bindToThis=function(fun,scope){
		var rst=fun;
		/*__JS__ */rst=fun.bind(scope);;
		return rst;
	}

	MiniSound._musicAudio=null;
	MiniSound._id=0;
	MiniSound._audioCache={};
	return MiniSound;
})(EventDispatcher)


/**@private **/
//class laya.wx.mini.MiniSoundChannel extends laya.media.SoundChannel
var MiniSoundChannel=(function(_super){
	function MiniSoundChannel(audio,miniSound){
		/**@private **/
		this._audio=null;
		/**@private **/
		this._onEnd=null;
		/**@private **/
		this._miniSound=null;
		MiniSoundChannel.__super.call(this);
		this._audio=audio;
		this._miniSound=miniSound;
		this._onEnd=MiniSoundChannel.bindToThis(this.__onEnd,this);
		audio.onEnded(this._onEnd);
	}

	__class(MiniSoundChannel,'laya.wx.mini.MiniSoundChannel',_super);
	var __proto=MiniSoundChannel.prototype;
	/**@private **/
	__proto.__onEnd=function(){
		if (this.loops==1){
			if (this.completeHandler){
				Laya.timer.once(10,this,this.__runComplete,[this.completeHandler],false);
				this.completeHandler=null;
			}
			this.stop();
			this.event(/*laya.events.Event.COMPLETE*/"complete");
			return;
		}
		if (this.loops > 0){
			this.loops--;
		}
		this.startTime=0;
		this.play();
	}

	/**
	*@private
	*播放
	*/
	__proto.play=function(){
		this.isStopped=false;
		SoundManager.addChannel(this);
		this._audio.play();
	}

	/**
	*@private
	*停止播放
	*
	*/
	__proto.stop=function(){
		this.isStopped=true;
		SoundManager.removeChannel(this);
		this.completeHandler=null;
		if (!this._audio)
			return;
		this._audio.pause();
		this._audio.offEnded(null);
		this._audio=null;
		this._miniSound=null;
		this._onEnd=null;
	}

	/**@private **/
	__proto.pause=function(){
		this.isStopped=true;
		this._audio.pause();
	}

	/**@private **/
	__proto.resume=function(){
		if (!this._audio)
			return;
		this.isStopped=false;
		SoundManager.addChannel(this);
		this._audio.play();
	}

	/**@private **/
	/**
	*@private
	*自动播放
	*@param value
	*/
	__getset(0,__proto,'autoplay',function(){
		return this._audio.autoplay;
		},function(value){
		this._audio.autoplay=value;
	});

	/**
	*@private
	*当前播放到的位置
	*@return
	*
	*/
	__getset(0,__proto,'position',function(){
		if (!this._audio)
			return 0;
		return this._audio.currentTime;
	});

	/**
	*@private
	*获取总时间。
	*/
	__getset(0,__proto,'duration',function(){
		if (!this._audio)
			return 0;
		return this._audio.duration;
	});

	/**@private **/
	/**@private **/
	__getset(0,__proto,'loop',function(){
		return this._audio.loop;
		},function(value){
		this._audio.loop=value;
	});

	/**
	*@private
	*设置音量
	*@param v
	*
	*/
	/**
	*@private
	*获取音量
	*@return
	*/
	__getset(0,__proto,'volume',function(){
		if (!this._audio)return 1;
		return this._audio.volume;
		},function(v){
		if (!this._audio)return;
		this._audio.volume=v;
	});

	MiniSoundChannel.bindToThis=function(fun,scope){
		var rst=fun;
		/*__JS__ */rst=fun.bind(scope);;
		return rst;
	}

	return MiniSoundChannel;
})(SoundChannel)



})(window,document,Laya);

if (typeof define === 'function' && define.amd){
	define('laya.core', ['require', "exports"], function(require, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        for (var i in Laya) {
			var o = Laya[i];
            o && o.__isclass && (exports[i] = o);
        }
    });
}

(function(window,document,Laya){
	var __un=Laya.un,__uns=Laya.uns,__static=Laya.static,__class=Laya.class,__getset=Laya.getset,__newvec=Laya.__newvec;

	var Arith=laya.maths.Arith,Bezier=laya.maths.Bezier,Bitmap=laya.resource.Bitmap,Browser=laya.utils.Browser;
	var Byte=laya.utils.Byte,Color=laya.utils.Color,ColorFilter=laya.filters.ColorFilter,Config=Laya.Config,Context=laya.resource.Context;
	var Event=laya.events.Event,Filter=laya.filters.Filter,Graphics=laya.display.Graphics,HTMLCanvas=laya.resource.HTMLCanvas;
	var HTMLChar=laya.utils.HTMLChar,HTMLImage=laya.resource.HTMLImage,HTMLSubImage=laya.resource.HTMLSubImage;
	var Handler=laya.utils.Handler,Loader=laya.net.Loader,Matrix=laya.maths.Matrix,Point=laya.maths.Point,Rectangle=laya.maths.Rectangle;
	var Render=laya.renders.Render,RenderContext=laya.renders.RenderContext,RenderSprite=laya.renders.RenderSprite;
	var Resource=laya.resource.Resource,ResourceManager=laya.resource.ResourceManager,RunDriver=laya.utils.RunDriver;
	var Sprite=laya.display.Sprite,Stage=laya.display.Stage,Stat=laya.utils.Stat,StringKey=laya.utils.StringKey;
	var Style=laya.display.css.Style,System=laya.system.System,Text=laya.display.Text,Texture=laya.resource.Texture;
	var TransformInfo=laya.display.css.TransformInfo,URL=laya.net.URL,Utils=laya.utils.Utils,VectorGraphManager=laya.utils.VectorGraphManager;
	var WordText=laya.utils.WordText;
Laya.interface('laya.webgl.shapes.IShape');
Laya.interface('laya.webgl.submit.ISubmit');
Laya.interface('laya.webgl.text.ICharSegment');
Laya.interface('laya.webgl.canvas.save.ISaveData');
Laya.interface('laya.webgl.resource.IMergeAtlasBitmap');
Laya.interface('laya.filters.IFilterActionGL','laya.filters.IFilterAction');
//class laya.filters.webgl.FilterActionGL
var FilterActionGL=(function(){
	function FilterActionGL(){}
	__class(FilterActionGL,'laya.filters.webgl.FilterActionGL');
	var __proto=FilterActionGL.prototype;
	Laya.imps(__proto,{"laya.filters.IFilterActionGL":true})
	__proto.setValue=function(shader){}
	__proto.setValueMix=function(shader){}
	__proto.apply3d=function(scope,sprite,context,x,y){return null;}
	__proto.apply=function(srcCanvas){return null;}
	__getset(0,__proto,'typeMix',function(){
		return 0;
	});

	return FilterActionGL;
})()


//class laya.webgl.shader.ShaderValue
var ShaderValue=(function(){
	function ShaderValue(){}
	__class(ShaderValue,'laya.webgl.shader.ShaderValue');
	return ShaderValue;
})()


//class laya.webgl.atlas.AtlasGrid
var AtlasGrid=(function(){
	var TexRowInfo,TexMergeTexSize;
	function AtlasGrid(width,height,atlasID){
		this._atlasID=0;
		this._width=0;
		this._height=0;
		this._texCount=0;
		this._rowInfo=null;
		this._cells=null;
		this._failSize=new TexMergeTexSize();
		(width===void 0)&& (width=0);
		(height===void 0)&& (height=0);
		(atlasID===void 0)&& (atlasID=0);
		this._cells=null;
		this._rowInfo=null;
		this._init(width,height);
		this._atlasID=atlasID;
	}

	__class(AtlasGrid,'laya.webgl.atlas.AtlasGrid');
	var __proto=AtlasGrid.prototype;
	//------------------------------------------------------------------------------
	__proto.getAltasID=function(){
		return this._atlasID;
	}

	//------------------------------------------------------------------------------
	__proto.setAltasID=function(atlasID){
		if (atlasID >=0){
			this._atlasID=atlasID;
		}
	}

	//------------------------------------------------------------------
	__proto.addTex=function(type,width,height){
		var result=this._get(width,height);
		if (result.ret==false){
			return result;
		}
		this._fill(result.x,result.y,width,height,type);
		this._texCount++;
		return result;
	}

	//------------------------------------------------------------------------------
	__proto._release=function(){
		if (this._cells !=null){
			this._cells.length=0;
			this._cells=null;
		}
		if (this._rowInfo){
			this._rowInfo.length=0;
			this._rowInfo=null;
		}
	}

	//------------------------------------------------------------------------------
	__proto._init=function(width,height){
		this._width=width;
		this._height=height;
		this._release();
		if (this._width==0)return false;
		this._cells=new Uint8Array(this._width *this._height*3);
		this._rowInfo=__newvec(this._height);
		for (var i=0;i < this._height;i++){
			this._rowInfo[i]=new TexRowInfo();
		}
		this._clear();
		return true;
	}

	//------------------------------------------------------------------
	__proto._get=function(width,height){
		var pFillInfo=new MergeFillInfo();
		if (width >=this._failSize.width && height >=this._failSize.height){
			return pFillInfo;
		};
		var rx=-1;
		var ry=-1;
		var nWidth=this._width;
		var nHeight=this._height;
		var pCellBox=this._cells;
		for (var y=0;y < nHeight;y++){
			if (this._rowInfo[y].spaceCount < width)continue ;
			for (var x=0;x < nWidth;){
				var tm=(y *nWidth+x)*3;
				if (pCellBox[tm] !=0 || pCellBox[tm+1] < width || pCellBox[tm+2] < height){
					x+=pCellBox[tm+1];
					continue ;
				}
				rx=x;
				ry=y;
				for (var xx=0;xx < width;xx++){
					if (pCellBox[3*xx+tm+2] < height){
						rx=-1;
						break ;
					}
				}
				if (rx < 0){
					x+=pCellBox[tm+1];
					continue ;
				}
				pFillInfo.ret=true;
				pFillInfo.x=rx;
				pFillInfo.y=ry;
				return pFillInfo;
			}
		}
		return pFillInfo;
	}

	//------------------------------------------------------------------
	__proto._fill=function(x,y,w,h,type){
		var nWidth=this._width;
		var nHeghit=this._height;
		this._check((x+w)<=nWidth && (y+h)<=nHeghit);
		for (var yy=y;yy < (h+y);++yy){
			this._check(this._rowInfo[yy].spaceCount >=w);
			this._rowInfo[yy].spaceCount-=w;
			for (var xx=0;xx < w;xx++){
				var tm=(x+yy *nWidth+xx)*3;
				this._check(this._cells[tm]==0);
				this._cells[tm]=type;
				this._cells[tm+1]=w;
				this._cells[tm+2]=h;
			}
		}
		if (x > 0){
			for (yy=0;yy < h;++yy){
				var s=0;
				for (xx=x-1;xx >=0;--xx,++s){
					if (this._cells[((y+yy)*nWidth+xx)*3] !=0)break ;
				}
				for (xx=s;xx > 0;--xx){
					this._cells[((y+yy)*nWidth+x-xx)*3+1]=xx;
					this._check(xx > 0);
				}
			}
		}
		if (y > 0){
			for (xx=x;xx < (x+w);++xx){
				s=0;
				for (yy=y-1;yy >=0;--yy,s++){
					if (this._cells[(xx+yy *nWidth)*3] !=0)break ;
				}
				for (yy=s;yy > 0;--yy){
					this._cells[(xx+(y-yy)*nWidth)*3+2]=yy;
					this._check(yy > 0);
				}
			}
		}
	}

	__proto._check=function(ret){
		if (ret==false){
			console.log("xtexMerger 错误啦");
		}
	}

	//------------------------------------------------------------------
	__proto._clear=function(){
		this._texCount=0;
		for (var y=0;y < this._height;y++){
			this._rowInfo[y].spaceCount=this._width;
		}
		for (var i=0;i < this._height;i++){
			for (var j=0;j < this._width;j++){
				var tm=(i *this._width+j)*3;
				this._cells[tm]=0;
				this._cells[tm+1]=this._width-j;
				this._cells[tm+2]=this._width-i;
			}
		}
		this._failSize.width=this._width+1;
		this._failSize.height=this._height+1;
	}

	AtlasGrid.__init$=function(){
		//------------------------------------------------------------------------------
		//class TexRowInfo
		TexRowInfo=(function(){
			function TexRowInfo(){
				this.spaceCount=0;
			}
			__class(TexRowInfo,'');
			return TexRowInfo;
		})()
		//------------------------------------------------------------------------------
		//class TexMergeTexSize
		TexMergeTexSize=(function(){
			function TexMergeTexSize(){
				this.width=0;
				this.height=0;
			}
			__class(TexMergeTexSize,'');
			return TexMergeTexSize;
		})()
	}

	return AtlasGrid;
})()


//class laya.webgl.atlas.AtlasResourceManager
var AtlasResourceManager=(function(){
	function AtlasResourceManager(width,height,gridSize,maxTexNum){
		this._currentAtlasCount=0;
		this._maxAtlaserCount=0;
		this._width=0;
		this._height=0;
		this._gridSize=0;
		this._gridNumX=0;
		this._gridNumY=0;
		this._init=false;
		this._curAtlasIndex=0;
		this._setAtlasParam=false;
		this._atlaserArray=null;
		this._needGC=false;
		this._setAtlasParam=true;
		this._width=width;
		this._height=height;
		this._gridSize=gridSize;
		this._maxAtlaserCount=maxTexNum;
		this._gridNumX=width / gridSize;
		this._gridNumY=height / gridSize;
		this._curAtlasIndex=0;
		this._atlaserArray=[];
	}

	__class(AtlasResourceManager,'laya.webgl.atlas.AtlasResourceManager');
	var __proto=AtlasResourceManager.prototype;
	__proto.setAtlasParam=function(width,height,gridSize,maxTexNum){
		if (this._setAtlasParam==true){
			AtlasResourceManager._sid_=0;
			this._width=width;
			this._height=height;
			this._gridSize=gridSize;
			this._maxAtlaserCount=maxTexNum;
			this._gridNumX=width / gridSize;
			this._gridNumY=height / gridSize;
			this._curAtlasIndex=0;
			this.freeAll();
			return true;
			}else {
			console.log("设置大图合集参数错误，只能在开始页面设置各种参数");
			throw-1;
			return false;
		}
		return false;
	}

	//添加 图片到大图集
	__proto.pushData=function(texture){
		var bitmap=texture.bitmap;
		var nWebGLImageIndex=-1;
		var curAtlas=null;
		var i=0,n=0,altasIndex=0;
		for (i=0,n=this._atlaserArray.length;i < n;i++){
			altasIndex=(this._curAtlasIndex+i)% n;
			curAtlas=this._atlaserArray[altasIndex];
			nWebGLImageIndex=curAtlas.findBitmapIsExist(bitmap);
			if (nWebGLImageIndex !=-1){
				break ;
			}
		}
		if (nWebGLImageIndex !=-1){
			var offset=curAtlas.InAtlasWebGLImagesOffsetValue[nWebGLImageIndex];
			offsetX=offset[0];
			offsetY=offset[1];
			curAtlas.addToAtlas(texture,offsetX,offsetY);
			return true;
			}else {
			var tex=texture;
			this._setAtlasParam=false;
			var bFound=false;
			var nImageGridX=(Math.ceil((texture.bitmap.width+2)/ this._gridSize));
			var nImageGridY=(Math.ceil((texture.bitmap.height+2)/ this._gridSize));
			var bSuccess=false;
			for (var k=0;k < 2;k++){
				var maxAtlaserCount=this._maxAtlaserCount;
				for (i=0;i < maxAtlaserCount;i++){
					altasIndex=(this._curAtlasIndex+i)% maxAtlaserCount;
					(this._atlaserArray.length-1 >=altasIndex)|| (this._atlaserArray.push(new Atlaser(this._gridNumX,this._gridNumY,this._width,this._height,AtlasResourceManager._sid_++)));
					var atlas=this._atlaserArray[altasIndex];
					var offsetX=0,offsetY=0;
					var fillInfo=atlas.addTex(1,nImageGridX,nImageGridY);
					if (fillInfo.ret){
						offsetX=fillInfo.x *this._gridSize+1;
						offsetY=fillInfo.y *this._gridSize+1;
						bitmap.lock=true;
						atlas.addToAtlasTexture((bitmap),offsetX,offsetY);
						atlas.addToAtlas(texture,offsetX,offsetY);
						bSuccess=true;
						this._curAtlasIndex=altasIndex;
						break ;
					}
				}
				if (bSuccess)
					break ;
				this._atlaserArray.push(new Atlaser(this._gridNumX,this._gridNumY,this._width,this._height,AtlasResourceManager._sid_++));
				this._needGC=true;
				this.garbageCollection();
				this._curAtlasIndex=this._atlaserArray.length-1;
			}
			if (!bSuccess){
				console.log(">>>AtlasManager pushData error");
			}
			return bSuccess;
		}
	}

	__proto.addToAtlas=function(tex){
		laya.webgl.atlas.AtlasResourceManager.instance.pushData(tex);
	}

	/**
	*回收大图合集,不建议手动调用
	*@return
	*/
	__proto.garbageCollection=function(){
		if (this._needGC===true){
			var n=this._atlaserArray.length-this._maxAtlaserCount;
			for (var i=0;i < n;i++){
				this._atlaserArray[i].dispose();
				console.log("AtlasResourceManager:Dispose the inner Atlas。");
			}
			console.log(">>>>altas garbageCollection ="+n);
			this._atlaserArray.splice(0,n);
			this._needGC=false;
		}
		return true;
	}

	__proto.freeAll=function(){
		for (var i=0,n=this._atlaserArray.length;i < n;i++){
			this._atlaserArray[i].dispose();
		}
		this._atlaserArray.length=0;
		this._curAtlasIndex=0;
	}

	__proto.getAtlaserCount=function(){
		return this._atlaserArray.length;
	}

	__proto.getAtlaserByIndex=function(index){
		return this._atlaserArray[index];
	}

	__getset(1,AtlasResourceManager,'instance',function(){
		if (!AtlasResourceManager._Instance){
			AtlasResourceManager._Instance=new AtlasResourceManager(laya.webgl.atlas.AtlasResourceManager.atlasTextureWidth,laya.webgl.atlas.AtlasResourceManager.atlasTextureHeight,/*CLASS CONST:laya.webgl.atlas.AtlasResourceManager.gridSize*/16,laya.webgl.atlas.AtlasResourceManager.maxTextureCount);
		}
		return AtlasResourceManager._Instance;
	});

	__getset(1,AtlasResourceManager,'enabled',function(){
		return Config.atlasEnable;
	});

	__getset(1,AtlasResourceManager,'atlasLimitWidth',function(){
		return AtlasResourceManager._atlasLimitWidth;
		},function(value){
		AtlasResourceManager._atlasLimitWidth=value;
	});

	__getset(1,AtlasResourceManager,'atlasLimitHeight',function(){
		return AtlasResourceManager._atlasLimitHeight;
		},function(value){
		AtlasResourceManager._atlasLimitHeight=value;
	});

	AtlasResourceManager._enable=function(){
		Config.atlasEnable=true;
	}

	AtlasResourceManager._disable=function(){
		Config.atlasEnable=false;
	}

	AtlasResourceManager.__init__=function(){
		AtlasResourceManager.atlasTextureWidth=2048;
		AtlasResourceManager.atlasTextureHeight=2048;
		AtlasResourceManager.maxTextureCount=6;
		AtlasResourceManager.atlasLimitWidth=512;
		AtlasResourceManager.atlasLimitHeight=512;
	}

	AtlasResourceManager._atlasLimitWidth=0;
	AtlasResourceManager._atlasLimitHeight=0;
	AtlasResourceManager.gridSize=16;
	AtlasResourceManager.atlasTextureWidth=0;
	AtlasResourceManager.atlasTextureHeight=0;
	AtlasResourceManager.maxTextureCount=0;
	AtlasResourceManager._atlasRestore=0;
	AtlasResourceManager.BOARDER_TYPE_NO=0;
	AtlasResourceManager.BOARDER_TYPE_RIGHT=1;
	AtlasResourceManager.BOARDER_TYPE_LEFT=2;
	AtlasResourceManager.BOARDER_TYPE_BOTTOM=4;
	AtlasResourceManager.BOARDER_TYPE_TOP=8;
	AtlasResourceManager.BOARDER_TYPE_ALL=15;
	AtlasResourceManager._sid_=0;
	AtlasResourceManager._Instance=null;
	return AtlasResourceManager;
})()


//class laya.webgl.atlas.MergeFillInfo
var MergeFillInfo=(function(){
	function MergeFillInfo(){
		this.x=0;
		this.y=0;
		this.ret=false;
		this.ret=false;
		this.x=0;
		this.y=0;
	}

	__class(MergeFillInfo,'laya.webgl.atlas.MergeFillInfo');
	return MergeFillInfo;
})()


;
//class laya.webgl.canvas.BlendMode
var BlendMode=(function(){
	function BlendMode(){}
	__class(BlendMode,'laya.webgl.canvas.BlendMode');
	BlendMode._init_=function(gl){
		BlendMode.fns=[BlendMode.BlendNormal,BlendMode.BlendAdd,BlendMode.BlendMultiply,BlendMode.BlendScreen,BlendMode.BlendOverlay,BlendMode.BlendLight,BlendMode.BlendMask,BlendMode.BlendDestinationOut];
		BlendMode.targetFns=[BlendMode.BlendNormalTarget,BlendMode.BlendAddTarget,BlendMode.BlendMultiplyTarget,BlendMode.BlendScreenTarget,BlendMode.BlendOverlayTarget,BlendMode.BlendLightTarget,BlendMode.BlendMask,BlendMode.BlendDestinationOut];
	}

	BlendMode.BlendNormal=function(gl){
		gl.blendFunc(/*laya.webgl.WebGLContext.ONE*/1,/*laya.webgl.WebGLContext.ONE_MINUS_SRC_ALPHA*/0x0303);
	}

	BlendMode.BlendAdd=function(gl){
		gl.blendFunc(/*laya.webgl.WebGLContext.ONE*/1,/*laya.webgl.WebGLContext.DST_ALPHA*/0x0304);
	}

	BlendMode.BlendMultiply=function(gl){
		gl.blendFunc(/*laya.webgl.WebGLContext.DST_COLOR*/0x0306,/*laya.webgl.WebGLContext.ONE_MINUS_SRC_ALPHA*/0x0303);
	}

	BlendMode.BlendScreen=function(gl){
		gl.blendFunc(/*laya.webgl.WebGLContext.ONE*/1,/*laya.webgl.WebGLContext.ONE*/1);
	}

	BlendMode.BlendOverlay=function(gl){
		gl.blendFunc(/*laya.webgl.WebGLContext.ONE*/1,/*laya.webgl.WebGLContext.ONE_MINUS_SRC_COLOR*/0x0301);
	}

	BlendMode.BlendLight=function(gl){
		gl.blendFunc(/*laya.webgl.WebGLContext.ONE*/1,/*laya.webgl.WebGLContext.ONE*/1);
	}

	BlendMode.BlendNormalTarget=function(gl){
		gl.blendFunc(/*laya.webgl.WebGLContext.ONE*/1,/*laya.webgl.WebGLContext.ONE_MINUS_SRC_ALPHA*/0x0303);
	}

	BlendMode.BlendAddTarget=function(gl){
		gl.blendFunc(/*laya.webgl.WebGLContext.ONE*/1,/*laya.webgl.WebGLContext.DST_ALPHA*/0x0304);
	}

	BlendMode.BlendMultiplyTarget=function(gl){
		gl.blendFunc(/*laya.webgl.WebGLContext.DST_COLOR*/0x0306,/*laya.webgl.WebGLContext.ONE_MINUS_SRC_ALPHA*/0x0303);
	}

	BlendMode.BlendScreenTarget=function(gl){
		gl.blendFunc(/*laya.webgl.WebGLContext.ONE*/1,/*laya.webgl.WebGLContext.ONE*/1);
	}

	BlendMode.BlendOverlayTarget=function(gl){
		gl.blendFunc(/*laya.webgl.WebGLContext.ONE*/1,/*laya.webgl.WebGLContext.ONE_MINUS_SRC_COLOR*/0x0301);
	}

	BlendMode.BlendLightTarget=function(gl){
		gl.blendFunc(/*laya.webgl.WebGLContext.ONE*/1,/*laya.webgl.WebGLContext.ONE*/1);
	}

	BlendMode.BlendMask=function(gl){
		gl.blendFunc(/*laya.webgl.WebGLContext.ZERO*/0,/*laya.webgl.WebGLContext.SRC_ALPHA*/0x0302);
	}

	BlendMode.BlendDestinationOut=function(gl){
		gl.blendFunc(/*laya.webgl.WebGLContext.ZERO*/0,/*laya.webgl.WebGLContext.ZERO*/0);
	}

	BlendMode.activeBlendFunction=null;
	BlendMode.NAMES=["normal","add","multiply","screen","overlay","light","mask","destination-out"];
	BlendMode.TOINT={"normal":0,"add":1,"multiply":2,"screen":3 ,"lighter":1,"overlay":4,"light":5,"mask":6,"destination-out":7};
	BlendMode.NORMAL="normal";
	BlendMode.ADD="add";
	BlendMode.MULTIPLY="multiply";
	BlendMode.SCREEN="screen";
	BlendMode.LIGHT="light";
	BlendMode.OVERLAY="overlay";
	BlendMode.DESTINATIONOUT="destination-out";
	BlendMode.fns=[];
	BlendMode.targetFns=[];
	return BlendMode;
})()


//class laya.webgl.canvas.DrawStyle
var DrawStyle=(function(){
	function DrawStyle(value){
		this._color=Color.create("black");
		this.setValue(value);
	}

	__class(DrawStyle,'laya.webgl.canvas.DrawStyle');
	var __proto=DrawStyle.prototype;
	__proto.setValue=function(value){
		if (value){
			if ((typeof value=='string')){
				this._color=Color.create(value);
				return;
			}
			if ((value instanceof laya.utils.Color )){
				this._color=value;
				return;
			}
		}
	}

	__proto.reset=function(){
		this._color=Color.create("black");
	}

	__proto.equal=function(value){
		if ((typeof value=='string'))return this._color.strColor===value;
		if ((value instanceof laya.utils.Color ))return this._color.numColor===(value).numColor;
		return false;
	}

	__proto.toColorStr=function(){
		return this._color.strColor;
	}

	DrawStyle.create=function(value){
		if (value){
			var color;
			if ((typeof value=='string'))color=Color.create(value);
			else if ((value instanceof laya.utils.Color ))color=value;
			if (color){
				return color._drawStyle || (color._drawStyle=new DrawStyle(value));
			}
		}
		return laya.webgl.canvas.DrawStyle.DEFAULT;
	}

	__static(DrawStyle,
	['DEFAULT',function(){return this.DEFAULT=new DrawStyle("#000000");}
	]);
	return DrawStyle;
})()


//class laya.webgl.canvas.Path
var Path=(function(){
	function Path(){
		this._x=0;
		this._y=0;
		//this._rect=null;
		//this.ib=null;
		//this.vb=null;
		this.dirty=false;
		//this.geomatrys=null;
		//this._curGeomatry=null;
		this.offset=0;
		this.count=0;
		this.geoStart=0;
		this.tempArray=[];
		this.closePath=false;
		this.geomatrys=[];
		var gl=WebGL.mainContext;
		this.ib=IndexBuffer2D.create(/*laya.webgl.WebGLContext.DYNAMIC_DRAW*/0x88E8);
		this.vb=VertexBuffer2D.create(5);
	}

	__class(Path,'laya.webgl.canvas.Path');
	var __proto=Path.prototype;
	__proto.addPoint=function(pointX,pointY){
		this.tempArray.push(pointX,pointY);
	}

	__proto.getEndPointX=function(){
		return this.tempArray[this.tempArray.length-2];
	}

	__proto.getEndPointY=function(){
		return this.tempArray[this.tempArray.length-1];
	}

	__proto.polygon=function(x,y,points,color,borderWidth,borderColor){
		var geo;
		this.geomatrys.push(this._curGeomatry=geo=new Polygon(x,y,points,color,borderWidth,borderColor));
		if (!color)geo.fill=false;
		if (borderColor==undefined)geo.borderWidth=0;
		return geo;
	}

	__proto.setGeomtry=function(shape){
		this.geomatrys.push(this._curGeomatry=shape);
	}

	__proto.drawLine=function(x,y,points,width,color){
		var geo;
		if (this.closePath){
			this.geomatrys.push(this._curGeomatry=geo=new LoopLine(x,y,points,width,color));
			}else {
			this.geomatrys.push(this._curGeomatry=geo=new Line(x,y,points,width,color));
		}
		geo.fill=false;
		return geo;
	}

	__proto.update=function(){
		var si=this.ib._byteLength;
		var len=this.geomatrys.length;
		this.offset=si;
		for (var i=this.geoStart;i < len;i++){
			this.geomatrys[i].getData(this.ib,this.vb,this.vb._byteLength / 20);
		}
		this.geoStart=len;
		this.count=(this.ib._byteLength-si)/ CONST3D2D.BYTES_PIDX;
	}

	__proto.reset=function(){
		this.vb.clear();
		this.ib.clear();
		this.offset=this.count=this.geoStart=0;
		this.geomatrys.length=0;
	}

	__proto.recover=function(){
		this._curGeomatry=null;
		this.vb.destory();
		this.vb=null;
		this.ib.destory();
		this.ib=null;
	}

	return Path;
})()


//class laya.webgl.canvas.save.SaveBase
var SaveBase=(function(){
	function SaveBase(){
		//this._valueName=null;
		//this._value=null;
		//this._dataObj=null;
		//this._newSubmit=false;
	}

	__class(SaveBase,'laya.webgl.canvas.save.SaveBase');
	var __proto=SaveBase.prototype;
	Laya.imps(__proto,{"laya.webgl.canvas.save.ISaveData":true})
	__proto.isSaveMark=function(){return false;}
	__proto.restore=function(context){
		this._dataObj[this._valueName]=this._value;
		SaveBase._cache[SaveBase._cache._length++]=this;
		this._newSubmit && (context._curSubmit=Submit.RENDERBASE,context._renderKey=0);
	}

	SaveBase._createArray=function(){
		var value=[];
		value._length=0;
		return value;
	}

	SaveBase._init=function(){
		var namemap=SaveBase._namemap={};
		namemap[0x1]="ALPHA";
		namemap[0x2]="fillStyle";
		namemap[0x8]="font";
		namemap[0x100]="lineWidth";
		namemap[0x200]="strokeStyle";
		namemap[0x2000]="_mergeID";
		namemap[0x400]=namemap[0x800]=namemap[0x1000]=[];
		namemap[0x4000]="textBaseline";
		namemap[0x8000]="textAlign";
		namemap[0x10000]="_nBlendType";
		namemap[0x100000]="shader";
		namemap[0x200000]="filters";
		return namemap;
	}

	SaveBase.save=function(context,type,dataObj,newSubmit){
		if ((context._saveMark._saveuse & type)!==type){
			context._saveMark._saveuse |=type;
			var cache=SaveBase._cache;
			var o=cache._length > 0 ? cache[--cache._length] :(new SaveBase());
			o._value=dataObj[o._valueName=SaveBase._namemap[type]];
			o._dataObj=dataObj;
			o._newSubmit=newSubmit;
			var _save=context._save;
			_save[_save._length++]=o;
		}
	}

	SaveBase._cache=laya.webgl.canvas.save.SaveBase._createArray();
	SaveBase._namemap=SaveBase._init();
	return SaveBase;
})()


//class laya.webgl.canvas.save.SaveClipRect
var SaveClipRect=(function(){
	function SaveClipRect(){
		//this._clipSaveRect=null;
		//this._submitScissor=null;
		this._clipRect=new Rectangle();
	}

	__class(SaveClipRect,'laya.webgl.canvas.save.SaveClipRect');
	var __proto=SaveClipRect.prototype;
	Laya.imps(__proto,{"laya.webgl.canvas.save.ISaveData":true})
	__proto.isSaveMark=function(){return false;}
	__proto.restore=function(context){
		context._clipRect=this._clipSaveRect;
		SaveClipRect._cache[SaveClipRect._cache._length++]=this;
		this._submitScissor.submitLength=context._submits._length-this._submitScissor.submitIndex;
		context._curSubmit=Submit.RENDERBASE;
		context._renderKey=0;
	}

	SaveClipRect.save=function(context,submitScissor){
		if ((context._saveMark._saveuse & /*laya.webgl.canvas.save.SaveBase.TYPE_CLIPRECT*/0x20000)==/*laya.webgl.canvas.save.SaveBase.TYPE_CLIPRECT*/0x20000)return;
		context._saveMark._saveuse |=/*laya.webgl.canvas.save.SaveBase.TYPE_CLIPRECT*/0x20000;
		var cache=SaveClipRect._cache;
		var o=cache._length > 0 ? cache[--cache._length] :(new SaveClipRect());
		o._clipSaveRect=context._clipRect;
		context._clipRect=o._clipRect.copyFrom(context._clipRect);
		o._submitScissor=submitScissor;
		var _save=context._save;
		_save[_save._length++]=o;
	}

	__static(SaveClipRect,
	['_cache',function(){return this._cache=SaveBase._createArray();}
	]);
	return SaveClipRect;
})()


//class laya.webgl.canvas.save.SaveClipRectStencil
var SaveClipRectStencil=(function(){
	function SaveClipRectStencil(){
		//this._clipSaveRect=null;
		//this._saveMatrix=null;
		this._contextX=0;
		this._contextY=0;
		//this._submitStencil=null;
		this._clipRect=new Rectangle();
		this._rect=new Rectangle();
		this._matrix=new Matrix();
	}

	__class(SaveClipRectStencil,'laya.webgl.canvas.save.SaveClipRectStencil');
	var __proto=SaveClipRectStencil.prototype;
	Laya.imps(__proto,{"laya.webgl.canvas.save.ISaveData":true})
	__proto.isSaveMark=function(){return false;}
	__proto.restore=function(context){
		SubmitStencil.restore(context,this._rect,this._saveMatrix,this._contextX,this._contextY);
		context._clipRect=this._clipSaveRect;
		context._curMat=this._saveMatrix;
		context._x=this._contextX;
		context._y=this._contextY;
		SaveClipRectStencil._cache[SaveClipRectStencil._cache._length++]=this;
		context._curSubmit=Submit.RENDERBASE;
	}

	SaveClipRectStencil.save=function(context,submitStencil,x,y,width,height,clipX,clipY,clipWidth,clipHeight){
		if ((context._saveMark._saveuse & /*laya.webgl.canvas.save.SaveBase.TYPE_CLIPRECT_STENCIL*/0x40000)==/*laya.webgl.canvas.save.SaveBase.TYPE_CLIPRECT_STENCIL*/0x40000)return;
		context._saveMark._saveuse |=/*laya.webgl.canvas.save.SaveBase.TYPE_CLIPRECT_STENCIL*/0x40000;
		var cache=SaveClipRectStencil._cache;
		var o=cache._length > 0 ? cache[--cache._length] :(new SaveClipRectStencil());
		o._clipSaveRect=context._clipRect;
		o._clipRect.setTo(clipX,clipY,clipWidth,clipHeight);
		context._clipRect=o._clipRect;
		o._rect.x=x;
		o._rect.y=y;
		o._rect.width=width;
		o._rect.height=height;
		o._contextX=context._x;
		o._contextY=context._y;
		o._saveMatrix=context._curMat;
		context._curMat.copyTo(o._matrix);
		context._curMat=o._matrix;
		o._submitStencil=submitStencil;
		var _save=context._save;
		_save[_save._length++]=o;
	}

	__static(SaveClipRectStencil,
	['_cache',function(){return this._cache=SaveBase._createArray();}
	]);
	return SaveClipRectStencil;
})()


//class laya.webgl.canvas.save.SaveMark
var SaveMark=(function(){
	function SaveMark(){
		this._saveuse=0;
		//this._preSaveMark=null;
		;
	}

	__class(SaveMark,'laya.webgl.canvas.save.SaveMark');
	var __proto=SaveMark.prototype;
	Laya.imps(__proto,{"laya.webgl.canvas.save.ISaveData":true})
	__proto.isSaveMark=function(){
		return true;
	}

	__proto.restore=function(context){
		context._saveMark=this._preSaveMark;
		SaveMark._no[SaveMark._no._length++]=this;
	}

	SaveMark.Create=function(context){
		var no=SaveMark._no;
		var o=no._length > 0 ? no[--no._length] :(new SaveMark());
		o._saveuse=0;
		o._preSaveMark=context._saveMark;
		context._saveMark=o;
		return o;
	}

	__static(SaveMark,
	['_no',function(){return this._no=SaveBase._createArray();}
	]);
	return SaveMark;
})()


//class laya.webgl.canvas.save.SaveTransform
var SaveTransform=(function(){
	function SaveTransform(){
		//this._savematrix=null;
		this._matrix=new Matrix();
	}

	__class(SaveTransform,'laya.webgl.canvas.save.SaveTransform');
	var __proto=SaveTransform.prototype;
	Laya.imps(__proto,{"laya.webgl.canvas.save.ISaveData":true})
	__proto.isSaveMark=function(){return false;}
	__proto.restore=function(context){
		context._curMat=this._savematrix;
		SaveTransform._no[SaveTransform._no._length++]=this;
	}

	SaveTransform.save=function(context){
		var _saveMark=context._saveMark;
		if ((_saveMark._saveuse & /*laya.webgl.canvas.save.SaveBase.TYPE_TRANSFORM*/0x800)===/*laya.webgl.canvas.save.SaveBase.TYPE_TRANSFORM*/0x800)return;
		_saveMark._saveuse |=/*laya.webgl.canvas.save.SaveBase.TYPE_TRANSFORM*/0x800;
		var no=SaveTransform._no;
		var o=no._length > 0 ? no[--no._length] :(new SaveTransform());
		o._savematrix=context._curMat;
		context._curMat=context._curMat.copyTo(o._matrix);
		var _save=context._save;
		_save[_save._length++]=o;
	}

	__static(SaveTransform,
	['_no',function(){return this._no=SaveBase._createArray();}
	]);
	return SaveTransform;
})()


//class laya.webgl.canvas.save.SaveTranslate
var SaveTranslate=(function(){
	function SaveTranslate(){
		//this._x=NaN;
		//this._y=NaN;
	}

	__class(SaveTranslate,'laya.webgl.canvas.save.SaveTranslate');
	var __proto=SaveTranslate.prototype;
	Laya.imps(__proto,{"laya.webgl.canvas.save.ISaveData":true})
	__proto.isSaveMark=function(){return false;}
	__proto.restore=function(context){
		var mat=context._curMat;
		context._x=this._x;
		context._y=this._y;
		SaveTranslate._no[SaveTranslate._no._length++]=this;
	}

	SaveTranslate.save=function(context){
		var no=SaveTranslate._no;
		var o=no._length > 0 ? no[--no._length] :(new SaveTranslate());
		o._x=context._x;
		o._y=context._y;
		var _save=context._save;
		_save[_save._length++]=o;
	}

	__static(SaveTranslate,
	['_no',function(){return this._no=SaveBase._createArray();}
	]);
	return SaveTranslate;
})()


//class laya.webgl.resource.RenderTargetMAX
var RenderTargetMAX=(function(){
	function RenderTargetMAX(){
		//public var targets:Vector.<OneTarget>;//没用到
		this.target=null;
		this.repaint=false;
		this._width=NaN;
		this._height=NaN;
		this._sp=null;
		this._clipRect=new Rectangle();
	}

	__class(RenderTargetMAX,'laya.webgl.resource.RenderTargetMAX');
	var __proto=RenderTargetMAX.prototype;
	__proto.setSP=function(sp){
		this._sp=sp;
	}

	__proto.size=function(w,h){
		var _$this=this;
		if (this._width===w && this._height===h){
			this.target.size(w,h);
			return;
		}
		this.repaint=true;
		this._width=w;
		this._height=h;
		if (!this.target)
			this.target=RenderTarget2D.create(w,h);
		else
		this.target.size(w,h);
		if (!this.target.hasListener(/*laya.events.Event.RECOVERED*/"recovered")){
			this.target.on(/*laya.events.Event.RECOVERED*/"recovered",this,function(e){
				Laya.timer.callLater(_$this._sp,_$this._sp.repaint);
			});
		}
	}

	__proto._flushToTarget=function(context,target){
		if (target._destroy)return;
		var worldScissorTest=RenderState2D.worldScissorTest;
		var preworldClipRect=RenderState2D.worldClipRect;
		RenderState2D.worldClipRect=this._clipRect;
		this._clipRect.x=this._clipRect.y=0;
		this._clipRect.width=this._width;
		this._clipRect.height=this._height;
		RenderState2D.worldScissorTest=false;
		WebGL.mainContext.disable(/*laya.webgl.WebGLContext.SCISSOR_TEST*/0x0C11);
		var preAlpha=RenderState2D.worldAlpha;
		var preMatrix4=RenderState2D.worldMatrix4;
		var preMatrix=RenderState2D.worldMatrix;
		var preFilters=RenderState2D.worldFilters;
		var preShaderDefines=RenderState2D.worldShaderDefines;
		RenderState2D.worldMatrix=Matrix.EMPTY;
		RenderState2D.restoreTempArray();
		RenderState2D.worldMatrix4=RenderState2D.TEMPMAT4_ARRAY;
		RenderState2D.worldAlpha=1;
		RenderState2D.worldFilters=null;
		RenderState2D.worldShaderDefines=null;
		BaseShader.activeShader=null;
		target.start();
		Config.showCanvasMark ? target.clear(0,1,0,0.3):target.clear(0,0,0,0);
		context.flush();
		target.end();
		BaseShader.activeShader=null;
		RenderState2D.worldAlpha=preAlpha;
		RenderState2D.worldMatrix4=preMatrix4;
		RenderState2D.worldMatrix=preMatrix;
		RenderState2D.worldFilters=preFilters;
		RenderState2D.worldShaderDefines=preShaderDefines;
		RenderState2D.worldScissorTest=worldScissorTest
		if (worldScissorTest){
			var y=RenderState2D.height-preworldClipRect.y-preworldClipRect.height;
			WebGL.mainContext.scissor(preworldClipRect.x,y,preworldClipRect.width,preworldClipRect.height);
			WebGL.mainContext.enable(/*laya.webgl.WebGLContext.SCISSOR_TEST*/0x0C11);
		}
		RenderState2D.worldClipRect=preworldClipRect;
	}

	__proto.flush=function(context){
		if (this.repaint){
			this._flushToTarget(context,this.target);
			this.repaint=false;
		}
	}

	__proto.drawTo=function(context,x,y,width,height){
		context.drawTexture(this.target.getTexture(),x,y,width,height,0,0);
	}

	__proto.destroy=function(){
		if (this.target){
			this.target.destroy();
			this.target=null;
			this._sp=null;
		}
	}

	return RenderTargetMAX;
})()


//class laya.webgl.shader.d2.Shader2D
var Shader2D=(function(){
	function Shader2D(){
		this.ALPHA=1;
		//this.glTexture=null;
		//this.shader=null;
		//this.filters=null;
		this.shaderType=0;
		//this.colorAdd=null;
		//this.strokeStyle=null;
		//this.fillStyle=null;
		this.defines=new ShaderDefines2D();
	}

	__class(Shader2D,'laya.webgl.shader.d2.Shader2D');
	var __proto=Shader2D.prototype;
	__proto.destroy=function(){
		this.defines=null;
		this.filters=null;
		this.glTexture=null;
		this.strokeStyle=null;
		this.fillStyle=null;
	}

	Shader2D.__init__=function(){
		Shader.addInclude("parts/ColorFilter_ps_uniform.glsl","uniform vec4 colorAlpha;\nuniform mat4 colorMat;");
		Shader.addInclude("parts/ColorFilter_ps_logic.glsl","mat4 alphaMat =colorMat;\n\nalphaMat[0][3] *= gl_FragColor.a;\nalphaMat[1][3] *= gl_FragColor.a;\nalphaMat[2][3] *= gl_FragColor.a;\n\ngl_FragColor = gl_FragColor * alphaMat;\ngl_FragColor += colorAlpha/255.0*gl_FragColor.a;\n");
		Shader.addInclude("parts/GlowFilter_ps_uniform.glsl","uniform vec4 u_color;\nuniform float u_strength;\nuniform float u_blurX;\nuniform float u_blurY;\nuniform float u_offsetX;\nuniform float u_offsetY;\nuniform float u_textW;\nuniform float u_textH;");
		Shader.addInclude("parts/GlowFilter_ps_logic.glsl","const float c_IterationTime = 10.0;\nfloat floatIterationTotalTime = c_IterationTime * c_IterationTime;\nvec4 vec4Color = vec4(0.0,0.0,0.0,0.0);\nvec2 vec2FilterDir = vec2(-(u_offsetX)/u_textW,-(u_offsetY)/u_textH);\nvec2 vec2FilterOff = vec2(u_blurX/u_textW/c_IterationTime * 2.0,u_blurY/u_textH/c_IterationTime * 2.0);\nfloat maxNum = u_blurX * u_blurY;\nvec2 vec2Off = vec2(0.0,0.0);\nfloat floatOff = c_IterationTime/2.0;\nfor(float i = 0.0;i<=c_IterationTime; ++i){\n	for(float j = 0.0;j<=c_IterationTime; ++j){\n		vec2Off = vec2(vec2FilterOff.x * (i - floatOff),vec2FilterOff.y * (j - floatOff));\n		vec4Color += texture2D(texture, v_texcoord + vec2FilterDir + vec2Off)/floatIterationTotalTime;\n	}\n}\ngl_FragColor = vec4(u_color.rgb,vec4Color.a * u_strength);\ngl_FragColor.rgb *= gl_FragColor.a;");
		Shader.addInclude("parts/BlurFilter_ps_logic.glsl","gl_FragColor =   blur();\ngl_FragColor.w*=alpha;");
		Shader.addInclude("parts/BlurFilter_ps_uniform.glsl","uniform vec4 strength_sig2_2sig2_gauss1;\nuniform vec2 blurInfo;\n\n#define PI 3.141593\n\n//float sigma=strength/3.0;//3σ以外影响很小。即当σ=1的时候，半径为3\n//float sig2 = sigma*sigma;\n//float _2sig2 = 2.0*sig2;\n//return 1.0/(2*PI*sig2)*exp(-(x*x+y*y)/_2sig2)\n//float gauss1 = 1.0/(2.0*PI*sig2);\n\nfloat getGaussian(float x, float y){\n    return strength_sig2_2sig2_gauss1.w*exp(-(x*x+y*y)/strength_sig2_2sig2_gauss1.z);\n}\n\nvec4 blur(){\n    const float blurw = 9.0;\n    vec4 vec4Color = vec4(0.0,0.0,0.0,0.0);\n    vec2 halfsz=vec2(blurw,blurw)/2.0/blurInfo;    \n    vec2 startpos=v_texcoord-halfsz;\n    vec2 ctexcoord = startpos;\n    vec2 step = 1.0/blurInfo;  //每个像素      \n    \n    for(float y = 0.0;y<=blurw; ++y){\n        ctexcoord.x=startpos.x;\n        for(float x = 0.0;x<=blurw; ++x){\n            //TODO 纹理坐标的固定偏移应该在vs中处理\n            vec4Color += texture2D(texture, ctexcoord)*getGaussian(x-blurw/2.0,y-blurw/2.0);\n            ctexcoord.x+=step.x;\n        }\n        ctexcoord.y+=step.y;\n    }\n    return vec4Color;\n}");
		Shader.addInclude("parts/ColorAdd_ps_uniform.glsl","uniform vec4 colorAdd;\n");
		Shader.addInclude("parts/ColorAdd_ps_logic.glsl","gl_FragColor = vec4(colorAdd.rgb,colorAdd.a*gl_FragColor.a);\ngl_FragColor.xyz *= colorAdd.a;");
		var vs,ps;
		vs="attribute vec4 position;\nattribute vec2 texcoord;\nuniform vec2 size;\n\n#ifdef WORLDMAT\nuniform mat4 mmat;\n#endif\nvarying vec2 v_texcoord;\nvoid main() {\n  #ifdef WORLDMAT\n  vec4 pos=mmat*position;\n  gl_Position =vec4((pos.x/size.x-0.5)*2.0,(0.5-pos.y/size.y)*2.0,pos.z,1.0);\n  #else\n  gl_Position =vec4((position.x/size.x-0.5)*2.0,(0.5-position.y/size.y)*2.0,position.z,1.0);\n  #endif\n  \n  v_texcoord = texcoord;\n}";
		ps="precision mediump float;\n//precision highp float;\nvarying vec2 v_texcoord;\nuniform sampler2D texture;\nuniform float alpha;\n#include?BLUR_FILTER  \"parts/BlurFilter_ps_uniform.glsl\";\n#include?COLOR_FILTER \"parts/ColorFilter_ps_uniform.glsl\";\n#include?GLOW_FILTER \"parts/GlowFilter_ps_uniform.glsl\";\n#include?COLOR_ADD \"parts/ColorAdd_ps_uniform.glsl\";\n\nvoid main() {\n   vec4 color= texture2D(texture, v_texcoord);\n   color.a*=alpha;\n   color.rgb*=alpha;\n   gl_FragColor=color;\n   #include?COLOR_ADD \"parts/ColorAdd_ps_logic.glsl\";   \n   #include?BLUR_FILTER  \"parts/BlurFilter_ps_logic.glsl\";\n   #include?COLOR_FILTER \"parts/ColorFilter_ps_logic.glsl\";\n   #include?GLOW_FILTER \"parts/GlowFilter_ps_logic.glsl\";\n}";
		Shader.preCompile2D(0,/*laya.webgl.shader.d2.ShaderDefines2D.TEXTURE2D*/0x01,vs,ps,null);
		vs="attribute vec4 position;\nuniform vec2 size;\nuniform mat4 mmat;\nvoid main() {\n  vec4 pos=mmat*position;\n  gl_Position =vec4((pos.x/size.x-0.5)*2.0,(0.5-pos.y/size.y)*2.0,pos.z,1.0);\n}";
		ps="precision mediump float;\nuniform vec4 color;\nuniform float alpha;\n#include?COLOR_FILTER \"parts/ColorFilter_ps_uniform.glsl\";\nvoid main() {\n	vec4 a = vec4(color.r, color.g, color.b, color.a);\n	a.w = alpha;\n	a.xyz *= alpha;\n	gl_FragColor = a;\n	#include?COLOR_FILTER \"parts/ColorFilter_ps_logic.glsl\";\n}";
		Shader.preCompile2D(0,/*laya.webgl.shader.d2.ShaderDefines2D.COLOR2D*/0x02,vs,ps,null);
		vs="attribute vec4 position;\nattribute vec3 a_color;\nuniform mat4 mmat;\nuniform mat4 u_mmat2;\nuniform vec2 u_pos;\nuniform vec2 size;\nvarying vec3 color;\nvoid main(){\n  vec4 tPos = vec4(position.x + u_pos.x,position.y + u_pos.y,position.z,position.w);\n  vec4 pos=mmat*u_mmat2*tPos;\n  gl_Position =vec4((pos.x/size.x-0.5)*2.0,(0.5-pos.y/size.y)*2.0,pos.z,1.0);\n  color=a_color;\n}";
		ps="precision mediump float;\n//precision mediump float;\nvarying vec3 color;\nuniform float alpha;\nvoid main(){\n	//vec4 a=vec4(color.r, color.g, color.b, 1);\n	//a.a*=alpha;\n    gl_FragColor=vec4(color.r, color.g, color.b, alpha);\n	gl_FragColor.rgb*=alpha;\n}";
		Shader.preCompile2D(0,/*laya.webgl.shader.d2.ShaderDefines2D.PRIMITIVE*/0x04,vs,ps,null);
		vs="attribute vec4 position;\nattribute vec2 texcoord;\nuniform vec2 size;\n\n#ifdef WORLDMAT\nuniform mat4 mmat;\n#endif\nvarying vec2 v_texcoord;\nvoid main() {\n  #ifdef WORLDMAT\n  vec4 pos=mmat*position;\n  gl_Position =vec4((pos.x/size.x-0.5)*2.0,(0.5-pos.y/size.y)*2.0,pos.z,1.0);\n  #else\n  gl_Position =vec4((position.x/size.x-0.5)*2.0,(0.5-position.y/size.y)*2.0,position.z,1.0);\n  #endif\n  \n  v_texcoord = texcoord;\n}";
		ps="#ifdef FSHIGHPRECISION\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n//precision highp float;\nvarying vec2 v_texcoord;\nuniform sampler2D texture;\nuniform float alpha;\nuniform vec4 u_TexRange;\nuniform vec2 u_offset;\n#include?BLUR_FILTER  \"parts/BlurFilter_ps_uniform.glsl\";\n#include?COLOR_FILTER \"parts/ColorFilter_ps_uniform.glsl\";\n#include?GLOW_FILTER \"parts/GlowFilter_ps_uniform.glsl\";\n#include?COLOR_ADD \"parts/ColorAdd_ps_uniform.glsl\";\n\nvoid main() {\n   vec2 newTexCoord;\n   newTexCoord.x = mod(u_offset.x + v_texcoord.x,u_TexRange.y) + u_TexRange.x;\n   newTexCoord.y = mod(u_offset.y + v_texcoord.y,u_TexRange.w) + u_TexRange.z;\n   vec4 color= texture2D(texture, newTexCoord);\n   color.a*=alpha;\n   gl_FragColor=color;\n   #include?COLOR_ADD \"parts/ColorAdd_ps_logic.glsl\";   \n   #include?BLUR_FILTER  \"parts/BlurFilter_ps_logic.glsl\";\n   #include?COLOR_FILTER \"parts/ColorFilter_ps_logic.glsl\";\n   #include?GLOW_FILTER \"parts/GlowFilter_ps_logic.glsl\";\n}";
		Shader.preCompile2D(0,/*laya.webgl.shader.d2.ShaderDefines2D.FILLTEXTURE*/0x100,vs,ps,null);
		vs="attribute vec2 position;\nattribute vec2 texcoord;\nattribute vec4 color;\nuniform vec2 size;\nuniform float offsetX;\nuniform float offsetY;\nuniform mat4 mmat;\nuniform mat4 u_mmat2;\nvarying vec2 v_texcoord;\nvarying vec4 v_color;\nvoid main() {\n  vec4 pos=mmat*u_mmat2*vec4(offsetX+position.x,offsetY+position.y,0,1 );\n  gl_Position = vec4((pos.x/size.x-0.5)*2.0,(0.5-pos.y/size.y)*2.0,pos.z,1.0);\n  v_color = color;\n  v_color.rgb *= v_color.a;\n  v_texcoord = texcoord;  \n}";
		ps="precision mediump float;\nvarying vec2 v_texcoord;\nvarying vec4 v_color;\nuniform sampler2D texture;\nuniform float alpha;\nvoid main() {\n	vec4 t_color = texture2D(texture, v_texcoord);\n	gl_FragColor = t_color.rgba * v_color;\n	gl_FragColor *= alpha;\n}";
		Shader.preCompile2D(0,/*laya.webgl.shader.d2.ShaderDefines2D.SKINMESH*/0x200,vs,ps,null);
	}

	return Shader2D;
})()


//class laya.webgl.shader.ShaderDefines
var ShaderDefines=(function(){
	function ShaderDefines(name2int,int2name,int2nameMap){
		this._value=0;
		//this._name2int=null;
		//this._int2name=null;
		//this._int2nameMap=null;
		this._name2int=name2int;
		this._int2name=int2name;
		this._int2nameMap=int2nameMap;
	}

	__class(ShaderDefines,'laya.webgl.shader.ShaderDefines');
	var __proto=ShaderDefines.prototype;
	__proto.add=function(value){
		if ((typeof value=='string'))value=this._name2int[value];
		this._value |=value;
		return this._value;
	}

	__proto.addInt=function(value){
		this._value |=value;
		return this._value;
	}

	__proto.remove=function(value){
		if ((typeof value=='string'))value=this._name2int[value];
		this._value &=(~value);
		return this._value;
	}

	__proto.isDefine=function(def){
		return (this._value & def)===def;
	}

	__proto.getValue=function(){
		return this._value;
	}

	__proto.setValue=function(value){
		this._value=value;
	}

	__proto.toNameDic=function(){
		var r=this._int2nameMap[this._value];
		return r ? r :ShaderDefines._toText(this._value,this._int2name,this._int2nameMap);
	}

	ShaderDefines._reg=function(name,value,_name2int,_int2name){
		_name2int[name]=value;
		_int2name[value]=name;
	}

	ShaderDefines._toText=function(value,_int2name,_int2nameMap){
		var r=_int2nameMap[value];
		if (r)return r;
		var o={};
		var d=1;
		for (var i=0;i < 32;i++){
			d=1 << i;
			if (d > value)break ;
			if (value & d){
				var name=_int2name[d];
				name && (o[name]="");
			}
		}
		_int2nameMap[value]=o;
		return o;
	}

	ShaderDefines._toInt=function(names,_name2int){
		var words=names.split('.');
		var num=0;
		for (var i=0,n=words.length;i < n;i++){
			var value=_name2int[words[i]];
			if (!value)throw new Error("Defines to int err:"+names+"/"+words[i]);
			num |=value;
		}
		return num;
	}

	return ShaderDefines;
})()


/**
*这里销毁的问题，后面待确认
*/
//class laya.webgl.shader.d2.skinAnishader.SkinMesh
var SkinMesh=(function(){
	function SkinMesh(){
		this.mVBBuffer=null;
		this.mIBBuffer=null;
		this.mVBData=null;
		this.mIBData=null;
		this.mEleNum=0;
		this.mTexture=null;
		this.transform=null;
		this._vs=null;
		this._ps=null;
		this._indexStart=-1;
		this._verticles=null;
		this._uvs=null;
		this._tempMatrix=new Matrix();
	}

	__class(SkinMesh,'laya.webgl.shader.d2.skinAnishader.SkinMesh');
	var __proto=SkinMesh.prototype;
	__proto.init=function(texture,vs,ps){
		if (vs){
			this._vs=vs;
			}else {
			this._vs=[];
			var tWidth=texture.width;
			var tHeight=texture.height;
			var tRed=1;
			var tGreed=1;
			var tBlue=1;
			var tAlpha=1;
			this._vs.push(0,0,0,0,tRed,tGreed,tBlue,tAlpha);
			this._vs.push(tWidth,0,1,0,tRed,tGreed,tBlue,tAlpha);
			this._vs.push(tWidth,tHeight,1,1,tRed,tGreed,tBlue,tAlpha);
			this._vs.push(0,tHeight,0,1,tRed,tGreed,tBlue,tAlpha);
		}
		if (ps){
			this._ps=ps;
			}else {
			if (!SkinMesh._defaultPS){
				SkinMesh._defaultPS=[];
				SkinMesh._defaultPS.push(0,1,3,3,1,2);
			}
			this._ps=SkinMesh._defaultPS;
		}
		this.mVBData=new Float32Array(this._vs);
		this.mIBData=new Uint16Array(this._ps.length);
		this.mIBData["start"]=-1;
		this.mEleNum=this._ps.length;
		this.mTexture=texture;
	}

	__proto.init2=function(texture,vs,ps,verticles,uvs){
		if (this.transform)this.transform=null;
		if (ps){
			this._ps=ps;
			}else {
			this._ps=[];
			this._ps.push(0,1,3,3,1,2);
		}
		this._verticles=verticles;
		this._uvs=uvs;
		this.mEleNum=this._ps.length;
		this.mTexture=texture;
		if (Render.isConchNode || Render.isConchApp){
			this._initMyData();
			this.mVBData=new Float32Array(this._vs);
		}
	}

	__proto._initMyData=function(){
		var vsI=0;
		var vI=0;
		var vLen=this._verticles.length;
		var tempVLen=vLen *4;
		this._vs=SkinMesh._tempVS;
		var insertNew=false;
		if (Render.isConchNode || Render.isConchApp){
			this._vs.length=tempVLen;
			insertNew=true;
			}else{
			if (this._vs.length < tempVLen){
				this._vs.length=tempVLen;
				insertNew=true;
			}
		}
		SkinMesh._tVSLen=tempVLen;
		if (insertNew){
			while (vsI < tempVLen){
				this._vs[vsI]=this._verticles[vI];
				this._vs[vsI+1]=this._verticles[vI+1];
				this._vs[vsI+2]=this._uvs[vI];
				this._vs[vsI+3]=this._uvs[vI+1];
				this._vs[vsI+4]=1;
				this._vs[vsI+5]=1;
				this._vs[vsI+6]=1;
				this._vs[vsI+7]=1;
				vsI+=8;
				vI+=2;
			}
			}else{
			while (vsI < tempVLen){
				this._vs[vsI]=this._verticles[vI];
				this._vs[vsI+1]=this._verticles[vI+1];
				this._vs[vsI+2]=this._uvs[vI];
				this._vs[vsI+3]=this._uvs[vI+1];
				vsI+=8;
				vI+=2;
			}
		}
	}

	__proto.getData2=function(vb,ib,start){
		this.mVBBuffer=vb;
		this.mIBBuffer=ib;
		this._initMyData();
		vb.appendEx2(this._vs,Float32Array,SkinMesh._tVSLen,4);
		this._indexStart=ib._byteLength;
		var tIB;
		tIB=SkinMesh._tempIB;
		if (tIB.length < this._ps.length){
			tIB.length=this._ps.length;
		}
		for (var i=0,n=this._ps.length;i < n;i++){
			tIB[i]=this._ps[i]+start;
		}
		ib.appendEx2(tIB,Uint16Array,this._ps.length,2);
	}

	__proto.getData=function(vb,ib,start){
		this.mVBBuffer=vb;
		this.mIBBuffer=ib;
		vb.append(this.mVBData);
		this._indexStart=ib._byteLength;
		if (this.mIBData["start"] !=start){
			for (var i=0,n=this._ps.length;i < n;i++){
				this.mIBData[i]=this._ps[i]+start;
			}
			this.mIBData["start"]=start;
		}
		ib.append(this.mIBData);
	}

	__proto.render=function(context,x,y){
		if (Render.isWebGL && this.mTexture){
			context._renderKey=0;
			context._shader2D.glTexture=null;
			SkinMeshBuffer.getInstance().addSkinMesh(this);
			var tempSubmit=Submit.createShape(context,this.mIBBuffer,this.mVBBuffer,this.mEleNum,this._indexStart,Value2D.create(/*laya.webgl.shader.d2.ShaderDefines2D.SKINMESH*/0x200,0));
			this.transform || (this.transform=Matrix.EMPTY);
			this.transform.translate(x,y);
			Matrix.mul(this.transform,context._curMat,this._tempMatrix);
			this.transform.translate(-x,-y);
			var tShaderValue=tempSubmit.shaderValue;
			var tArray=tShaderValue.u_mmat2||RenderState2D.getMatrArray();
			RenderState2D.mat2MatArray(this._tempMatrix,tArray);
			tShaderValue.textureHost=this.mTexture;
			tShaderValue.offsetX=0;
			tShaderValue.offsetY=0;
			tShaderValue.u_mmat2=tArray;
			tShaderValue.ALPHA=context._shader2D.ALPHA;
			context._submits[context._submits._length++]=tempSubmit;
		}
		else if (Render.isConchApp&&this.mTexture){
			this.transform || (this.transform=Matrix.EMPTY);
			context.setSkinMesh&&context.setSkinMesh(x,y,this._ps,this.mVBData,this.mEleNum,0,this.mTexture,this.transform);
		}
	}

	SkinMesh._tempVS=[];
	SkinMesh._tempIB=[];
	SkinMesh._defaultPS=null;
	SkinMesh._tVSLen=0;
	return SkinMesh;
})()


//class laya.webgl.shader.d2.skinAnishader.SkinMeshBuffer
var SkinMeshBuffer=(function(){
	function SkinMeshBuffer(){
		this.ib=null;
		this.vb=null;
		var gl=WebGL.mainContext;
		this.ib=IndexBuffer2D.create(/*laya.webgl.WebGLContext.DYNAMIC_DRAW*/0x88E8);
		this.vb=VertexBuffer2D.create(8);
	}

	__class(SkinMeshBuffer,'laya.webgl.shader.d2.skinAnishader.SkinMeshBuffer');
	var __proto=SkinMeshBuffer.prototype;
	__proto.addSkinMesh=function(skinMesh){
		skinMesh.getData2(this.vb,this.ib,this.vb._byteLength / 32);
	}

	__proto.reset=function(){
		this.vb.clear();
		this.ib.clear();
	}

	SkinMeshBuffer.getInstance=function(){
		return SkinMeshBuffer.instance=SkinMeshBuffer.instance|| new SkinMeshBuffer();
	}

	SkinMeshBuffer.instance=null;
	return SkinMeshBuffer;
})()


//此类可以减少代码
//class laya.webgl.shapes.BasePoly
var BasePoly=(function(){
	function BasePoly(x,y,width,height,edges,color,borderWidth,borderColor,round){
		//this.x=NaN;
		//this.y=NaN;
		//this.r=NaN;
		//this.width=NaN;
		//this.height=NaN;
		//this.edges=NaN;
		this.r0=0
		//this.color=0;
		//this.borderColor=NaN;
		//this.borderWidth=NaN;
		//this.round=0;
		this.fill=true;
		//this.mUint16Array=null;
		//this.mFloat32Array=null;
		this.r1=Math.PI / 2;
		(round===void 0)&& (round=0);
		this.x=x;
		this.y=y;
		this.width=width;
		this.height=height;
		this.edges=edges;
		this.color=color;
		this.borderWidth=borderWidth;
		this.borderColor=borderColor;
	}

	__class(BasePoly,'laya.webgl.shapes.BasePoly');
	var __proto=BasePoly.prototype;
	Laya.imps(__proto,{"laya.webgl.shapes.IShape":true})
	__proto.getData=function(ib,vb,start){}
	__proto.rebuild=function(points){}
	__proto.setMatrix=function(mat){}
	__proto.needUpdate=function(mat){
		return true;
	}

	__proto.sector=function(outVert,outIndex,start){
		var x=this.x,y=this.y,edges=this.edges,seg=(this.r1-this.r0)/ edges;
		var w=this.width,h=this.height,color=this.color;
		var r=((color >> 16)& 0x0000ff)/ 255,g=((color >> 8)& 0xff)/ 255,b=(color & 0x0000ff)/ 255;
		outVert.push(x,y,r,g,b);
		for (var i=0;i < edges+1;i++){
			outVert.push(x+Math.sin(seg *i+this.r0)*w,y+Math.cos(seg *i+this.r0)*h);
			outVert.push(r,g,b);
		}
		for (i=0;i < edges;i++){
			outIndex.push(start,start+i+1,start+i+2);
		}
	}

	//用于画线
	__proto.createLine2=function(p,indices,lineWidth,len,outVertex,indexCount){
		var points=p.concat();
		var result=outVertex;
		var color=this.borderColor;
		var r=((color >> 16)& 0x0000ff)/ 255,g=((color >> 8)& 0xff)/ 255,b=(color & 0x0000ff)/ 255;
		var length=points.length / 2;
		var iStart=len,w=lineWidth / 2;
		var px,py,p1x,p1y,p2x,p2y,p3x,p3y;
		var perpx,perpy,perp2x,perp2y,perp3x,perp3y;
		var a1,b1,c1,a2,b2,c2;
		var denom,pdist,dist;
		p1x=points[0];
		p1y=points[1];
		p2x=points[2];
		p2y=points[3];
		perpx=-(p1y-p2y);
		perpy=p1x-p2x;
		dist=Math.sqrt(perpx *perpx+perpy *perpy);
		perpx=perpx / dist *w;
		perpy=perpy / dist *w;
		result.push(p1x-perpx+this.x,p1y-perpy+this.y,r,g,b,p1x+perpx+this.x,p1y+perpy+this.y,r,g,b);
		for (var i=1;i < length-1;i++){
			p1x=points[(i-1)*2];
			p1y=points[(i-1)*2+1];
			p2x=points[(i)*2];
			p2y=points[(i)*2+1];
			p3x=points[(i+1)*2];
			p3y=points[(i+1)*2+1];
			perpx=-(p1y-p2y);
			perpy=p1x-p2x;
			dist=Math.sqrt(perpx *perpx+perpy *perpy);
			perpx=perpx / dist *w;
			perpy=perpy / dist *w;
			perp2x=-(p2y-p3y);
			perp2y=p2x-p3x;
			dist=Math.sqrt(perp2x *perp2x+perp2y *perp2y);
			perp2x=perp2x / dist *w;
			perp2y=perp2y / dist *w;
			a1=(-perpy+p1y)-(-perpy+p2y);
			b1=(-perpx+p2x)-(-perpx+p1x);
			c1=(-perpx+p1x)*(-perpy+p2y)-(-perpx+p2x)*(-perpy+p1y);
			a2=(-perp2y+p3y)-(-perp2y+p2y);
			b2=(-perp2x+p2x)-(-perp2x+p3x);
			c2=(-perp2x+p3x)*(-perp2y+p2y)-(-perp2x+p2x)*(-perp2y+p3y);
			denom=a1 *b2-a2 *b1;
			if (Math.abs(denom)< 0.1){
				denom+=10.1;
				result.push(p2x-perpx+this.x,p2y-perpy+this.y,r,g,b,p2x+perpx+this.x,p2y+perpy+this.y,r,g,b);
				continue ;
			}
			px=(b1 *c2-b2 *c1)/ denom;
			py=(a2 *c1-a1 *c2)/ denom;
			pdist=(px-p2x)*(px-p2x)+(py-p2y)+(py-p2y);
			result.push(px+this.x,py+this.y,r,g,b,p2x-(px-p2x)+this.x,p2y-(py-p2y)+this.y,r,g,b);
		}
		p1x=points[points.length-4];
		p1y=points[points.length-3];
		p2x=points[points.length-2];
		p2y=points[points.length-1];
		perpx=-(p1y-p2y);
		perpy=p1x-p2x;
		dist=Math.sqrt(perpx *perpx+perpy *perpy);
		perpx=perpx / dist *w;
		perpy=perpy / dist *w;
		result.push(p2x-perpx+this.x,p2y-perpy+this.y,r,g,b,p2x+perpx+this.x,p2y+perpy+this.y,r,g,b);
		var groupLen=indexCount;
		for (i=1;i < groupLen;i++){
			indices.push(iStart+(i-1)*2,iStart+(i-1)*2+1,iStart+i *2+1,iStart+i *2+1,iStart+i *2,iStart+(i-1)*2);
		}
		return result;
	}

	// /*,outVertex:Array,outIndex:Array*/
	__proto.createLine=function(p,indices,lineWidth,len){
		var points=p.concat();
		var result=p;
		var color=this.borderColor;
		var r=((color >> 16)& 0x0000ff)/ 255,g=((color >> 8)& 0xff)/ 255,b=(color & 0x0000ff)/ 255;
		points.splice(0,5);
		var length=points.length / 5;
		var iStart=len,w=lineWidth / 2;
		var px,py,p1x,p1y,p2x,p2y,p3x,p3y;
		var perpx,perpy,perp2x,perp2y,perp3x,perp3y;
		var a1,b1,c1,a2,b2,c2;
		var denom,pdist,dist;
		p1x=points[0];
		p1y=points[1];
		p2x=points[5];
		p2y=points[6];
		perpx=-(p1y-p2y);
		perpy=p1x-p2x;
		dist=Math.sqrt(perpx *perpx+perpy *perpy);
		perpx=perpx / dist *w;
		perpy=perpy / dist *w;
		result.push(p1x-perpx,p1y-perpy,r,g,b,p1x+perpx,p1y+perpy,r,g,b);
		for (var i=1;i < length-1;i++){
			p1x=points[(i-1)*5];
			p1y=points[(i-1)*5+1];
			p2x=points[(i)*5];
			p2y=points[(i)*5+1];
			p3x=points[(i+1)*5];
			p3y=points[(i+1)*5+1];
			perpx=-(p1y-p2y);
			perpy=p1x-p2x;
			dist=Math.sqrt(perpx *perpx+perpy *perpy);
			perpx=perpx / dist *w;
			perpy=perpy / dist *w;
			perp2x=-(p2y-p3y);
			perp2y=p2x-p3x;
			dist=Math.sqrt(perp2x *perp2x+perp2y *perp2y);
			perp2x=perp2x / dist *w;
			perp2y=perp2y / dist *w;
			a1=(-perpy+p1y)-(-perpy+p2y);
			b1=(-perpx+p2x)-(-perpx+p1x);
			c1=(-perpx+p1x)*(-perpy+p2y)-(-perpx+p2x)*(-perpy+p1y);
			a2=(-perp2y+p3y)-(-perp2y+p2y);
			b2=(-perp2x+p2x)-(-perp2x+p3x);
			c2=(-perp2x+p3x)*(-perp2y+p2y)-(-perp2x+p2x)*(-perp2y+p3y);
			denom=a1 *b2-a2 *b1;
			if (Math.abs(denom)< 0.1){
				denom+=10.1;
				result.push(p2x-perpx,p2y-perpy,r,g,b,p2x+perpx,p2y+perpy,r,g,b);
				continue ;
			}
			px=(b1 *c2-b2 *c1)/ denom;
			py=(a2 *c1-a1 *c2)/ denom;
			pdist=(px-p2x)*(px-p2x)+(py-p2y)+(py-p2y);
			result.push(px,py,r,g,b,p2x-(px-p2x),p2y-(py-p2y),r,g,b);
		}
		p1x=points[points.length-10];
		p1y=points[points.length-9];
		p2x=points[points.length-5];
		p2y=points[points.length-4];
		perpx=-(p1y-p2y);
		perpy=p1x-p2x;
		dist=Math.sqrt(perpx *perpx+perpy *perpy);
		perpx=perpx / dist *w;
		perpy=perpy / dist *w;
		result.push(p2x-perpx,p2y-perpy,r,g,b,p2x+perpx,p2y+perpy,r,g,b);
		var groupLen=this.edges+1;
		for (i=1;i < groupLen;i++){
			indices.push(iStart+(i-1)*2,iStart+(i-1)*2+1,iStart+i *2+1,iStart+i *2+1,iStart+i *2,iStart+(i-1)*2);
		}
		return result;
	}

	//闭合路径
	__proto.createLoopLine=function(p,indices,lineWidth,len,outVertex,outIndex){
		var points=p.concat();
		var result=outVertex ? outVertex :p;
		var color=this.borderColor;
		var r=((color >> 16)& 0x0000ff)/ 255,g=((color >> 8)& 0xff)/ 255,b=(color & 0x0000ff)/ 255;
		points.splice(0,5);
		var firstPoint=[points[0],points[1]];
		var lastPoint=[points[points.length-5],points[points.length-4]];
		var midPointX=lastPoint[0]+(firstPoint[0]-lastPoint[0])*0.5;
		var midPointY=lastPoint[1]+(firstPoint[1]-lastPoint[1])*0.5;
		points.unshift(midPointX,midPointY,0,0,0);
		points.push(midPointX,midPointY,0,0,0);
		var length=points.length / 5;
		var iStart=len,w=lineWidth / 2;
		var px,py,p1x,p1y,p2x,p2y,p3x,p3y;
		var perpx,perpy,perp2x,perp2y,perp3x,perp3y;
		var a1,b1,c1,a2,b2,c2;
		var denom,pdist,dist;
		p1x=points[0];
		p1y=points[1];
		p2x=points[5];
		p2y=points[6];
		perpx=-(p1y-p2y);
		perpy=p1x-p2x;
		dist=Math.sqrt(perpx *perpx+perpy *perpy);
		perpx=perpx / dist *w;
		perpy=perpy / dist *w;
		result.push(p1x-perpx,p1y-perpy,r,g,b,p1x+perpx,p1y+perpy,r,g,b);
		for (var i=1;i < length-1;i++){
			p1x=points[(i-1)*5];
			p1y=points[(i-1)*5+1];
			p2x=points[(i)*5];
			p2y=points[(i)*5+1];
			p3x=points[(i+1)*5];
			p3y=points[(i+1)*5+1];
			perpx=-(p1y-p2y);
			perpy=p1x-p2x;
			dist=Math.sqrt(perpx *perpx+perpy *perpy);
			perpx=perpx / dist *w;
			perpy=perpy / dist *w;
			perp2x=-(p2y-p3y);
			perp2y=p2x-p3x;
			dist=Math.sqrt(perp2x *perp2x+perp2y *perp2y);
			perp2x=perp2x / dist *w;
			perp2y=perp2y / dist *w;
			a1=(-perpy+p1y)-(-perpy+p2y);
			b1=(-perpx+p2x)-(-perpx+p1x);
			c1=(-perpx+p1x)*(-perpy+p2y)-(-perpx+p2x)*(-perpy+p1y);
			a2=(-perp2y+p3y)-(-perp2y+p2y);
			b2=(-perp2x+p2x)-(-perp2x+p3x);
			c2=(-perp2x+p3x)*(-perp2y+p2y)-(-perp2x+p2x)*(-perp2y+p3y);
			denom=a1 *b2-a2 *b1;
			if (Math.abs(denom)< 0.1){
				denom+=10.1;
				result.push(p2x-perpx,p2y-perpy,r,g,b,p2x+perpx,p2y+perpy,r,g,b);
				continue ;
			}
			px=(b1 *c2-b2 *c1)/ denom;
			py=(a2 *c1-a1 *c2)/ denom;
			pdist=(px-p2x)*(px-p2x)+(py-p2y)+(py-p2y);
			result.push(px,py,r,g,b,p2x-(px-p2x),p2y-(py-p2y),r,g,b);
		}
		if (outIndex){
			indices=outIndex;
		};
		var groupLen=this.edges+1;
		for (i=1;i < groupLen;i++){
			indices.push(iStart+(i-1)*2,iStart+(i-1)*2+1,iStart+i *2+1,iStart+i *2+1,iStart+i *2,iStart+(i-1)*2);
		}
		indices.push(iStart+(i-1)*2,iStart+(i-1)*2+1,iStart+1,iStart+1,iStart,iStart+(i-1)*2);
		return result;
	}

	return BasePoly;
})()


//class laya.webgl.shapes.Earcut
var Earcut=(function(){
	function Earcut(){}
	__class(Earcut,'laya.webgl.shapes.Earcut');
	Earcut.earcut=function(data,holeIndices,dim){
		dim=dim || 2;
		var hasHoles=holeIndices && holeIndices.length,
		outerLen=hasHoles ? holeIndices[0] *dim :data.length,
		outerNode=Earcut.linkedList(data,0,outerLen,dim,true),
		triangles=[];
		if (!outerNode)return triangles;
		var minX,minY,maxX,maxY,x,y,invSize;
		if (hasHoles)outerNode=Earcut.eliminateHoles(data,holeIndices,outerNode,dim);
		if (data.length > 80 *dim){
			minX=maxX=data[0];
			minY=maxY=data[1];
			for (var i=dim;i < outerLen;i+=dim){
				x=data[i];
				y=data[i+1];
				if (x < minX)minX=x;
				if (y < minY)minY=y;
				if (x > maxX)maxX=x;
				if (y > maxY)maxY=y;
			}
			invSize=Math.max(maxX-minX,maxY-minY);
			invSize=invSize!==0 ? 1 / invSize :0;
		}
		Earcut.earcutLinked(outerNode,triangles,dim,minX,minY,invSize);
		return triangles;
	}

	Earcut.linkedList=function(data,start,end,dim,clockwise){
		var i,last;
		if (clockwise===(Earcut.signedArea(data,start,end,dim)> 0)){
			for (i=start;i < end;i+=dim)last=Earcut.insertNode(i,data[i],data[i+1],last);
			}else {
			for (i=end-dim;i >=start;i-=dim)last=Earcut.insertNode(i,data[i],data[i+1],last);
		}
		if (last && Earcut.equals(last,last.next)){
			Earcut.removeNode(last);
			last=last.next;
		}
		return last;
	}

	Earcut.filterPoints=function(start,end){
		if (!start)return start;
		if (!end)end=start;
		var p=start,
		again;
		do {
			again=false;
			if (!p.steiner && (Earcut.equals(p,p.next)|| Earcut.area(p.prev,p,p.next)===0)){
				Earcut.removeNode(p);
				p=end=p.prev;
				if (p===p.next)break ;
				again=true;
				}else {
				p=p.next;
			}
		}while (again || p!==end);
		return end;
	}

	Earcut.earcutLinked=function(ear,triangles,dim,minX,minY,invSize,pass){
		if (!ear)return;
		if (!pass && invSize)Earcut.indexCurve(ear,minX,minY,invSize);
		var stop=ear,
		prev,next;
		while (ear.prev!==ear.next){
			prev=ear.prev;
			next=ear.next;
			if (invSize ? Earcut.isEarHashed(ear,minX,minY,invSize):Earcut.isEar(ear)){
				triangles.push(prev.i / dim);
				triangles.push(ear.i / dim);
				triangles.push(next.i / dim);
				Earcut.removeNode(ear);
				ear=next.next;
				stop=next.next;
				continue ;
			}
			ear=next;
			if (ear===stop){
				if (!pass){
					Earcut.earcutLinked(Earcut.filterPoints(ear,null),triangles,dim,minX,minY,invSize,1);
					}else if (pass===1){
					ear=Earcut.cureLocalIntersections(ear,triangles,dim);
					Earcut.earcutLinked(ear,triangles,dim,minX,minY,invSize,2);
					}else if (pass===2){
					Earcut.splitEarcut(ear,triangles,dim,minX,minY,invSize);
				}
				break ;
			}
		}
	}

	Earcut.isEar=function(ear){
		var a=ear.prev,
		b=ear,
		c=ear.next;
		if (Earcut.area(a,b,c)>=0)return false;
		var p=ear.next.next;
		while (p!==ear.prev){
			if (Earcut.pointInTriangle(a.x,a.y,b.x,b.y,c.x,c.y,p.x,p.y)&&
				Earcut.area(p.prev,p,p.next)>=0)return false;
			p=p.next;
		}
		return true;
	}

	Earcut.isEarHashed=function(ear,minX,minY,invSize){
		var a=ear.prev,
		b=ear,
		c=ear.next;
		if (Earcut.area(a,b,c)>=0)return false;
		var minTX=a.x < b.x ? (a.x < c.x ? a.x :c.x):(b.x < c.x ? b.x :c.x),
		minTY=a.y < b.y ? (a.y < c.y ? a.y :c.y):(b.y < c.y ? b.y :c.y),
		maxTX=a.x > b.x ? (a.x > c.x ? a.x :c.x):(b.x > c.x ? b.x :c.x),
		maxTY=a.y > b.y ? (a.y > c.y ? a.y :c.y):(b.y > c.y ? b.y :c.y);
		var minZ=Earcut.zOrder(minTX,minTY,minX,minY,invSize),
		maxZ=Earcut.zOrder(maxTX,maxTY,minX,minY,invSize);
		var p=ear.nextZ;
		while (p && p.z <=maxZ){
			if (p!==ear.prev && p!==ear.next &&
				Earcut.pointInTriangle(a.x,a.y,b.x,b.y,c.x,c.y,p.x,p.y)&&
			Earcut.area(p.prev,p,p.next)>=0)return false;
			p=p.nextZ;
		}
		p=ear.prevZ;
		while (p && p.z >=minZ){
			if (p!==ear.prev && p!==ear.next &&
				Earcut.pointInTriangle(a.x,a.y,b.x,b.y,c.x,c.y,p.x,p.y)&&
			Earcut.area(p.prev,p,p.next)>=0)return false;
			p=p.prevZ;
		}
		return true;
	}

	Earcut.cureLocalIntersections=function(start,triangles,dim){
		var p=start;
		do {
			var a=p.prev,
			b=p.next.next;
			if (!Earcut.equals(a,b)&& Earcut.intersects(a,p,p.next,b)&& Earcut.locallyInside(a,b)&& Earcut.locallyInside(b,a)){
				triangles.push(a.i / dim);
				triangles.push(p.i / dim);
				triangles.push(b.i / dim);
				Earcut.removeNode(p);
				Earcut.removeNode(p.next);
				p=start=b;
			}
			p=p.next;
		}while (p!==start);
		return p;
	}

	Earcut.splitEarcut=function(start,triangles,dim,minX,minY,invSize){
		var a=start;
		do {
			var b=a.next.next;
			while (b!==a.prev){
				if (a.i!==b.i && Earcut.isValidDiagonal(a,b)){
					var c=Earcut.splitPolygon(a,b);
					a=Earcut.filterPoints(a,a.next);
					c=Earcut.filterPoints(c,c.next);
					Earcut.earcutLinked(a,triangles,dim,minX,minY,invSize);
					Earcut.earcutLinked(c,triangles,dim,minX,minY,invSize);
					return;
				}
				b=b.next;
			}
			a=a.next;
		}while (a!==start);
	}

	Earcut.eliminateHoles=function(data,holeIndices,outerNode,dim){
		var queue=[],
		i,len,start,end,list;
		for (i=0,len=holeIndices.length;i < len;i++){
			start=holeIndices[i] *dim;
			end=i < len-1 ? holeIndices[i+1] *dim :data.length;
			list=Earcut.linkedList(data,start,end,dim,false);
			if (list===list.next)list.steiner=true;
			queue.push(Earcut.getLeftmost(list));
		}
		queue.sort(Earcut.compareX);
		for (i=0;i < queue.length;i++){
			Earcut.eliminateHole(queue[i],outerNode);
			outerNode=Earcut.filterPoints(outerNode,outerNode.next);
		}
		return outerNode;
	}

	Earcut.compareX=function(a,b){
		return a.x-b.x;
	}

	Earcut.eliminateHole=function(hole,outerNode){
		outerNode=Earcut.findHoleBridge(hole,outerNode);
		if (outerNode){
			var b=Earcut.splitPolygon(outerNode,hole);
			Earcut.filterPoints(b,b.next);
		}
	}

	Earcut.findHoleBridge=function(hole,outerNode){
		var p=outerNode,
		hx=hole.x,
		hy=hole.y,
		qx=-Infinity,
		m;
		do {
			if (hy <=p.y && hy >=p.next.y && p.next.y!==p.y){
				var x=p.x+(hy-p.y)*(p.next.x-p.x)/ (p.next.y-p.y);
				if (x <=hx && x > qx){
					qx=x;
					if (x===hx){
						if (hy===p.y)return p;
						if (hy===p.next.y)return p.next;
					}
					m=p.x < p.next.x ? p :p.next;
				}
			}
			p=p.next;
		}while (p!==outerNode);
		if (!m)return null;
		if (hx===qx)return m.prev;
		var stop=m,
		mx=m.x,
		my=m.y,
		tanMin=Infinity,
		tan;
		p=m.next;
		while (p!==stop){
			if (hx >=p.x && p.x >=mx && hx!==p.x &&
				Earcut.pointInTriangle(hy < my ? hx :qx,hy,mx,my,hy < my ? qx :hx,hy,p.x,p.y)){
				tan=Math.abs(hy-p.y)/ (hx-p.x);
				if ((tan < tanMin || (tan===tanMin && p.x > m.x))&& Earcut.locallyInside(p,hole)){
					m=p;
					tanMin=tan;
				}
			}
			p=p.next;
		}
		return m;
	}

	Earcut.indexCurve=function(start,minX,minY,invSize){
		var p=start;
		do {
			if (p.z===null)p.z=Earcut.zOrder(p.x,p.y,minX,minY,invSize);
			p.prevZ=p.prev;
			p.nextZ=p.next;
			p=p.next;
		}while (p!==start);
		p.prevZ.nextZ=null;
		p.prevZ=null;
		Earcut.sortLinked(p);
	}

	Earcut.sortLinked=function(list){
		var i,p,q,e,tail,numMerges,pSize,qSize,
		inSize=1;
		do {
			p=list;
			list=null;
			tail=null;
			numMerges=0;
			while (p){
				numMerges++;
				q=p;
				pSize=0;
				for (i=0;i < inSize;i++){
					pSize++;
					q=q.nextZ;
					if (!q)break ;
				}
				qSize=inSize;
				while (pSize > 0 || (qSize > 0 && q)){
					if (pSize!==0 && (qSize===0 || !q || p.z <=q.z)){
						e=p;
						p=p.nextZ;
						pSize--;
						}else {
						e=q;
						q=q.nextZ;
						qSize--;
					}
					if (tail)tail.nextZ=e;
					else list=e;
					e.prevZ=tail;
					tail=e;
				}
				p=q;
			}
			tail.nextZ=null;
			inSize *=2;
		}while (numMerges > 1);
		return list;
	}

	Earcut.zOrder=function(x,y,minX,minY,invSize){
		x=32767 *(x-minX)*invSize;
		y=32767 *(y-minY)*invSize;
		x=(x | (x << 8))& 0x00FF00FF;
		x=(x | (x << 4))& 0x0F0F0F0F;
		x=(x | (x << 2))& 0x33333333;
		x=(x | (x << 1))& 0x55555555;
		y=(y | (y << 8))& 0x00FF00FF;
		y=(y | (y << 4))& 0x0F0F0F0F;
		y=(y | (y << 2))& 0x33333333;
		y=(y | (y << 1))& 0x55555555;
		return x | (y << 1);
	}

	Earcut.getLeftmost=function(start){
		var p=start,
		leftmost=start;
		do {
			if (p.x < leftmost.x)leftmost=p;
			p=p.next;
		}while (p!==start);
		return leftmost;
	}

	Earcut.pointInTriangle=function(ax,ay,bx,by,cx,cy,px,py){
		return (cx-px)*(ay-py)-(ax-px)*(cy-py)>=0 &&
		(ax-px)*(by-py)-(bx-px)*(ay-py)>=0 &&
		(bx-px)*(cy-py)-(cx-px)*(by-py)>=0;
	}

	Earcut.isValidDiagonal=function(a,b){
		return a.next.i!==b.i && a.prev.i!==b.i && !Earcut.intersectsPolygon(a,b)&&
		Earcut.locallyInside(a,b)&& Earcut.locallyInside(b,a)&& Earcut.middleInside(a,b);
	}

	Earcut.area=function(p,q,r){
		return (q.y-p.y)*(r.x-q.x)-(q.x-p.x)*(r.y-q.y);
	}

	Earcut.equals=function(p1,p2){
		return p1.x===p2.x && p1.y===p2.y;
	}

	Earcut.intersects=function(p1,q1,p2,q2){
		if ((Earcut.equals(p1,q1)&& Earcut.equals(p2,q2))||
			(Earcut.equals(p1,q2)&& Earcut.equals(p2,q1)))return true;
		return Earcut.area(p1,q1,p2)> 0!==Earcut.area(p1,q1,q2)> 0 &&
		Earcut.area(p2,q2,p1)> 0!==Earcut.area(p2,q2,q1)> 0;
	}

	Earcut.intersectsPolygon=function(a,b){
		var p=a;
		do {
			if (p.i!==a.i && p.next.i!==a.i && p.i!==b.i && p.next.i!==b.i &&
				Earcut.intersects(p,p.next,a,b))return true;
			p=p.next;
		}while (p!==a);
		return false;
	}

	Earcut.locallyInside=function(a,b){
		return Earcut.area(a.prev,a,a.next)< 0 ?
		Earcut.area(a,b,a.next)>=0 && Earcut.area(a,a.prev,b)>=0 :
		Earcut.area(a,b,a.prev)< 0 || Earcut.area(a,a.next,b)< 0;
	}

	Earcut.middleInside=function(a,b){
		var p=a,
		inside=false,
		px=(a.x+b.x)/ 2,
		py=(a.y+b.y)/ 2;
		do {
			if (((p.y > py)!==(p.next.y > py))&& p.next.y!==p.y &&
				(px < (p.next.x-p.x)*(py-p.y)/ (p.next.y-p.y)+p.x))
			inside=!inside;
			p=p.next;
		}while (p!==a);
		return inside;
	}

	Earcut.splitPolygon=function(a,b){
		var a2=new EarcutNode(a.i,a.x,a.y),
		b2=new EarcutNode(b.i,b.x,b.y),
		an=a.next,
		bp=b.prev;
		a.next=b;
		b.prev=a;
		a2.next=an;
		an.prev=a2;
		b2.next=a2;
		a2.prev=b2;
		bp.next=b2;
		b2.prev=bp;
		return b2;
	}

	Earcut.insertNode=function(i,x,y,last){
		var p=new EarcutNode(i,x,y);
		if (!last){
			p.prev=p;
			p.next=p;
			}else {
			p.next=last.next;
			p.prev=last;
			last.next.prev=p;
			last.next=p;
		}
		return p;
	}

	Earcut.removeNode=function(p){
		p.next.prev=p.prev;
		p.prev.next=p.next;
		if (p.prevZ)p.prevZ.nextZ=p.nextZ;
		if (p.nextZ)p.nextZ.prevZ=p.prevZ;
	}

	Earcut.signedArea=function(data,start,end,dim){
		var sum=0;
		for (var i=start,j=end-dim;i < end;i+=dim){
			sum+=(data[j]-data[i])*(data[i+1]+data[j+1]);
			j=i;
		}
		return sum;
	}

	return Earcut;
})()


//class laya.webgl.shapes.EarcutNode
var EarcutNode=(function(){
	function EarcutNode(i,x,y){
		this.i=null;
		this.x=null;
		this.y=null;
		this.prev=null;
		this.next=null;
		this.z=null;
		this.prevZ=null;
		this.nextZ=null;
		this.steiner=null;
		this.i=i;
		this.x=x;
		this.y=y;
		this.prev=null;
		this.next=null;
		this.z=null;
		this.prevZ=null;
		this.nextZ=null;
		this.steiner=false;
	}

	__class(EarcutNode,'laya.webgl.shapes.EarcutNode');
	return EarcutNode;
})()


//class laya.webgl.shapes.GeometryData
var GeometryData=(function(){
	function GeometryData(lineWidth,lineColor,lineAlpha,fillColor,fillAlpha,fill,shape){
		//this.lineWidth=NaN;
		//this.lineColor=NaN;
		//this.lineAlpha=NaN;
		//this.fillColor=NaN;
		//this.fillAlpha=NaN;
		//this.shape=null;
		//this.fill=false;
		this.lineWidth=lineWidth;
		this.lineColor=lineColor;
		this.lineAlpha=lineAlpha;
		this.fillColor=fillColor;
		this.fillAlpha=fillAlpha;
		this.shape=shape;
		this.fill=fill;
	}

	__class(GeometryData,'laya.webgl.shapes.GeometryData');
	var __proto=GeometryData.prototype;
	__proto.clone=function(){
		return new GeometryData(this.lineWidth,this.lineColor,this.lineAlpha,this.fillColor,this.fillAlpha,this.fill,this.shape);
	}

	__proto.getIndexData=function(){
		return null;
	}

	__proto.getVertexData=function(){
		return null;
	}

	__proto.destroy=function(){
		this.shape=null;
	}

	return GeometryData;
})()


//class laya.webgl.shapes.Vertex
var Vertex=(function(){
	function Vertex(p){
		//this.points=null;
		if((p instanceof Float32Array))
			this.points=p;
		else if((p instanceof Array)){
			var len=p.length;
			this.points=new Float32Array(p);
		}
	}

	__class(Vertex,'laya.webgl.shapes.Vertex');
	var __proto=Vertex.prototype;
	Laya.imps(__proto,{"laya.webgl.shapes.IShape":true})
	__proto.getData=function(ib,vb,start){}
	__proto.needUpdate=function(mat){
		return false;
	}

	__proto.rebuild=function(points){}
	// TODO Auto Generated method stub
	__proto.setMatrix=function(mat){}
	return Vertex;
})()


//class laya.webgl.submit.Submit
var Submit=(function(){
	function Submit(renderType){
		//this._selfVb=null;
		//this._ib=null;
		//this._blendFn=null;
		//this._renderType=0;
		//this._vb=null;
		// 从VB中什么地方开始画，画到哪
		//this._startIdx=0;
		//this._numEle=0;
		//this.shaderValue=null;
		(renderType===void 0)&& (renderType=10000);
		this._renderType=renderType;
	}

	__class(Submit,'laya.webgl.submit.Submit');
	var __proto=Submit.prototype;
	Laya.imps(__proto,{"laya.webgl.submit.ISubmit":true})
	__proto.releaseRender=function(){
		var cache=Submit._cache;
		cache[cache._length++]=this;
		this.shaderValue.release();
		this._vb=null;
	}

	__proto.getRenderType=function(){
		return this._renderType;
	}

	__proto.renderSubmit=function(){
		if (this._numEle===0)return 1;
		var _tex=this.shaderValue.textureHost;
		if (_tex){
			var source=_tex.source;
			if (!_tex.bitmap || !source)
				return 1;
			this.shaderValue.texture=source;
		}
		this._vb.bind_upload(this._ib);
		var gl=WebGL.mainContext;
		this.shaderValue.upload();
		if (BlendMode.activeBlendFunction!==this._blendFn){
			gl.enable(/*laya.webgl.WebGLContext.BLEND*/0x0BE2);
			this._blendFn(gl);
			BlendMode.activeBlendFunction=this._blendFn;
		}
		Stat.drawCall++;
		Stat.trianglesFaces+=this._numEle / 3;
		gl.drawElements(/*laya.webgl.WebGLContext.TRIANGLES*/0x0004,this._numEle,/*laya.webgl.WebGLContext.UNSIGNED_SHORT*/0x1403,this._startIdx);
		return 1;
	}

	Submit.__init__=function(){
		var s=Submit.RENDERBASE=new Submit(-1);
		s.shaderValue=new Value2D(0,0);
		s.shaderValue.ALPHA=-1234;
	}

	Submit.createSubmit=function(context,ib,vb,pos,sv){
		var o=Submit._cache._length ? Submit._cache[--Submit._cache._length] :new Submit();
		if (vb==null){
			vb=o._selfVb || (o._selfVb=VertexBuffer2D.create(-1));
			vb.clear();
			pos=0;
		}
		o._ib=ib;
		o._vb=vb;
		o._startIdx=pos *CONST3D2D.BYTES_PIDX;
		o._numEle=0;
		var blendType=context._nBlendType;
		o._blendFn=context._targets ? BlendMode.targetFns[blendType] :BlendMode.fns[blendType];
		o.shaderValue=sv;
		o.shaderValue.setValue(context._shader2D);
		var filters=context._shader2D.filters;
		filters && o.shaderValue.setFilters(filters);
		return o;
	}

	Submit.createShape=function(ctx,ib,vb,numEle,offset,sv){
		var o=(!Submit._cache._length)? (new Submit()):Submit._cache[--Submit._cache._length];
		o._ib=ib;
		o._vb=vb;
		o._numEle=numEle;
		o._startIdx=offset;
		o.shaderValue=sv;
		o.shaderValue.setValue(ctx._shader2D);
		var blendType=ctx._nBlendType;
		o._blendFn=ctx._targets ? BlendMode.targetFns[blendType] :BlendMode.fns[blendType];
		return o;
	}

	Submit.TYPE_2D=10000;
	Submit.TYPE_CANVAS=10003;
	Submit.TYPE_CMDSETRT=10004;
	Submit.TYPE_CUSTOM=10005;
	Submit.TYPE_BLURRT=10006;
	Submit.TYPE_CMDDESTORYPRERT=10007;
	Submit.TYPE_DISABLESTENCIL=10008;
	Submit.TYPE_OTHERIBVB=10009;
	Submit.TYPE_PRIMITIVE=10010;
	Submit.TYPE_RT=10011;
	Submit.TYPE_BLUR_RT=10012;
	Submit.TYPE_TARGET=10013;
	Submit.TYPE_CHANGE_VALUE=10014;
	Submit.TYPE_SHAPE=10015;
	Submit.TYPE_TEXTURE=10016;
	Submit.TYPE_FILLTEXTURE=10017;
	Submit.RENDERBASE=null;
	Submit._cache=(Submit._cache=[],Submit._cache._length=0,Submit._cache);
	return Submit;
})()


//class laya.webgl.submit.SubmitCMD
var SubmitCMD=(function(){
	function SubmitCMD(){
		this.fun=null;
		this.args=null;
	}

	__class(SubmitCMD,'laya.webgl.submit.SubmitCMD');
	var __proto=SubmitCMD.prototype;
	Laya.imps(__proto,{"laya.webgl.submit.ISubmit":true})
	__proto.renderSubmit=function(){
		this.fun.apply(null,this.args);
		return 1;
	}

	__proto.getRenderType=function(){
		return 0;
	}

	__proto.releaseRender=function(){
		var cache=SubmitCMD._cache;
		cache[cache._length++]=this;
	}

	SubmitCMD.create=function(args,fun){
		var o=SubmitCMD._cache._length?SubmitCMD._cache[--SubmitCMD._cache._length]:new SubmitCMD();
		o.fun=fun;
		o.args=args;
		return o;
	}

	SubmitCMD._cache=(SubmitCMD._cache=[],SubmitCMD._cache._length=0,SubmitCMD._cache);
	return SubmitCMD;
})()


//class laya.webgl.submit.SubmitCMDScope
var SubmitCMDScope=(function(){
	function SubmitCMDScope(){
		this.variables={};
	}

	__class(SubmitCMDScope,'laya.webgl.submit.SubmitCMDScope');
	var __proto=SubmitCMDScope.prototype;
	__proto.getValue=function(name){
		return this.variables[name];
	}

	__proto.addValue=function(name,value){
		return this.variables[name]=value;
	}

	__proto.setValue=function(name,value){
		if(this.variables.hasOwnProperty(name)){
			return this.variables[name]=value;
		}
		return null;
	}

	__proto.clear=function(){
		for(var key in this.variables){
			delete this.variables[key];
		}
	}

	__proto.recycle=function(){
		this.clear();
		SubmitCMDScope.POOL.push(this);
	}

	SubmitCMDScope.create=function(){
		var scope=SubmitCMDScope.POOL.pop();
		scope||(scope=new SubmitCMDScope());
		return scope;
	}

	SubmitCMDScope.POOL=[];
	return SubmitCMDScope;
})()


//class laya.webgl.submit.SubmitOtherIBVB
var SubmitOtherIBVB=(function(){
	function SubmitOtherIBVB(){
		this.offset=0;
		//this._vb=null;
		//this._ib=null;
		//this._blendFn=null;
		//this._mat=null;
		//this._shader=null;
		//this._shaderValue=null;
		//this._numEle=0;
		this.startIndex=0;
		;
		this._mat=Matrix.create();
	}

	__class(SubmitOtherIBVB,'laya.webgl.submit.SubmitOtherIBVB');
	var __proto=SubmitOtherIBVB.prototype;
	Laya.imps(__proto,{"laya.webgl.submit.ISubmit":true})
	__proto.releaseRender=function(){
		var cache=SubmitOtherIBVB._cache;
		cache[cache._length++]=this;
	}

	__proto.getRenderType=function(){
		return /*laya.webgl.submit.Submit.TYPE_OTHERIBVB*/10009;
	}

	__proto.renderSubmit=function(){
		var _tex=this._shaderValue.textureHost;
		if (_tex){
			var source=_tex.source;
			if (!_tex.bitmap || !source)
				return 1;
			this._shaderValue.texture=source;
		}
		this._vb.bind_upload(this._ib);
		var w=RenderState2D.worldMatrix4;
		var wmat=Matrix.TEMP;
		Matrix.mulPre(this._mat,w[0],w[1],w[4],w[5],w[12],w[13],wmat);
		var tmp=RenderState2D.worldMatrix4=SubmitOtherIBVB.tempMatrix4;
		tmp[0]=wmat.a;
		tmp[1]=wmat.b;
		tmp[4]=wmat.c;
		tmp[5]=wmat.d;
		tmp[12]=wmat.tx;
		tmp[13]=wmat.ty;
		this._shader._offset=this.offset;
		this._shaderValue.refresh();
		this._shader.upload(this._shaderValue);
		this._shader._offset=0;
		var gl=WebGL.mainContext;
		if (BlendMode.activeBlendFunction!==this._blendFn){
			gl.enable(/*laya.webgl.WebGLContext.BLEND*/0x0BE2);
			this._blendFn(gl);
			BlendMode.activeBlendFunction=this._blendFn;
		}
		Stat.drawCall++;
		Stat.trianglesFaces+=this._numEle / 3;
		gl.drawElements(/*laya.webgl.WebGLContext.TRIANGLES*/0x0004,this._numEle,/*laya.webgl.WebGLContext.UNSIGNED_SHORT*/0x1403,this.startIndex);
		RenderState2D.worldMatrix4=w;
		BaseShader.activeShader=null;
		return 1;
	}

	SubmitOtherIBVB.create=function(context,vb,ib,numElement,shader,shaderValue,startIndex,offset,type){
		(type===void 0)&& (type=0);
		var o=(!SubmitOtherIBVB._cache._length)? (new SubmitOtherIBVB()):SubmitOtherIBVB._cache[--SubmitOtherIBVB._cache._length];
		o._ib=ib;
		o._vb=vb;
		o._numEle=numElement;
		o._shader=shader;
		o._shaderValue=shaderValue;
		var blendType=context._nBlendType;
		o._blendFn=context._targets ? BlendMode.targetFns[blendType] :BlendMode.fns[blendType];
		switch(type){
			case 0:
				o.offset=0;
				o.startIndex=offset / (CONST3D2D.BYTES_PE *vb.vertexStride)*1.5;
				o.startIndex *=CONST3D2D.BYTES_PIDX;
				break ;
			case 1:
				o.startIndex=startIndex;
				o.offset=offset;
				break ;
			}
		return o;
	}

	SubmitOtherIBVB._cache=(SubmitOtherIBVB._cache=[],SubmitOtherIBVB._cache._length=0,SubmitOtherIBVB._cache);
	SubmitOtherIBVB.tempMatrix4=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,];
	return SubmitOtherIBVB;
})()


//class laya.webgl.submit.SubmitScissor
var SubmitScissor=(function(){
	function SubmitScissor(){
		this.submitIndex=0;
		this.submitLength=0;
		this.context=null;
		this.clipRect=new Rectangle();
		this.screenRect=new Rectangle();
	}

	__class(SubmitScissor,'laya.webgl.submit.SubmitScissor');
	var __proto=SubmitScissor.prototype;
	Laya.imps(__proto,{"laya.webgl.submit.ISubmit":true})
	__proto._scissor=function(x,y,w,h){
		var m=RenderState2D.worldMatrix4;
		var a=m[0],d=m[5],tx=m[12],ty=m[13];
		x=x *a+tx;
		y=y *d+ty;
		w *=a;
		h *=d;
		if (w < 1 || h < 1){
			return false;
		};
		var r=x+w;
		var b=y+h;
		x < 0 && (x=0,w=r-x);
		y < 0 && (y=0,h=b-y);
		var screen=RenderState2D.worldClipRect;
		x=Math.max(x,screen.x);
		y=Math.max(y,screen.y);
		w=Math.min(r,screen.right)-x;
		h=Math.min(b,screen.bottom)-y;
		if (w < 1 || h < 1){
			return false;
		};
		var worldScissorTest=RenderState2D.worldScissorTest;
		this.screenRect.copyFrom(screen);
		screen.x=x;
		screen.y=y;
		screen.width=w;
		screen.height=h;
		RenderState2D.worldScissorTest=true;
		y=RenderState2D.height-y-h;
		WebGL.mainContext.scissor(x,y,w,h);
		WebGL.mainContext.enable(/*laya.webgl.WebGLContext.SCISSOR_TEST*/0x0C11);
		this.context.submitElement(this.submitIndex,this.submitIndex+this.submitLength);
		if (worldScissorTest){
			y=RenderState2D.height-this.screenRect.y-this.screenRect.height;
			WebGL.mainContext.scissor(this.screenRect.x,y,this.screenRect.width,this.screenRect.height);
			WebGL.mainContext.enable(/*laya.webgl.WebGLContext.SCISSOR_TEST*/0x0C11);
		}
		else{
			WebGL.mainContext.disable(/*laya.webgl.WebGLContext.SCISSOR_TEST*/0x0C11);
			RenderState2D.worldScissorTest=false;
		}
		screen.copyFrom(this.screenRect);
		return true;
	}

	__proto._scissorWithTagart=function(x,y,w,h){
		if (w < 1 || h < 1){
			return false;
		};
		var r=x+w;
		var b=y+h;
		x < 0 && (x=0,w=r-x);
		y < 0 && (y=0,h=b-y);
		var screen=RenderState2D.worldClipRect;
		x=Math.max(x,screen.x);
		y=Math.max(y,screen.y);
		w=Math.min(r,screen.right)-x;
		h=Math.min(b,screen.bottom)-y;
		if (w < 1 || h < 1){
			return false;
		};
		var worldScissorTest=RenderState2D.worldScissorTest;
		this.screenRect.copyFrom(screen);
		RenderState2D.worldScissorTest=true;
		screen.x=x;
		screen.y=y;
		screen.width=w;
		screen.height=h;
		y=RenderState2D.height-y-h;
		WebGL.mainContext.scissor(x,y,w,h);
		WebGL.mainContext.enable(/*laya.webgl.WebGLContext.SCISSOR_TEST*/0x0C11);
		this.context.submitElement(this.submitIndex,this.submitIndex+this.submitLength);
		if (worldScissorTest){
			y=RenderState2D.height-this.screenRect.y-this.screenRect.height;
			WebGL.mainContext.scissor(this.screenRect.x,y,this.screenRect.width,this.screenRect.height);
			WebGL.mainContext.enable(/*laya.webgl.WebGLContext.SCISSOR_TEST*/0x0C11);
		}
		else{
			WebGL.mainContext.disable(/*laya.webgl.WebGLContext.SCISSOR_TEST*/0x0C11);
			RenderState2D.worldScissorTest=false;
		}
		screen.copyFrom(this.screenRect);
		return true;
	}

	__proto.renderSubmit=function(){
		this.submitLength=Math.min(this.context._submits._length-1,this.submitLength);
		if (this.submitLength < 1 || this.clipRect.width < 1 || this.clipRect.height < 1)
			return this.submitLength+1;
		if (this.context._targets)
			this._scissorWithTagart(this.clipRect.x,this.clipRect.y,this.clipRect.width,this.clipRect.height);
		else this._scissor(this.clipRect.x,this.clipRect.y,this.clipRect.width,this.clipRect.height);
		return this.submitLength+1;
	}

	__proto.getRenderType=function(){
		return 0;
	}

	__proto.releaseRender=function(){
		var cache=SubmitScissor._cache;
		cache[cache._length++]=this;
		this.context=null;
	}

	SubmitScissor.create=function(context){
		var o=SubmitScissor._cache._length?SubmitScissor._cache[--SubmitScissor._cache._length]:new SubmitScissor();
		o.context=context;
		return o;
	}

	SubmitScissor._cache=(SubmitScissor._cache=[],SubmitScissor._cache._length=0,SubmitScissor._cache);
	return SubmitScissor;
})()


//class laya.webgl.submit.SubmitStencil
var SubmitStencil=(function(){
	function SubmitStencil(){
		this.step=0;
		this.blendMode=null;
		this.level=0;
	}

	__class(SubmitStencil,'laya.webgl.submit.SubmitStencil');
	var __proto=SubmitStencil.prototype;
	Laya.imps(__proto,{"laya.webgl.submit.ISubmit":true})
	__proto.renderSubmit=function(){
		switch(this.step){
			case 1:
				this.do1();
				break ;
			case 2:
				this.do2();
				break ;
			case 3:
				this.do3();
				break ;
			case 4:
				this.do4();
				break ;
			case 5:
				this.do5();
				break ;
			case 6:
				this.do6();
				break ;
			case 7:
				this.do7();
				break ;
			case 8:
				this.do8();
				break ;
			}
		return 1;
	}

	__proto.getRenderType=function(){
		return 0;
	}

	__proto.releaseRender=function(){
		var cache=SubmitStencil._cache;
		cache[cache._length++]=this;
	}

	__proto.do1=function(){
		var gl=WebGL.mainContext;
		gl.enable(/*laya.webgl.WebGLContext.STENCIL_TEST*/0x0B90);
		gl.clear(/*laya.webgl.WebGLContext.STENCIL_BUFFER_BIT*/0x00000400);
		gl.colorMask(false,false,false,false);
		gl.stencilFunc(/*laya.webgl.WebGLContext.EQUAL*/0x0202,this.level,0xFF);
		gl.stencilOp(/*laya.webgl.WebGLContext.KEEP*/0x1E00,/*laya.webgl.WebGLContext.KEEP*/0x1E00,/*laya.webgl.WebGLContext.INCR*/0x1E02);
	}

	//gl.stencilOp(WebGLContext.KEEP,WebGLContext.KEEP,WebGLContext.INVERT);//测试通过给模版缓冲 写入值 一开始是0 现在是 0xFF (模版缓冲中不知道是多少位的数据)
	__proto.do2=function(){
		var gl=WebGL.mainContext;
		gl.stencilFunc(/*laya.webgl.WebGLContext.EQUAL*/0x0202,this.level+1,0xFF);
		gl.colorMask(true,true,true,true);
		gl.stencilOp(/*laya.webgl.WebGLContext.KEEP*/0x1E00,/*laya.webgl.WebGLContext.KEEP*/0x1E00,/*laya.webgl.WebGLContext.KEEP*/0x1E00);
	}

	__proto.do3=function(){
		var gl=WebGL.mainContext;
		gl.colorMask(true,true,true,true);
		gl.stencilOp(/*laya.webgl.WebGLContext.KEEP*/0x1E00,/*laya.webgl.WebGLContext.KEEP*/0x1E00,/*laya.webgl.WebGLContext.KEEP*/0x1E00);
		gl.clear(/*laya.webgl.WebGLContext.STENCIL_BUFFER_BIT*/0x00000400);
		gl.disable(/*laya.webgl.WebGLContext.STENCIL_TEST*/0x0B90);
	}

	__proto.do4=function(){
		var gl=WebGL.mainContext;
		if (this.level==0){
			gl.enable(/*laya.webgl.WebGLContext.STENCIL_TEST*/0x0B90);
			gl.clear(/*laya.webgl.WebGLContext.STENCIL_BUFFER_BIT*/0x00000400);
		}
		gl.colorMask(false,false,false,false);
		gl.stencilFunc(/*laya.webgl.WebGLContext.ALWAYS*/0x0207,0,0xFF);
		gl.stencilOp(/*laya.webgl.WebGLContext.KEEP*/0x1E00,/*laya.webgl.WebGLContext.KEEP*/0x1E00,/*laya.webgl.WebGLContext.INCR*/0x1E02);
	}

	__proto.do5=function(){
		var gl=WebGL.mainContext;
		gl.stencilFunc(/*laya.webgl.WebGLContext.EQUAL*/0x0202,this.level,0xFF);
		gl.colorMask(true,true,true,true);
		gl.stencilOp(/*laya.webgl.WebGLContext.KEEP*/0x1E00,/*laya.webgl.WebGLContext.KEEP*/0x1E00,/*laya.webgl.WebGLContext.KEEP*/0x1E00);
	}

	__proto.do6=function(){
		var gl=WebGL.mainContext;
		BlendMode.targetFns[BlendMode.TOINT[this.blendMode]](gl);
	}

	__proto.do7=function(){
		var gl=WebGL.mainContext;
		gl.colorMask(false,false,false,false);
		gl.stencilOp(/*laya.webgl.WebGLContext.KEEP*/0x1E00,/*laya.webgl.WebGLContext.KEEP*/0x1E00,/*laya.webgl.WebGLContext.DECR*/0x1E03);
	}

	__proto.do8=function(){
		var gl=WebGL.mainContext;
		gl.colorMask(true,true,true,true);
		gl.stencilFunc(/*laya.webgl.WebGLContext.EQUAL*/0x0202,this.level,0xFF);
		gl.stencilOp(/*laya.webgl.WebGLContext.KEEP*/0x1E00,/*laya.webgl.WebGLContext.KEEP*/0x1E00,/*laya.webgl.WebGLContext.KEEP*/0x1E00);
	}

	SubmitStencil.restore=function(context,clip,m,_x,_y){
		var submitStencil;
		context._renderKey=0;
		if (SubmitStencil._mask > 0){
			SubmitStencil._mask--;
		}
		if (SubmitStencil._mask==0){
			submitStencil=laya.webgl.submit.SubmitStencil.create(3);
			context.addRenderObject(submitStencil);
			context._curSubmit=Submit.RENDERBASE;
		}
		else{
			submitStencil=laya.webgl.submit.SubmitStencil.create(7);
			context.addRenderObject(submitStencil);
			var vb=context._vb;
			var nPos=(vb._byteLength >> 2);
			if (GlUtils.fillRectImgVb(vb,null,clip.x,clip.y,clip.width,clip.height,Texture.DEF_UV,m,_x,_y,0,0)){
				var shader=context._shader2D;
				shader.glTexture=null;
				var submit=context._curSubmit=Submit.createSubmit(context,context._ib,vb,((vb._byteLength-/*laya.webgl.canvas.WebGLContext2D._RECTVBSIZE*/16 */*laya.webgl.utils.Buffer2D.FLOAT32*/4)/ 32)*3,Value2D.create(/*laya.webgl.shader.d2.ShaderDefines2D.COLOR2D*/0x02,0));
				submit.shaderValue.ALPHA=1.0;
				context._submits[context._submits._length++]=submit;
				context._curSubmit._numEle+=6;
				context._curSubmit=Submit.RENDERBASE;
				}else {
				alert("clipRect calc stencil rect error");
			}
			submitStencil=laya.webgl.submit.SubmitStencil.create(8);
			context.addRenderObject(submitStencil);
		}
	}

	SubmitStencil.restore2=function(context,submit){
		var submitStencil;
		context._renderKey=0;
		if (SubmitStencil._mask > 0){
			SubmitStencil._mask--;
		}
		if (SubmitStencil._mask==0){
			submitStencil=laya.webgl.submit.SubmitStencil.create(3);
			context.addRenderObject(submitStencil);
			context._curSubmit=Submit.RENDERBASE;
		}
		else{
			submitStencil=laya.webgl.submit.SubmitStencil.create(7);
			context.addRenderObject(submitStencil);
			context._submits[context._submits._length++]=submit;
			submitStencil=laya.webgl.submit.SubmitStencil.create(8);
			context.addRenderObject(submitStencil);
		}
	}

	SubmitStencil.create=function(step){
		var o=SubmitStencil._cache._length?SubmitStencil._cache[--SubmitStencil._cache._length]:new SubmitStencil();
		o.step=step;
		if (step==5)
			++SubmitStencil._mask;
		o.level=SubmitStencil._mask;
		return o;
	}

	SubmitStencil._cache=(SubmitStencil._cache=[],SubmitStencil._cache._length=0,SubmitStencil._cache);
	SubmitStencil._mask=0;
	return SubmitStencil;
})()


//class laya.webgl.submit.SubmitTarget
var SubmitTarget=(function(){
	function SubmitTarget(){
		this._renderType=0;
		this._vb=null;
		this._ib=null;
		this._startIdx=0;
		this._numEle=0;
		this.shaderValue=null;
		this.blendType=0;
		this.proName=null;
		this.scope=null;
	}

	__class(SubmitTarget,'laya.webgl.submit.SubmitTarget');
	var __proto=SubmitTarget.prototype;
	Laya.imps(__proto,{"laya.webgl.submit.ISubmit":true})
	__proto.renderSubmit=function(){
		this._vb.bind_upload(this._ib);
		var target=this.scope.getValue(this.proName);
		if (target){
			this.shaderValue.texture=target.source;
			if (this.shaderValue["strength"] && !this.shaderValue["blurInfo"]){
				this.shaderValue["blurInfo"]=[target.width,target.height];
			}
			this.shaderValue.upload();
			this.blend();
			Stat.drawCall++;
			Stat.trianglesFaces+=this._numEle/3;
			WebGL.mainContext.drawElements(/*laya.webgl.WebGLContext.TRIANGLES*/0x0004,this._numEle,/*laya.webgl.WebGLContext.UNSIGNED_SHORT*/0x1403,this._startIdx);
		}
		return 1;
	}

	__proto.blend=function(){
		if (BlendMode.activeBlendFunction!==BlendMode.fns[this.blendType]){
			var gl=WebGL.mainContext;
			gl.enable(/*laya.webgl.WebGLContext.BLEND*/0x0BE2);
			BlendMode.fns[this.blendType](gl);
			BlendMode.activeBlendFunction=BlendMode.fns[this.blendType];
		}
	}

	__proto.getRenderType=function(){
		return 0;
	}

	__proto.releaseRender=function(){
		var cache=SubmitTarget._cache;
		cache[cache._length++]=this;
	}

	SubmitTarget.create=function(context,ib,vb,pos,sv,proName){
		var o=SubmitTarget._cache._length?SubmitTarget._cache[--SubmitTarget._cache._length]:new SubmitTarget();
		o._ib=ib;
		o._vb=vb;
		o.proName=proName;
		o._startIdx=pos *CONST3D2D.BYTES_PIDX;
		o._numEle=0;
		o.blendType=context._nBlendType;
		o.shaderValue=sv;
		o.shaderValue.setValue(context._shader2D);
		return o;
	}

	SubmitTarget._cache=(SubmitTarget._cache=[],SubmitTarget._cache._length=0,SubmitTarget._cache);
	return SubmitTarget;
})()


/**
*...特殊的字符，如泰文，必须重新实现这个类
*/
//class laya.webgl.text.CharSegment
var CharSegment=(function(){
	function CharSegment(){
		this._sourceStr=null;
	}

	__class(CharSegment,'laya.webgl.text.CharSegment');
	var __proto=CharSegment.prototype;
	Laya.imps(__proto,{"laya.webgl.text.ICharSegment":true})
	__proto.textToSpit=function(str){
		this._sourceStr=str;
	}

	__proto.getChar=function(i){
		return this._sourceStr.charAt(i);
	}

	__proto.getCharCode=function(i){
		return this._sourceStr.charCodeAt(i);
	}

	__proto.length=function(){
		return this._sourceStr.length;
	}

	return CharSegment;
})()


//class laya.webgl.text.DrawText
var DrawText=(function(){
	var CharValue;
	function DrawText(){}
	__class(DrawText,'laya.webgl.text.DrawText');
	DrawText.__init__=function(){
		DrawText._charsTemp=new Array;
		DrawText._drawValue=new CharValue();
		DrawText._charSeg=new CharSegment();
	}

	DrawText.customCharSeg=function(charseg){
		DrawText._charSeg=charseg;
	}

	DrawText.getChar=function(char,id,drawValue){
		var result=WebGLCharImage.createOneChar(char,drawValue);
		if(id!=-1)
			DrawText._charsCache[id]=result;
		return result;
	}

	DrawText._drawSlow=function(save,ctx,txt,words,curMat,font,textAlign,fillColor,borderColor,lineWidth,x,y,sx,sy,underLine){
		var drawValue=DrawText._drawValue.value(font,fillColor,borderColor,lineWidth,sx,sy,underLine);
		var i=0,n=0;
		var chars=DrawText._charsTemp;
		var width=0,oneChar,htmlWord,id=NaN;
		if (words){
			chars.length=words.length;
			for (i=0,n=words.length;i < n;i++){
				htmlWord=words[i];
				id=htmlWord.charNum+drawValue.txtID;
				chars[i]=oneChar=DrawText._charsCache[id] || DrawText.getChar(htmlWord.char,id,drawValue);
				oneChar.active();
			}
			}else {
			var text=((txt instanceof laya.utils.WordText ))? txt.toString():txt;
			if (Text.CharacterCache){
				DrawText._charSeg.textToSpit(text);
				var len=/*if err,please use iflash.method.xmlLength()*/DrawText._charSeg.length();
				chars.length=len;
				for (i=0,n=len;i < n;i++){
					id=DrawText._charSeg.getCharCode(i)+drawValue.txtID;
					chars[i]=oneChar=DrawText._charsCache[id] || DrawText.getChar(DrawText._charSeg.getChar(i),id,drawValue);
					oneChar.active();
					width+=oneChar.cw;
				}
			}
			else {
				chars.length=0;
				oneChar=DrawText.getChar(text,-1,drawValue);
				oneChar.active();
				width+=oneChar.cw;
				chars[0]=oneChar;
			}
		};
		var dx=0;
		if (textAlign!==null && textAlign!=="left")
			dx=-(textAlign=="center" ? (width / 2):width);
		var uv,bdSz=NaN,texture,value,saveLength=0;
		if (words){
			for (i=0,n=chars.length;i < n;i++){
				oneChar=chars[i];
				if (!oneChar.isSpace){
					htmlWord=words[i];
					bdSz=oneChar.borderSize;
					texture=oneChar.texture;
					ctx._drawText(texture,x+dx+htmlWord.x *sx-bdSz,y+htmlWord.y *sy-bdSz,texture.width,texture.height,curMat,0,0,0,0);
				}
			}
			}else {
			for (i=0,n=chars.length;i < n;i++){
				oneChar=chars[i];
				if (!oneChar.isSpace){
					bdSz=oneChar.borderSize;
					texture=oneChar.texture;
					ctx._drawText(texture,x+dx-bdSz,y-bdSz,texture.width,texture.height,curMat,0,0,0,0);
					save && (value=save[saveLength++],value || (value=save[saveLength-1]=[]),value[0]=texture,value[1]=dx-bdSz,value[2]=-bdSz);
				}
				dx+=oneChar.cw;
			}
			save && (save.length=saveLength);
		}
	}

	DrawText._drawFast=function(save,ctx,curMat,x,y){
		var texture,value;
		for (var i=0,n=save.length;i < n;i++){
			value=save[i];
			texture=value[0];
			texture.active();
			ctx._drawText(texture,x+value[1],y+value[2],texture.width,texture.height,curMat,0,0,0,0);
		}
	}

	DrawText.drawText=function(ctx,txt,words,curMat,font,textAlign,fillColor,borderColor,lineWidth,x,y,underLine){
		(underLine===void 0)&& (underLine=0);
		if ((txt && txt.length===0)|| (words && words.length===0))
			return;
		var sx=curMat.a,sy=curMat.d;
		(curMat.b!==0 || curMat.c!==0)&& (sx=sy=1);
		var scale=sx!==1 || sy!==1;
		if (scale && Laya.stage.transform){
			var t=Laya.stage.transform;
			scale=t.a===sx && t.d===sy;
		}else scale=false;
		if (scale){
			curMat=curMat.copyTo(WebGLContext2D._tmpMatrix);
			var tempTx=curMat.tx;
			var tempTy=curMat.ty;
			curMat.scale(1 / sx,1 / sy);
			curMat._checkTransform();
			x *=sx;
			y *=sy;
			x+=tempTx-curMat.tx;
			y+=tempTy-curMat.ty;
		}else sx=sy=1;
		if (words){
			DrawText._drawSlow(null,ctx,txt,words,curMat,font,textAlign,fillColor,borderColor,lineWidth,x,y,sx,sy,underLine);
			}else {
			if (txt.toUpperCase===null){
				var idNum=sx+sy *100000;
				var myCache=txt;
				if (!myCache.changed && myCache.id===idNum){
					DrawText._drawFast(myCache.save,ctx,curMat,x,y);
					}else {
					myCache.id=idNum;
					myCache.changed=false;
					DrawText._drawSlow(myCache.save,ctx,txt,words,curMat,font,textAlign,fillColor,borderColor,lineWidth,x,y,sx,sy,underLine);
				}
				return;
			};
			var id=txt+font.toString()+fillColor+borderColor+lineWidth+sx+sy+textAlign;
			var cache=DrawText._textsCache[id];
			if (Text.CharacterCache){
				if (cache){
					DrawText._drawFast(cache,ctx,curMat,x,y);
					}else {
					DrawText._textsCache.__length || (DrawText._textsCache.__length=0);
					if (DrawText._textsCache.__length > Config.WebGLTextCacheCount){
						DrawText._textsCache={};
						DrawText._textsCache.__length=0;
						DrawText._curPoolIndex=0;
					}
					DrawText._textCachesPool[DrawText._curPoolIndex] ? (cache=DrawText._textsCache[id]=DrawText._textCachesPool[DrawText._curPoolIndex],cache.length=0):(DrawText._textCachesPool[DrawText._curPoolIndex]=cache=DrawText._textsCache[id]=[]);
					DrawText._textsCache.__length++
					DrawText._curPoolIndex++;
					DrawText._drawSlow(cache,ctx,txt,words,curMat,font,textAlign,fillColor,borderColor,lineWidth,x,y,sx,sy,underLine);
				}
			}
			else{
				DrawText._drawSlow(cache,ctx,txt,words,curMat,font,textAlign,fillColor,borderColor,lineWidth,x,y,sx,sy,underLine);
			}
		}
	}

	DrawText._charsTemp=null;
	DrawText._textCachesPool=[];
	DrawText._curPoolIndex=0;
	DrawText._charsCache={};
	DrawText._textsCache={};
	DrawText._drawValue=null;
	DrawText.d=[];
	DrawText._charSeg=null;
	DrawText.__init$=function(){
		//class CharValue
		CharValue=(function(){
			function CharValue(){
				//this.txtID=NaN;
				//this.font=null;
				//this.fillColor=null;
				//this.borderColor=null;
				//this.lineWidth=0;
				//this.scaleX=NaN;
				//this.scaleY=NaN;
				//this.underLine=0;
			}
			__class(CharValue,'');
			var __proto=CharValue.prototype;
			__proto.value=function(font,fillColor,borderColor,lineWidth,scaleX,scaleY,underLine){
				this.font=font;
				this.fillColor=fillColor;
				this.borderColor=borderColor;
				this.lineWidth=lineWidth;
				this.scaleX=scaleX;
				this.scaleY=scaleY;
				this.underLine=underLine;
				var key=font.toString()+scaleX+scaleY+lineWidth+fillColor+borderColor+underLine;
				this.txtID=CharValue._keymap[key];
				if (!this.txtID){
					this.txtID=(++CharValue._keymapCount)*0.0000001;
					CharValue._keymap[key]=this.txtID;
				}
				return this;
			}
			CharValue.clear=function(){
				CharValue._keymap={};
				CharValue._keymapCount=1;
			}
			CharValue._keymap={};
			CharValue._keymapCount=1;
			return CharValue;
		})()
	}

	return DrawText;
})()


//class laya.webgl.text.FontInContext
var FontInContext=(function(){
	function FontInContext(font){
		//this._text=null;
		//this._words=null;
		this._index=0;
		this._size=14;
		this._italic=-2;
		FontInContext._cache2=FontInContext._cache2|| [];
		this.setFont(font || "14px Arial");
	}

	__class(FontInContext,'laya.webgl.text.FontInContext');
	var __proto=FontInContext.prototype;
	__proto.setFont=function(value){
		var arr=FontInContext._cache2[value];
		if (!arr){
			this._words=value.split(' ');
			for (var i=0,n=this._words.length;i < n;i++){
				if (this._words[i].indexOf('px')> 0){
					this._index=i;
					break ;
				}
			}
			this._size=parseInt(this._words[this._index]);
			FontInContext._cache2[value]=[this._words,this._size];
			}else {
			this._words=arr[0];
			this._size=arr[1];
		}
		this._text=null;
		this._italic=-2;
	}

	__proto.getItalic=function(){
		this._italic===-2 && (this._italic=this.hasType("italic"));
		return this._italic;
	}

	__proto.hasType=function(name){
		for (var i=0,n=this._words.length;i < n;i++)
		if (this._words[i]===name)return i;
		return-1;
	}

	__proto.removeType=function(name){
		for (var i=0,n=this._words.length;i < n;i++)
		if (this._words[i]===name){
			this._words.splice(i,1);
			if (this._index > i)this._index--;
			break ;
		}
		this._text=null;
		this._italic=-2;
	}

	__proto.copyTo=function(dec){
		dec._text=this._text;
		dec._size=this._size;
		dec._index=this._index;
		dec._words=this._words.slice();
		dec._italic=-2;
		return dec;
	}

	__proto.toString=function(){
		return this._text ? this._text :(this._text=this._words.join(' '));
	}

	__getset(0,__proto,'size',function(){
		return this._size;
		},function(value){
		this._size=value;
		this._words[this._index]=value+"px";
		this._text=null;
	});

	FontInContext.create=function(font){
		var r=FontInContext._cache[font];
		if (r)return r;
		r=FontInContext._cache[font]=new FontInContext(font);
		return r;
	}

	FontInContext.EMPTY=new FontInContext();
	FontInContext._cache={};
	FontInContext._cache2=null;
	return FontInContext;
})()


//class laya.webgl.utils.CONST3D2D
var CONST3D2D=(function(){
	function CONST3D2D(){}
	__class(CONST3D2D,'laya.webgl.utils.CONST3D2D');
	CONST3D2D.defaultMatrix4=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];
	CONST3D2D.defaultMinusYMatrix4=[1,0,0,0,0,-1,0,0,0,0,1,0,0,0,0,1];
	CONST3D2D.uniformMatrix3=[1,0,0,0,0,1,0,0,0,0,1,0];
	CONST3D2D._TMPARRAY=[];
	CONST3D2D._OFFSETX=0;
	CONST3D2D._OFFSETY=0;
	__static(CONST3D2D,
	['BYTES_PE',function(){return this.BYTES_PE=/*__JS__ */Float32Array.BYTES_PER_ELEMENT;},'BYTES_PIDX',function(){return this.BYTES_PIDX=/*__JS__ */Uint16Array.BYTES_PER_ELEMENT;}
	]);
	return CONST3D2D;
})()


//class laya.webgl.utils.GlUtils
var GlUtils=(function(){
	function GlUtils(){}
	__class(GlUtils,'laya.webgl.utils.GlUtils');
	GlUtils.make2DProjection=function(width,height,depth){
		return [2.0 / width,0,0,0,0,-2.0 / height,0,0,0,0,2.0 / depth,0,-1,1,0,1,];
	}

	GlUtils.fillIBQuadrangle=function(buffer,count){
		if (count > 65535 / 4){
			throw Error("IBQuadrangle count:"+count+" must<:"+Math.floor(65535 / 4));
			return false;
		}
		count=Math.floor(count);
		buffer._resizeBuffer((count+1)*6 */*laya.webgl.utils.Buffer2D.SHORT*/2,false);
		buffer.byteLength=buffer.bufferLength;
		var bufferData=buffer.getUint16Array();
		var idx=0;
		for (var i=0;i < count;i++){
			bufferData[idx++]=i *4;
			bufferData[idx++]=i *4+2;
			bufferData[idx++]=i *4+1;
			bufferData[idx++]=i *4;
			bufferData[idx++]=i *4+3;
			bufferData[idx++]=i *4+2;
		}
		buffer.setNeedUpload();
		return true;
	}

	GlUtils.expandIBQuadrangle=function(buffer,count){
		buffer.bufferLength >=(count *6 */*laya.webgl.utils.Buffer2D.SHORT*/2)|| GlUtils.fillIBQuadrangle(buffer,count);
	}

	GlUtils.mathCeilPowerOfTwo=function(value){
		value--;
		value |=value >> 1;
		value |=value >> 2;
		value |=value >> 4;
		value |=value >> 8;
		value |=value >> 16;
		value++;
		return value;
	}

	GlUtils.fillQuadrangleImgVb=function(vb,x,y,point4,uv,m,_x,_y){
		var vpos=(vb._byteLength >> 2)+/*laya.webgl.canvas.WebGLContext2D._RECTVBSIZE*/16;
		vb.byteLength=(vpos << 2);
		var vbdata=vb.getFloat32Array();
		vpos-=/*laya.webgl.canvas.WebGLContext2D._RECTVBSIZE*/16;
		vbdata[vpos+2]=uv[0];
		vbdata[vpos+3]=uv[1];
		vbdata[vpos+6]=uv[2];
		vbdata[vpos+7]=uv[3];
		vbdata[vpos+10]=uv[4];
		vbdata[vpos+11]=uv[5];
		vbdata[vpos+14]=uv[6];
		vbdata[vpos+15]=uv[7];
		var a=m.a,b=m.b,c=m.c,d=m.d;
		if (a!==1 || b!==0 || c!==0 || d!==1){
			m.bTransform=true;
			var tx=m.tx+_x,ty=m.ty+_y;
			vbdata[vpos]=(point4[0]+x)*a+(point4[1]+y)*c+tx;
			vbdata[vpos+1]=(point4[0]+x)*b+(point4[1]+y)*d+ty;
			vbdata[vpos+4]=(point4[2]+x)*a+(point4[3]+y)*c+tx;
			vbdata[vpos+5]=(point4[2]+x)*b+(point4[3]+y)*d+ty;
			vbdata[vpos+8]=(point4[4]+x)*a+(point4[5]+y)*c+tx;
			vbdata[vpos+9]=(point4[4]+x)*b+(point4[5]+y)*d+ty;
			vbdata[vpos+12]=(point4[6]+x)*a+(point4[7]+y)*c+tx;
			vbdata[vpos+13]=(point4[6]+x)*b+(point4[7]+y)*d+ty;
			}else {
			m.bTransform=false;
			x+=m.tx+_x;
			y+=m.ty+_y;
			vbdata[vpos]=x+point4[0];
			vbdata[vpos+1]=y+point4[1];
			vbdata[vpos+4]=x+point4[2];
			vbdata[vpos+5]=y+point4[3];
			vbdata[vpos+8]=x+point4[4];
			vbdata[vpos+9]=y+point4[5];
			vbdata[vpos+12]=x+point4[6];
			vbdata[vpos+13]=y+point4[7];
		}
		vb._upload=true;
		return true;
	}

	GlUtils.fillTranglesVB=function(vb,x,y,points,m,_x,_y){
		var vpos=(vb._byteLength >> 2)+points.length;
		vb.byteLength=(vpos << 2);
		var vbdata=vb.getFloat32Array();
		vpos-=points.length;
		var len=points.length;
		var a=m.a,b=m.b,c=m.c,d=m.d;
		for (var i=0;i < len;i+=4){
			vbdata[vpos+i+2]=points[i+2];
			vbdata[vpos+i+3]=points[i+3];
			if (a!==1 || b!==0 || c!==0 || d!==1){
				m.bTransform=true;
				var tx=m.tx+_x,ty=m.ty+_y;
				vbdata[vpos+i]=(points[i]+x)*a+(points[i+1]+y)*c+tx;
				vbdata[vpos+i+1]=(points[i]+x)*b+(points[i+1]+y)*d+ty;
				}else {
				m.bTransform=false;
				x+=m.tx+_x;
				y+=m.ty+_y;
				vbdata[vpos+i]=x+points[i];
				vbdata[vpos+i+1]=y+points[i+1];
			}
		}
		vb._upload=true;
		return true;
	}

	GlUtils.copyPreImgVb=function(vb,dx,dy){
		var vpos=(vb._byteLength >> 2);
		vb.byteLength=((vpos+/*laya.webgl.canvas.WebGLContext2D._RECTVBSIZE*/16)<< 2);
		var vbdata=vb.getFloat32Array();
		for (var i=0,ci=vpos-16;i < 4;i++){
			vbdata[vpos]=vbdata[ci]+dx;
			++vpos;
			++ci;
			vbdata[vpos]=vbdata[ci]+dy;
			++vpos;
			++ci;
			vbdata[vpos]=vbdata[ci];
			++vpos;
			++ci;
			vbdata[vpos]=vbdata[ci];
			++vpos;
			++ci;
		}
		vb._upload=true;
	}

	GlUtils.fillRectImgVb=function(vb,clip,x,y,width,height,uv,m,_x,_y,dx,dy,round){
		(round===void 0)&& (round=false);
		var mType=1;
		var toBx,toBy,toEx,toEy;
		var cBx,cBy,cEx,cEy;
		var w0,h0,tx,ty;
		var finalX,finalY,offsetX,offsetY;
		var a=m.a,b=m.b,c=m.c,d=m.d;
		var useClip=clip && clip.width < /*laya.webgl.canvas.WebGLContext2D._MAXSIZE*/99999999;
		if (a!==1 || b!==0 || c!==0 || d!==1){
			m.bTransform=true;
			if (b===0 && c===0){
				mType=23;
				w0=width+x,h0=height+y;
				tx=m.tx+_x,ty=m.ty+_y;
				toBx=a *x+tx;
				toEx=a *w0+tx;
				toBy=d *y+ty;
				toEy=d *h0+ty;
			}
			}else {
			mType=23;
			m.bTransform=false;
			toBx=x+m.tx+_x;
			toEx=toBx+width;
			toBy=y+m.ty+_y;
			toEy=toBy+height;
		}
		if (useClip){
			cBx=clip.x,cBy=clip.y,cEx=clip.width+cBx,cEy=clip.height+cBy;
		}
		if (mType!==1){
			if (Math.min(toBx,toEx)>=cEx)return false;
			if (Math.min(toBy,toEy)>=cEy)return false;
			if (Math.max(toEx,toBx)<=cBx)return false;
			if (Math.max(toEy,toBy)<=cBy)return false;
		};
		var vpos=(vb._byteLength >> 2);
		vb.byteLength=((vpos+/*laya.webgl.canvas.WebGLContext2D._RECTVBSIZE*/16)<< 2);
		var vbdata=vb.getFloat32Array();
		vbdata[vpos+2]=uv[0];
		vbdata[vpos+3]=uv[1];
		vbdata[vpos+6]=uv[2];
		vbdata[vpos+7]=uv[3];
		vbdata[vpos+10]=uv[4];
		vbdata[vpos+11]=uv[5];
		vbdata[vpos+14]=uv[6];
		vbdata[vpos+15]=uv[7];
		switch (mType){
			case 1:
				tx=m.tx+_x,ty=m.ty+_y;
				w0=width+x,h0=height+y;
				var w1=x,h1=y;
				var aw1=a *w1,ch1=c *h1,dh1=d *h1,bw1=b *w1;
				var aw0=a *w0,ch0=c *h0,dh0=d *h0,bw0=b *w0;
				if (round){
					finalX=aw1+ch1+tx;
					offsetX=Math.round(finalX)-finalX;
					finalY=dh1+bw1+ty;
					offsetY=Math.round(finalY)-finalY;
					vbdata[vpos]=finalX+offsetX;
					vbdata[vpos+1]=finalY+offsetY;
					vbdata[vpos+4]=aw0+ch1+tx+offsetX;
					vbdata[vpos+5]=dh1+bw0+ty+offsetY;
					vbdata[vpos+8]=aw0+ch0+tx+offsetX;
					vbdata[vpos+9]=dh0+bw0+ty+offsetY;
					vbdata[vpos+12]=aw1+ch0+tx+offsetX;
					vbdata[vpos+13]=dh0+bw1+ty+offsetY;
					}else {
					vbdata[vpos]=aw1+ch1+tx;
					vbdata[vpos+1]=dh1+bw1+ty;
					vbdata[vpos+4]=aw0+ch1+tx;
					vbdata[vpos+5]=dh1+bw0+ty;
					vbdata[vpos+8]=aw0+ch0+tx;
					vbdata[vpos+9]=dh0+bw0+ty;
					vbdata[vpos+12]=aw1+ch0+tx;
					vbdata[vpos+13]=dh0+bw1+ty;
				}
				break ;
			case 23:
				if (round){
					finalX=toBx+dx;
					offsetX=Math.round(finalX)-finalX;
					finalY=toBy;
					offsetY=Math.round(finalY)-finalY;
					vbdata[vpos]=finalX+offsetX;
					vbdata[vpos+1]=finalY+offsetY;
					vbdata[vpos+4]=toEx+dx+offsetX;
					vbdata[vpos+5]=toBy+offsetY;
					vbdata[vpos+8]=toEx+offsetX;
					vbdata[vpos+9]=toEy+offsetY;
					vbdata[vpos+12]=toBx+offsetX;
					vbdata[vpos+13]=toEy+offsetY;
					}else {
					vbdata[vpos]=toBx+dx;
					vbdata[vpos+1]=toBy;
					vbdata[vpos+4]=toEx+dx;
					vbdata[vpos+5]=toBy;
					vbdata[vpos+8]=toEx;
					vbdata[vpos+9]=toEy;
					vbdata[vpos+12]=toBx;
					vbdata[vpos+13]=toEy;
				}
				break ;
			}
		vb._upload=true;
		return true;
	}

	GlUtils.fillLineVb=function(vb,clip,fx,fy,tx,ty,width,mat){
		var linew=width *.5;
		var data=GlUtils._fillLineArray;
		var perpx=-(fy-ty),perpy=fx-tx;
		var dist=Math.sqrt(perpx *perpx+perpy *perpy);
		perpx /=dist,perpy /=dist,perpx *=linew,perpy *=linew;
		data[0]=fx-perpx,data[1]=fy-perpy,data[4]=fx+perpx,data[5]=fy+perpy,data[8]=tx+perpx,data[9]=ty+perpy,data[12]=tx-perpx,data[13]=ty-perpy;
		mat && mat.transformPointArray(data,data);
		var vpos=(vb._byteLength >> 2)+/*laya.webgl.canvas.WebGLContext2D._RECTVBSIZE*/16;
		vb.byteLength=(vpos << 2);
		vb.insertData(data,vpos-/*laya.webgl.canvas.WebGLContext2D._RECTVBSIZE*/16);
		return true;
	}

	GlUtils._fillLineArray=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
	return GlUtils;
})()


//class laya.webgl.utils.MatirxArray
var MatirxArray=(function(){
	function MatirxArray(){}
	__class(MatirxArray,'laya.webgl.utils.MatirxArray');
	MatirxArray.ArrayMul=function(a,b,o){
		if (!a){
			MatirxArray.copyArray(b,o);
			return;
		}
		if (!b){
			MatirxArray.copyArray(a,o);
			return;
		};
		var ai0=NaN,ai1=NaN,ai2=NaN,ai3=NaN;
		for (var i=0;i < 4;i++){
			ai0=a[i];
			ai1=a[i+4];
			ai2=a[i+8];
			ai3=a[i+12];
			o[i]=ai0 *b[0]+ai1 *b[1]+ai2 *b[2]+ai3 *b[3];
			o[i+4]=ai0 *b[4]+ai1 *b[5]+ai2 *b[6]+ai3 *b[7];
			o[i+8]=ai0 *b[8]+ai1 *b[9]+ai2 *b[10]+ai3 *b[11];
			o[i+12]=ai0 *b[12]+ai1 *b[13]+ai2 *b[14]+ai3 *b[15];
		}
	}

	MatirxArray.copyArray=function(f,t){
		if (!f)return;
		if (!t)return;
		for (var i=0;i < f.length;i++){
			t[i]=f[i];
		}
	}

	return MatirxArray;
})()


/**
*Mesh2d只是保存数据。描述attribute用的。本身不具有渲染功能。
*/
//class laya.webgl.utils.Mesh2D
var Mesh2D=(function(){
	function Mesh2D(stride,vballoc,iballoc){
		this._stride=0;
		//顶点结构大小。每个mesh的顶点结构是固定的。
		this.vertNum=0;
		//当前的顶点的个数
		this.indexNum=0;
		//实际index 个数。例如一个三角形是3个。由于ib本身可能超过实际使用的数量，所以需要一个indexNum
		this._applied=false;
		//是否已经设置给webgl了
		this._vb=null;
		//vb和ib都可能需要在外部修改，所以public
		this._ib=null;
		this._vao=null;
		this._attribInfo=null;
		//保存起来的属性定义数组。
		this._quadNum=0;
		//public static var meshlist:Array=[];//活着的mesh对象列表。
		this.canReuse=false;
		this._stride=stride;
		this._vb=new VertexBuffer2D(stride,/*laya.webgl.WebGLContext.DYNAMIC_DRAW*/0x88E8);
		if (vballoc){
			this._vb._resizeBuffer(vballoc,false);
		}else{}
		this._ib=new IndexBuffer2D();
		if (iballoc){
			this._ib._resizeBuffer(iballoc,false);
		}
	}

	__class(Mesh2D,'laya.webgl.utils.Mesh2D');
	var __proto=Mesh2D.prototype;
	/**
	*重新创建一个mesh。复用这个对象的vertex结构，ib对象和attribinfo对象
	*/
	__proto.cloneWithNewVB=function(){
		var mesh=new Mesh2D(this._stride,0,0);
		mesh._ib=this._ib;
		mesh._quadNum=this._quadNum;
		mesh._attribInfo=this._attribInfo;
		return mesh;
	}

	/**
	*创建一个mesh，使用当前对象的vertex结构。vb和ib自己提供。
	*@return
	*/
	__proto.cloneWithNewVBIB=function(){
		var mesh=new Mesh2D(this._stride,0,0);
		mesh._attribInfo=this._attribInfo;
		return mesh;
	}

	/**
	*获得一个可以写的vb对象
	*/
	__proto.getVBW=function(){
		this._vb.setNeedUpload();
		return this._vb;
	}

	/**
	*获得一个只读vb
	*/
	__proto.getVBR=function(){
		return this._vb;
	}

	__proto.getIBR=function(){
		return this._ib;
	}

	/**
	*获得一个可写的ib
	*/
	__proto.getIBW=function(){
		this._ib.setNeedUpload();
		return this._ib;
	}

	/**
	*直接创建一个固定的ib。按照固定四边形的索引。
	*@param var QuadNum
	*/
	__proto.createQuadIB=function(QuadNum){
		this._quadNum=QuadNum;
		this._ib._resizeBuffer(QuadNum *6 *2,false);
		this._ib.byteLength=this._ib.bufferLength;
		var bd=this._ib.getUint16Array();
		var idx=0;
		var curvert=0;
		for (var i=0;i < QuadNum;i++){
			bd[idx++]=curvert;
			bd[idx++]=curvert+2;
			bd[idx++]=curvert+1;
			bd[idx++]=curvert;
			bd[idx++]=curvert+3;
			bd[idx++]=curvert+2;
			curvert+=4;
		}
		this._ib.setNeedUpload();
	}

	/**
	*设置mesh的属性。每3个一组，对应的location分别是0,1,2...
	*含义是：type,size,offset
	*不允许多流。因此stride是固定的，offset只是在一个vertex之内。
	*@param attribs
	*/
	__proto.setAttributes=function(attribs){
		this._attribInfo=attribs;
		if (this._attribInfo.length % 3 !=0){
			throw 'Mesh2D setAttributes error!';
		}
	}

	__proto.getEleNum=function(){
		return this._ib.getBuffer().byteLength / 2;
	}

	/**
	*子类实现。用来把自己放到对应的回收池中，以便复用。
	*/
	__proto.releaseMesh=function(){}
	/**
	*释放资源。
	*/
	__proto.destroy=function(){}
	/**
	*清理vb数据
	*/
	__proto.clearVB=function(){
		this._vb.clear();
	}

	Mesh2D._gvaoid=0;
	return Mesh2D;
})()


//class laya.webgl.utils.RenderState2D
var RenderState2D=(function(){
	function RenderState2D(){}
	__class(RenderState2D,'laya.webgl.utils.RenderState2D');
	RenderState2D.getMatrArray=function(){
		return [1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];
	}

	RenderState2D.mat2MatArray=function(mat,matArray){
		var m=mat;
		var m4=matArray;
		m4[0]=m.a;
		m4[1]=m.b;
		m4[2]=RenderState2D.EMPTYMAT4_ARRAY[2];
		m4[3]=RenderState2D.EMPTYMAT4_ARRAY[3];
		m4[4]=m.c;
		m4[5]=m.d;
		m4[6]=RenderState2D.EMPTYMAT4_ARRAY[6];
		m4[7]=RenderState2D.EMPTYMAT4_ARRAY[7];
		m4[8]=RenderState2D.EMPTYMAT4_ARRAY[8];
		m4[9]=RenderState2D.EMPTYMAT4_ARRAY[9];
		m4[10]=RenderState2D.EMPTYMAT4_ARRAY[10];
		m4[11]=RenderState2D.EMPTYMAT4_ARRAY[11];
		m4[12]=m.tx;
		m4[13]=m.ty;
		m4[14]=RenderState2D.EMPTYMAT4_ARRAY[14];
		m4[15]=RenderState2D.EMPTYMAT4_ARRAY[15];
		return matArray;
	}

	RenderState2D.restoreTempArray=function(){
		RenderState2D.TEMPMAT4_ARRAY[0]=1;
		RenderState2D.TEMPMAT4_ARRAY[1]=0;
		RenderState2D.TEMPMAT4_ARRAY[4]=0;
		RenderState2D.TEMPMAT4_ARRAY[5]=1;
		RenderState2D.TEMPMAT4_ARRAY[12]=0;
		RenderState2D.TEMPMAT4_ARRAY[13]=0;
	}

	RenderState2D.clear=function(){
		RenderState2D.worldScissorTest=false;
		RenderState2D.worldShaderDefines=null;
		RenderState2D.worldFilters=null;
		RenderState2D.worldAlpha=1;
		RenderState2D.worldClipRect.x=RenderState2D.worldClipRect.y=0;
		RenderState2D.worldClipRect.width=RenderState2D.width;
		RenderState2D.worldClipRect.height=RenderState2D.height;
		RenderState2D.curRenderTarget=null;
	}

	RenderState2D._MAXSIZE=99999999;
	RenderState2D.EMPTYMAT4_ARRAY=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];
	RenderState2D.TEMPMAT4_ARRAY=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];
	RenderState2D.worldMatrix4=RenderState2D.TEMPMAT4_ARRAY;
	RenderState2D.worldAlpha=1.0;
	RenderState2D.worldScissorTest=false;
	RenderState2D.worldFilters=null;
	RenderState2D.worldShaderDefines=null;
	RenderState2D.curRenderTarget=null;
	RenderState2D.width=0;
	RenderState2D.height=0;
	__static(RenderState2D,
	['worldMatrix',function(){return this.worldMatrix=new Matrix();},'worldClipRect',function(){return this.worldClipRect=new Rectangle(0,0,99999999,99999999);}
	]);
	return RenderState2D;
})()


/**
*@private
*<code>ShaderCompile</code> 类用于实现Shader编译。
*/
//class laya.webgl.utils.ShaderCompile
var ShaderCompile=(function(){
	var ShaderNode,InlcudeFile;
	function ShaderCompile(name,vs,ps,nameMap,defs){
		//this._nameMap=null;
		//this._VS=null;
		//this._PS=null;
		var _$this=this;
		function _compile (script){
			var includefiles=[];
			var top=new ShaderNode(includefiles);
			_$this._compileToTree(top,script.split('\n'),0,includefiles,defs);
			return top;
		};
		var startTime=Browser.now();
		this._VS=_compile(vs);
		this._PS=_compile(ps);
		this._nameMap=nameMap;
		if ((Browser.now()-startTime)> 2)
			console.log("ShaderCompile use time:"+(Browser.now()-startTime)+"  size:"+vs.length+"/"+ps.length);
	}

	__class(ShaderCompile,'laya.webgl.utils.ShaderCompile');
	var __proto=ShaderCompile.prototype;
	__proto._compileToTree=function(parent,lines,start,includefiles,defs){
		var node,preNode;
		var text,name,fname;
		var ofs=0,words,noUseNode;
		var i=0,n=0,j=0;
		for (i=start;i < lines.length;i++){
			text=lines[i];
			if (text.length < 1)continue ;
			ofs=text.indexOf("//");
			if (ofs===0)continue ;
			if (ofs >=0)text=text.substr(0,ofs);
			node=noUseNode || new ShaderNode(includefiles);
			noUseNode=null;
			node.text=text;
			node.noCompile=true;
			if ((ofs=text.indexOf("#"))>=0){
				name="#";
				for (j=ofs+1,n=text.length;j < n;j++){
					var c=text.charAt(j);
					if (c===' ' || c==='\t' || c==='?')break ;
					name+=c;
				}
				node.name=name;
				switch (name){
					case "#ifdef":
					case "#ifndef":
						node.src=text;
						node.noCompile=text.match(/[!&|()=<>]/)!=null;
						if (!node.noCompile){
							words=text.replace(/^\s*/,'').split(/\s+/);
							node.setCondition(words[1],name==="#ifdef" ? 1 :2);
							node.text="//"+node.text;
							}else {
							console.log("function():Boolean{return "+text.substr(ofs+node.name.length)+"}");
						}
						node.setParent(parent);
						parent=node;
						if (defs){
							words=text.substr(j).split(ShaderCompile._splitToWordExps3);
							for (j=0;j < words.length;j++){
								text=words[j];
								text.length && (defs[ text]=true);
							}
						}
						continue ;
					case "#if":
						node.src=text;
						node.noCompile=true;
						node.setParent(parent);
						parent=node;
						if (defs){
							words=text.substr(j).split(ShaderCompile._splitToWordExps3);
							for (j=0;j < words.length;j++){
								text=words[j];
								text.length && text!="defined" && (defs[ text]=true);
							}
						}
						continue ;
					case "#else":
						node.src=text;
						parent=parent.parent;
						preNode=parent.childs[parent.childs.length-1];
						node.noCompile=preNode.noCompile
						if (!(node.noCompile)){
							node.condition=preNode.condition;
							node.conditionType=preNode.conditionType==1 ? 2 :1;
							node.text="//"+node.text+" "+preNode.text+" "+node.conditionType;
						}
						node.setParent(parent);
						parent=node;
						continue ;
					case "#endif":
						parent=parent.parent;
						preNode=parent.childs[parent.childs.length-1];
						node.noCompile=preNode.noCompile;
						if (!(node.noCompile)){
							node.text="//"+node.text;
						}
						node.setParent(parent);
						continue ;
					case "#include":
						words=ShaderCompile.splitToWords(text,null);
						var inlcudeFile=ShaderCompile.includes[words[1]];
						if (!inlcudeFile){
							throw "ShaderCompile error no this include file:"+words[1];
							return;
						}
						if ((ofs=words[0].indexOf("?"))< 0){
							node.setParent(parent);
							text=inlcudeFile.getWith(words[2]=='with' ? words[3] :null);
							this._compileToTree(node,text.split('\n'),0,includefiles,defs);
							node.text="";
							continue ;
						}
						node.setCondition(words[0].substr(ofs+1),1);
						node.text=inlcudeFile.getWith(words[2]=='with' ? words[3] :null);
						break ;
					case "#import":
						words=ShaderCompile.splitToWords(text,null);
						fname=words[1];
						includefiles.push({node:node,file:ShaderCompile.includes[fname],ofs:node.text.length});
						continue ;
					}
				}else {
				preNode=parent.childs[parent.childs.length-1];
				if (preNode && !preNode.name){
					includefiles.length > 0 && ShaderCompile.splitToWords(text,preNode);
					noUseNode=node;
					preNode.text+="\n"+text;
					continue ;
				}
				includefiles.length > 0 && ShaderCompile.splitToWords(text,node);
			}
			node.setParent(parent);
		}
	}

	__proto.createShader=function(define,shaderName,createShader){
		var defMap={};
		var defineStr="";
		if (define){
			for (var i in define){
				defineStr+="#define "+i+"\n";
				defMap[i]=true;
			}
		};
		var vs=this._VS.toscript(defMap,[]);
		var ps=this._PS.toscript(defMap,[]);
		return (createShader || Shader.create)(defineStr+vs.join('\n'),defineStr+ps.join('\n'),shaderName,this._nameMap);
	}

	ShaderCompile._parseOne=function(attributes,uniforms,words,i,word,b){
		var one={type:ShaderCompile.shaderParamsMap[words[i+1]],name:words[i+2],size:isNaN(parseInt(words[i+3]))? 1 :parseInt(words[i+3])};
		if (b){
			if (word=="attribute"){
				attributes.push(one);
				}else {
				uniforms.push(one);
			}
		}
		if (words[i+3]==':'){
			one.type=words[i+4];
			i+=2;
		}
		i+=2;
		return i;
	}

	ShaderCompile.addInclude=function(fileName,txt){
		if (!txt || txt.length===0)
			throw new Error("add shader include file err:"+fileName);
		if (ShaderCompile.includes[fileName])
			throw new Error("add shader include file err, has add:"+fileName);
		ShaderCompile.includes[fileName]=new InlcudeFile(txt);
	}

	ShaderCompile.preGetParams=function(vs,ps){
		var text=[vs,ps];
		var result={};
		var attributes=[];
		var uniforms=[];
		var definesInfo={};
		var definesName=[];
		result.attributes=attributes;
		result.uniforms=uniforms;
		result.defines=definesInfo;
		var i=0,n=0,one;
		for (var s=0;s < 2;s++){
			text[s]=text[s].replace(ShaderCompile._removeAnnotation,"");
			var words=text[s].match(ShaderCompile._reg);
			var tempelse;
			for (i=0,n=words.length;i < n;i++){
				var word=words[i];
				if (word !="attribute" && word !="uniform"){
					if (word=="#define"){
						word=words[++i];
						definesName[word]=1;
						continue ;
						}else if (word=="#ifdef"){
						tempelse=words[++i];
						var def=definesInfo[tempelse]=definesInfo[tempelse] || [];
						for (i++;i < n;i++){
							word=words[i];
							if (word !="attribute" && word !="uniform"){
								if (word=="#else"){
									for (i++;i < n;i++){
										word=words[i];
										if (word !="attribute" && word !="uniform"){
											if (word=="#endif"){
												break ;
											}
											continue ;
										}
										i=ShaderCompile._parseOne(attributes,uniforms,words,i,word,!definesName[tempelse]);
									}
								}
								continue ;
							}
							i=ShaderCompile._parseOne(attributes,uniforms,words,i,word,definesName[tempelse]);
						}
					}
					continue ;
				}
				i=ShaderCompile._parseOne(attributes,uniforms,words,i,word,true);
			}
		}
		return result;
	}

	ShaderCompile.splitToWords=function(str,block){
		var out=[];
		var c;
		var ofs=-1;
		var word;
		for (var i=0,n=str.length;i < n;i++){
			c=str.charAt(i);
			if (" \t=+-*/&%!<>()'\",;".indexOf(c)>=0){
				if (ofs >=0 && (i-ofs)> 1){
					word=str.substr(ofs,i-ofs);
					out.push(word);
				}
				if (c=='"' || c=="'"){
					var ofs2=str.indexOf(c,i+1);
					if (ofs2 < 0){
						throw "Sharder err:"+str;
					}
					out.push(str.substr(i+1,ofs2-i-1));
					i=ofs2;
					ofs=-1;
					continue ;
				}
				if (c=='(' && block && out.length > 0){
					word=out[out.length-1]+";";
					if ("vec4;main;".indexOf(word)< 0)
						block.useFuns+=word;
				}
				ofs=-1;
				continue ;
			}
			if (ofs < 0)ofs=i;
		}
		if (ofs < n && (n-ofs)> 1){
			word=str.substr(ofs,n-ofs);
			out.push(word);
		}
		return out;
	}

	ShaderCompile.IFDEF_NO=0;
	ShaderCompile.IFDEF_YES=1;
	ShaderCompile.IFDEF_ELSE=2;
	ShaderCompile.IFDEF_PARENT=3;
	ShaderCompile._removeAnnotation=new RegExp("(/\\*([^*]|[\\r\\\n]|(\\*+([^*/]|[\\r\\n])))*\\*+/)|(//.*)","g");
	ShaderCompile._reg=new RegExp("(\".*\")|('.*')|([#\\w\\*-\\.+/()=<>{}\\\\]+)|([,;:\\\\])","g");
	ShaderCompile._splitToWordExps=new RegExp("[(\".*\")]+|[('.*')]+|([ \\t=\\+\\-*/&%!<>!%\(\),;])","g");
	ShaderCompile.includes={};
	__static(ShaderCompile,
	['shaderParamsMap',function(){return this.shaderParamsMap={"float":/*laya.webgl.WebGLContext.FLOAT*/0x1406,"int":/*laya.webgl.WebGLContext.INT*/0x1404,"bool":/*laya.webgl.WebGLContext.BOOL*/0x8B56,"vec2":/*laya.webgl.WebGLContext.FLOAT_VEC2*/0x8B50,"vec3":/*laya.webgl.WebGLContext.FLOAT_VEC3*/0x8B51,"vec4":/*laya.webgl.WebGLContext.FLOAT_VEC4*/0x8B52,"ivec2":/*laya.webgl.WebGLContext.INT_VEC2*/0x8B53,"ivec3":/*laya.webgl.WebGLContext.INT_VEC3*/0x8B54,"ivec4":/*laya.webgl.WebGLContext.INT_VEC4*/0x8B55,"bvec2":/*laya.webgl.WebGLContext.BOOL_VEC2*/0x8B57,"bvec3":/*laya.webgl.WebGLContext.BOOL_VEC3*/0x8B58,"bvec4":/*laya.webgl.WebGLContext.BOOL_VEC4*/0x8B59,"mat2":/*laya.webgl.WebGLContext.FLOAT_MAT2*/0x8B5A,"mat3":/*laya.webgl.WebGLContext.FLOAT_MAT3*/0x8B5B,"mat4":/*laya.webgl.WebGLContext.FLOAT_MAT4*/0x8B5C,"sampler2D":/*laya.webgl.WebGLContext.SAMPLER_2D*/0x8B5E,"samplerCube":/*laya.webgl.WebGLContext.SAMPLER_CUBE*/0x8B60};},'_splitToWordExps3',function(){return this._splitToWordExps3=new RegExp("[ \\t=\\+\\-*/&%!<>!%\(\),;\\|]","g");}
	]);
	ShaderCompile.__init$=function(){
		//class ShaderNode
		ShaderNode=(function(){
			function ShaderNode(includefiles){
				this.childs=[];
				this.text="";
				this.parent=null;
				this.name=null;
				this.noCompile=false;
				this.includefiles=null;
				this.condition=null;
				this.conditionType=0;
				this.useFuns="";
				this.z=0;
				this.src=null;
				this.includefiles=includefiles;
			}
			__class(ShaderNode,'');
			var __proto=ShaderNode.prototype;
			__proto.setParent=function(parent){
				parent.childs.push(this);
				this.z=parent.z+1;
				this.parent=parent;
			}
			__proto.setCondition=function(condition,type){
				if (condition){
					this.conditionType=type;
					condition=condition.replace(/(\s*$)/g,"");
					this.condition=function (){
						return this[condition];
					}
					this.condition.__condition=condition;
				}
			}
			__proto.toscript=function(def,out){
				return this._toscript(def,out,++ShaderNode.__id);
			}
			__proto._toscript=function(def,out,id){
				if (this.childs.length < 1 && !this.text)return out;
				var outIndex=out.length;
				if (this.condition){
					var ifdef=!!this.condition.call(def);
					this.conditionType===/*laya.webgl.utils.ShaderCompile.IFDEF_ELSE*/2 && (ifdef=!ifdef);
					if (!ifdef)return out;
				}
				this.text && out.push(this.text);
				this.childs.length > 0 && this.childs.forEach(function(o,index,arr){
					o._toscript(def,out,id);
				});
				if (this.includefiles.length > 0 && this.useFuns.length > 0){
					var funsCode;
					for (var i=0,n=this.includefiles.length;i < n;i++){
						if (this.includefiles[i].curUseID==id){
							continue ;
						}
						funsCode=this.includefiles[i].file.getFunsScript(this.useFuns);
						if (funsCode.length > 0){
							this.includefiles[i].curUseID=id;
							out[0]=funsCode+out[0];
						}
					}
				}
				return out;
			}
			ShaderNode.__id=1;
			return ShaderNode;
		})()
		//class InlcudeFile
		InlcudeFile=(function(){
			function InlcudeFile(txt){
				this.script=null;
				this.codes={};
				this.funs={};
				this.curUseID=-1;
				this.funnames="";
				this.script=txt;
				var begin=0,ofs=0,end=0;
				while (true){
					begin=txt.indexOf("#begin",begin);
					if (begin < 0)break ;
					end=begin+5;
					while (true){
						end=txt.indexOf("#end",end);
						if (end < 0)break ;
						if (txt.charAt(end+4)==='i')
							end+=5;
						else break ;
					}
					if (end < 0){
						throw "add include err,no #end:"+txt;
						return;
					}
					ofs=txt.indexOf('\n',begin);
					var words=ShaderCompile.splitToWords(txt.substr(begin,ofs-begin),null);
					if (words[1]=='code'){
						this.codes[words[2]]=txt.substr(ofs+1,end-ofs-1);
						}else if (words[1]=='function'){
						ofs=txt.indexOf("function",begin);
						ofs+="function".length;
						this.funs[words[3]]=txt.substr(ofs+1,end-ofs-1);
						this.funnames+=words[3]+";";
					}
					begin=end+1;
				}
			}
			__class(InlcudeFile,'');
			var __proto=InlcudeFile.prototype;
			__proto.getWith=function(name){
				var r=name ? this.codes[name] :this.script;
				if (!r){
					throw "get with error:"+name;
				}
				return r;
			}
			__proto.getFunsScript=function(funsdef){
				var r="";
				for (var i in this.funs){
					if (funsdef.indexOf(i+";")>=0){
						r+=this.funs[i];
					}
				}
				return r;
			}
			return InlcudeFile;
		})()
	}

	return ShaderCompile;
})()


/**
*@private
*/
//class laya.webgl.WebGL
var WebGL=(function(){
	function WebGL(){}
	__class(WebGL,'laya.webgl.WebGL');
	WebGL._uint8ArraySlice=function(){
		var _this=/*__JS__ */this;
		var sz=_this.length;
		var dec=new Uint8Array(_this.length);
		for (var i=0;i < sz;i++)dec[i]=_this[i];
		return dec;
	}

	WebGL._float32ArraySlice=function(){
		var _this=/*__JS__ */this;
		var sz=_this.length;
		var dec=new Float32Array(_this.length);
		for (var i=0;i < sz;i++)dec[i]=_this[i];
		return dec;
	}

	WebGL._uint16ArraySlice=function(__arg){
		var arg=arguments;
		var _this=/*__JS__ */this;
		var sz=0;
		var dec;
		var i=0;
		if (arg.length===0){
			sz=_this.length;
			dec=new Uint16Array(sz);
			for (i=0;i < sz;i++)
			dec[i]=_this[i];
			}else if (arg.length===2){
			var start=arg[0];
			var end=arg[1];
			if (end > start){
				sz=end-start;
				dec=new Uint16Array(sz);
				for (i=start;i < end;i++)
				dec[i-start]=_this[i];
				}else {
				dec=new Uint16Array(0);
			}
		}
		return dec;
	}

	WebGL.expandContext=function(){
		var from=Context.prototype;
		var to=/*__JS__ */CanvasRenderingContext2D.prototype;
		to.fillTrangles=from.fillTrangles;
		Buffer2D.__int__(null);
		to.setIBVB=function (x,y,ib,vb,numElement,mat,shader,shaderValues,startIndex,offset){
			(startIndex===void 0)&& (startIndex=0);
			(offset===void 0)&& (offset=0);
			if (ib===null){
				this._ib=this._ib || IndexBuffer2D.QuadrangleIB;
				ib=this._ib;
				GlUtils.expandIBQuadrangle(ib,(vb._byteLength / (4 *16)+8));
			}
			this._setIBVB(x,y,ib,vb,numElement,mat,shader,shaderValues,startIndex,offset);
		};
		to.fillTrangles=function (tex,x,y,points,m){
			this._curMat=this._curMat || Matrix.create();
			this._vb=this._vb || VertexBuffer2D.create();
			if (!this._ib){
				this._ib=IndexBuffer2D.create();
				GlUtils.fillIBQuadrangle(this._ib,length / 4);
			};
			var vb=this._vb;
			var length=points.length >> 4;
			GlUtils.fillTranglesVB(vb,x,y,points,m || this._curMat,0,0);
			GlUtils.expandIBQuadrangle(this._ib,(vb._byteLength / (4 *16)+8));
			var shaderValues=new Value2D(0x01,0);
			shaderValues.textureHost=tex;
			var sd=new Shader2X("attribute vec2 position; attribute vec2 texcoord; uniform vec2 size; uniform mat4 mmat; varying vec2 v_texcoord; void main() { vec4 p=vec4(position.xy,0.0,1.0);vec4 pos=mmat*p; gl_Position =vec4((pos.x/size.x-0.5)*2.0,(0.5-pos.y/size.y)*2.0,pos.z,1.0); v_texcoord = texcoord; }","precision mediump float; varying vec2 v_texcoord; uniform sampler2D texture; void main() {vec4 color= texture2D(texture, v_texcoord); color.a*=1.0; gl_FragColor= color;}");
			/*__JS__ */vb._vertType=3;
			this._setIBVB(x,y,this._ib,vb,length *6,m,sd,shaderValues,0,0);
		}
	}

	WebGL.enable=function(){
		Browser.__init__();
		if (Render.isConchApp){
			if (!Render.isConchWebGL){
				RunDriver.skinAniSprite=function (){
					var tSkinSprite=new SkinMesh()
					return tSkinSprite;
				}
				WebGL.expandContext();
				return false;
			}
		}
		RunDriver.getWebGLContext=function getWebGLContext (canvas){
			var gl;
			var names=["webgl","experimental-webgl","webkit-3d","moz-webgl"];
			for (var i=0;i < names.length;i++){
				try {
					gl=canvas.getContext(names[i],{stencil:Config.isStencil,alpha:Config.isAlpha,antialias:Config.isAntialias,premultipliedAlpha:Config.premultipliedAlpha,preserveDrawingBuffer:Config.preserveDrawingBuffer});
				}catch (e){}
				if (gl)
					return gl;
			}
			return null;
		}
		WebGL.mainContext=RunDriver.getWebGLContext(Render._mainCanvas);
		if (WebGL.mainContext==null)
			return false;
		if (Render.isWebGL)return true;
		HTMLImage.create=function (src,def){
			return new WebGLImage(src,def);
		}
		HTMLSubImage.create=function (canvas,offsetX,offsetY,width,height,atlasImage,src){
			return new WebGLSubImage(canvas,offsetX,offsetY,width,height,atlasImage,src);
		}
		Render.WebGL=WebGL;
		Render.isWebGL=true;
		DrawText.__init__();
		RunDriver.createRenderSprite=function (type,next){
			return new RenderSprite3D(type,next);
		}
		RunDriver.createWebGLContext2D=function (c){
			return new WebGLContext2D(c);
		}
		RunDriver.changeWebGLSize=function (width,height){
			laya.webgl.WebGL.onStageResize(width,height);
		}
		RunDriver.createGraphics=function (){
			return new GraphicsGL();
		};
		var action=RunDriver.createFilterAction;
		RunDriver.createFilterAction=action ? action :function (type){
			return new ColorFilterActionGL()
		}
		RunDriver.clear=function (color){
			RenderState2D.worldScissorTest && laya.webgl.WebGL.mainContext.disable(/*laya.webgl.WebGLContext.SCISSOR_TEST*/0x0C11);
			var ctx=Render.context.ctx;
			var c=(ctx._submits._length==0 || Config.preserveDrawingBuffer)? Color.create(color)._color :Stage._wgColor;
			if (c)ctx.clearBG(c[0],c[1],c[2],c[3]);
			RenderState2D.clear();
		}
		RunDriver.addToAtlas=function (texture,force){
			(force===void 0)&& (force=false);
			var bitmap=texture.bitmap;
			if (!Render.optimizeTextureMemory(texture.url,texture)){
				(bitmap).enableMerageInAtlas=false;
				return;
			}
			if ((Laya.__typeof(bitmap,'laya.webgl.resource.IMergeAtlasBitmap'))&& ((bitmap).allowMerageInAtlas)){
				bitmap.on(/*laya.events.Event.RECOVERED*/"recovered",texture,texture.addTextureToAtlas);
			}
		}
		RunDriver.isAtlas=function (bitmap){
			return (bitmap instanceof laya.webgl.atlas.AtlasWebGLCanvas );
		}
		AtlasResourceManager._enable();
		RunDriver.beginFlush=function (){
			var atlasResourceManager=AtlasResourceManager.instance;
			var count=atlasResourceManager.getAtlaserCount();
			for (var i=0;i < count;i++){
				var atlerCanvas=atlasResourceManager.getAtlaserByIndex(i).texture;
				(atlerCanvas._flashCacheImageNeedFlush)&& (RunDriver.flashFlushImage(atlerCanvas));
			}
		}
		RunDriver.drawToCanvas=function (sprite,_renderType,canvasWidth,canvasHeight,offsetX,offsetY){
			if (canvasWidth <=0 || canvasHeight <=0){
				console.log("[error] canvasWidth and canvasHeight should greater than zero");
			}
			offsetX-=sprite.x;
			offsetY-=sprite.y;
			canvasWidth |=1;canvasHeight |=1;offsetX |=1;offsetY |=1;
			var renderTarget=RenderTarget2D.create(canvasWidth,canvasHeight,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401,0,false);
			renderTarget.start();
			renderTarget.clear(0,0,0,0);
			Render.context.clear();
			RenderSprite.renders[_renderType]._fun(sprite,Render.context,offsetX,RenderState2D.height-canvasHeight+offsetY);
			Render.context.flush();
			renderTarget.end();
			var pixels=renderTarget.getData(0,0,canvasWidth,canvasHeight);
			renderTarget.recycle();
			if (pixels.byteLength !=canvasWidth *canvasHeight *4){
				console.log('drawToCanvas error: w:'+canvasWidth+',h:'+canvasHeight+',datalen:'+pixels.byteLength);
				return;
			};
			var htmlCanvas=new WebGLCanvas();
			htmlCanvas._canvas=Browser.createElement("canvas");
			htmlCanvas.size(canvasWidth,canvasHeight);
			var context=htmlCanvas._canvas.getContext('2d');
			Browser.canvas.size(canvasWidth,canvasHeight);
			var tempContext=Browser.context;
			var imgData=tempContext.createImageData(canvasWidth,canvasHeight);
			imgData.data.set(/*__JS__ */new Uint8ClampedArray(pixels.buffer));
			htmlCanvas._imgData=imgData;
			tempContext.putImageData(imgData,0,0);
			context.save();
			context.translate(0,canvasHeight);
			context.scale(1,-1);
			context.drawImage(Browser.canvas.source,0,0);
			context.restore();
			return htmlCanvas;
		}
		RunDriver.createFilterAction=function (type){
			var action;
			switch (type){
				case /*laya.filters.Filter.COLOR*/0x20:
					action=new ColorFilterActionGL();
					break ;
				}
			return action;
		}
		RunDriver.addTextureToAtlas=function (texture){
			texture._uvID++;
			AtlasResourceManager._atlasRestore++;
			((texture.bitmap).enableMerageInAtlas)&& (AtlasResourceManager.instance.addToAtlas(texture));
		}
		RunDriver.getTexturePixels=function (value,x,y,width,height){
			(Render.context.ctx).clear();
			var tSprite=new Sprite();
			tSprite.graphics.drawTexture(value,-x,-y);
			var tRenderTarget=RenderTarget2D.create(width,height);
			tRenderTarget.start();
			tRenderTarget.clear(0,0,0,0);
			tSprite.render(Render.context,0,0);
			(Render.context.ctx).flush();
			tRenderTarget.end();
			var tUint8Array=tRenderTarget.getData(0,0,width,height);
			var tArray=[];
			var tIndex=0;
			for (var i=height-1;i >=0;i--){
				for (var j=0;j < width;j++){
					tIndex=(i *width+j)*4;
					tArray.push(tUint8Array[tIndex]);
					tArray.push(tUint8Array[tIndex+1]);
					tArray.push(tUint8Array[tIndex+2]);
					tArray.push(tUint8Array[tIndex+3]);
				}
			}
			return tArray;
		}
		RunDriver.skinAniSprite=function (){
			var tSkinSprite=new SkinMesh()
			return tSkinSprite;
		}
		HTMLCanvas.create=function (type,canvas){
			var ret=new WebGLCanvas();
			ret._imgData=canvas;
			ret.flipY=false;
			return ret;
		}
		Filter._filterStart=function (scope,sprite,context,x,y){
			var b=scope.getValue("bounds");
			var source=RenderTarget2D.create(b.width,b.height);
			source.start();
			source.clear(0,0,0,0);
			scope.addValue("src",source);
			scope.addValue("ScissorTest",RenderState2D.worldScissorTest);
			if (RenderState2D.worldScissorTest){
				var tClilpRect=new Rectangle();
				tClilpRect.copyFrom((context.ctx)._clipRect)
				scope.addValue("clipRect",tClilpRect);
				RenderState2D.worldScissorTest=false;
				laya.webgl.WebGL.mainContext.disable(/*laya.webgl.WebGLContext.SCISSOR_TEST*/0x0C11);
			}
		}
		Filter._filterEnd=function (scope,sprite,context,x,y){
			var b=scope.getValue("bounds");
			var source=scope.getValue("src");
			source.end();
			var out=RenderTarget2D.create(b.width,b.height);
			out.start();
			out.clear(0,0,0,0);
			scope.addValue("out",out);
			sprite._set$P('_filterCache',out);
			sprite._set$P('_isHaveGlowFilter',scope.getValue("_isHaveGlowFilter"));
		}
		Filter._EndTarget=function (scope,context){
			var source=scope.getValue("src");
			source.recycle();
			var out=scope.getValue("out");
			out.end();
			var b=scope.getValue("ScissorTest");
			if (b){
				RenderState2D.worldScissorTest=true;
				laya.webgl.WebGL.mainContext.enable(/*laya.webgl.WebGLContext.SCISSOR_TEST*/0x0C11);
				context.ctx.save();
				var tClipRect=scope.getValue("clipRect");
				(context.ctx).clipRect(tClipRect.x,tClipRect.y,tClipRect.width,tClipRect.height);
			}
		}
		Filter._useSrc=function (scope){
			var source=scope.getValue("out");
			source.end();
			source=scope.getValue("src");
			source.start();
			source.clear(0,0,0,0);
		}
		Filter._endSrc=function (scope){
			var source=scope.getValue("src");
			source.end();
		}
		Filter._useOut=function (scope){
			var source=scope.getValue("src");
			source.end();
			source=scope.getValue("out");
			source.start();
			source.clear(0,0,0,0);
		}
		Filter._endOut=function (scope){
			var source=scope.getValue("out");
			source.end();
		}
		Filter._recycleScope=function (scope){
			scope.recycle();
		}
		Filter._filter=function (sprite,context,x,y){
			var next=this._next;
			if (next){
				var filters=sprite.filters,len=filters.length;
				if (len==1 && (filters[0].type==/*laya.filters.Filter.COLOR*/0x20)){
					context.ctx.save();
					context.ctx.setFilters([filters[0]]);
					next._fun.call(next,sprite,context,x,y);
					context.ctx.restore();
					return;
				};
				var shaderValue;
				var b;
				var scope=SubmitCMDScope.create();
				var p=Point.TEMP;
				var tMatrix=context.ctx._getTransformMatrix();
				var mat=Matrix.create();
				tMatrix.copyTo(mat);
				var tPadding=0;
				var tHalfPadding=0;
				var tIsHaveGlowFilter=false;
				var out=sprite._$P._filterCache ? sprite._$P._filterCache :null;
				if (!out || sprite._repaint){
					tIsHaveGlowFilter=sprite._isHaveGlowFilter();
					scope.addValue("_isHaveGlowFilter",tIsHaveGlowFilter);
					if (tIsHaveGlowFilter){
						tPadding=50;
						tHalfPadding=25;
					}
					b=new Rectangle();
					b.copyFrom((sprite).getSelfBounds());
					b.x+=(sprite).x;
					b.y+=(sprite).y;
					b.x-=(sprite).pivotX+4;
					b.y-=(sprite).pivotY+4;
					var tSX=b.x;
					var tSY=b.y;
					b.width+=(tPadding+8);
					b.height+=(tPadding+8);
					p.x=b.x *mat.a+b.y *mat.c;
					p.y=b.y *mat.d+b.x *mat.b;
					b.x=p.x;
					b.y=p.y;
					p.x=b.width *mat.a+b.height *mat.c;
					p.y=b.height *mat.d+b.width *mat.b;
					b.width=p.x;
					b.height=p.y;
					if (b.width <=0 || b.height <=0){
						return;
					}
					out && out.recycle();
					scope.addValue("bounds",b);
					var submit=SubmitCMD.create([scope,sprite,context,0,0],Filter._filterStart);
					context.addRenderObject(submit);
					(context.ctx)._renderKey=0;
					(context.ctx)._shader2D.glTexture=null;
					var tX=sprite.x-tSX+tHalfPadding;
					var tY=sprite.y-tSY+tHalfPadding;
					next._fun.call(next,sprite,context,tX,tY);
					submit=SubmitCMD.create([scope,sprite,context,0,0],Filter._filterEnd);
					context.addRenderObject(submit);
					for (var i=0;i < len;i++){
						if (i !=0){
							submit=SubmitCMD.create([scope],Filter._useSrc);
							context.addRenderObject(submit);
							shaderValue=Value2D.create(/*laya.webgl.shader.d2.ShaderDefines2D.TEXTURE2D*/0x01,0);
							Matrix.TEMP.identity();
							context.ctx.drawTarget(scope,0,0,b.width,b.height,Matrix.TEMP,"out",shaderValue,null,BlendMode.TOINT.overlay);
							submit=SubmitCMD.create([scope],Filter._useOut);
							context.addRenderObject(submit);
						};
						var fil=filters[i];
						fil.action.apply3d(scope,sprite,context,0,0);
					}
					submit=SubmitCMD.create([scope,context],Filter._EndTarget);
					context.addRenderObject(submit);
					}else {
					tIsHaveGlowFilter=sprite._$P._isHaveGlowFilter ? sprite._$P._isHaveGlowFilter :false;
					if (tIsHaveGlowFilter){
						tPadding=50;
						tHalfPadding=25;
					}
					b=sprite.getBounds();
					if (b.width <=0 || b.height <=0){
						return;
					}
					b.width+=tPadding;
					b.height+=tPadding;
					p.x=b.x *mat.a+b.y *mat.c;
					p.y=b.y *mat.d+b.x *mat.b;
					b.x=p.x;
					b.y=p.y;
					p.x=b.width *mat.a+b.height *mat.c;
					p.y=b.height *mat.d+b.width *mat.b;
					b.width=p.x;
					b.height=p.y;
					scope.addValue("out",out);
				}
				x=x-tHalfPadding-sprite.x;
				y=y-tHalfPadding-sprite.y;
				p.setTo(x,y);
				mat.transformPoint(p);
				x=p.x+b.x;
				y=p.y+b.y;
				shaderValue=Value2D.create(/*laya.webgl.shader.d2.ShaderDefines2D.TEXTURE2D*/0x01,0);
				Matrix.TEMP.identity();
				(context.ctx).drawTarget(scope,x,y,b.width,b.height,Matrix.TEMP,"out",shaderValue,null,BlendMode.TOINT.overlay);
				submit=SubmitCMD.create([scope],Filter._recycleScope);
				context.addRenderObject(submit);
				mat.destroy();
			}
		}
		Float32Array.prototype.slice || (Float32Array.prototype.slice=WebGL._float32ArraySlice);
		Uint16Array.prototype.slice || (Uint16Array.prototype.slice=WebGL._uint16ArraySlice);
		Uint8Array.prototype.slice || (Uint8Array.prototype.slice=WebGL._uint8ArraySlice);
		return true;
	}

	WebGL.onStageResize=function(width,height){
		if (WebGL.mainContext==null)return;
		WebGL.mainContext.viewport(0,0,width,height);
		RenderState2D.width=width;
		RenderState2D.height=height;
	}

	WebGL.onInvalidGLRes=function(){
		AtlasResourceManager.instance.freeAll();
		ResourceManager.releaseContentManagers(true);
		WebGL.doNodeRepaint(Laya.stage);
		WebGL.mainContext.viewport(0,0,RenderState2D.width,RenderState2D.height);
		Laya.stage.event(/*laya.events.Event.DEVICE_LOST*/"devicelost");
	}

	WebGL.doNodeRepaint=function(sprite){
		(sprite.numChildren==0)&& (sprite.repaint());
		for (var i=0;i < sprite.numChildren;i++)
		WebGL.doNodeRepaint(sprite.getChildAt(i));
	}

	WebGL.init=function(canvas,width,height){
		WebGL.mainCanvas=canvas;
		HTMLCanvas._createContext=function (canvas){
			return new WebGLContext2D(canvas);
		}
		WebGLCanvas._createContext=function (canvas){
			return new WebGLContext2D(canvas);
		};
		var gl=laya.webgl.WebGL.mainContext;
		if (gl.getShaderPrecisionFormat !=null){
			var vertexPrecisionFormat=gl.getShaderPrecisionFormat(/*laya.webgl.WebGLContext.VERTEX_SHADER*/0x8B31,/*laya.webgl.WebGLContext.HIGH_FLOAT*/0x8DF2);
			var framePrecisionFormat=gl.getShaderPrecisionFormat(/*laya.webgl.WebGLContext.FRAGMENT_SHADER*/0x8B30,/*laya.webgl.WebGLContext.HIGH_FLOAT*/0x8DF2);
			WebGL.shaderHighPrecision=(vertexPrecisionFormat.precision&&framePrecisionFormat.precision)? true :false;
			}else {
			WebGL.shaderHighPrecision=false;
		}
		WebGL.compressAstc=gl.getExtension("WEBGL_compressed_texture_astc");
		WebGL.compressAtc=gl.getExtension("WEBGL_compressed_texture_atc");
		WebGL.compressEtc=gl.getExtension("WEBGL_compressed_texture_etc");
		WebGL.compressEtc1=gl.getExtension("WEBGL_compressed_texture_etc1");
		WebGL.compressPvrtc=gl.getExtension("WEBGL_compressed_texture_pvrtc");
		WebGL.compressS3tc=gl.getExtension("WEBGL_compressed_texture_s3tc");
		WebGL.compressS3tc_srgb=gl.getExtension("WEBGL_compressed_texture_s3tc_srgb");
		gl.deleteTexture1=gl.deleteTexture;
		gl.deleteTexture=function (t){
			if (t==WebGLContext.curBindTexValue){
				WebGLContext.curBindTexValue=null;
			}
			gl.deleteTexture1(t);
		}
		WebGL.onStageResize(width,height);
		if (WebGL.mainContext==null)
			throw new Error("webGL getContext err!");
		System.__init__();
		AtlasResourceManager.__init__();
		ShaderDefines2D.__init__();
		Submit.__init__();
		WebGLContext2D.__init__();
		Value2D.__init__();
		Shader2D.__init__();
		Buffer2D.__int__(gl);
		BlendMode._init_(gl);
		if (Render.isConchApp){
			/*__JS__ */conch.setOnInvalidGLRes(WebGL.onInvalidGLRes);
		}
	}

	WebGL.compressAstc=null;
	WebGL.compressAtc=null;
	WebGL.compressEtc=null;
	WebGL.compressEtc1=null;
	WebGL.compressPvrtc=null;
	WebGL.compressS3tc=null;
	WebGL.compressS3tc_srgb=null;
	WebGL.mainCanvas=null;
	WebGL.mainContext=null;
	WebGL.antialias=true;
	WebGL.shaderHighPrecision=false;
	WebGL._bg_null=[0,0,0,0];
	return WebGL;
})()


//class laya.webgl.WebGLContext
var WebGLContext=(function(){
	function WebGLContext(){}
	__class(WebGLContext,'laya.webgl.WebGLContext');
	WebGLContext.UseProgram=function(program){
		if (WebGLContext._useProgram===program)return false;
		WebGL.mainContext.useProgram(program);
		WebGLContext._useProgram=program;
		return true;
	}

	WebGLContext.setDepthTest=function(gl,value){
		value!==WebGLContext._depthTest && (WebGLContext._depthTest=value,value?gl.enable(/*CLASS CONST:laya.webgl.WebGLContext.DEPTH_TEST*/0x0B71):gl.disable(/*CLASS CONST:laya.webgl.WebGLContext.DEPTH_TEST*/0x0B71));
	}

	WebGLContext.setDepthMask=function(gl,value){
		value!==WebGLContext._depthMask && (WebGLContext._depthMask=value,gl.depthMask(value));
	}

	WebGLContext.setDepthFunc=function(gl,value){
		value!==WebGLContext._depthFunc && (WebGLContext._depthFunc=value,gl.depthFunc(value));
	}

	WebGLContext.setBlend=function(gl,value){
		value!==WebGLContext._blend && (WebGLContext._blend=value,value?gl.enable(/*CLASS CONST:laya.webgl.WebGLContext.BLEND*/0x0BE2):gl.disable(/*CLASS CONST:laya.webgl.WebGLContext.BLEND*/0x0BE2));
	}

	WebGLContext.setBlendFunc=function(gl,sFactor,dFactor){
		(sFactor!==WebGLContext._sFactor||dFactor!==WebGLContext._dFactor)&& (WebGLContext._sFactor=sFactor,WebGLContext._dFactor=dFactor,gl.blendFunc(sFactor,dFactor));
	}

	WebGLContext.setCullFace=function(gl,value){
		value!==WebGLContext._cullFace && (WebGLContext._cullFace=value,value?gl.enable(/*CLASS CONST:laya.webgl.WebGLContext.CULL_FACE*/0x0B44):gl.disable(/*CLASS CONST:laya.webgl.WebGLContext.CULL_FACE*/0x0B44));
	}

	WebGLContext.setFrontFace=function(gl,value){
		value!==WebGLContext._frontFace && (WebGLContext._frontFace=value,gl.frontFace(value));
	}

	WebGLContext.bindTexture=function(gl,target,texture){
		gl.bindTexture(target,texture);
		WebGLContext.curBindTexTarget=target;
		WebGLContext.curBindTexValue=texture;
	}

	WebGLContext.DEPTH_BUFFER_BIT=0x00000100;
	WebGLContext.STENCIL_BUFFER_BIT=0x00000400;
	WebGLContext.COLOR_BUFFER_BIT=0x00004000;
	WebGLContext.POINTS=0x0000;
	WebGLContext.LINES=0x0001;
	WebGLContext.LINE_LOOP=0x0002;
	WebGLContext.LINE_STRIP=0x0003;
	WebGLContext.TRIANGLES=0x0004;
	WebGLContext.TRIANGLE_STRIP=0x0005;
	WebGLContext.TRIANGLE_FAN=0x0006;
	WebGLContext.ZERO=0;
	WebGLContext.ONE=1;
	WebGLContext.SRC_COLOR=0x0300;
	WebGLContext.ONE_MINUS_SRC_COLOR=0x0301;
	WebGLContext.SRC_ALPHA=0x0302;
	WebGLContext.ONE_MINUS_SRC_ALPHA=0x0303;
	WebGLContext.DST_ALPHA=0x0304;
	WebGLContext.ONE_MINUS_DST_ALPHA=0x0305;
	WebGLContext.DST_COLOR=0x0306;
	WebGLContext.ONE_MINUS_DST_COLOR=0x0307;
	WebGLContext.SRC_ALPHA_SATURATE=0x0308;
	WebGLContext.FUNC_ADD=0x8006;
	WebGLContext.BLEND_EQUATION=0x8009;
	WebGLContext.BLEND_EQUATION_RGB=0x8009;
	WebGLContext.BLEND_EQUATION_ALPHA=0x883D;
	WebGLContext.FUNC_SUBTRACT=0x800A;
	WebGLContext.FUNC_REVERSE_SUBTRACT=0x800B;
	WebGLContext.BLEND_DST_RGB=0x80C8;
	WebGLContext.BLEND_SRC_RGB=0x80C9;
	WebGLContext.BLEND_DST_ALPHA=0x80CA;
	WebGLContext.BLEND_SRC_ALPHA=0x80CB;
	WebGLContext.CONSTANT_COLOR=0x8001;
	WebGLContext.ONE_MINUS_CONSTANT_COLOR=0x8002;
	WebGLContext.CONSTANT_ALPHA=0x8003;
	WebGLContext.ONE_MINUS_CONSTANT_ALPHA=0x8004;
	WebGLContext.BLEND_COLOR=0x8005;
	WebGLContext.ARRAY_BUFFER=0x8892;
	WebGLContext.ELEMENT_ARRAY_BUFFER=0x8893;
	WebGLContext.ARRAY_BUFFER_BINDING=0x8894;
	WebGLContext.ELEMENT_ARRAY_BUFFER_BINDING=0x8895;
	WebGLContext.STREAM_DRAW=0x88E0;
	WebGLContext.STATIC_DRAW=0x88E4;
	WebGLContext.DYNAMIC_DRAW=0x88E8;
	WebGLContext.BUFFER_SIZE=0x8764;
	WebGLContext.BUFFER_USAGE=0x8765;
	WebGLContext.CURRENT_VERTEX_ATTRIB=0x8626;
	WebGLContext.FRONT=0x0404;
	WebGLContext.BACK=0x0405;
	WebGLContext.CULL_FACE=0x0B44;
	WebGLContext.FRONT_AND_BACK=0x0408;
	WebGLContext.BLEND=0x0BE2;
	WebGLContext.DITHER=0x0BD0;
	WebGLContext.STENCIL_TEST=0x0B90;
	WebGLContext.DEPTH_TEST=0x0B71;
	WebGLContext.SCISSOR_TEST=0x0C11;
	WebGLContext.POLYGON_OFFSET_FILL=0x8037;
	WebGLContext.SAMPLE_ALPHA_TO_COVERAGE=0x809E;
	WebGLContext.SAMPLE_COVERAGE=0x80A0;
	WebGLContext.NO_ERROR=0;
	WebGLContext.INVALID_ENUM=0x0500;
	WebGLContext.INVALID_VALUE=0x0501;
	WebGLContext.INVALID_OPERATION=0x0502;
	WebGLContext.OUT_OF_MEMORY=0x0505;
	WebGLContext.CW=0x0900;
	WebGLContext.CCW=0x0901;
	WebGLContext.LINE_WIDTH=0x0B21;
	WebGLContext.ALIASED_POINT_SIZE_RANGE=0x846D;
	WebGLContext.ALIASED_LINE_WIDTH_RANGE=0x846E;
	WebGLContext.CULL_FACE_MODE=0x0B45;
	WebGLContext.FRONT_FACE=0x0B46;
	WebGLContext.DEPTH_RANGE=0x0B70;
	WebGLContext.DEPTH_WRITEMASK=0x0B72;
	WebGLContext.DEPTH_CLEAR_VALUE=0x0B73;
	WebGLContext.DEPTH_FUNC=0x0B74;
	WebGLContext.STENCIL_CLEAR_VALUE=0x0B91;
	WebGLContext.STENCIL_FUNC=0x0B92;
	WebGLContext.STENCIL_FAIL=0x0B94;
	WebGLContext.STENCIL_PASS_DEPTH_FAIL=0x0B95;
	WebGLContext.STENCIL_PASS_DEPTH_PASS=0x0B96;
	WebGLContext.STENCIL_REF=0x0B97;
	WebGLContext.STENCIL_VALUE_MASK=0x0B93;
	WebGLContext.STENCIL_WRITEMASK=0x0B98;
	WebGLContext.STENCIL_BACK_FUNC=0x8800;
	WebGLContext.STENCIL_BACK_FAIL=0x8801;
	WebGLContext.STENCIL_BACK_PASS_DEPTH_FAIL=0x8802;
	WebGLContext.STENCIL_BACK_PASS_DEPTH_PASS=0x8803;
	WebGLContext.STENCIL_BACK_REF=0x8CA3;
	WebGLContext.STENCIL_BACK_VALUE_MASK=0x8CA4;
	WebGLContext.STENCIL_BACK_WRITEMASK=0x8CA5;
	WebGLContext.VIEWPORT=0x0BA2;
	WebGLContext.SCISSOR_BOX=0x0C10;
	WebGLContext.COLOR_CLEAR_VALUE=0x0C22;
	WebGLContext.COLOR_WRITEMASK=0x0C23;
	WebGLContext.UNPACK_ALIGNMENT=0x0CF5;
	WebGLContext.PACK_ALIGNMENT=0x0D05;
	WebGLContext.MAX_TEXTURE_SIZE=0x0D33;
	WebGLContext.MAX_VIEWPORT_DIMS=0x0D3A;
	WebGLContext.SUBPIXEL_BITS=0x0D50;
	WebGLContext.RED_BITS=0x0D52;
	WebGLContext.GREEN_BITS=0x0D53;
	WebGLContext.BLUE_BITS=0x0D54;
	WebGLContext.ALPHA_BITS=0x0D55;
	WebGLContext.DEPTH_BITS=0x0D56;
	WebGLContext.STENCIL_BITS=0x0D57;
	WebGLContext.POLYGON_OFFSET_UNITS=0x2A00;
	WebGLContext.POLYGON_OFFSET_FACTOR=0x8038;
	WebGLContext.TEXTURE_BINDING_2D=0x8069;
	WebGLContext.SAMPLE_BUFFERS=0x80A8;
	WebGLContext.SAMPLES=0x80A9;
	WebGLContext.SAMPLE_COVERAGE_VALUE=0x80AA;
	WebGLContext.SAMPLE_COVERAGE_INVERT=0x80AB;
	WebGLContext.NUM_COMPRESSED_TEXTURE_FORMATS=0x86A2;
	WebGLContext.COMPRESSED_TEXTURE_FORMATS=0x86A3;
	WebGLContext.DONT_CARE=0x1100;
	WebGLContext.FASTEST=0x1101;
	WebGLContext.NICEST=0x1102;
	WebGLContext.GENERATE_MIPMAP_HINT=0x8192;
	WebGLContext.BYTE=0x1400;
	WebGLContext.UNSIGNED_BYTE=0x1401;
	WebGLContext.SHORT=0x1402;
	WebGLContext.UNSIGNED_SHORT=0x1403;
	WebGLContext.INT=0x1404;
	WebGLContext.UNSIGNED_INT=0x1405;
	WebGLContext.FLOAT=0x1406;
	WebGLContext.DEPTH_COMPONENT=0x1902;
	WebGLContext.ALPHA=0x1906;
	WebGLContext.RGB=0x1907;
	WebGLContext.RGBA=0x1908;
	WebGLContext.LUMINANCE=0x1909;
	WebGLContext.LUMINANCE_ALPHA=0x190A;
	WebGLContext.UNSIGNED_SHORT_4_4_4_4=0x8033;
	WebGLContext.UNSIGNED_SHORT_5_5_5_1=0x8034;
	WebGLContext.UNSIGNED_SHORT_5_6_5=0x8363;
	WebGLContext.FRAGMENT_SHADER=0x8B30;
	WebGLContext.VERTEX_SHADER=0x8B31;
	WebGLContext.MAX_VERTEX_ATTRIBS=0x8869;
	WebGLContext.MAX_VERTEX_UNIFORM_VECTORS=0x8DFB;
	WebGLContext.MAX_VARYING_VECTORS=0x8DFC;
	WebGLContext.MAX_COMBINED_TEXTURE_IMAGE_UNITS=0x8B4D;
	WebGLContext.MAX_VERTEX_TEXTURE_IMAGE_UNITS=0x8B4C;
	WebGLContext.MAX_TEXTURE_IMAGE_UNITS=0x8872;
	WebGLContext.MAX_FRAGMENT_UNIFORM_VECTORS=0x8DFD;
	WebGLContext.SHADER_TYPE=0x8B4F;
	WebGLContext.DELETE_STATUS=0x8B80;
	WebGLContext.LINK_STATUS=0x8B82;
	WebGLContext.VALIDATE_STATUS=0x8B83;
	WebGLContext.ATTACHED_SHADERS=0x8B85;
	WebGLContext.ACTIVE_UNIFORMS=0x8B86;
	WebGLContext.ACTIVE_ATTRIBUTES=0x8B89;
	WebGLContext.SHADING_LANGUAGE_VERSION=0x8B8C;
	WebGLContext.CURRENT_PROGRAM=0x8B8D;
	WebGLContext.NEVER=0x0200;
	WebGLContext.LESS=0x0201;
	WebGLContext.EQUAL=0x0202;
	WebGLContext.LEQUAL=0x0203;
	WebGLContext.GREATER=0x0204;
	WebGLContext.NOTEQUAL=0x0205;
	WebGLContext.GEQUAL=0x0206;
	WebGLContext.ALWAYS=0x0207;
	WebGLContext.KEEP=0x1E00;
	WebGLContext.REPLACE=0x1E01;
	WebGLContext.INCR=0x1E02;
	WebGLContext.DECR=0x1E03;
	WebGLContext.INVERT=0x150A;
	WebGLContext.INCR_WRAP=0x8507;
	WebGLContext.DECR_WRAP=0x8508;
	WebGLContext.VENDOR=0x1F00;
	WebGLContext.RENDERER=0x1F01;
	WebGLContext.VERSION=0x1F02;
	WebGLContext.NEAREST=0x2600;
	WebGLContext.LINEAR=0x2601;
	WebGLContext.NEAREST_MIPMAP_NEAREST=0x2700;
	WebGLContext.LINEAR_MIPMAP_NEAREST=0x2701;
	WebGLContext.NEAREST_MIPMAP_LINEAR=0x2702;
	WebGLContext.LINEAR_MIPMAP_LINEAR=0x2703;
	WebGLContext.TEXTURE_MAG_FILTER=0x2800;
	WebGLContext.TEXTURE_MIN_FILTER=0x2801;
	WebGLContext.TEXTURE_WRAP_S=0x2802;
	WebGLContext.TEXTURE_WRAP_T=0x2803;
	WebGLContext.TEXTURE_2D=0x0DE1;
	WebGLContext.TEXTURE=0x1702;
	WebGLContext.TEXTURE_CUBE_MAP=0x8513;
	WebGLContext.TEXTURE_BINDING_CUBE_MAP=0x8514;
	WebGLContext.TEXTURE_CUBE_MAP_POSITIVE_X=0x8515;
	WebGLContext.TEXTURE_CUBE_MAP_NEGATIVE_X=0x8516;
	WebGLContext.TEXTURE_CUBE_MAP_POSITIVE_Y=0x8517;
	WebGLContext.TEXTURE_CUBE_MAP_NEGATIVE_Y=0x8518;
	WebGLContext.TEXTURE_CUBE_MAP_POSITIVE_Z=0x8519;
	WebGLContext.TEXTURE_CUBE_MAP_NEGATIVE_Z=0x851A;
	WebGLContext.MAX_CUBE_MAP_TEXTURE_SIZE=0x851C;
	WebGLContext.TEXTURE0=0x84C0;
	WebGLContext.TEXTURE1=0x84C1;
	WebGLContext.TEXTURE2=0x84C2;
	WebGLContext.TEXTURE3=0x84C3;
	WebGLContext.TEXTURE4=0x84C4;
	WebGLContext.TEXTURE5=0x84C5;
	WebGLContext.TEXTURE6=0x84C6;
	WebGLContext.TEXTURE7=0x84C7;
	WebGLContext.TEXTURE8=0x84C8;
	WebGLContext.TEXTURE9=0x84C9;
	WebGLContext.TEXTURE10=0x84CA;
	WebGLContext.TEXTURE11=0x84CB;
	WebGLContext.TEXTURE12=0x84CC;
	WebGLContext.TEXTURE13=0x84CD;
	WebGLContext.TEXTURE14=0x84CE;
	WebGLContext.TEXTURE15=0x84CF;
	WebGLContext.TEXTURE16=0x84D0;
	WebGLContext.TEXTURE17=0x84D1;
	WebGLContext.TEXTURE18=0x84D2;
	WebGLContext.TEXTURE19=0x84D3;
	WebGLContext.TEXTURE20=0x84D4;
	WebGLContext.TEXTURE21=0x84D5;
	WebGLContext.TEXTURE22=0x84D6;
	WebGLContext.TEXTURE23=0x84D7;
	WebGLContext.TEXTURE24=0x84D8;
	WebGLContext.TEXTURE25=0x84D9;
	WebGLContext.TEXTURE26=0x84DA;
	WebGLContext.TEXTURE27=0x84DB;
	WebGLContext.TEXTURE28=0x84DC;
	WebGLContext.TEXTURE29=0x84DD;
	WebGLContext.TEXTURE30=0x84DE;
	WebGLContext.TEXTURE31=0x84DF;
	WebGLContext.ACTIVE_TEXTURE=0x84E0;
	WebGLContext.REPEAT=0x2901;
	WebGLContext.CLAMP_TO_EDGE=0x812F;
	WebGLContext.MIRRORED_REPEAT=0x8370;
	WebGLContext.FLOAT_VEC2=0x8B50;
	WebGLContext.FLOAT_VEC3=0x8B51;
	WebGLContext.FLOAT_VEC4=0x8B52;
	WebGLContext.INT_VEC2=0x8B53;
	WebGLContext.INT_VEC3=0x8B54;
	WebGLContext.INT_VEC4=0x8B55;
	WebGLContext.BOOL=0x8B56;
	WebGLContext.BOOL_VEC2=0x8B57;
	WebGLContext.BOOL_VEC3=0x8B58;
	WebGLContext.BOOL_VEC4=0x8B59;
	WebGLContext.FLOAT_MAT2=0x8B5A;
	WebGLContext.FLOAT_MAT3=0x8B5B;
	WebGLContext.FLOAT_MAT4=0x8B5C;
	WebGLContext.SAMPLER_2D=0x8B5E;
	WebGLContext.SAMPLER_CUBE=0x8B60;
	WebGLContext.VERTEX_ATTRIB_ARRAY_ENABLED=0x8622;
	WebGLContext.VERTEX_ATTRIB_ARRAY_SIZE=0x8623;
	WebGLContext.VERTEX_ATTRIB_ARRAY_STRIDE=0x8624;
	WebGLContext.VERTEX_ATTRIB_ARRAY_TYPE=0x8625;
	WebGLContext.VERTEX_ATTRIB_ARRAY_NORMALIZED=0x886A;
	WebGLContext.VERTEX_ATTRIB_ARRAY_POINTER=0x8645;
	WebGLContext.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING=0x889F;
	WebGLContext.COMPILE_STATUS=0x8B81;
	WebGLContext.LOW_FLOAT=0x8DF0;
	WebGLContext.MEDIUM_FLOAT=0x8DF1;
	WebGLContext.HIGH_FLOAT=0x8DF2;
	WebGLContext.LOW_INT=0x8DF3;
	WebGLContext.MEDIUM_INT=0x8DF4;
	WebGLContext.HIGH_INT=0x8DF5;
	WebGLContext.FRAMEBUFFER=0x8D40;
	WebGLContext.RENDERBUFFER=0x8D41;
	WebGLContext.RGBA4=0x8056;
	WebGLContext.RGB5_A1=0x8057;
	WebGLContext.RGB565=0x8D62;
	WebGLContext.DEPTH_COMPONENT16=0x81A5;
	WebGLContext.STENCIL_INDEX=0x1901;
	WebGLContext.STENCIL_INDEX8=0x8D48;
	WebGLContext.DEPTH_STENCIL=0x84F9;
	WebGLContext.RENDERBUFFER_WIDTH=0x8D42;
	WebGLContext.RENDERBUFFER_HEIGHT=0x8D43;
	WebGLContext.RENDERBUFFER_INTERNAL_FORMAT=0x8D44;
	WebGLContext.RENDERBUFFER_RED_SIZE=0x8D50;
	WebGLContext.RENDERBUFFER_GREEN_SIZE=0x8D51;
	WebGLContext.RENDERBUFFER_BLUE_SIZE=0x8D52;
	WebGLContext.RENDERBUFFER_ALPHA_SIZE=0x8D53;
	WebGLContext.RENDERBUFFER_DEPTH_SIZE=0x8D54;
	WebGLContext.RENDERBUFFER_STENCIL_SIZE=0x8D55;
	WebGLContext.FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE=0x8CD0;
	WebGLContext.FRAMEBUFFER_ATTACHMENT_OBJECT_NAME=0x8CD1;
	WebGLContext.FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL=0x8CD2;
	WebGLContext.FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE=0x8CD3;
	WebGLContext.COLOR_ATTACHMENT0=0x8CE0;
	WebGLContext.DEPTH_ATTACHMENT=0x8D00;
	WebGLContext.STENCIL_ATTACHMENT=0x8D20;
	WebGLContext.DEPTH_STENCIL_ATTACHMENT=0x821A;
	WebGLContext.NONE=0;
	WebGLContext.FRAMEBUFFER_COMPLETE=0x8CD5;
	WebGLContext.FRAMEBUFFER_INCOMPLETE_ATTACHMENT=0x8CD6;
	WebGLContext.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT=0x8CD7;
	WebGLContext.FRAMEBUFFER_INCOMPLETE_DIMENSIONS=0x8CD9;
	WebGLContext.FRAMEBUFFER_UNSUPPORTED=0x8CDD;
	WebGLContext.FRAMEBUFFER_BINDING=0x8CA6;
	WebGLContext.RENDERBUFFER_BINDING=0x8CA7;
	WebGLContext.MAX_RENDERBUFFER_SIZE=0x84E8;
	WebGLContext.INVALID_FRAMEBUFFER_OPERATION=0x0506;
	WebGLContext.UNPACK_FLIP_Y_WEBGL=0x9240;
	WebGLContext.UNPACK_PREMULTIPLY_ALPHA_WEBGL=0x9241;
	WebGLContext.CONTEXT_LOST_WEBGL=0x9242;
	WebGLContext.UNPACK_COLORSPACE_CONVERSION_WEBGL=0x9243;
	WebGLContext.BROWSER_DEFAULT_WEBGL=0x9244;
	WebGLContext._useProgram=null;
	WebGLContext._depthTest=true;
	WebGLContext._depthMask=true;
	WebGLContext._blend=false;
	WebGLContext._cullFace=false;
	WebGLContext.curBindTexTarget=null;
	WebGLContext.curBindTexValue=null;
	__static(WebGLContext,
	['_depthFunc',function(){return this._depthFunc=/*CLASS CONST:laya.webgl.WebGLContext.LESS*/0x0201;},'_sFactor',function(){return this._sFactor=/*CLASS CONST:laya.webgl.WebGLContext.ONE*/1;},'_dFactor',function(){return this._dFactor=/*CLASS CONST:laya.webgl.WebGLContext.ZERO*/0;},'_frontFace',function(){return this._frontFace=/*CLASS CONST:laya.webgl.WebGLContext.CCW*/0x0901;}
	]);
	return WebGLContext;
})()


//class laya.webgl.display.GraphicsGL extends laya.display.Graphics
var GraphicsGL=(function(_super){
	function GraphicsGL(){
		GraphicsGL.__super.call(this);
	}

	__class(GraphicsGL,'laya.webgl.display.GraphicsGL',_super);
	var __proto=GraphicsGL.prototype;
	__proto.setShader=function(shader){
		this._saveToCmd(Render.context._setShader,[shader]);
	}

	__proto.setIBVB=function(x,y,ib,vb,numElement,shader){
		this._saveToCmd(Render.context._setIBVB,[x,y,ib,vb,numElement,shader]);
	}

	__proto.drawParticle=function(x,y,ps){
		var pt=RunDriver.createParticleTemplate2D(ps);
		pt.x=x;
		pt.y=y;
		this._saveToCmd(Render.context._drawParticle,[pt]);
	}

	return GraphicsGL;
})(Graphics)


//class laya.webgl.canvas.WebGLContext2D extends laya.resource.Context
var WebGLContext2D=(function(_super){
	var ContextParams;
	function WebGLContext2D(c){
		this._x=0;
		this._y=0;
		this._id=++WebGLContext2D._COUNT;
		//this._other=null;
		this._path=null;
		//this._primitiveValue2D=null;
		this._drawCount=1;
		this._maxNumEle=0;
		this._clear=false;
		this._isMain=false;
		this._atlasResourceChange=0;
		this._submits=null;
		this._curSubmit=null;
		this._ib=null;
		this._vb=null;
		//this._curMat=null;
		this._nBlendType=0;
		//this._save=null;
		//this._targets=null;
		//this._renderKey=NaN;
		this._saveMark=null;
		this._shader2D=null;
		//this._triangleMesh=null;
		//drawTriangles专用mesh。由于ib不固定，所以不能与_mesh通用
		this.meshlist=[];
		/**所cacheAs精灵*/
		//this.sprite=null;
		/*******************************************start矢量绘制***************************************************/
		this.mId=-1;
		this.mHaveKey=false;
		this.mHaveLineKey=false;
		this.mX=0;
		this.mY=0;
		WebGLContext2D.__super.call(this);
		this._width=99999999;
		this._height=99999999;
		this._clipRect=WebGLContext2D.MAXCLIPRECT;
		this.mOutPoint
		this._canvas=c;
		WebGLContext2D._contextcount++;
		if (Render.isFlash){
			this._ib=IndexBuffer2D.create(/*laya.webgl.WebGLContext.STATIC_DRAW*/0x88E4);
			GlUtils.fillIBQuadrangle(this._ib,16);
		}else
		this._ib=IndexBuffer2D.QuadrangleIB;
		this.clear();
	}

	__class(WebGLContext2D,'laya.webgl.canvas.WebGLContext2D',_super);
	var __proto=WebGLContext2D.prototype;
	__proto.setIsMainContext=function(){
		this._isMain=true;
	}

	__proto.clearBG=function(r,g,b,a){
		var gl=WebGL.mainContext;
		gl.clearColor(r,g,b,a);
		gl.clear(/*laya.webgl.WebGLContext.COLOR_BUFFER_BIT*/0x00004000);
	}

	__proto._getSubmits=function(){
		return this._submits;
	}

	__proto._releaseMem=function(){
		if (!this._submits)
			return;
		this._curMat.destroy();
		this._curMat=null;
		this._shader2D.destroy();
		this._shader2D=null;
		for (var i=0,n=this._submits._length;i < n;i++)
		this._submits[i].releaseRender();
		this._submits.length=0;
		this._submits._length=0;
		this._submits=null;
		this._curSubmit=null;
		this._path && this._path.recover();
		this._path=null;
		this._other && (this._other.font=null);
		this._save=null;
		if (this._vb){
			this._vb.releaseResource();
			this._vb.destroy();
			this._vb.destory();
			this._vb=null;
		}
	}

	__proto.destroy=function(){
		--WebGLContext2D._contextcount;
		this.sprite=null;
		this._releaseMem();
		this._targets && this._targets.destroy();
		this._targets=null;
		this._canvas=null;
		this._ib && (this._ib !=IndexBuffer2D.QuadrangleIB)&& this._ib.releaseResource();
	}

	__proto.clear=function(){
		if (!this._submits){
			this._other=ContextParams.DEFAULT;
			this._curMat=Matrix.create();
			this._vb=VertexBuffer2D.create(-1);
			this._submits=[];
			this._save=[SaveMark.Create(this)];
			this._save.length=10;
			this._shader2D=new Shader2D();
			this._triangleMesh=MeshTexture.getAMesh();
		}
		this._vb.clear();
		this._targets && (this._targets.repaint=true);
		this._other=ContextParams.DEFAULT;
		this._clear=true;
		this._repaint=false;
		this._drawCount=1;
		this._renderKey=0;
		this._other.lineWidth=this._shader2D.ALPHA=1.0;
		this._nBlendType=0;
		this._clipRect=WebGLContext2D.MAXCLIPRECT;
		this._curSubmit=Submit.RENDERBASE;
		this._shader2D.glTexture=null;
		this._shader2D.fillStyle=this._shader2D.strokeStyle=DrawStyle.DEFAULT;
		for (var i=0,n=this._submits._length;i < n;i++)
		this._submits[i].releaseRender();
		this._submits._length=0;
		this._curMat.identity();
		this._other.clear();
		this._saveMark=this._save[0];
		this._save._length=1;
	}

	__proto.size=function(w,h){
		if (this._width !=w || this._height !=h){
			if (w==0 || h==0){
				if (this._vb._byteLength !=0){
					this._width=w;
					this._height=h;
					this._vb.clear();
					this._vb.upload();
				}
				for (var i=0,n=this._submits._length;i < n;i++)
				this._submits[i].releaseRender();
				this._submits.length=0;
				this._submits._length=0;
				this._curSubmit=null;
				this._path && this._path.recover();
				this._path=null;
				this.sprite=null;
				this._targets && (this._targets.destroy());
				this._targets=null;
				}else {
				this._width=w;
				this._height=h;
				this._targets && (this._targets.size(w,h));
				this._canvas.memorySize-=this._canvas.memorySize;
			}
		}
		if (w===0 && h===0)this._releaseMem();
	}

	__proto._getTransformMatrix=function(){
		return this._curMat;
	}

	__proto.translate=function(x,y){
		if (x!==0 || y!==0){
			SaveTranslate.save(this);
			if (this._curMat.bTransform){
				SaveTransform.save(this);
				this._curMat.transformPointN(Point.TEMP.setTo(x,y));
				x=Point.TEMP.x;
				y=Point.TEMP.y;
			}
			this._x+=x;
			this._y+=y;
		}
	}

	__proto.save=function(){
		this._save[this._save._length++]=SaveMark.Create(this);
	}

	__proto.restore=function(){
		var sz=this._save._length;
		if (sz < 1)
			return;
		for (var i=sz-1;i >=0;i--){
			var o=this._save[i];
			o.restore(this);
			if (o.isSaveMark()){
				this._save._length=i;
				return;
			}
		}
	}

	__proto._fillText=function(txt,words,x,y,fontStr,color,strokeColor,lineWidth,textAlign,underLine){
		(underLine===void 0)&& (underLine=0);
		var shader=this._shader2D;
		var curShader=this._curSubmit.shaderValue;
		var font=fontStr ? FontInContext.create(fontStr):this._other.font;
		if (AtlasResourceManager.enabled){
			if (shader.ALPHA!==curShader.ALPHA)
				shader.glTexture=null;
			DrawText.drawText(this,txt,words,this._curMat,font,textAlign || this._other.textAlign,color,strokeColor,lineWidth,x,y,underLine);
			}else {
			var preDef=this._shader2D.defines.getValue();
			var colorAdd=color ? Color.create(color)._color :shader.colorAdd;
			if (shader.ALPHA!==curShader.ALPHA || colorAdd!==shader.colorAdd || curShader.colorAdd!==shader.colorAdd){
				shader.glTexture=null;
				shader.colorAdd=colorAdd;
			}
			DrawText.drawText(this,txt,words,this._curMat,font,textAlign || this._other.textAlign,color,strokeColor,lineWidth,x,y,underLine);
		}
	}

	//TODO:实现下划线
	__proto.fillWords=function(words,x,y,fontStr,color,underLine){
		this._fillText(null,words,x,y,fontStr,color,null,-1,null,underLine);
	}

	__proto.fillBorderWords=function(words,x,y,font,color,borderColor,lineWidth){
		this._fillBorderText(null,words,x,y,font,color,borderColor,lineWidth,null);
	}

	__proto.fillText=function(txt,x,y,fontStr,color,textAlign){
		this._fillText(txt,null,x,y,fontStr,color,null,-1,textAlign);
	}

	__proto.strokeText=function(txt,x,y,fontStr,color,lineWidth,textAlign){
		this._fillText(txt,null,x,y,fontStr,null,color,lineWidth || 1,textAlign);
	}

	__proto.fillBorderText=function(txt,x,y,fontStr,fillColor,borderColor,lineWidth,textAlign){
		this._fillBorderText(txt,null,x,y,fontStr,fillColor,borderColor,lineWidth,textAlign);
	}

	__proto._fillBorderText=function(txt,words,x,y,fontStr,fillColor,borderColor,lineWidth,textAlign){
		if (!AtlasResourceManager.enabled){
			this._fillText(txt,words,x,y,fontStr,null,borderColor,lineWidth || 1,textAlign);
			this._fillText(txt,words,x,y,fontStr,fillColor,null,-1,textAlign);
			return;
		};
		var shader=this._shader2D;
		var curShader=this._curSubmit.shaderValue;
		if (shader.ALPHA!==curShader.ALPHA)
			shader.glTexture=null;
		var font=fontStr ? (WebGLContext2D._fontTemp.setFont(fontStr),WebGLContext2D._fontTemp):this._other.font;
		DrawText.drawText(this,txt,words,this._curMat,font,textAlign || this._other.textAlign,fillColor,borderColor,lineWidth || 1,x,y,0);
	}

	__proto.fillRect=function(x,y,width,height,fillStyle){
		var vb=this._vb;
		if (GlUtils.fillRectImgVb(vb,this._clipRect,x,y,width,height,Texture.DEF_UV,this._curMat,this._x,this._y,0,0)){
			this._renderKey=0;
			var pre=this._shader2D.fillStyle;
			fillStyle && (this._shader2D.fillStyle=DrawStyle.create(fillStyle));
			var shader=this._shader2D;
			var curShader=this._curSubmit.shaderValue;
			if (shader.fillStyle!==curShader.fillStyle || shader.ALPHA!==curShader.ALPHA){
				shader.glTexture=null;
				var submit=this._curSubmit=Submit.createSubmit(this,this._ib,vb,((vb._byteLength-16 */*laya.webgl.utils.Buffer2D.FLOAT32*/4)/ 32)*3,Value2D.create(/*laya.webgl.shader.d2.ShaderDefines2D.COLOR2D*/0x02,0));
				submit.shaderValue.color=shader.fillStyle._color._color;
				submit.shaderValue.ALPHA=shader.ALPHA;
				this._submits[this._submits._length++]=submit;
			}
			this._curSubmit._numEle+=6;
			this._shader2D.fillStyle=pre;
		}
	}

	__proto.fillTexture=function(texture,x,y,width,height,type,offset,other){
		if (!(texture.loaded && texture.bitmap && texture.source)){
			if (this.sprite){
				Laya.timer.callLater(this,this._repaintSprite);
			}
			return;
		};
		var vb=this._vb;
		var w=texture.bitmap.width,h=texture.bitmap.height,uv=texture.uv;
		var ox=offset.x % texture.width,oy=offset.y % texture.height;
		if (w !=other.w || h !=other.h){
			if (!other.w && !other.h){
				other.oy=other.ox=0;
				switch (type){
					case "repeat":
						other.width=width;
						other.height=height;
						break ;
					case "repeat-x":
						other.width=width;
						if (oy < 0){
							if (texture.height+oy > height){
								other.height=height;
								}else {
								other.height=texture.height+oy;
							}
							}else {
							other.oy=oy;
							if (texture.height+oy > height){
								other.height=height-oy;
								}else {
								other.height=texture.height;
							}
						}
						break ;
					case "repeat-y":
						if (ox < 0){
							if (texture.width+ox > width){
								other.width=width;
								}else {
								other.width=texture.width+ox;
							}
							}else {
							other.ox=ox;
							if (texture.width+ox > width){
								other.width=width-ox;
								}else {
								other.width=texture.width;
							}
						}
						other.height=height;
						break ;
					default :
						other.width=width;
						other.height=height;
						break ;
					}
			}
			other.w=w;
			other.h=h;
			other.uv=[0,0,other.width / w,0,other.width / w,other.height / h,0,other.height / h];
		}
		x+=other.ox;
		y+=other.oy;
		ox-=other.ox;
		oy-=other.oy;
		if (GlUtils.fillRectImgVb(vb,this._clipRect,x,y,other.width,other.height,other.uv,this._curMat,this._x,this._y,0,0)){
			this._renderKey=0;
			var submit=SubmitTexture.create(this,this._ib,vb,((vb._byteLength-16 */*laya.webgl.utils.Buffer2D.FLOAT32*/4)/ 32)*3,Value2D.create(/*laya.webgl.shader.d2.ShaderDefines2D.FILLTEXTURE*/0x100,0));
			this._submits[this._submits._length++]=submit;
			var shaderValue=submit.shaderValue;
			shaderValue.textureHost=texture;
			var tTextureX=uv[0] *w;
			var tTextureY=uv[1] *h;
			var tTextureW=(uv[2]-uv[0])*w;
			var tTextureH=(uv[5]-uv[3])*h;
			var tx=-ox / w;
			var ty=-oy / h;
			shaderValue.u_TexRange[0]=tTextureX / w;
			shaderValue.u_TexRange[1]=tTextureW / w;
			shaderValue.u_TexRange[2]=tTextureY / h;
			shaderValue.u_TexRange[3]=tTextureH / h;
			shaderValue.u_offset[0]=tx;
			shaderValue.u_offset[1]=ty;
			if (AtlasResourceManager.enabled && !this._isMain)
				submit.addTexture(texture,(vb._byteLength >> 2)-/*CLASS CONST:laya.webgl.canvas.WebGLContext2D._RECTVBSIZE*/16);
			this._curSubmit=submit;
			submit._renderType=/*laya.webgl.submit.Submit.TYPE_FILLTEXTURE*/10017;
			submit._numEle+=6;
		}
	}

	__proto.setShader=function(shader){
		SaveBase.save(this,/*laya.webgl.canvas.save.SaveBase.TYPE_SHADER*/0x100000,this._shader2D,true);
		this._shader2D.shader=shader;
	}

	__proto.setFilters=function(value){
		SaveBase.save(this,/*laya.webgl.canvas.save.SaveBase.TYPE_FILTERS*/0x200000,this._shader2D,true);
		this._shader2D.filters=value;
		this._curSubmit=Submit.RENDERBASE;
		this._renderKey=0;
		this._drawCount++;
	}

	__proto.drawTexture=function(tex,x,y,width,height,tx,ty){
		this._drawTextureM(tex,x,y,width,height,tx,ty,null,1);
	}

	__proto.addTextureVb=function(invb,x,y){
		var finalVB=this._curSubmit._vb || this._vb;
		var vpos=(finalVB._byteLength >> 2);
		finalVB.byteLength=((vpos+/*CLASS CONST:laya.webgl.canvas.WebGLContext2D._RECTVBSIZE*/16)<< 2);
		var vbdata=finalVB.getFloat32Array();
		for (var i=0,ci=0;i < 16;i+=4){
			vbdata[vpos++]=invb[i]+x;
			vbdata[vpos++]=invb[i+1]+y;
			vbdata[vpos++]=invb[i+2];
			vbdata[vpos++]=invb[i+3];
		}
		this._curSubmit._numEle+=6;
		this._maxNumEle=Math.max(this._maxNumEle,this._curSubmit._numEle);
		finalVB._upload=true;
	}

	__proto.willDrawTexture=function(tex,alpha){
		if (!(tex.loaded && tex.bitmap && tex.source)){
			if (this.sprite){
				Laya.timer.callLater(this,this._repaintSprite);
			}
			return 0;
		};
		var webGLImg=tex.bitmap;
		var rid=webGLImg.id+this._shader2D.ALPHA *alpha+/*laya.webgl.submit.Submit.TYPE_TEXTURE*/10016;
		if (rid==this._renderKey)return rid;
		var shader=this._shader2D;
		var preAlpha=shader.ALPHA;
		var curShader=this._curSubmit.shaderValue;
		shader.ALPHA *=alpha;
		this._renderKey=rid;
		this._drawCount++;
		shader.glTexture=webGLImg;
		var vb=this._vb;
		var submit=null;
		var vbSize=(vb._byteLength / 32)*3;
		submit=SubmitTexture.create(this,this._ib,vb,vbSize,Value2D.create(/*laya.webgl.shader.d2.ShaderDefines2D.TEXTURE2D*/0x01,0));
		this._submits[this._submits._length++]=submit;
		submit.shaderValue.textureHost=tex;
		submit._renderType=/*laya.webgl.submit.Submit.TYPE_TEXTURE*/10016;
		submit._preIsSameTextureShader=this._curSubmit._renderType===/*laya.webgl.submit.Submit.TYPE_TEXTURE*/10016 && shader.ALPHA===curShader.ALPHA;
		this._curSubmit=submit;
		shader.ALPHA=preAlpha;
		return rid;
	}

	__proto.drawTextures=function(tex,pos,tx,ty){
		if (!(tex.loaded && tex.bitmap && tex.source)){
			this.sprite && Laya.timer.callLater(this,this._repaintSprite);
			return;
		};
		var pre=this._clipRect;
		this._clipRect=WebGLContext2D.MAXCLIPRECT;
		if (!this._drawTextureM(tex,pos[0],pos[1],tex.width,tex.height,tx,ty,null,1)){
			alert("drawTextures err");
			return;
		}
		this._clipRect=pre;
		Stat.drawCall++;
		if (pos.length < 4)
			return;
		var finalVB=this._curSubmit._vb || this._vb;
		var sx=this._curMat.a,sy=this._curMat.d;
		for (var i=2,sz=pos.length;i < sz;i+=2){
			GlUtils.copyPreImgVb(finalVB,(pos[i]-pos[i-2])*sx,(pos[i+1]-pos[i-1])*sy);
			this._curSubmit._numEle+=6;
		}
		this._maxNumEle=Math.max(this._maxNumEle,this._curSubmit._numEle);
	}

	__proto._drawTextureM=function(tex,x,y,width,height,tx,ty,m,alpha){
		if (!(tex.loaded && tex.source)){
			if (this.sprite){
				Laya.timer.callLater(this,this._repaintSprite);
			}
			return false;
		};
		var finalVB=this._curSubmit._vb || this._vb;
		var webGLImg=tex.bitmap;
		x+=tx;
		y+=ty;
		this._drawCount++;
		var rid=webGLImg.id+this._shader2D.ALPHA *alpha+/*laya.webgl.submit.Submit.TYPE_TEXTURE*/10016;
		if (rid !=this._renderKey){
			this._renderKey=rid;
			var curShader=this._curSubmit.shaderValue;
			var shader=this._shader2D;
			var alphaBack=shader.ALPHA;
			shader.ALPHA *=alpha;
			shader.glTexture=webGLImg;
			var vb=this._vb;
			var submit=null;
			var vbSize=(vb._byteLength / 32)*3;
			submit=SubmitTexture.create(this,this._ib,vb,vbSize,Value2D.create(/*laya.webgl.shader.d2.ShaderDefines2D.TEXTURE2D*/0x01,0));
			this._submits[this._submits._length++]=submit;
			submit.shaderValue.textureHost=tex;
			submit._renderType=/*laya.webgl.submit.Submit.TYPE_TEXTURE*/10016;
			submit._preIsSameTextureShader=this._curSubmit._renderType===/*laya.webgl.submit.Submit.TYPE_TEXTURE*/10016 && shader.ALPHA===curShader.ALPHA;
			this._curSubmit=submit;
			finalVB=this._curSubmit._vb || this._vb;
			shader.ALPHA=alphaBack;
		}
		if (GlUtils.fillRectImgVb(finalVB,this._clipRect,x,y,width || tex.width,height || tex.height,tex.uv,m || this._curMat,this._x,this._y,0,0)){
			if (AtlasResourceManager.enabled && !this._isMain)
				(this._curSubmit).addTexture(tex,(finalVB._byteLength >> 2)-/*CLASS CONST:laya.webgl.canvas.WebGLContext2D._RECTVBSIZE*/16);
			this._curSubmit._numEle+=6;
			this._maxNumEle=Math.max(this._maxNumEle,this._curSubmit._numEle);
			return true;
		}
		return false;
	}

	__proto._repaintSprite=function(){
		if(this.sprite)
			this.sprite.repaint();
	}

	//}
	__proto._drawText=function(tex,x,y,width,height,m,tx,ty,dx,dy){
		var webGLImg=tex.bitmap;
		this._drawCount++;
		var rid=webGLImg.id+this._shader2D.ALPHA+/*laya.webgl.submit.Submit.TYPE_TEXTURE*/10016;
		if (rid !=this._renderKey){
			this._renderKey=rid;
			var curShader=this._curSubmit.shaderValue;
			var shader=this._shader2D;
			shader.glTexture=webGLImg;
			var vb=this._vb;
			var submit=null;
			var submitID=NaN;
			var vbSize=(vb._byteLength / 32)*3;
			if (AtlasResourceManager.enabled){
				submit=SubmitTexture.create(this,this._ib,vb,vbSize,Value2D.create(/*laya.webgl.shader.d2.ShaderDefines2D.TEXTURE2D*/0x01,0));
				}else {
				submit=SubmitTexture.create(this,this._ib,vb,vbSize,TextSV.create());
			}
			submit._preIsSameTextureShader=this._curSubmit._renderType===/*laya.webgl.submit.Submit.TYPE_TEXTURE*/10016 && shader.ALPHA===curShader.ALPHA;
			this._submits[this._submits._length++]=submit;
			submit.shaderValue.textureHost=tex;
			submit._renderType=/*laya.webgl.submit.Submit.TYPE_TEXTURE*/10016;
			this._curSubmit=submit;
		}
		tex.active();
		var finalVB=this._curSubmit._vb || this._vb;
		if (GlUtils.fillRectImgVb(finalVB,this._clipRect,x+tx,y+ty,width || tex.width,height || tex.height,tex.uv,m || this._curMat,this._x,this._y,dx,dy,true)){
			if (AtlasResourceManager.enabled && !this._isMain){
				(this._curSubmit).addTexture(tex,(finalVB._byteLength >> 2)-/*CLASS CONST:laya.webgl.canvas.WebGLContext2D._RECTVBSIZE*/16);
			}
			this._curSubmit._numEle+=6;
			this._maxNumEle=Math.max(this._maxNumEle,this._curSubmit._numEle);
		}
	}

	__proto.drawTextureWithTransform=function(tex,x,y,width,height,transform,tx,ty,alpha){
		if (!transform){
			this._drawTextureM(tex,x,y,width,height,tx,ty,null,alpha);
			return;
		};
		var curMat=this._curMat;
		var prex=this._x;
		var prey=this._y;
		(tx!==0 || ty!==0)&& (this._x=tx *curMat.a+ty *curMat.c,this._y=ty *curMat.d+tx *curMat.b);
		if (transform && curMat.bTransform){
			Matrix.mul(transform,curMat,WebGLContext2D._tmpMatrix);
			transform=WebGLContext2D._tmpMatrix;
			transform._checkTransform();
			}else {
			this._x+=curMat.tx;
			this._y+=curMat.ty;
		}
		this._drawTextureM(tex,x,y,width,height,0,0,transform,alpha);
		this._x=prex;
		this._y=prey;
	}

	__proto.fillQuadrangle=function(tex,x,y,point4,m){
		var submit=this._curSubmit;
		var vb=this._vb;
		var shader=this._shader2D;
		var curShader=submit.shaderValue;
		this._renderKey=0;
		if (tex.bitmap){
			var t_tex=tex.bitmap;
			if (shader.glTexture !=t_tex || shader.ALPHA!==curShader.ALPHA){
				shader.glTexture=t_tex;
				submit=this._curSubmit=Submit.createSubmit(this,this._ib,vb,((vb._byteLength)/ 32)*3,Value2D.create(/*laya.webgl.shader.d2.ShaderDefines2D.TEXTURE2D*/0x01,0));
				submit.shaderValue.glTexture=t_tex;
				this._submits[this._submits._length++]=submit;
			}
			GlUtils.fillQuadrangleImgVb(vb,x,y,point4,tex.uv,m || this._curMat,this._x,this._y);
			}else {
			if (!submit.shaderValue.fillStyle || !submit.shaderValue.fillStyle.equal(tex)|| shader.ALPHA!==curShader.ALPHA){
				shader.glTexture=null;
				submit=this._curSubmit=Submit.createSubmit(this,this._ib,vb,((vb._byteLength)/ 32)*3,Value2D.create(/*laya.webgl.shader.d2.ShaderDefines2D.COLOR2D*/0x02,0));
				submit.shaderValue.defines.add(/*laya.webgl.shader.d2.ShaderDefines2D.COLOR2D*/0x02);
				submit.shaderValue.fillStyle=DrawStyle.create(tex);
				this._submits[this._submits._length++]=submit;
			}
			GlUtils.fillQuadrangleImgVb(vb,x,y,point4,Texture.DEF_UV,m || this._curMat,this._x,this._y);
		}
		submit._numEle+=6;
	}

	__proto.drawTexture2=function(x,y,pivotX,pivotY,transform,alpha,blendMode,args){
		if (alpha==0)return;
		var curMat=this._curMat;
		this._x=x *curMat.a+y *curMat.c;
		this._y=y *curMat.d+x *curMat.b;
		if (transform){
			if (curMat.bTransform || transform.bTransform){
				Matrix.mul(transform,curMat,WebGLContext2D._tmpMatrix);
				transform=WebGLContext2D._tmpMatrix;
				}else {
				this._x+=transform.tx+curMat.tx;
				this._y+=transform.ty+curMat.ty;
				transform=Matrix.EMPTY;
			}
		}
		if (alpha===1 && !blendMode)
			this._drawTextureM(args[0],args[1]-pivotX,args[2]-pivotY,args[3],args[4],0,0,transform,1);
		else {
			var preAlpha=this._shader2D.ALPHA;
			var preblendType=this._nBlendType;
			this._shader2D.ALPHA=alpha;
			blendMode && (this._nBlendType=BlendMode.TOINT(blendMode));
			this._drawTextureM(args[0],args[1]-pivotX,args[2]-pivotY,args[3],args[4],0,0,transform,1);
			this._shader2D.ALPHA=preAlpha;
			this._nBlendType=preblendType;
		}
		this._x=this._y=0;
	}

	__proto.drawCanvas=function(canvas,x,y,width,height){
		var src=canvas.context;
		this._renderKey=0;
		if (src._targets){
			this._submits[this._submits._length++]=SubmitCanvas.create(src,0,null);
			this._curSubmit=Submit.RENDERBASE;
			src._targets.drawTo(this,x,y,width,height);
			}else {
			var submit=this._submits[this._submits._length++]=SubmitCanvas.create(src,this._shader2D.ALPHA,this._shader2D.filters);
			var sx=width / canvas.width;
			var sy=height / canvas.height;
			var mat=submit._matrix;
			this._curMat.copyTo(mat);
			sx !=1 && sy !=1 && mat.scale(sx,sy);
			var tx=mat.tx,ty=mat.ty;
			mat.tx=mat.ty=0;
			mat.transformPoint(Point.TEMP.setTo(x,y));
			mat.translate(Point.TEMP.x+tx,Point.TEMP.y+ty);
			this._curSubmit=Submit.RENDERBASE;
		}
		if (Config.showCanvasMark){
			this.save();
			this.lineWidth=4;
			this.strokeStyle=src._targets ? "yellow" :"green";
			this.strokeRect(x-1,y-1,width+2,height+2,1);
			this.strokeRect(x,y,width,height,1);
			this.restore();
		}
	}

	__proto.drawTarget=function(scope,x,y,width,height,m,proName,shaderValue,uv,blend){
		(blend===void 0)&& (blend=-1);
		var vb=this._vb;
		if (GlUtils.fillRectImgVb(vb,this._clipRect,x,y,width,height,uv || Texture.DEF_UV,m || this._curMat,this._x,this._y,0,0)){
			this._renderKey=0;
			var shader=this._shader2D;
			shader.glTexture=null;
			var curShader=this._curSubmit.shaderValue;
			var submit=this._curSubmit=SubmitTarget.create(this,this._ib,vb,((vb._byteLength-16 */*laya.webgl.utils.Buffer2D.FLOAT32*/4)/ 32)*3,shaderValue,proName);
			if (blend==-1){
				submit.blendType=this._nBlendType;
				}else {
				submit.blendType=blend;
			}
			submit.scope=scope;
			this._submits[this._submits._length++]=submit;
			this._curSubmit._numEle+=6;
		}
	}

	/**
	*把颜色跟当前设置的alpha混合
	*@return
	*/
	__proto.mixRGBandAlpha=function(color){
		return this._mixRGBandAlpha(color,this._shader2D.ALPHA);
	}

	__proto._mixRGBandAlpha=function(color,alpha){
		var a=((color & 0xff000000)>>> 24);
		if (a !=0){
			a*=alpha;
			}else {
			a=alpha*255;
		}
		return (color & 0x00ffffff)| (a << 24);
	}

	__proto.drawTriangles=function(tex,x,y,vertices,uvs,indices,matrix,alpha,color,blendMode){
		if (!(tex.loaded && tex.source)){
			if (this.sprite){
				Laya.timer.callLater(this,this._repaintSprite);
			}
			return false;
		}
		this._drawCount++;
		var webGLImg=tex.bitmap;
		var rgba=this._mixRGBandAlpha(0xffffffff,alpha);
		var vertNum=vertices.length / 2;
		var eleNum=indices.length;
		this._renderKey=-1;
		var submit=this._curSubmit=SubmitTexture.create(this,this._triangleMesh.getIBR(),this._triangleMesh.getVBR(),this._triangleMesh.indexNum,Value2D.create(/*laya.webgl.shader.d2.ShaderDefines2D.TEXTURE2D*/0x01,0));
		submit.shaderValue.textureHost=tex;
		submit._renderType=/*laya.webgl.submit.Submit.TYPE_TEXTURE*/10016;
		this._submits[this._submits._length++]=submit;
		if(matrix){
			WebGLContext2D._tmpMatrix.a=matrix.a;WebGLContext2D._tmpMatrix.b=matrix.b;WebGLContext2D._tmpMatrix.c=matrix.c;WebGLContext2D._tmpMatrix.d=matrix.d;WebGLContext2D._tmpMatrix.tx=matrix.tx+x;WebGLContext2D._tmpMatrix.ty=matrix.ty+y;
			Matrix.mul(WebGLContext2D._tmpMatrix,this._curMat,WebGLContext2D._tmpMatrix);
			}else {
			WebGLContext2D._tmpMatrix.a=this._curMat.a;WebGLContext2D._tmpMatrix.b=this._curMat.b;WebGLContext2D._tmpMatrix.c=this._curMat.c;WebGLContext2D._tmpMatrix.d=this._curMat.d;WebGLContext2D._tmpMatrix.tx=this._curMat.tx+x;WebGLContext2D._tmpMatrix.ty=this._curMat.ty+y;
		}
		this._triangleMesh.addData(vertices,uvs,indices,WebGLContext2D._tmpMatrix,rgba,this);
		this._curSubmit._numEle+=eleNum;
		this._maxNumEle=Math.max(this._maxNumEle,this._curSubmit._numEle);
		return true;
	}

	__proto.transform=function(a,b,c,d,tx,ty){
		SaveTransform.save(this);
		Matrix.mul(Matrix.TEMP.setTo(a,b,c,d,tx,ty),this._curMat,this._curMat);
		this._curMat._checkTransform();
	}

	__proto.setTransformByMatrix=function(value){
		value.copyTo(this._curMat);
	}

	__proto.transformByMatrix=function(value){
		SaveTransform.save(this);
		Matrix.mul(value,this._curMat,this._curMat);
		this._curMat._checkTransform();
	}

	__proto.rotate=function(angle){
		SaveTransform.save(this);
		this._curMat.rotateEx(angle);
	}

	__proto.scale=function(scaleX,scaleY){
		SaveTransform.save(this);
		this._curMat.scaleEx(scaleX,scaleY);
	}

	__proto.clipRect=function(x,y,width,height){
		if (this._curMat.b !=0 || this._curMat.c !=0){
			this._renderKey=0;
			var submitStencil0=SubmitStencil.create(4);
			this.addRenderObject(submitStencil0);
			var vb=this._vb;
			var nPos=(vb._byteLength >> 2);
			if (GlUtils.fillRectImgVb(vb,null,x,y,width,height,Texture.DEF_UV,this._curMat,this._x,this._y,0,0)){
				var shader=this._shader2D;
				shader.glTexture=null;
				var submit=this._curSubmit=Submit.createSubmit(this,this._ib,vb,((vb._byteLength-16 */*laya.webgl.utils.Buffer2D.FLOAT32*/4)/ 32)*3,Value2D.create(/*laya.webgl.shader.d2.ShaderDefines2D.COLOR2D*/0x02,0));
				submit.shaderValue.ALPHA=1.0;
				this._submits[this._submits._length++]=submit;
				this._curSubmit._numEle+=6;
				}else {
				alert("clipRect calc stencil rect error");
			};
			var submitStencil1=SubmitStencil.create(5);
			this.addRenderObject(submitStencil1);
			var vbdata=vb.getFloat32Array();
			var minx=Math.min(Math.min(Math.min(vbdata[nPos+0],vbdata[nPos+4]),vbdata[nPos+8]),vbdata[nPos+12]);
			var maxx=Math.max(Math.max(Math.max(vbdata[nPos+0],vbdata[nPos+4]),vbdata[nPos+8]),vbdata[nPos+12]);
			var miny=Math.min(Math.min(Math.min(vbdata[nPos+1],vbdata[nPos+5]),vbdata[nPos+9]),vbdata[nPos+13]);
			var maxy=Math.max(Math.max(Math.max(vbdata[nPos+1],vbdata[nPos+5]),vbdata[nPos+9]),vbdata[nPos+13]);
			SaveClipRectStencil.save(this,submitStencil1,x,y,width,height,minx,miny,maxx-minx,maxy-miny);
			this._curSubmit=Submit.RENDERBASE;
			}else {
			width *=this._curMat.a;
			height *=this._curMat.d;
			var p=Point.TEMP;
			this._curMat.transformPoint(p.setTo(x,y));
			if (width < 0){
				p.x=p.x+width;
				width=-width;
			}
			if (height < 0){
				p.y=p.y+height;
				height=-height;
			}
			this._renderKey=0;
			var submitSc=this._curSubmit=SubmitScissor.create(this);
			this._submits[this._submits._length++]=submitSc;
			submitSc.submitIndex=this._submits._length;
			submitSc.submitLength=9999999;
			SaveClipRect.save(this,submitSc);
			var clip=this._clipRect;
			var x1=clip.x,y1=clip.y;
			var r=p.x+width,b=p.y+height;
			x1 < p.x && (clip.x=p.x);
			y1 < p.y && (clip.y=p.y);
			clip.width=Math.min(r,x1+clip.width)-clip.x;
			clip.height=Math.min(b,y1+clip.height)-clip.y;
			this._shader2D.glTexture=null;
			submitSc.clipRect.copyFrom(clip);
			this._curSubmit=Submit.RENDERBASE;
		}
	}

	__proto.setIBVB=function(x,y,ib,vb,numElement,mat,shader,shaderValues,startIndex,offset,type){
		(startIndex===void 0)&& (startIndex=0);
		(offset===void 0)&& (offset=0);
		(type===void 0)&& (type=0);
		if (ib===null){
			if (!Render.isFlash){
				ib=this._ib;
				}else {
				var falshVB=vb;
				(falshVB._selfIB)|| (falshVB._selfIB=IndexBuffer2D.create(/*laya.webgl.WebGLContext.STATIC_DRAW*/0x88E4));
				falshVB._selfIB.clear();
				ib=falshVB._selfIB;
			}
			GlUtils.expandIBQuadrangle(ib,(vb._byteLength / (/*laya.webgl.utils.Buffer2D.FLOAT32*/4 *vb.vertexStride *4)));
		}
		if (!shaderValues || !shader)
			throw Error("setIBVB must input:shader shaderValues");
		var submit=SubmitOtherIBVB.create(this,vb,ib,numElement,shader,shaderValues,startIndex,offset,type);
		mat || (mat=Matrix.EMPTY);
		mat.translate(x,y);
		Matrix.mul(mat,this._curMat,submit._mat);
		mat.translate(-x,-y);
		this._submits[this._submits._length++]=submit;
		this._curSubmit=Submit.RENDERBASE;
		this._renderKey=0;
	}

	__proto.addRenderObject=function(o){
		this._submits[this._submits._length++]=o;
	}

	__proto.fillTrangles=function(tex,x,y,points,m){
		var submit=this._curSubmit;
		var vb=this._vb;
		var shader=this._shader2D;
		var curShader=submit.shaderValue;
		var length=points.length >> 4;
		var t_tex=tex.bitmap;
		this._renderKey=0;
		if (shader.glTexture !=t_tex || shader.ALPHA!==curShader.ALPHA){
			submit=this._curSubmit=Submit.createSubmit(this,this._ib,vb,((vb._byteLength)/ 32)*3,Value2D.create(/*laya.webgl.shader.d2.ShaderDefines2D.TEXTURE2D*/0x01,0));
			submit.shaderValue.textureHost=tex;
			this._submits[this._submits._length++]=submit;
		}
		GlUtils.fillTranglesVB(vb,x,y,points,m || this._curMat,this._x,this._y);
		submit._numEle+=length *6;
	}

	__proto.submitElement=function(start,end){
		var renderList=this._submits;
		end < 0 && (end=renderList._length);
		while (start < end){
			start+=renderList[start].renderSubmit();
		}
	}

	__proto.finish=function(){
		WebGL.mainContext.finish();
	}

	__proto.flush=function(){
		var maxNum=Math.max(this._vb._byteLength / (/*laya.webgl.utils.Buffer2D.FLOAT32*/4 *16),this._maxNumEle / 6)+8;
		if (maxNum > (this._ib.bufferLength / (6 */*laya.webgl.utils.Buffer2D.SHORT*/2))){
			GlUtils.expandIBQuadrangle(this._ib,maxNum);
		}
		if (!this._isMain && AtlasResourceManager.enabled && AtlasResourceManager._atlasRestore > this._atlasResourceChange){
			this._atlasResourceChange=AtlasResourceManager._atlasRestore;
			var renderList=this._submits;
			for (var i=0,s=renderList._length;i < s;i++){
				var submit=renderList [i];
				if (submit.getRenderType()===/*laya.webgl.submit.Submit.TYPE_TEXTURE*/10016)
					(submit).checkTexture();
			}
		}
		this.submitElement(0,this._submits._length);
		this._path && this._path.reset();
		SkinMeshBuffer.instance && SkinMeshBuffer.getInstance().reset();
		var sz=0;
		for (i=0,sz=this.meshlist.length;i < sz;i++){
			var curm=this.meshlist[i];
			curm.canReuse?(curm.releaseMesh()):(curm.destroy());
		}
		this.meshlist.length=0;
		this._curSubmit=Submit.RENDERBASE;
		this._renderKey=0;
		this._triangleMesh=MeshTexture.getAMesh();
		this.meshlist.push(this._triangleMesh);
		return this._submits._length;
	}

	__proto.setPathId=function(id){
		this.mId=id;
		if (this.mId !=-1){
			this.mHaveKey=false;
			var tVGM=VectorGraphManager.getInstance();
			if (tVGM.shapeDic[this.mId]){
				this.mHaveKey=true;
			}
			this.mHaveLineKey=false;
			if (tVGM.shapeLineDic[this.mId]){
				this.mHaveLineKey=true;
			}
		}
	}

	__proto.movePath=function(x,y){
		var _x1=x,_y1=y;
		x=this._curMat.a *_x1+this._curMat.c *_y1+this._curMat.tx;
		y=this._curMat.b *_x1+this._curMat.d *_y1+this._curMat.ty;
		this.mX+=x;
		this.mY+=y;
	}

	__proto.beginPath=function(){
		var tPath=this._getPath();
		tPath.tempArray.length=0;
		tPath.closePath=false;
		this.mX=0;
		this.mY=0;
	}

	__proto.closePath=function(){
		this._path.closePath=true;
	}

	__proto.fill=function(isConvexPolygon){
		(isConvexPolygon===void 0)&& (isConvexPolygon=false);
		var tPath=this._getPath();
		this.drawPoly(0,0,tPath.tempArray,this.fillStyle._color.numColor,0,0,isConvexPolygon);
	}

	__proto.stroke=function(){
		var tPath=this._getPath();
		if (this.lineWidth > 0){
			if (this.mId==-1){
				tPath.drawLine(0,0,tPath.tempArray,this.lineWidth,this.strokeStyle._color.numColor);
				}else {
				if (this.mHaveLineKey){
					var tShapeLine=VectorGraphManager.getInstance().shapeLineDic[this.mId];
					tShapeLine.rebuild(tPath.tempArray);
					tPath.setGeomtry(tShapeLine);
					}else {
					VectorGraphManager.getInstance().addLine(this.mId,tPath.drawLine(0,0,tPath.tempArray,this.lineWidth,this.strokeStyle._color.numColor));
				}
			}
			tPath.update();
			var tPosArray=[this.mX,this.mY];
			var tempSubmit=Submit.createShape(this,tPath.ib,tPath.vb,tPath.count,tPath.offset,Value2D.create(/*laya.webgl.shader.d2.ShaderDefines2D.PRIMITIVE*/0x04,0));
			tempSubmit.shaderValue.ALPHA=this._shader2D.ALPHA;
			(tempSubmit.shaderValue).u_pos=tPosArray;
			tempSubmit.shaderValue.u_mmat2=RenderState2D.TEMPMAT4_ARRAY;
			this._submits[this._submits._length++]=tempSubmit;
			this._renderKey=-1;
		}
	}

	__proto.line=function(fromX,fromY,toX,toY,lineWidth,mat){
		var submit=this._curSubmit;
		var vb=this._vb;
		if (GlUtils.fillLineVb(vb,this._clipRect,fromX,fromY,toX,toY,lineWidth,mat)){
			this._renderKey=0;
			var shader=this._shader2D;
			var curShader=submit.shaderValue;
			if (shader.strokeStyle!==curShader.strokeStyle || shader.ALPHA!==curShader.ALPHA){
				shader.glTexture=null;
				submit=this._curSubmit=Submit.createSubmit(this,this._ib,vb,((vb._byteLength-16 */*laya.webgl.utils.Buffer2D.FLOAT32*/4)/ 32)*3,Value2D.create(/*laya.webgl.shader.d2.ShaderDefines2D.COLOR2D*/0x02,0));
				submit.shaderValue.strokeStyle=shader.strokeStyle;
				submit.shaderValue.mainID=/*laya.webgl.shader.d2.ShaderDefines2D.COLOR2D*/0x02;
				submit.shaderValue.ALPHA=shader.ALPHA;
				this._submits[this._submits._length++]=submit;
			}
			submit._numEle+=6;
		}
	}

	__proto.moveTo=function(x,y,b){
		(b===void 0)&& (b=true);
		var tPath=this._getPath();
		if (b){
			var _x1=x,_y1=y;
			x=this._curMat.a *_x1+this._curMat.c *_y1;
			y=this._curMat.b *_x1+this._curMat.d *_y1;
		}
		tPath.addPoint(x,y);
	}

	__proto.lineTo=function(x,y,b){
		(b===void 0)&& (b=true);
		var tPath=this._getPath();
		if (b){
			var _x1=x,_y1=y;
			x=this._curMat.a *_x1+this._curMat.c *_y1;
			y=this._curMat.b *_x1+this._curMat.d *_y1;
		}
		tPath.addPoint(x,y);
	}

	__proto.drawCurves=function(x,y,args){
		this.setPathId(-1);
		this.beginPath();
		this.strokeStyle=args[3];
		this.lineWidth=args[4];
		var points=args[2];
		x+=args[0],y+=args[1];
		this.movePath(x,y);
		this.moveTo(points[0],points[1]);
		var i=2,n=points.length;
		while (i < n){
			this.quadraticCurveTo(points[i++],points[i++],points[i++],points[i++]);
		}
		this.stroke();
	}

	__proto.arcTo=function(x1,y1,x2,y2,r){
		if (this.mId !=-1){
			if (this.mHaveKey){
				return;
			}
		};
		var i=0;
		var x=0,y=0;
		var tPath=this._getPath();
		this._curMat.copyTo(WebGLContext2D._tmpMatrix);
		WebGLContext2D._tmpMatrix.tx=WebGLContext2D._tmpMatrix.ty=0;
		WebGLContext2D._tempPoint.setTo(tPath.getEndPointX(),tPath.getEndPointY());
		WebGLContext2D._tmpMatrix.invertTransformPoint(WebGLContext2D._tempPoint);
		var dx=WebGLContext2D._tempPoint.x-x1;
		var dy=WebGLContext2D._tempPoint.y-y1;
		var len1=Math.sqrt(dx*dx+dy*dy);
		if (len1 <=0.000001){
			return;
		};
		var ndx=dx / len1;
		var ndy=dy / len1;
		var dx2=x2-x1;
		var dy2=y2-y1;
		var len22=dx2*dx2+dy2*dy2;
		var len2=Math.sqrt(len22);
		if (len2 <=0.000001){
			return;
		};
		var ndx2=dx2 / len2;
		var ndy2=dy2 / len2;
		var odx=ndx+ndx2;
		var ody=ndy+ndy2;
		var olen=Math.sqrt(odx*odx+ody*ody);
		if (olen <=0.000001){
			return;
		};
		var nOdx=odx / olen;
		var nOdy=ody / olen;
		var alpha=Math.acos(nOdx*ndx+nOdy*ndy);
		var halfAng=Math.PI / 2-alpha;
		len1=r / Math.tan(halfAng);
		var ptx1=len1*ndx+x1;
		var pty1=len1*ndy+y1;
		var orilen=Math.sqrt(len1*len1+r*r);
		var orix=x1+nOdx*orilen;
		var oriy=y1+nOdy*orilen;
		var ptx2=len1*ndx2+x1;
		var pty2=len1*ndy2+y1;
		var dir=ndx *ndy2-ndy *ndx2;
		var fChgAng=0;
		var sinx=0.0;
		var cosx=0.0;
		if (dir >=0){
			fChgAng=halfAng *2;
			var fda=fChgAng / WebGLContext2D.SEGNUM;
			sinx=Math.sin(fda);
			cosx=Math.cos(fda);
		}
		else {
			fChgAng=-halfAng *2;
			fda=fChgAng / WebGLContext2D.SEGNUM;
			sinx=Math.sin(fda);
			cosx=Math.cos(fda);
		}
		x=this._curMat.a *ptx1+this._curMat.c *pty1;
		y=this._curMat.b *ptx1+this._curMat.d *pty1;
		if (x !=this._path.getEndPointX()|| y !=this._path.getEndPointY()){
			tPath.addPoint(x,y);
		};
		var cvx=ptx1-orix;
		var cvy=pty1-oriy;
		var tx=0.0;
		var ty=0.0;
		for (i=0;i < WebGLContext2D.SEGNUM;i++){
			var cx=cvx*cosx+cvy*sinx;
			var cy=-cvx*sinx+cvy*cosx;
			x=cx+orix;
			y=cy+oriy;
			x1=this._curMat.a *x+this._curMat.c *y;
			y1=this._curMat.b *x+this._curMat.d *y;
			x=x1;
			y=y1;
			if (x !=this._path.getEndPointX()|| y !=this._path.getEndPointY()){
				tPath.addPoint(x,y);
			}
			cvx=cx;
			cvy=cy;
		}
	}

	__proto.arc=function(cx,cy,r,startAngle,endAngle,counterclockwise,b){
		(counterclockwise===void 0)&& (counterclockwise=false);
		(b===void 0)&& (b=true);
		if (this.mId !=-1){
			var tShape=VectorGraphManager.getInstance().shapeDic[this.mId];
			if (tShape){
				if (this.mHaveKey && !tShape.needUpdate(this._curMat))
					return;
			}
			cx=0;
			cy=0;
		};
		var a=0,da=0,hda=0,kappa=0;
		var dx=0,dy=0,x=0,y=0,tanx=0,tany=0;
		var px=0,py=0,ptanx=0,ptany=0;
		var i=0,ndivs=0,nvals=0;
		da=endAngle-startAngle;
		if (!counterclockwise){
			if (Math.abs(da)>=Math.PI *2){
				da=Math.PI *2;
				}else {
				while (da < 0.0){
					da+=Math.PI *2;
				}
			}
			}else {
			if (Math.abs(da)>=Math.PI *2){
				da=-Math.PI *2;
				}else {
				while (da > 0.0){
					da-=Math.PI *2;
				}
			}
		}
		if (r < 101){
			ndivs=Math.max(10,da *r / 5);
			}else if (r < 201){
			ndivs=Math.max(10,da *r / 20);
			}else {
			ndivs=Math.max(10,da *r / 40);
		}
		hda=(da / ndivs)/ 2.0;
		kappa=Math.abs(4 / 3 *(1-Math.cos(hda))/ Math.sin(hda));
		if (counterclockwise)
			kappa=-kappa;
		nvals=0;
		var tPath=this._getPath();
		var _x1=NaN,_y1=NaN;
		for (i=0;i <=ndivs;i++){
			a=startAngle+da *(i / ndivs);
			dx=Math.cos(a);
			dy=Math.sin(a);
			x=cx+dx *r;
			y=cy+dy *r;
			if (b){
				_x1=x,_y1=y;
				x=this._curMat.a *_x1+this._curMat.c *_y1;
				y=this._curMat.b *_x1+this._curMat.d *_y1;
			}
			if (x !=this._path.getEndPointX()|| y !=this._path.getEndPointY()){
				tPath.addPoint(x,y);
			}
		}
		dx=Math.cos(endAngle);
		dy=Math.sin(endAngle);
		x=cx+dx *r;
		y=cy+dy *r;
		if (b){
			_x1=x,_y1=y;
			x=this._curMat.a *_x1+this._curMat.c *_y1;
			y=this._curMat.b *_x1+this._curMat.d *_y1;
		}
		if (x !=this._path.getEndPointX()|| y !=this._path.getEndPointY()){
			tPath.addPoint(x,y);
		}
	}

	__proto.quadraticCurveTo=function(cpx,cpy,x,y){
		var tBezier=Bezier.I;
		var tResultArray=[];
		var _x1=x,_y1=y;
		x=this._curMat.a *_x1+this._curMat.c *_y1;
		y=this._curMat.b *_x1+this._curMat.d *_y1;
		_x1=cpx,_y1=cpy;
		cpx=this._curMat.a *_x1+this._curMat.c *_y1;
		cpy=this._curMat.b *_x1+this._curMat.d *_y1;
		var tArray=tBezier.getBezierPoints([this._path.getEndPointX(),this._path.getEndPointY(),cpx,cpy,x,y],30,2);
		for (var i=0,n=tArray.length / 2;i < n;i++){
			this.lineTo(tArray[i *2],tArray[i *2+1],false);
		}
		this.lineTo(x,y,false);
	}

	__proto.rect=function(x,y,width,height){
		this._other=this._other.make();
		this._other.path || (this._other.path=new Path());
		this._other.path.rect(x,y,width,height);
	}

	__proto.strokeRect=function(x,y,width,height,parameterLineWidth){
		var tW=parameterLineWidth *0.5;
		this.line(x-tW,y,x+width+tW,y,parameterLineWidth,this._curMat);
		this.line(x+width,y,x+width,y+height,parameterLineWidth,this._curMat);
		this.line(x,y,x,y+height,parameterLineWidth,this._curMat);
		this.line(x-tW,y+height,x+width+tW,y+height,parameterLineWidth,this._curMat);
	}

	__proto.clip=function(){}
	/**
	*画多边形(用)
	*@param x
	*@param y
	*@param points
	*/
	__proto.drawPoly=function(x,y,points,color,lineWidth,boderColor,isConvexPolygon){
		(isConvexPolygon===void 0)&& (isConvexPolygon=false);
		this._renderKey=0;
		this._shader2D.glTexture=null;
		var tPath=this._getPath();
		if (this.mId==-1){
			tPath.polygon(x,y,points,color,lineWidth ? lineWidth :1,boderColor)
			}else {
			if (this.mHaveKey){
				var tShape=VectorGraphManager.getInstance().shapeDic[this.mId];
				tShape.setMatrix(this._curMat);
				tShape.rebuild(tPath.tempArray);
				tPath.setGeomtry(tShape);
				}else {
				var t=tPath.polygon(x,y,points,color,lineWidth ? lineWidth :1,boderColor);
				VectorGraphManager.getInstance().addShape(this.mId,t);
				t.setMatrix(this._curMat);
			}
		}
		tPath.update();
		var tPosArray=[this.mX,this.mY];
		var tempSubmit;
		tempSubmit=Submit.createShape(this,tPath.ib,tPath.vb,tPath.count,tPath.offset,Value2D.create(/*laya.webgl.shader.d2.ShaderDefines2D.PRIMITIVE*/0x04,0));
		tempSubmit.shaderValue.ALPHA=this._shader2D.ALPHA;
		(tempSubmit.shaderValue).u_pos=tPosArray;
		tempSubmit.shaderValue.u_mmat2=RenderState2D.EMPTYMAT4_ARRAY;
		this._submits[this._submits._length++]=tempSubmit;
		if (lineWidth > 0){
			if (this.mHaveLineKey){
				var tShapeLine=VectorGraphManager.getInstance().shapeLineDic[this.mId];
				tShapeLine.rebuild(tPath.tempArray);
				tPath.setGeomtry(tShapeLine);
				}else {
				VectorGraphManager.getInstance().addShape(this.mId,tPath.drawLine(x,y,points,lineWidth,boderColor));
			}
			tPath.update();
			tempSubmit=Submit.createShape(this,tPath.ib,tPath.vb,tPath.count,tPath.offset,Value2D.create(/*laya.webgl.shader.d2.ShaderDefines2D.PRIMITIVE*/0x04,0));
			tempSubmit.shaderValue.ALPHA=this._shader2D.ALPHA;
			tempSubmit.shaderValue.u_mmat2=RenderState2D.EMPTYMAT4_ARRAY;
			this._submits[this._submits._length++]=tempSubmit;
		}
	}

	/*******************************************end矢量绘制***************************************************/
	__proto.drawParticle=function(x,y,pt){
		pt.x=x;
		pt.y=y;
		this._submits[this._submits._length++]=pt;
	}

	__proto._getPath=function(){
		return this._path || (this._path=new Path());
	}

	/*,_shader2D.ALPHA=1*/
	__getset(0,__proto,'globalCompositeOperation',function(){
		return BlendMode.NAMES[this._nBlendType];
		},function(value){
		var n=BlendMode.TOINT[value];
		n==null || (this._nBlendType===n)|| (SaveBase.save(this,/*laya.webgl.canvas.save.SaveBase.TYPE_GLOBALCOMPOSITEOPERATION*/0x10000,this,true),this._curSubmit=Submit.RENDERBASE,this._renderKey=0,this._nBlendType=n);
	});

	__getset(0,__proto,'strokeStyle',function(){
		return this._shader2D.strokeStyle;
		},function(value){
		this._shader2D.strokeStyle.equal(value)|| (SaveBase.save(this,/*laya.webgl.canvas.save.SaveBase.TYPE_STROKESTYLE*/0x200,this._shader2D,false),this._shader2D.strokeStyle=DrawStyle.create(value));
	});

	__getset(0,__proto,'globalAlpha',function(){
		return this._shader2D.ALPHA;
		},function(value){
		value=Math.floor(value *1000)/ 1000;
		if (value !=this._shader2D.ALPHA){
			SaveBase.save(this,/*laya.webgl.canvas.save.SaveBase.TYPE_ALPHA*/0x1,this._shader2D,true);
			this._shader2D.ALPHA=value;
		}
	});

	__getset(0,__proto,'asBitmap',null,function(value){
		if (value){
			this._targets || (this._targets=new RenderTargetMAX());
			this._targets.repaint=true;
			if (!this._width || !this._height)
				throw Error("asBitmap no size!");
			this._targets.setSP(this.sprite);
			this._targets.size(this._width,this._height);
		}else
		this._targets=null;
	});

	__getset(0,__proto,'fillStyle',function(){
		return this._shader2D.fillStyle;
		},function(value){
		this._shader2D.fillStyle.equal(value)|| (SaveBase.save(this,/*laya.webgl.canvas.save.SaveBase.TYPE_FILESTYLE*/0x2,this._shader2D,false),this._shader2D.fillStyle=DrawStyle.create(value));
	});

	__getset(0,__proto,'textAlign',function(){
		return this._other.textAlign;
		},function(value){
		(this._other.textAlign===value)|| (this._other=this._other.make(),SaveBase.save(this,/*laya.webgl.canvas.save.SaveBase.TYPE_TEXTALIGN*/0x8000,this._other,false),this._other.textAlign=value);
	});

	__getset(0,__proto,'lineWidth',function(){
		return this._other.lineWidth;
		},function(value){
		(this._other.lineWidth===value)|| (this._other=this._other.make(),SaveBase.save(this,/*laya.webgl.canvas.save.SaveBase.TYPE_LINEWIDTH*/0x100,this._other,false),this._other.lineWidth=value);
	});

	__getset(0,__proto,'textBaseline',function(){
		return this._other.textBaseline;
		},function(value){
		(this._other.textBaseline===value)|| (this._other=this._other.make(),SaveBase.save(this,/*laya.webgl.canvas.save.SaveBase.TYPE_TEXTBASELINE*/0x4000,this._other,false),this._other.textBaseline=value);
	});

	__getset(0,__proto,'font',null,function(str){
		if (str==this._other.font.toString())
			return;
		this._other=this._other.make();
		SaveBase.save(this,/*laya.webgl.canvas.save.SaveBase.TYPE_FONT*/0x8,this._other,false);
		this._other.font===FontInContext.EMPTY ? (this._other.font=new FontInContext(str)):(this._other.font.setFont(str));
	});

	WebGLContext2D.__init__=function(){
		ContextParams.DEFAULT=new ContextParams();
	}

	WebGLContext2D._tempPoint=new Point();
	WebGLContext2D._SUBMITVBSIZE=32000;
	WebGLContext2D._MAXSIZE=99999999;
	WebGLContext2D._RECTVBSIZE=16;
	WebGLContext2D.MAXCLIPRECT=new Rectangle(0,0,99999999,99999999);
	WebGLContext2D._COUNT=0;
	WebGLContext2D._tmpMatrix=new Matrix();
	WebGLContext2D.SEGNUM=32;
	WebGLContext2D._contextcount=0;
	__static(WebGLContext2D,
	['_fontTemp',function(){return this._fontTemp=new FontInContext();},'_drawStyleTemp',function(){return this._drawStyleTemp=new DrawStyle(null);}
	]);
	WebGLContext2D.__init$=function(){
		//class ContextParams
		ContextParams=(function(){
			function ContextParams(){
				this.lineWidth=1;
				this.path=null;
				this.textAlign=null;
				this.textBaseline=null;
				this.font=FontInContext.EMPTY;
			}
			__class(ContextParams,'');
			var __proto=ContextParams.prototype;
			__proto.clear=function(){
				this.lineWidth=1;
				this.path && this.path.clear();
				this.textAlign=this.textBaseline=null;
				this.font=FontInContext.EMPTY;
			}
			__proto.make=function(){
				return this===ContextParams.DEFAULT ? new ContextParams():this;
			}
			ContextParams.DEFAULT=null;
			return ContextParams;
		})()
	}

	return WebGLContext2D;
})(Context)


//class laya.webgl.shader.d2.value.Value2D extends laya.webgl.shader.ShaderValue
var Value2D=(function(_super){
	function Value2D(mainID,subID){
		this.size=[0,0];
		this.alpha=1.0;
		//this.mmat=null;
		this.ALPHA=1.0;
		//this.shader=null;
		//this.mainID=0;
		this.subID=0;
		//this.filters=null;
		//this.textureHost=null;
		//this.texture=null;
		//this.fillStyle=null;
		//this.color=null;
		//this.strokeStyle=null;
		//this.colorAdd=null;
		//this.glTexture=null;
		//this.u_mmat2=null;
		//this._inClassCache=null;
		this._cacheID=0;
		Value2D.__super.call(this);
		this.defines=new ShaderDefines2D();
		this.position=Value2D._POSITION;
		this.mainID=mainID;
		this.subID=subID;
		this.textureHost=null;
		this.texture=null;
		this.fillStyle=null;
		this.color=null;
		this.strokeStyle=null;
		this.colorAdd=null;
		this.glTexture=null;
		this.u_mmat2=null;
		this._cacheID=mainID|subID;
		this._inClassCache=Value2D._cache[this._cacheID];
		if (mainID>0 && !this._inClassCache){
			this._inClassCache=Value2D._cache[this._cacheID]=[];
			this._inClassCache._length=0;
		}
		this.clear();
	}

	__class(Value2D,'laya.webgl.shader.d2.value.Value2D',_super);
	var __proto=Value2D.prototype;
	__proto.setValue=function(value){}
	//throw new Error("todo in subclass");
	__proto.refresh=function(){
		var size=this.size;
		size[0]=RenderState2D.width;
		size[1]=RenderState2D.height;
		this.alpha=this.ALPHA *RenderState2D.worldAlpha;
		this.mmat=RenderState2D.worldMatrix4;
		return this;
	}

	__proto._ShaderWithCompile=function(){
		return Shader.withCompile2D(0,this.mainID,this.defines.toNameDic(),this.mainID | this.defines._value,Shader2X.create);
	}

	__proto._withWorldShaderDefines=function(){
		var defs=RenderState2D.worldShaderDefines;
		var sd=Shader.sharders [this.mainID | this.defines._value | defs.getValue()];
		if (!sd){
			var def={};
			var dic;
			var name;
			dic=this.defines.toNameDic();for (name in dic)def[name]="";
			dic=defs.toNameDic();for (name in dic)def[name]="";
			sd=Shader.withCompile2D(0,this.mainID,def,this.mainID | this.defines._value| defs.getValue(),Shader2X.create);
		};
		var worldFilters=RenderState2D.worldFilters;
		if (!worldFilters)return sd;
		var n=worldFilters.length,f;
		for (var i=0;i < n;i++){
			((f=worldFilters[i]))&& f.action.setValue(this);
		}
		return sd;
	}

	__proto.upload=function(){
		var renderstate2d=RenderState2D;
		this.alpha=this.ALPHA *renderstate2d.worldAlpha;
		if (RenderState2D.worldMatrix4!==RenderState2D.TEMPMAT4_ARRAY)this.defines.add(/*laya.webgl.shader.d2.ShaderDefines2D.WORLDMAT*/0x80);
		(WebGL.shaderHighPrecision)&& (this.defines.add(/*laya.webgl.shader.d2.ShaderDefines2D.SHADERDEFINE_FSHIGHPRECISION*/0x400));
		var sd=renderstate2d.worldShaderDefines?this._withWorldShaderDefines():(Shader.sharders [this.mainID | this.defines._value] || this._ShaderWithCompile());
		var params;
		this.size[0]=renderstate2d.width,this.size[1]=renderstate2d.height;
		this.mmat=renderstate2d.worldMatrix4;
		if (BaseShader.activeShader!==sd){
			if (sd._shaderValueWidth!==renderstate2d.width || sd._shaderValueHeight!==renderstate2d.height){
				sd._shaderValueWidth=renderstate2d.width;
				sd._shaderValueHeight=renderstate2d.height;
			}
			else{
				params=sd._params2dQuick2 || sd._make2dQuick2();
			}
			sd.upload(this,params);
		}
		else{
			if (sd._shaderValueWidth!==renderstate2d.width || sd._shaderValueHeight!==renderstate2d.height){
				sd._shaderValueWidth=renderstate2d.width;
				sd._shaderValueHeight=renderstate2d.height;
			}
			else{
				params=(sd._params2dQuick1)|| sd._make2dQuick1();
			}
			sd.upload(this,params);
		}
	}

	__proto.setFilters=function(value){
		this.filters=value;
		if (!value)
			return;
		var n=value.length,f;
		for (var i=0;i < n;i++){
			f=value[i];
			if (f){
				this.defines.add(f.type);
				f.action.setValue(this);
			}
		}
	}

	__proto.clear=function(){
		this.defines.setValue(this.subID);
	}

	__proto.release=function(){
		this._inClassCache[this._inClassCache._length++]=this;
		this.fillStyle=null;
		this.strokeStyle=null;
		this.clear();
	}

	Value2D._initone=function(type,classT){
		Value2D._typeClass[type]=classT;
		Value2D._cache[type]=[];
		Value2D._cache[type]._length=0;
	}

	Value2D.__init__=function(){
		Value2D._POSITION=[2,/*laya.webgl.WebGLContext.FLOAT*/0x1406,false,4 *CONST3D2D.BYTES_PE,0];
		Value2D._TEXCOORD=[2,/*laya.webgl.WebGLContext.FLOAT*/0x1406,false,4 *CONST3D2D.BYTES_PE,2 *CONST3D2D.BYTES_PE];
		Value2D._initone(/*laya.webgl.shader.d2.ShaderDefines2D.COLOR2D*/0x02,Color2dSV);
		Value2D._initone(/*laya.webgl.shader.d2.ShaderDefines2D.PRIMITIVE*/0x04,PrimitiveSV);
		Value2D._initone(/*laya.webgl.shader.d2.ShaderDefines2D.FILLTEXTURE*/0x100,FillTextureSV);
		Value2D._initone(/*laya.webgl.shader.d2.ShaderDefines2D.SKINMESH*/0x200,SkinSV);
		Value2D._initone(/*laya.webgl.shader.d2.ShaderDefines2D.TEXTURE2D*/0x01,TextureSV);
		Value2D._initone(/*laya.webgl.shader.d2.ShaderDefines2D.TEXTURE2D*/0x01 | /*laya.webgl.shader.d2.ShaderDefines2D.COLORADD*/0x40,TextSV);
		Value2D._initone(/*laya.webgl.shader.d2.ShaderDefines2D.TEXTURE2D*/0x01 | /*laya.webgl.shader.d2.ShaderDefines2D.FILTERGLOW*/0x08,TextureSV);
	}

	Value2D.create=function(mainType,subType){
		var types=Value2D._cache[mainType|subType];
		if (types._length)
			return types[--types._length];
		else
		return new Value2D._typeClass[mainType|subType](subType);
	}

	Value2D._POSITION=null;
	Value2D._TEXCOORD=null;
	Value2D._cache=[];
	Value2D._typeClass=[];
	Value2D.TEMPMAT4_ARRAY=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];
	return Value2D;
})(ShaderValue)


//class laya.webgl.utils.RenderSprite3D extends laya.renders.RenderSprite
var RenderSprite3D=(function(_super){
	function RenderSprite3D(type,next){
		RenderSprite3D.__super.call(this,type,next);
	}

	__class(RenderSprite3D,'laya.webgl.utils.RenderSprite3D',_super);
	var __proto=RenderSprite3D.prototype;
	__proto.onCreate=function(type){
		switch (type){
			case 0x08:
				this._fun=this._blend;
				return;
			case 0x04:
				this._fun=this._transform;
				return;
			}
	}

	__proto._mask=function(sprite,context,x,y){
		var next=this._next;
		var mask=sprite.mask;
		var submitCMD;
		var submitStencil;
		if (mask){
			context.ctx.save();
			var preBlendMode=(context.ctx).globalCompositeOperation;
			var tRect=new Rectangle();
			tRect.copyFrom(mask.getBounds());
			tRect.width=Math.round(tRect.width);
			tRect.height=Math.round(tRect.height);
			tRect.x=Math.round(tRect.x);
			tRect.y=Math.round(tRect.y);
			if (tRect.width > 0 && tRect.height > 0){
				var tf=sprite._style._tf;
				var scope=SubmitCMDScope.create();
				scope.addValue("bounds",tRect);
				submitCMD=SubmitCMD.create([scope,context],laya.webgl.utils.RenderSprite3D.tmpTarget);
				context.addRenderObject(submitCMD);
				mask.render(context,-tRect.x,-tRect.y);
				submitCMD=SubmitCMD.create([scope],laya.webgl.utils.RenderSprite3D.endTmpTarget);
				context.addRenderObject(submitCMD);
				context.ctx.save();
				context.clipRect(x-tf.translateX+tRect.x,y-tf.translateY+tRect.y,tRect.width,tRect.height);
				next._fun.call(next,sprite,context,x,y);
				context.ctx.restore();
				submitStencil=SubmitStencil.create(6);
				preBlendMode=(context.ctx).globalCompositeOperation;
				submitStencil.blendMode="mask";
				context.addRenderObject(submitStencil);
				Matrix.TEMP.identity();
				var shaderValue=Value2D.create(/*laya.webgl.shader.d2.ShaderDefines2D.TEXTURE2D*/0x01,0);
				var uv=Texture.INV_UV;
				var w=tRect.width;
				var h=tRect.height;
				var tempLimit=32;
				if (tRect.width < tempLimit || tRect.height < tempLimit){
					uv=RenderSprite3D.tempUV;
					uv[0]=0;
					uv[1]=0;
					uv[2]=(tRect.width >=32)? 1 :tRect.width/tempLimit;
					uv[3]=0
					uv[4]=(tRect.width >=32)? 1 :tRect.width/tempLimit;
					uv[5]=(tRect.height >=32)? 1 :tRect.height/tempLimit;
					uv[6]=0;
					uv[7]=(tRect.height >=32)? 1 :tRect.height/tempLimit;
					tRect.width=(tRect.width >=32)? tRect.width :tempLimit;
					tRect.height=(tRect.height >=32)? tRect.height :tempLimit;
					uv[1] *=-1;uv[3] *=-1;uv[5] *=-1;uv[7] *=-1;
					uv[1]+=1;uv[3]+=1;uv[5]+=1;uv[7]+=1;
				}
				(context.ctx).drawTarget(scope,x+tRect.x-tf.translateX,y+tRect.y-tf.translateY,w,h,Matrix.TEMP,"tmpTarget",shaderValue,uv,6);
				submitCMD=SubmitCMD.create([scope],laya.webgl.utils.RenderSprite3D.recycleTarget);
				context.addRenderObject(submitCMD);
				submitStencil=SubmitStencil.create(6);
				submitStencil.blendMode=preBlendMode;
				context.addRenderObject(submitStencil);
			}
			context.ctx.restore();
		}
		else{
			next._fun.call(next,sprite,context,x,y);
		}
	}

	__proto._blend=function(sprite,context,x,y){
		var style=sprite._style;
		var next=this._next;
		if (style.blendMode){
			context.ctx.save();
			context.ctx.globalCompositeOperation=style.blendMode;
			next._fun.call(next,sprite,context,x,y);
			context.ctx.restore();
		}
		else{
			next._fun.call(next,sprite,context,x,y);
		}
	}

	__proto._transform=function(sprite,context,x,y){
		var transform=sprite.transform,_next=this._next;
		if (transform && _next !=RenderSprite.NORENDER){
			var ctx=context.ctx;
			var style=sprite._style;
			transform.tx=x;
			transform.ty=y;
			var m2=ctx._getTransformMatrix();
			var m1=m2.clone();
			Matrix.mul(transform,m2,m2);
			m2._checkTransform();
			transform.tx=transform.ty=0;
			_next._fun.call(_next,sprite,context,0,0);
			m1.copyTo(m2);
			m1.destroy();
			}else {
			_next._fun.call(_next,sprite,context,x,y);
		}
	}

	RenderSprite3D.tmpTarget=function(scope,context){
		var b=scope.getValue("bounds");
		var tmpTarget=RenderTarget2D.create(b.width,b.height);
		tmpTarget.start();
		tmpTarget.clear(0,0,0,0);
		scope.addValue("tmpTarget",tmpTarget);
	}

	RenderSprite3D.endTmpTarget=function(scope){
		var tmpTarget=scope.getValue("tmpTarget");
		tmpTarget.end();
	}

	RenderSprite3D.recycleTarget=function(scope){
		var tmpTarget=scope.getValue("tmpTarget");
		tmpTarget.recycle();
		scope.recycle();
	}

	__static(RenderSprite3D,
	['tempUV',function(){return this.tempUV=new Array(8);}
	]);
	return RenderSprite3D;
})(RenderSprite)


//class laya.filters.webgl.ColorFilterActionGL extends laya.filters.webgl.FilterActionGL
var ColorFilterActionGL=(function(_super){
	function ColorFilterActionGL(){
		this.data=null;
		ColorFilterActionGL.__super.call(this);
	}

	__class(ColorFilterActionGL,'laya.filters.webgl.ColorFilterActionGL',_super);
	var __proto=ColorFilterActionGL.prototype;
	Laya.imps(__proto,{"laya.filters.IFilterActionGL":true})
	__proto.setValue=function(shader){
		shader.colorMat=this.data._mat;
		shader.colorAlpha=this.data._alpha;
	}

	__proto.apply3d=function(scope,sprite,context,x,y){
		var b=scope.getValue("bounds");
		var shaderValue=Value2D.create(/*laya.webgl.shader.d2.ShaderDefines2D.TEXTURE2D*/0x01,0);
		shaderValue.setFilters([this.data]);
		var tMatrix=Matrix.TEMP;
		tMatrix.identity();
		context.ctx.drawTarget(scope,0,0,b.width,b.height,tMatrix,"src",shaderValue);
	}

	return ColorFilterActionGL;
})(FilterActionGL)


//class laya.webgl.atlas.Atlaser extends laya.webgl.atlas.AtlasGrid
var Atlaser=(function(_super){
	function Atlaser(gridNumX,gridNumY,width,height,atlasID){
		this._atlasCanvas=null;
		this._inAtlasTextureKey=null;
		this._inAtlasTextureBitmapValue=null;
		this._inAtlasTextureOriUVValue=null;
		this._InAtlasWebGLImagesKey=null;
		this._InAtlasWebGLImagesOffsetValue=null;
		Atlaser.__super.call(this,gridNumX,gridNumY,atlasID);
		this._inAtlasTextureKey=[];
		this._inAtlasTextureBitmapValue=[];
		this._inAtlasTextureOriUVValue=[];
		this._InAtlasWebGLImagesKey={};
		this._InAtlasWebGLImagesOffsetValue=[];
		this._atlasCanvas=new AtlasWebGLCanvas();
		this._atlasCanvas._atlaser=this;
		this._atlasCanvas.width=width;
		this._atlasCanvas.height=height;
		this._atlasCanvas.activeResource();
		this._atlasCanvas.lock=true;
	}

	__class(Atlaser,'laya.webgl.atlas.Atlaser',_super);
	var __proto=Atlaser.prototype;
	__proto.computeUVinAtlasTexture=function(texture,oriUV,offsetX,offsetY){
		var tex=texture;
		var _width=AtlasResourceManager.atlasTextureWidth;
		var _height=AtlasResourceManager.atlasTextureHeight;
		var u1=offsetX / _width,v1=offsetY / _height,u2=(offsetX+texture.bitmap.width)/ _width,v2=(offsetY+texture.bitmap.height)/ _height;
		var inAltasUVWidth=texture.bitmap.width / _width,inAltasUVHeight=texture.bitmap.height / _height;
		texture.uv=[u1+oriUV[0] *inAltasUVWidth,v1+oriUV[1] *inAltasUVHeight,u2-(1-oriUV[2])*inAltasUVWidth,v1+oriUV[3] *inAltasUVHeight,u2-(1-oriUV[4])*inAltasUVWidth,v2-(1-oriUV[5])*inAltasUVHeight,u1+oriUV[6] *inAltasUVWidth,v2-(1-oriUV[7])*inAltasUVHeight];
	}

	__proto.findBitmapIsExist=function(bitmap){
		if ((bitmap instanceof laya.webgl.resource.WebGLImage )){
			var webImage=bitmap;
			var sUrl=webImage.url;
			var object=this._InAtlasWebGLImagesKey[sUrl?sUrl:webImage.id]
			if (object){
				return object.offsetInfoID;
			}
		}
		return-1;
	}

	/**
	*
	*@param inAtlasRes
	*@return 是否已经存在队列中
	*/
	__proto.addToAtlasTexture=function(mergeAtlasBitmap,offsetX,offsetY){
		if ((mergeAtlasBitmap instanceof laya.webgl.resource.WebGLImage )){
			var webImage=mergeAtlasBitmap;
			var sUrl=webImage.url;
			this._InAtlasWebGLImagesKey[sUrl?sUrl:webImage.id]={bitmap:mergeAtlasBitmap,offsetInfoID:this._InAtlasWebGLImagesOffsetValue.length};
			this._InAtlasWebGLImagesOffsetValue.push([offsetX,offsetY]);
		}
		this._atlasCanvas.texSubImage2D(offsetX,offsetY,mergeAtlasBitmap.atlasSource);
		mergeAtlasBitmap.clearAtlasSource();
	}

	__proto.addToAtlas=function(texture,offsetX,offsetY){
		texture._atlasID=this._inAtlasTextureKey.length;
		var oriUV=texture.uv.slice();
		var oriBitmap=texture.bitmap;
		this._inAtlasTextureKey.push(texture);
		this._inAtlasTextureOriUVValue.push(oriUV);
		this._inAtlasTextureBitmapValue.push(oriBitmap);
		this.computeUVinAtlasTexture(texture,oriUV,offsetX,offsetY);
		texture.bitmap=this._atlasCanvas;
	}

	__proto.clear=function(){
		for (var i=0,n=this._inAtlasTextureKey.length;i < n;i++){
			this._inAtlasTextureKey[i].bitmap=this._inAtlasTextureBitmapValue[i];
			this._inAtlasTextureKey[i].uv=this._inAtlasTextureOriUVValue[i];
			this._inAtlasTextureKey[i]._atlasID=-1;
			this._inAtlasTextureKey[i].bitmap.lock=false;
			this._inAtlasTextureKey[i].bitmap.releaseResource();
		}
		this._inAtlasTextureKey.length=0;
		this._inAtlasTextureBitmapValue.length=0;
		this._inAtlasTextureOriUVValue.length=0;
		this._InAtlasWebGLImagesKey=null;
		this._InAtlasWebGLImagesOffsetValue.length=0;
	}

	__proto.dispose=function(){
		this.clear();
		this._atlasCanvas.destroy();
	}

	__getset(0,__proto,'InAtlasWebGLImagesOffsetValue',function(){
		return this._InAtlasWebGLImagesOffsetValue;
	});

	__getset(0,__proto,'texture',function(){
		return this._atlasCanvas;
	});

	__getset(0,__proto,'inAtlasWebGLImagesKey',function(){
		return this._InAtlasWebGLImagesKey;
	});

	return Atlaser;
})(AtlasGrid)


//class laya.webgl.shader.d2.ShaderDefines2D extends laya.webgl.shader.ShaderDefines
var ShaderDefines2D=(function(_super){
	function ShaderDefines2D(){
		ShaderDefines2D.__super.call(this,ShaderDefines2D.__name2int,ShaderDefines2D.__int2name,ShaderDefines2D.__int2nameMap);
	}

	__class(ShaderDefines2D,'laya.webgl.shader.d2.ShaderDefines2D',_super);
	ShaderDefines2D.__init__=function(){
		ShaderDefines2D.reg("TEXTURE2D",0x01);
		ShaderDefines2D.reg("COLOR2D",0x02);
		ShaderDefines2D.reg("PRIMITIVE",0x04);
		ShaderDefines2D.reg("GLOW_FILTER",0x08);
		ShaderDefines2D.reg("BLUR_FILTER",0x10);
		ShaderDefines2D.reg("COLOR_FILTER",0x20);
		ShaderDefines2D.reg("COLOR_ADD",0x40);
		ShaderDefines2D.reg("WORLDMAT",0x80);
		ShaderDefines2D.reg("FILLTEXTURE",0x100);
		ShaderDefines2D.reg("FSHIGHPRECISION",0x400);
	}

	ShaderDefines2D.reg=function(name,value){
		ShaderDefines._reg(name,value,ShaderDefines2D.__name2int,ShaderDefines2D.__int2name);
	}

	ShaderDefines2D.toText=function(value,int2name,int2nameMap){
		return ShaderDefines._toText(value,int2name,int2nameMap);
	}

	ShaderDefines2D.toInt=function(names){
		return ShaderDefines._toInt(names,ShaderDefines2D.__name2int);
	}

	ShaderDefines2D.TEXTURE2D=0x01;
	ShaderDefines2D.COLOR2D=0x02;
	ShaderDefines2D.PRIMITIVE=0x04;
	ShaderDefines2D.FILTERGLOW=0x08;
	ShaderDefines2D.FILTERBLUR=0x10;
	ShaderDefines2D.FILTERCOLOR=0x20;
	ShaderDefines2D.COLORADD=0x40;
	ShaderDefines2D.WORLDMAT=0x80;
	ShaderDefines2D.FILLTEXTURE=0x100;
	ShaderDefines2D.SKINMESH=0x200;
	ShaderDefines2D.SHADERDEFINE_FSHIGHPRECISION=0x400;
	ShaderDefines2D.__name2int={};
	ShaderDefines2D.__int2name=[];
	ShaderDefines2D.__int2nameMap=[];
	return ShaderDefines2D;
})(ShaderDefines)


//class laya.webgl.shapes.Ellipse extends laya.webgl.shapes.BasePoly
var Ellipse=(function(_super){
	function Ellipse(x,y,width,height,color,borderWidth,borderColor){
		Ellipse.__super.call(this,x,y,width,height,40,color,borderWidth,borderColor);
	}

	__class(Ellipse,'laya.webgl.shapes.Ellipse',_super);
	return Ellipse;
})(BasePoly)


//class laya.webgl.shapes.Line extends laya.webgl.shapes.BasePoly
var Line=(function(_super){
	function Line(x,y,points,borderWidth,color){
		this._points=[];
		this.rebuild(points);
		Line.__super.call(this,x,y,0,0,0,color,borderWidth,color,0);
	}

	__class(Line,'laya.webgl.shapes.Line',_super);
	var __proto=Line.prototype;
	__proto.rebuild=function(points){
		var len=points.length;
		var preLen=this._points.length;
		if (len !=preLen){
			this.mUint16Array=new Uint16Array((len/2-1)*6);
			this.mFloat32Array=new Float32Array(len*5);
		}
		this._points.length=0;
		var tCurrX=NaN;
		var tCurrY=NaN;
		var tLastX=-1;
		var tLastY=-1;
		var tLen=points.length / 2;
		for (var i=0;i < tLen;i++){
			tCurrX=points[i *2];
			tCurrY=points[i *2+1];
			if (Math.abs(tLastX-tCurrX)> 0.01 || Math.abs(tLastY-tCurrY)>0.01){
				this._points.push(tCurrX,tCurrY);
			}
			tLastX=tCurrX;
			tLastY=tCurrY;
		}
	}

	__proto.getData=function(ib,vb,start){
		var indices=[];
		var verts=[];
		(this.borderWidth > 0)&& this.createLine2(this._points,indices,this.borderWidth,start,verts,this._points.length / 2);
		this.mUint16Array.set(indices,0);
		this.mFloat32Array.set(verts,0);
		ib.append(this.mUint16Array);
		vb.append(this.mFloat32Array);
	}

	return Line;
})(BasePoly)


//class laya.webgl.shapes.LoopLine extends laya.webgl.shapes.BasePoly
var LoopLine=(function(_super){
	function LoopLine(x,y,points,width,color){
		this._points=[];
		var tCurrX=NaN;
		var tCurrY=NaN;
		var tLastX=-1;
		var tLastY=-1;
		var tLen=points.length / 2-1;
		for (var i=0;i < tLen;i++){
			tCurrX=points[i *2];
			tCurrY=points[i *2+1];
			if (Math.abs(tLastX-tCurrX)> 0.01 || Math.abs(tLastY-tCurrY)> 0.01){
				this._points.push(tCurrX,tCurrY);
			}
			tLastX=tCurrX;
			tLastY=tCurrY;
		}
		tCurrX=points[tLen *2];
		tCurrY=points[tLen *2+1];
		tLastX=this._points[0];
		tLastY=this._points[1];
		if (Math.abs(tLastX-tCurrX)> 0.01 || Math.abs(tLastY-tCurrY)> 0.01){
			this._points.push(tCurrX,tCurrY);
		}
		LoopLine.__super.call(this,x,y,0,0,this._points.length / 2,0,width,color);
	}

	__class(LoopLine,'laya.webgl.shapes.LoopLine',_super);
	var __proto=LoopLine.prototype;
	__proto.getData=function(ib,vb,start){
		if (this.borderWidth > 0){
			var color=this.color;
			var r=((color >> 16)& 0x0000ff)/ 255,g=((color >> 8)& 0xff)/ 255,b=(color & 0x0000ff)/ 255;
			var verts=[];
			var tLastX=-1,tLastY=-1;
			var tCurrX=0,tCurrY=0;
			var indices=[];
			var tLen=Math.floor(this._points.length / 2);
			for (var i=0;i < tLen;i++){
				tCurrX=this._points[i *2];
				tCurrY=this._points[i *2+1];
				verts.push(this.x+tCurrX,this.y+tCurrY,r,g,b);
			}
			this.createLoopLine(verts,indices,this.borderWidth,start+verts.length / 5);
			ib.append(new Uint16Array(indices));
			vb.append(new Float32Array(verts));
		}
	}

	__proto.createLoopLine=function(p,indices,lineWidth,len,outVertex,outIndex){
		var tLen=p.length / 5;
		var points=p.concat();
		var result=outVertex ? outVertex :p;
		var color=this.borderColor;
		var r=((color >> 16)& 0x0000ff)/ 255,g=((color >> 8)& 0xff)/ 255,b=(color & 0x0000ff)/ 255;
		var firstPoint=[points[0],points[1]];
		var lastPoint=[points[points.length-5],points[points.length-4]];
		var midPointX=lastPoint[0]+(firstPoint[0]-lastPoint[0])*0.5;
		var midPointY=lastPoint[1]+(firstPoint[1]-lastPoint[1])*0.5;
		points.unshift(midPointX,midPointY,0,0,0);
		points.push(midPointX,midPointY,0,0,0);
		var length=points.length / 5;
		var iStart=len,w=lineWidth / 2;
		var px,py,p1x,p1y,p2x,p2y,p3x,p3y;
		var perpx,perpy,perp2x,perp2y,perp3x,perp3y;
		var a1,b1,c1,a2,b2,c2;
		var denom,pdist,dist;
		p1x=points[0];
		p1y=points[1];
		p2x=points[5];
		p2y=points[6];
		perpx=-(p1y-p2y);
		perpy=p1x-p2x;
		dist=Math.sqrt(perpx *perpx+perpy *perpy);
		perpx=perpx / dist *w;
		perpy=perpy / dist *w;
		result.push(p1x-perpx,p1y-perpy,r,g,b,p1x+perpx,p1y+perpy,r,g,b);
		for (var i=1;i < length-1;i++){
			p1x=points[(i-1)*5];
			p1y=points[(i-1)*5+1];
			p2x=points[(i)*5];
			p2y=points[(i)*5+1];
			p3x=points[(i+1)*5];
			p3y=points[(i+1)*5+1];
			perpx=-(p1y-p2y);
			perpy=p1x-p2x;
			dist=Math.sqrt(perpx *perpx+perpy *perpy);
			perpx=perpx / dist *w;
			perpy=perpy / dist *w;
			perp2x=-(p2y-p3y);
			perp2y=p2x-p3x;
			dist=Math.sqrt(perp2x *perp2x+perp2y *perp2y);
			perp2x=perp2x / dist *w;
			perp2y=perp2y / dist *w;
			a1=(-perpy+p1y)-(-perpy+p2y);
			b1=(-perpx+p2x)-(-perpx+p1x);
			c1=(-perpx+p1x)*(-perpy+p2y)-(-perpx+p2x)*(-perpy+p1y);
			a2=(-perp2y+p3y)-(-perp2y+p2y);
			b2=(-perp2x+p2x)-(-perp2x+p3x);
			c2=(-perp2x+p3x)*(-perp2y+p2y)-(-perp2x+p2x)*(-perp2y+p3y);
			denom=a1 *b2-a2 *b1;
			if (Math.abs(denom)< 0.1){
				denom+=10.1;
				result.push(p2x-perpx,p2y-perpy,r,g,b,p2x+perpx,p2y+perpy,r,g,b);
				continue ;
			}
			px=(b1 *c2-b2 *c1)/ denom;
			py=(a2 *c1-a1 *c2)/ denom;
			pdist=(px-p2x)*(px-p2x)+(py-p2y)+(py-p2y);
			result.push(px,py,r,g,b,p2x-(px-p2x),p2y-(py-p2y),r,g,b);
		}
		if (outIndex){
			indices=outIndex;
		};
		var groupLen=this.edges+1;
		for (i=1;i < groupLen;i++){
			indices.push(iStart+(i-1)*2,iStart+(i-1)*2+1,iStart+i *2+1,iStart+i *2+1,iStart+i *2,iStart+(i-1)*2);
		}
		indices.push(iStart+(i-1)*2,iStart+(i-1)*2+1,iStart+1,iStart+1,iStart,iStart+(i-1)*2);
		return result;
	}

	return LoopLine;
})(BasePoly)


//class laya.webgl.shapes.Polygon extends laya.webgl.shapes.BasePoly
var Polygon=(function(_super){
	function Polygon(x,y,points,color,borderWidth,borderColor){
		this._points=null;
		this._start=-1;
		this._repaint=false;
		this.earcutTriangles=null;
		this._mat=Matrix.create();
		this._points=points.slice(0,points.length);
		Polygon.__super.call(this,x,y,0,0,this._points.length / 2,color,borderWidth,borderColor);
	}

	__class(Polygon,'laya.webgl.shapes.Polygon',_super);
	var __proto=Polygon.prototype;
	__proto.rebuild=function(point){
		if (!this._repaint){
			this._points.length=0;
			this._points=this._points.concat(point);
		}
	}

	__proto.setMatrix=function(mat){
		mat.copyTo(this._mat);
	}

	__proto.needUpdate=function(mat){
		this._repaint=(this._mat.a==mat.a && this._mat.b==mat.b && this._mat.c==mat.c && this._mat.d==mat.d && this._mat.tx==mat.tx && this._mat.ty==mat.ty);
		return !this._repaint;
	}

	__proto.getData=function(ib,vb,start){
		var indices,i=0;
		var tArray=this._points;
		var tLen=0;
		if (this.mUint16Array && this.mFloat32Array&&this._repaint){
			if (this._start !=start){
				this._start=start;
				indices=[];
				tLen=this.earcutTriangles.length;
				for (i=0;i < tLen;i++){
					indices.push(this.earcutTriangles[i]+start);
				}
				this.mUint16Array=new Uint16Array(indices);
			}
		}
		else {
			this._start=start;
			indices=[];
			var verts=[];
			var vertsEarcut=[];
			var color=this.color;
			var r=((color >> 16)& 0x0000ff)/ 255,g=((color >> 8)& 0xff)/ 255,b=(color & 0x0000ff)/ 255;
			tLen=Math.floor(tArray.length / 2);
			for (i=0;i < tLen;i++){
				verts.push(this.x+tArray[i *2],this.y+tArray[i *2+1],r,g,b);
				vertsEarcut.push(this.x+tArray[i *2],this.y+tArray[i *2+1]);
			}
			this.earcutTriangles=Earcut.earcut(vertsEarcut,null,2);
			tLen=this.earcutTriangles.length;
			for (i=0;i < tLen;i++){
				indices.push(this.earcutTriangles[i]+start);
			}
			this.mUint16Array=new Uint16Array(indices);
			this.mFloat32Array=new Float32Array(verts);
		}
		ib.append(this.mUint16Array);
		vb.append(this.mFloat32Array);
	}

	return Polygon;
})(BasePoly)


//class laya.webgl.submit.SubmitCanvas extends laya.webgl.submit.Submit
var SubmitCanvas=(function(_super){
	function SubmitCanvas(){
		//this._ctx_src=null;
		this._matrix=new Matrix();
		this._matrix4=CONST3D2D.defaultMatrix4.concat();
		SubmitCanvas.__super.call(this,/*laya.webgl.submit.Submit.TYPE_2D*/10000);
		this.shaderValue=new Value2D(0,0);
	}

	__class(SubmitCanvas,'laya.webgl.submit.SubmitCanvas',_super);
	var __proto=SubmitCanvas.prototype;
	__proto.renderSubmit=function(){
		if (this._ctx_src._targets){
			this._ctx_src._targets.flush(this._ctx_src);
			return 1;
		};
		var preAlpha=RenderState2D.worldAlpha;
		var preMatrix4=RenderState2D.worldMatrix4;
		var preMatrix=RenderState2D.worldMatrix;
		var preFilters=RenderState2D.worldFilters;
		var preWorldShaderDefines=RenderState2D.worldShaderDefines;
		var v=this.shaderValue;
		var m=this._matrix;
		var m4=this._matrix4;
		var mout=Matrix.TEMP;
		Matrix.mul(m,preMatrix,mout);
		m4[0]=mout.a;
		m4[1]=mout.b;
		m4[4]=mout.c;
		m4[5]=mout.d;
		m4[12]=mout.tx;
		m4[13]=mout.ty;
		RenderState2D.worldMatrix=mout.clone();
		RenderState2D.worldMatrix4=m4;
		RenderState2D.worldAlpha=RenderState2D.worldAlpha *v.alpha;
		if (v.filters && v.filters.length){
			RenderState2D.worldFilters=v.filters;
			RenderState2D.worldShaderDefines=v.defines;
		}
		this._ctx_src.flush();
		RenderState2D.worldAlpha=preAlpha;
		RenderState2D.worldMatrix4=preMatrix4;
		RenderState2D.worldMatrix.destroy();
		RenderState2D.worldMatrix=preMatrix;
		RenderState2D.worldFilters=preFilters;
		RenderState2D.worldShaderDefines=preWorldShaderDefines;
		return 1;
	}

	__proto.releaseRender=function(){
		var cache=SubmitCanvas._cache;
		this._ctx_src=null;
		cache[cache._length++]=this;
	}

	__proto.getRenderType=function(){
		return /*laya.webgl.submit.Submit.TYPE_CANVAS*/10003;
	}

	SubmitCanvas.create=function(ctx_src,alpha,filters){
		var o=(!SubmitCanvas._cache._length)? (new SubmitCanvas()):SubmitCanvas._cache[--SubmitCanvas._cache._length];
		o._ctx_src=ctx_src;
		var v=o.shaderValue;
		v.alpha=alpha;
		v.defines.setValue(0);
		filters && filters.length && v.setFilters(filters);
		return o;
	}

	SubmitCanvas._cache=(SubmitCanvas._cache=[],SubmitCanvas._cache._length=0,SubmitCanvas._cache);
	return SubmitCanvas;
})(Submit)


//class laya.webgl.submit.SubmitTexture extends laya.webgl.submit.Submit
var SubmitTexture=(function(_super){
	function SubmitTexture(renderType){
		this._preIsSameTextureShader=false;
		this._isSameTexture=true;
		this._texs=new Array;
		this._texsID=new Array;
		this._vbPos=new Array;
		(renderType===void 0)&& (renderType=10000);
		SubmitTexture.__super.call(this,renderType);
	}

	__class(SubmitTexture,'laya.webgl.submit.SubmitTexture',_super);
	var __proto=SubmitTexture.prototype;
	__proto.releaseRender=function(){
		var cache=SubmitTexture._cache;
		cache[cache._length++]=this;
		this.shaderValue.release();
		this._preIsSameTextureShader=false;
		this._vb=null;
		this._texs.length=0;
		this._vbPos.length=0;
		this._isSameTexture=true;
	}

	__proto.addTexture=function(tex,vbpos){
		this._texsID[this._texs.length]=tex._uvID;
		this._texs.push(tex);
		this._vbPos.push(vbpos);
	}

	//检查材质是否修改，修改UV，设置是否是同一材质
	__proto.checkTexture=function(){
		if (this._texs.length < 1){
			this._isSameTexture=true;
			return;
		};
		var _tex=this.shaderValue.textureHost;
		var webGLImg=_tex.bitmap;
		if (webGLImg===null)return;
		var vbdata=this._vb.getFloat32Array();
		for (var i=0,s=this._texs.length;i < s;i++){
			var tex=this._texs[i];
			tex.active();
			var newUV=tex.uv;
			if (this._texsID[i]!==tex._uvID){
				this._texsID[i]=tex._uvID;
				var vbPos=this._vbPos[i];
				vbdata[vbPos+2]=newUV[0];
				vbdata[vbPos+3]=newUV[1];
				vbdata[vbPos+6]=newUV[2];
				vbdata[vbPos+7]=newUV[3];
				vbdata[vbPos+10]=newUV[4];
				vbdata[vbPos+11]=newUV[5];
				vbdata[vbPos+14]=newUV[6];
				vbdata[vbPos+15]=newUV[7];
				this._vb.setNeedUpload();
			}
			if (tex.bitmap!==webGLImg){
				this._isSameTexture=false;
			}
		}
	}

	__proto.renderSubmit=function(){
		if (this._numEle===0){
			SubmitTexture._shaderSet=false;
			return 1;
		};
		var _tex=this.shaderValue.textureHost;
		if (_tex){
			var source=_tex.source;
			if (!_tex.bitmap || !source){
				SubmitTexture._shaderSet=false;
				return 1;
			}
			this.shaderValue.texture=source;
		}
		this._vb.bind_upload(this._ib);
		var gl=WebGL.mainContext;
		if (BlendMode.activeBlendFunction!==this._blendFn){
			gl.enable(/*laya.webgl.WebGLContext.BLEND*/0x0BE2);
			this._blendFn(gl);
			BlendMode.activeBlendFunction=this._blendFn;
		}
		Stat.drawCall++;
		Stat.trianglesFaces+=this._numEle / 3;
		if (this._preIsSameTextureShader && BaseShader.activeShader && SubmitTexture._shaderSet)
			(BaseShader.activeShader).uploadTexture2D(this.shaderValue.texture);
		else this.shaderValue.upload();
		SubmitTexture._shaderSet=true;
		if (this._texs.length > 1 && !this._isSameTexture){
			var webGLImg=_tex.bitmap;
			var index=0;
			var shader=BaseShader.activeShader;
			for (var i=0,s=this._texs.length;i < s;i++){
				var tex2=this._texs[i];
				if (tex2.bitmap!==webGLImg || (i+1)===s){
					shader.uploadTexture2D(tex2.source);
					gl.drawElements(/*laya.webgl.WebGLContext.TRIANGLES*/0x0004,(i-index+1)*6,/*laya.webgl.WebGLContext.UNSIGNED_SHORT*/0x1403,this._startIdx+index *6 *CONST3D2D.BYTES_PIDX);
					webGLImg=tex2.bitmap;
					index=i;
				}
			}
			}else {
			gl.drawElements(/*laya.webgl.WebGLContext.TRIANGLES*/0x0004,this._numEle,/*laya.webgl.WebGLContext.UNSIGNED_SHORT*/0x1403,this._startIdx);
		}
		return 1;
	}

	SubmitTexture.create=function(context,ib,vb,pos,sv){
		var o=SubmitTexture._cache._length ? SubmitTexture._cache[--SubmitTexture._cache._length] :new SubmitTexture();
		if (vb==null){
			vb=o._selfVb || (o._selfVb=VertexBuffer2D.create(-1));
			vb.clear();
			pos=0;
		}
		o._ib=ib;
		o._vb=vb;
		o._startIdx=pos *CONST3D2D.BYTES_PIDX;
		o._numEle=0;
		var blendType=context._nBlendType;
		o._blendFn=context._targets ? BlendMode.targetFns[blendType] :BlendMode.fns[blendType];
		o.shaderValue=sv;
		o.shaderValue.setValue(context._shader2D);
		var filters=context._shader2D.filters;
		filters && o.shaderValue.setFilters(filters);
		return o;
	}

	SubmitTexture._cache=(SubmitTexture._cache=[],SubmitTexture._cache._length=0,SubmitTexture._cache);
	SubmitTexture._shaderSet=true;
	return SubmitTexture;
})(Submit)


/**
*与MeshQuadTexture基本相同。不过index不是固定的
*/
//class laya.webgl.utils.MeshTexture extends laya.webgl.utils.Mesh2D
var MeshTexture=(function(_super){
	function MeshTexture(){
		MeshTexture.__super.call(this,laya.webgl.utils.MeshTexture.const_stride,0,0);
		this.canReuse=true;
		this.setAttributes(laya.webgl.utils.MeshTexture._fixattriInfo);
	}

	__class(MeshTexture,'laya.webgl.utils.MeshTexture',_super);
	var __proto=MeshTexture.prototype;
	__proto.addData=function(vertices,uvs,idx,matrix,rgba,ctx){
		var sz=vertices.length / 2;
		var startpos=this._vb.needSize(sz *MeshTexture.const_stride);
		var f32pos=startpos >> 2;
		var vbdata=this._vb.getFloat32Array();
		var ci=0;
		for (var i=0;i < sz;i++){
			var x=vertices[ci],y=vertices[ci+1];
			var x1=x *matrix.a+y *matrix.c+matrix.tx;
			var y1=x *matrix.b+y *matrix.d+matrix.ty;
			vbdata[f32pos++]=x1;vbdata[f32pos++]=y1;
			vbdata[f32pos++]=uvs[ci];vbdata[f32pos++]=uvs[ci+1];
			ci+=2;
		}
		this._vb.setNeedUpload();
		var vertN=this.vertNum;
		if (vertN > 0){
			sz=idx.length;
			if (sz > MeshTexture.tmpIdx.length)MeshTexture.tmpIdx=new Uint16Array(sz);
			for (var ii=0;ii < sz;ii++){
				MeshTexture.tmpIdx[ii]=idx[ii]+vertN;
			}
			this._ib.appendU16Array(MeshTexture.tmpIdx,idx.length);
			}else {
			this._ib.append(idx);
		}
		this._ib.setNeedUpload();
		this.vertNum+=sz;
		this.indexNum+=idx.length;
	}

	/**
	*把本对象放到回收池中，以便getMesh能用。
	*/
	__proto.releaseMesh=function(){
		this._vb._byteLength=0;
		this._ib._byteLength=0;
		this.vertNum=0;
		this.indexNum=0;
		laya.webgl.utils.MeshTexture._POOL.push(this);
	}

	__proto.destroy=function(){
		this._ib.destroy();
		this._vb.destroy();
	}

	MeshTexture.getAMesh=function(){
		if (laya.webgl.utils.MeshTexture._POOL.length){
			return laya.webgl.utils.MeshTexture._POOL.pop();
		}
		return new MeshTexture();
	}

	MeshTexture.const_stride=16;
	MeshTexture._POOL=[];
	__static(MeshTexture,
	['_fixattriInfo',function(){return this._fixattriInfo=[
		/*laya.webgl.WebGLContext.FLOAT*/0x1406,2,0,
		/*laya.webgl.WebGLContext.FLOAT*/0x1406,2,8];},'tmpIdx',function(){return this.tmpIdx=new Uint16Array(4);}
	]);
	return MeshTexture;
})(Mesh2D)


/**
*...
*@author ...
*/
//class laya.webgl.shader.BaseShader extends laya.resource.Resource
var BaseShader=(function(_super){
	function BaseShader(){
		BaseShader.__super.call(this);
		this.lock=true;
	}

	__class(BaseShader,'laya.webgl.shader.BaseShader',_super);
	BaseShader.activeShader=null;
	BaseShader.bindShader=null;
	return BaseShader;
})(Resource)


//class laya.webgl.resource.RenderTarget2D extends laya.resource.Texture
var RenderTarget2D=(function(_super){
	function RenderTarget2D(width,height,surfaceFormat,surfaceType,depthStencilFormat,mipMap,repeat,minFifter,magFifter){
		this._type=0;
		this._svWidth=NaN;
		this._svHeight=NaN;
		this._preRenderTarget=null;
		//TODO:.........................................................
		this._alreadyResolved=false;
		this._looked=false;
		this._surfaceFormat=0;
		this._surfaceType=0;
		this._depthStencilFormat=0;
		this._mipMap=false;
		this._repeat=false;
		this._minFifter=0;
		this._magFifter=0;
		this._destroy=false;
		(surfaceFormat===void 0)&& (surfaceFormat=/*laya.webgl.WebGLContext.RGBA*/0x1908);
		(surfaceType===void 0)&& (surfaceType=/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401);
		(depthStencilFormat===void 0)&& (depthStencilFormat=/*laya.webgl.WebGLContext.DEPTH_STENCIL*/0x84F9);
		(mipMap===void 0)&& (mipMap=false);
		(repeat===void 0)&& (repeat=false);
		(minFifter===void 0)&& (minFifter=-1);
		(magFifter===void 0)&& (magFifter=-1);
		this._type=1;
		this._w=width;
		this._h=height;
		this._surfaceFormat=surfaceFormat;
		this._surfaceType=surfaceType;
		this._depthStencilFormat=depthStencilFormat;
		if (Render.isConchWebGL && this._depthStencilFormat===/*laya.webgl.WebGLContext.DEPTH_STENCIL*/0x84F9){
			this._depthStencilFormat=/*laya.webgl.WebGLContext.DEPTH_COMPONENT16*/0x81A5;
		}
		this._mipMap=mipMap;
		this._repeat=repeat;
		this._minFifter=minFifter;
		this._magFifter=magFifter;
		this._createWebGLRenderTarget();
		this.bitmap.lock=true;
		RenderTarget2D.__super.call(this,this.bitmap,Texture.INV_UV);
	}

	__class(RenderTarget2D,'laya.webgl.resource.RenderTarget2D',_super);
	var __proto=RenderTarget2D.prototype;
	Laya.imps(__proto,{"laya.resource.IDispose":true})
	//TODO:临时......................................................
	__proto.getType=function(){
		return this._type;
	}

	//*/
	__proto.getTexture=function(){
		return this;
	}

	__proto.size=function(w,h){
		if (this._w==w && this._h==h)return;
		this._w=w;
		this._h=h;
		this.release();
		if (this._w !=0 && this._h !=0)this._createWebGLRenderTarget();
	}

	__proto.release=function(){
		this.destroy();
	}

	__proto.recycle=function(){
		RenderTarget2D.POOL.push(this);
	}

	__proto.start=function(){
		var gl=WebGL.mainContext;
		this._preRenderTarget=RenderState2D.curRenderTarget;
		RenderState2D.curRenderTarget=this;
		gl.bindFramebuffer(/*laya.webgl.WebGLContext.FRAMEBUFFER*/0x8D40,this.bitmap.frameBuffer);
		this._alreadyResolved=false;
		if (this._type==1){
			gl.viewport(0,0,this._w,this._h);
			this._svWidth=RenderState2D.width;
			this._svHeight=RenderState2D.height;
			RenderState2D.width=this._w;
			RenderState2D.height=this._h;
			BaseShader.activeShader=null;
		}
		return this;
	}

	__proto.clear=function(r,g,b,a){
		(r===void 0)&& (r=0.0);
		(g===void 0)&& (g=0.0);
		(b===void 0)&& (b=0.0);
		(a===void 0)&& (a=1.0);
		var gl=WebGL.mainContext;
		gl.clearColor(r,g,b,a);
		var clearFlag=/*laya.webgl.WebGLContext.COLOR_BUFFER_BIT*/0x00004000;
		switch (this._depthStencilFormat){
			case /*laya.webgl.WebGLContext.DEPTH_COMPONENT16*/0x81A5:
				clearFlag |=/*laya.webgl.WebGLContext.DEPTH_BUFFER_BIT*/0x00000100;
				break ;
			case /*laya.webgl.WebGLContext.STENCIL_INDEX8*/0x8D48:
				clearFlag |=/*laya.webgl.WebGLContext.STENCIL_BUFFER_BIT*/0x00000400;
				break ;
			case /*laya.webgl.WebGLContext.DEPTH_STENCIL*/0x84F9:
				clearFlag |=/*laya.webgl.WebGLContext.DEPTH_BUFFER_BIT*/0x00000100;
				clearFlag |=/*laya.webgl.WebGLContext.STENCIL_BUFFER_BIT*/0x00000400
				break ;
			}
		gl.clear(clearFlag);
	}

	__proto.end=function(){
		var gl=WebGL.mainContext;
		gl.bindFramebuffer(/*laya.webgl.WebGLContext.FRAMEBUFFER*/0x8D40,this._preRenderTarget ? this._preRenderTarget.bitmap.frameBuffer :null);
		this._alreadyResolved=true;
		RenderState2D.curRenderTarget=this._preRenderTarget;
		if (this._type==1){
			gl.viewport(0,0,this._svWidth,this._svHeight);
			RenderState2D.width=this._svWidth;
			RenderState2D.height=this._svHeight;
			BaseShader.activeShader=null;
		}else gl.viewport(0,0,Laya.stage.width,Laya.stage.height);
	}

	__proto.getData=function(x,y,width,height){
		var gl=WebGL.mainContext;
		gl.bindFramebuffer(/*laya.webgl.WebGLContext.FRAMEBUFFER*/0x8D40,(this.bitmap).frameBuffer);
		var canRead=(gl.checkFramebufferStatus(/*laya.webgl.WebGLContext.FRAMEBUFFER*/0x8D40)===/*laya.webgl.WebGLContext.FRAMEBUFFER_COMPLETE*/0x8CD5);
		if (!canRead){
			gl.bindFramebuffer(/*laya.webgl.WebGLContext.FRAMEBUFFER*/0x8D40,null);
			return null;
		};
		var pixels=new Uint8Array(this._w *this._h *4);
		gl.readPixels(x,y,width,height,this._surfaceFormat,this._surfaceType,pixels);
		gl.bindFramebuffer(/*laya.webgl.WebGLContext.FRAMEBUFFER*/0x8D40,null);
		return pixels;
	}

	/**彻底清理资源,注意会强制解锁清理*/
	__proto.destroy=function(foreDiposeTexture){
		(foreDiposeTexture===void 0)&& (foreDiposeTexture=false);
		if (!this._destroy){
			this._loaded=false;
			this.bitmap.offAll();
			this.bitmap.disposeResource();
			this.bitmap.dispose();
			this.offAll();
			this.bitmap=null;
			this._alreadyResolved=false;
			this._destroy=true;
			_super.prototype.destroy.call(this);
		}
	}

	//待测试
	__proto.dispose=function(){}
	__proto._createWebGLRenderTarget=function(){
		this.bitmap=new WebGLRenderTarget(this.width,this.height,this._surfaceFormat,this._surfaceType,this._depthStencilFormat,this._mipMap,this._repeat,this._minFifter,this._magFifter);
		this.bitmap.activeResource();
		this._alreadyResolved=true;
		this._destroy=false;
		this._loaded=true;
		this.bitmap.on(/*laya.events.Event.RECOVERED*/"recovered",this,function(e){
			this.event(/*laya.events.Event.RECOVERED*/"recovered");
		})
	}

	__getset(0,__proto,'surfaceFormat',function(){
		return this._surfaceFormat;
	});

	__getset(0,__proto,'magFifter',function(){
		return this._magFifter;
	});

	__getset(0,__proto,'surfaceType',function(){
		return this._surfaceType;
	});

	__getset(0,__proto,'mipMap',function(){
		return this._mipMap;
	});

	__getset(0,__proto,'depthStencilFormat',function(){
		return this._depthStencilFormat;
	});

	//}
	__getset(0,__proto,'minFifter',function(){
		return this._minFifter;
	});

	/**返回RenderTarget的Texture*/
	__getset(0,__proto,'source',function(){
		if (this._alreadyResolved)
			return Laya.superGet(Texture,this,'source');
		return null;
	});

	RenderTarget2D.create=function(w,h,surfaceFormat,surfaceType,depthStencilFormat,mipMap,repeat,minFifter,magFifter){
		(surfaceFormat===void 0)&& (surfaceFormat=/*laya.webgl.WebGLContext.RGBA*/0x1908);
		(surfaceType===void 0)&& (surfaceType=/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401);
		(depthStencilFormat===void 0)&& (depthStencilFormat=/*laya.webgl.WebGLContext.DEPTH_STENCIL*/0x84F9);
		(mipMap===void 0)&& (mipMap=false);
		(repeat===void 0)&& (repeat=false);
		(minFifter===void 0)&& (minFifter=-1);
		(magFifter===void 0)&& (magFifter=-1);
		var t=RenderTarget2D.POOL.pop();
		t || (t=new RenderTarget2D(w,h));
		if (!t.bitmap || t._w !=w || t._h !=h || t._surfaceFormat !=surfaceFormat || t._surfaceType !=surfaceType || t._depthStencilFormat !=depthStencilFormat || t._mipMap !=mipMap || t._repeat !=repeat || t._minFifter !=minFifter || t._magFifter !=magFifter){
			t._w=w;
			t._h=h;
			t._surfaceFormat=surfaceFormat;
			t._surfaceType=surfaceType;
			t._depthStencilFormat=depthStencilFormat;
			if (Render.isConchWebGL && t._depthStencilFormat===/*laya.webgl.WebGLContext.DEPTH_STENCIL*/0x84F9){
				t._depthStencilFormat=/*laya.webgl.WebGLContext.DEPTH_COMPONENT16*/0x81A5;
			}
			t._mipMap=mipMap;
			t._repeat=repeat;
			t._minFifter=minFifter;
			t._magFifter=magFifter;
			t.release();
			t._createWebGLRenderTarget();
		}
		return t;
	}

	RenderTarget2D.TYPE2D=1;
	RenderTarget2D.TYPE3D=2;
	RenderTarget2D.POOL=[];
	return RenderTarget2D;
})(Texture)


//class laya.webgl.utils.Buffer extends laya.resource.Resource
var Buffer=(function(_super){
	function Buffer(){
		this._glBuffer=null;
		this._buffer=null;
		//可能为Float32Array、Uint16Array、Uint8Array、ArrayBuffer等。
		this._bufferType=0;
		this._bufferUsage=0;
		this._byteLength=0;
		Buffer.__super.call(this);
		Buffer._gl=WebGL.mainContext;
	}

	__class(Buffer,'laya.webgl.utils.Buffer',_super);
	var __proto=Buffer.prototype;
	__proto._bind=function(){
		this.activeResource();
		if (Buffer._bindActive[this._bufferType]!==this._glBuffer){
			(this._bufferType===/*laya.webgl.WebGLContext.ARRAY_BUFFER*/0x8892)&& (Buffer._bindVertexBuffer=this._glBuffer);
			Buffer._gl.bindBuffer(this._bufferType,Buffer._bindActive[this._bufferType]=this._glBuffer);
			BaseShader.activeShader=null;
		}
	}

	__proto.recreateResource=function(){
		this._glBuffer || (this._glBuffer=Buffer._gl.createBuffer());
		this.completeCreate();
	}

	__proto.disposeResource=function(){
		if (this._glBuffer){
			WebGL.mainContext.deleteBuffer(this._glBuffer);
			this._glBuffer=null;
		}
		this.memorySize=0;
	}

	__getset(0,__proto,'bufferUsage',function(){
		return this._bufferUsage;
	});

	Buffer._gl=null;
	Buffer._bindActive={};
	Buffer._bindVertexBuffer=null;
	Buffer._enableAtributes=[];
	return Buffer;
})(Resource)


//class laya.webgl.shader.d2.skinAnishader.SkinSV extends laya.webgl.shader.d2.value.Value2D
var SkinSV=(function(_super){
	function SkinSV(type){
		this.texcoord=null;
		this.offsetX=300;
		this.offsetY=0;
		SkinSV.__super.call(this,/*laya.webgl.shader.d2.ShaderDefines2D.SKINMESH*/0x200,0);
		var _vlen=8 *CONST3D2D.BYTES_PE;
		this.position=[2,/*laya.webgl.WebGLContext.FLOAT*/0x1406,false,_vlen,0];
		this.texcoord=[2,/*laya.webgl.WebGLContext.FLOAT*/0x1406,false,_vlen,2 *CONST3D2D.BYTES_PE];
		this.color=[4,/*laya.webgl.WebGLContext.FLOAT*/0x1406,false,_vlen,4 *CONST3D2D.BYTES_PE];
	}

	__class(SkinSV,'laya.webgl.shader.d2.skinAnishader.SkinSV',_super);
	return SkinSV;
})(Value2D)


//class laya.webgl.shader.d2.value.Color2dSV extends laya.webgl.shader.d2.value.Value2D
var Color2dSV=(function(_super){
	function Color2dSV(args){
		Color2dSV.__super.call(this,/*laya.webgl.shader.d2.ShaderDefines2D.COLOR2D*/0x02,0);
		this.color=[];
	}

	__class(Color2dSV,'laya.webgl.shader.d2.value.Color2dSV',_super);
	var __proto=Color2dSV.prototype;
	__proto.setValue=function(value){
		value.fillStyle&&(this.color=value.fillStyle._color._color);
		value.strokeStyle&&(this.color=value.strokeStyle._color._color);
	}

	return Color2dSV;
})(Value2D)


//class laya.webgl.shader.d2.value.FillTextureSV extends laya.webgl.shader.d2.value.Value2D
var FillTextureSV=(function(_super){
	function FillTextureSV(type){
		this.u_colorMatrix=null;
		this.strength=0;
		this.colorMat=null;
		this.colorAlpha=null;
		this.u_TexRange=[0,1,0,1];
		this.u_offset=[0,0];
		this.texcoord=Value2D._TEXCOORD;
		FillTextureSV.__super.call(this,/*laya.webgl.shader.d2.ShaderDefines2D.FILLTEXTURE*/0x100,0);
	}

	__class(FillTextureSV,'laya.webgl.shader.d2.value.FillTextureSV',_super);
	var __proto=FillTextureSV.prototype;
	//this.color=[4,WebGLContext.FLOAT,false,_vlen,4 *CONST3D2D.BYTES_PE];
	__proto.setValue=function(vo){
		this.ALPHA=vo.ALPHA;
		vo.filters && this.setFilters(vo.filters);
	}

	__proto.clear=function(){
		this.texture=null;
		this.shader=null;
		this.defines.setValue(0);
	}

	return FillTextureSV;
})(Value2D)


//class laya.webgl.shader.d2.value.TextureSV extends laya.webgl.shader.d2.value.Value2D
var TextureSV=(function(_super){
	function TextureSV(subID){
		this.u_colorMatrix=null;
		this.strength=0;
		this.blurInfo=null;
		this.colorMat=null;
		this.colorAlpha=null;
		this.texcoord=Value2D._TEXCOORD;
		(subID===void 0)&& (subID=0);
		TextureSV.__super.call(this,/*laya.webgl.shader.d2.ShaderDefines2D.TEXTURE2D*/0x01,subID);
	}

	__class(TextureSV,'laya.webgl.shader.d2.value.TextureSV',_super);
	var __proto=TextureSV.prototype;
	__proto.setValue=function(vo){
		this.ALPHA=vo.ALPHA;
		vo.filters && this.setFilters(vo.filters);
	}

	__proto.clear=function(){
		this.texture=null;
		this.shader=null;
		this.defines.setValue(0);
	}

	return TextureSV;
})(Value2D)


//class laya.webgl.shader.d2.value.PrimitiveSV extends laya.webgl.shader.d2.value.Value2D
var PrimitiveSV=(function(_super){
	function PrimitiveSV(args){
		this.a_color=null;
		this.u_pos=[0,0];
		PrimitiveSV.__super.call(this,/*laya.webgl.shader.d2.ShaderDefines2D.PRIMITIVE*/0x04,0);
		this.position=[2,/*laya.webgl.WebGLContext.FLOAT*/0x1406,false,5 *CONST3D2D.BYTES_PE,0];
		this.a_color=[3,/*laya.webgl.WebGLContext.FLOAT*/0x1406,false,5 *CONST3D2D.BYTES_PE,2 *CONST3D2D.BYTES_PE];
	}

	__class(PrimitiveSV,'laya.webgl.shader.d2.value.PrimitiveSV',_super);
	return PrimitiveSV;
})(Value2D)


//class laya.webgl.atlas.AtlasWebGLCanvas extends laya.resource.Bitmap
var AtlasWebGLCanvas=(function(_super){
	function AtlasWebGLCanvas(){
		this._atlaser=null;
		/**兼容Stage3D使用*/
		this._flashCacheImage=null;
		this._flashCacheImageNeedFlush=false;
		AtlasWebGLCanvas.__super.call(this);
	}

	__class(AtlasWebGLCanvas,'laya.webgl.atlas.AtlasWebGLCanvas',_super);
	var __proto=AtlasWebGLCanvas.prototype;
	/***重新创建资源*/
	__proto.recreateResource=function(){
		var gl=WebGL.mainContext;
		var glTex=this._source=gl.createTexture();
		var preTarget=WebGLContext.curBindTexTarget;
		var preTexture=WebGLContext.curBindTexValue;
		WebGLContext.bindTexture(gl,/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,glTex);
		gl.texImage2D(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,0,/*laya.webgl.WebGLContext.RGBA*/0x1908,this._w,this._h,0,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401,null);
		gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_MIN_FILTER*/0x2801,/*laya.webgl.WebGLContext.LINEAR*/0x2601);
		gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_MAG_FILTER*/0x2800,/*laya.webgl.WebGLContext.LINEAR*/0x2601);
		gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_WRAP_S*/0x2802,/*laya.webgl.WebGLContext.CLAMP_TO_EDGE*/0x812F);
		gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_WRAP_T*/0x2803,/*laya.webgl.WebGLContext.CLAMP_TO_EDGE*/0x812F);
		(preTarget && preTexture)&& (WebGLContext.bindTexture(gl,preTarget,preTexture));
		this.memorySize=this._w *this._h *4;
		this.completeCreate();
	}

	/***销毁资源*/
	__proto.disposeResource=function(){
		if (this._source){
			WebGL.mainContext.deleteTexture(this._source);
			this._source=null;
			this.memorySize=0;
		}
	}

	/**采样image到WebGLTexture的一部分*/
	__proto.texSubImage2D=function(xoffset,yoffset,bitmap){
		if (!Render.isFlash){
			var gl=WebGL.mainContext;
			var preTarget=WebGLContext.curBindTexTarget;
			var preTexture=WebGLContext.curBindTexValue;
			WebGLContext.bindTexture(gl,/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,this._source);
			if (Render.isConchWebGL){
				(xoffset-1 >=0)&& (gl.texSubImage2DEx(true,/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,0,xoffset-1,yoffset,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401,bitmap));
				(xoffset+1 <=this._w)&& (gl.texSubImage2DEx(true,/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,0,xoffset+1,yoffset,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401,bitmap));
				(yoffset-1 >=0)&& (gl.texSubImage2DEx(true,/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,0,xoffset,yoffset-1,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401,bitmap));
				(yoffset+1 <=this._h)&& (gl.texSubImage2DEx(true,/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,0,xoffset,yoffset+1,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401,bitmap));
				gl.texSubImage2DEx(true,/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,0,xoffset,yoffset,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401,bitmap);
			}
			else {
				gl.pixelStorei(/*laya.webgl.WebGLContext.UNPACK_PREMULTIPLY_ALPHA_WEBGL*/0x9241,true);
				(xoffset-1 >=0)&& (gl.texSubImage2D(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,0,xoffset-1,yoffset,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401,bitmap));
				(xoffset+1 <=this._w)&& (gl.texSubImage2D(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,0,xoffset+1,yoffset,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401,bitmap));
				(yoffset-1 >=0)&& (gl.texSubImage2D(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,0,xoffset,yoffset-1,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401,bitmap));
				(yoffset+1 <=this._h)&& (gl.texSubImage2D(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,0,xoffset,yoffset+1,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401,bitmap));
				gl.texSubImage2D(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,0,xoffset,yoffset,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401,bitmap);
				gl.pixelStorei(/*laya.webgl.WebGLContext.UNPACK_PREMULTIPLY_ALPHA_WEBGL*/0x9241,false);
			}
			(preTarget && preTexture)&& (WebGLContext.bindTexture(gl,preTarget,preTexture));
			}else {
			if (!this._flashCacheImage){
				this._flashCacheImage=HTMLImage.create("");
				this._flashCacheImage._image.createCanvas(this._w,this._h);
			};
			var bmData=bitmap.bitmapdata;
			this._flashCacheImage._image.copyPixels(bmData,0,0,bmData.width,bmData.height,xoffset,yoffset);
			(this._flashCacheImageNeedFlush)|| (this._flashCacheImageNeedFlush=true);
		}
	}

	/**采样image到WebGLTexture的一部分*/
	__proto.texSubImage2DPixel=function(xoffset,yoffset,width,height,pixel){
		var gl=WebGL.mainContext;
		var preTarget=WebGLContext.curBindTexTarget;
		var preTexture=WebGLContext.curBindTexValue;
		WebGLContext.bindTexture(gl,/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,this._source);
		var pixels=new Uint8Array(pixel.data);
		if (Render.isConchWebGL){
			gl.texSubImage2DEx(true,/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,0,xoffset,yoffset,width,height,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401,pixels);
		}
		else {
			gl.pixelStorei(/*laya.webgl.WebGLContext.UNPACK_PREMULTIPLY_ALPHA_WEBGL*/0x9241,true);
			gl.texSubImage2D(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,0,xoffset,yoffset,width,height,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401,pixels);
			gl.pixelStorei(/*laya.webgl.WebGLContext.UNPACK_PREMULTIPLY_ALPHA_WEBGL*/0x9241,false);
		}
		(preTarget && preTexture)&& (WebGLContext.bindTexture(gl,preTarget,preTexture));
	}

	/***
	*设置图片宽度
	*@param value 图片宽度
	*/
	__getset(0,__proto,'width',_super.prototype._$get_width,function(value){
		this._w=value;
	});

	/***
	*设置图片高度
	*@param value 图片高度
	*/
	__getset(0,__proto,'height',_super.prototype._$get_height,function(value){
		this._h=value;
	});

	return AtlasWebGLCanvas;
})(Bitmap)


/**@private */
//class laya.webgl.resource.WebGLCanvas extends laya.resource.Bitmap
var WebGLCanvas=(function(_super){
	function WebGLCanvas(){
		this.flipY=true;
		//上传的时候是否预乘alpha
		//this._ctx=null;
		/**HTML Canvas*/
		//this._canvas=null;
		//this._imgData=null;
		//}
		//this.iscpuSource=false;
		this.alwaysChange=false;
		WebGLCanvas.__super.call(this);
	}

	__class(WebGLCanvas,'laya.webgl.resource.WebGLCanvas',_super);
	var __proto=WebGLCanvas.prototype;
	//}
	__proto.getCanvas=function(){
		return this._canvas;
	}

	__proto.clear=function(){
		this._ctx && this._ctx.clear();
	}

	__proto.destroy=function(){
		this._ctx && this._ctx.destroy();
		this._ctx=null;
	}

	__proto._setContext=function(context){
		this._ctx=context;
	}

	__proto.getContext=function(contextID,other){
		return this._ctx ? this._ctx :(this._ctx=WebGLCanvas._createContext(this));
	}

	/*override public function copyTo(dec:Bitmap):void {
	super.copyTo(dec);
	(dec as WebGLCanvas)._ctx=_ctx;
}*/


__proto.size=function(w,h){
	if (this._w !=w || this._h !=h){
		this._w=w;
		this._h=h;
		this._ctx && this._ctx.size(w,h);
		this._canvas && (this._canvas.height=h,this._canvas.width=w);
	}

}


__proto.activeResource=function(force){
	(force===void 0)&& (force=false);
	if (!this._source){
		this.recreateResource();
	}

}


__proto.recreateResource=function(){
	this.createWebGlTexture();
	this.completeCreate();
}


__proto.disposeResource=function(){
	if (this._source && !this.iscpuSource){
		WebGL.mainContext.deleteTexture(this._source);
		this._source=null;
		this.memorySize=0;
	}

}


__proto.createWebGlTexture=function(){
	var gl=WebGL.mainContext;
	if (!this._canvas){
	};

	var glTex=this._source=gl.createTexture();
	this.iscpuSource=false;
	var preTarget=WebGLContext.curBindTexTarget;
	var preTexture=WebGLContext.curBindTexValue;
	WebGLContext.bindTexture(gl,/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,glTex);
	gl.pixelStorei(/*laya.webgl.WebGLContext.UNPACK_FLIP_Y_WEBGL*/0x9240,this.flipY?1:0);
	if (Render.isConchWebGL){
		gl.texImage2DEx(WebGLCanvas.premulAlpha,/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,0,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401,this._imgData);
	}

	else {
		WebGLCanvas.premulAlpha&&gl.pixelStorei(/*laya.webgl.WebGLContext.UNPACK_PREMULTIPLY_ALPHA_WEBGL*/0x9241,true);
		gl.texImage2D(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,0,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401,this._imgData);
		WebGLCanvas.premulAlpha && gl.pixelStorei(/*laya.webgl.WebGLContext.UNPACK_PREMULTIPLY_ALPHA_WEBGL*/0x9241,false);
	}

	gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_MAG_FILTER*/0x2800,/*laya.webgl.WebGLContext.LINEAR*/0x2601);
	gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_MIN_FILTER*/0x2801,/*laya.webgl.WebGLContext.LINEAR*/0x2601);
	gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_WRAP_S*/0x2802,/*laya.webgl.WebGLContext.CLAMP_TO_EDGE*/0x812F);
	gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_WRAP_T*/0x2803,/*laya.webgl.WebGLContext.CLAMP_TO_EDGE*/0x812F);
	gl.pixelStorei(/*laya.webgl.WebGLContext.UNPACK_FLIP_Y_WEBGL*/0x9240,0);
	this.memorySize=this._w *this._h *4;
	(preTarget && preTexture)&& (WebGLContext.bindTexture(gl,preTarget,preTexture));
}


//_canvas=null;
__proto.reloadCanvasData=function(){
	var gl=WebGL.mainContext;
	if (!this._source){
		throw "reloadCanvasData error, gl texture not created!";
	};

	var preTarget=WebGLContext.curBindTexTarget;
	var preTexture=WebGLContext.curBindTexValue;
	WebGLContext.bindTexture(gl,/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,this._source);
	if (Render.isConchWebGL){
		gl.texImage2DEx(WebGLCanvas.premulAlpha,/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,0,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401,this._imgData);
	}

	else {
		WebGLCanvas.premulAlpha&&gl.pixelStorei(/*laya.webgl.WebGLContext.UNPACK_PREMULTIPLY_ALPHA_WEBGL*/0x9241,true);
		gl.texImage2D(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,0,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401,this._imgData);
		WebGLCanvas.premulAlpha && gl.pixelStorei(/*laya.webgl.WebGLContext.UNPACK_PREMULTIPLY_ALPHA_WEBGL*/0x9241,false);
	}

	gl.pixelStorei(/*laya.webgl.WebGLContext.UNPACK_FLIP_Y_WEBGL*/0x9240,0);
	(preTarget && preTexture)&& (WebGLContext.bindTexture(gl,preTarget,preTexture));
}


//_canvas=null;
__proto.texSubImage2D=function(webglCanvas,xoffset,yoffset){
	var gl=WebGL.mainContext;
	var preTarget=WebGLContext.curBindTexTarget;
	var preTexture=WebGLContext.curBindTexValue;
	WebGLContext.bindTexture(gl,/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,this._source);
	if (Render.isConchWebGL){
		gl.texSubImage2DEx(true,/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,0,xoffset,yoffset,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401,webglCanvas._source);
	}

	else {
		gl.pixelStorei(/*laya.webgl.WebGLContext.UNPACK_PREMULTIPLY_ALPHA_WEBGL*/0x9241,true);
		gl.texSubImage2D(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,0,xoffset,yoffset,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401,webglCanvas._source);
		gl.pixelStorei(/*laya.webgl.WebGLContext.UNPACK_PREMULTIPLY_ALPHA_WEBGL*/0x9241,false);
	}

	(preTarget && preTexture)&& (WebGLContext.bindTexture(gl,preTarget,preTexture));
}


__proto.toBase64=function(type,encoderOptions,callBack){
	var base64Data=null;
	if (this._canvas){
		base64Data=this._canvas.toDataURL(type,encoderOptions);
	}

	callBack.call(this,base64Data);
}


__getset(0,__proto,'context',function(){
	return this._ctx;
});


__getset(0,__proto,'source',function(){
	if (this.alwaysChange)this.reloadCanvasData();
	return this._source;
});


__getset(0,__proto,'asBitmap',null,function(value){
	this._ctx && (this._ctx.asBitmap=value);
});


WebGLCanvas._createContext=null;
WebGLCanvas.premulAlpha=false;
return WebGLCanvas;
})(Bitmap)


//class laya.webgl.resource.WebGLCharImage extends laya.resource.Bitmap
var WebGLCharImage=(function(_super){
	function WebGLCharImage(content,drawValue){
		this.CborderSize=12;
		//this._ctx=null;
		/***是否创建私有Source*/
		//this._allowMerageInAtlas=false;
		/**是否允许加入大图合集*/
		//this._enableMerageInAtlas=false;
		/**HTML Canvas，绘制字符载体,非私有数据载体*/
		//this.canvas=null;
		/**********************************************************************************/
		//this.cw=NaN;
		//this.ch=NaN;
		//this.xs=NaN;
		//this.ys=NaN;
		//this.char=null;
		//this.fillColor=null;
		//this.borderColor=null;
		//this.borderSize=0;
		//this.font=null;
		//this.fontSize=0;
		//this.texture=null;
		//this.lineWidth=0;
		//this.UV=null;
		//this.isSpace=false;
		//this.underLine=0;
		WebGLCharImage.__super.call(this);
		this.char=content;
		this.isSpace=content===' ';
		this.xs=drawValue.scaleX;
		this.ys=drawValue.scaleY;
		this.font=drawValue.font.toString();
		this.fontSize=drawValue.font.size;
		this.fillColor=drawValue.fillColor;
		this.borderColor=drawValue.borderColor;
		this.lineWidth=drawValue.lineWidth;
		this.underLine=drawValue.underLine;
		var bIsConchApp=Render.isConchApp;
		var pCanvas;
		if (bIsConchApp){
			/*__JS__ */pCanvas=ConchTextCanvas;
			/*__JS__ */pCanvas._source=ConchTextCanvas;
			/*__JS__ */pCanvas._source.canvas=ConchTextCanvas;
			}else {
			pCanvas=Browser.canvas.source;
		}
		this.canvas=pCanvas;
		this._enableMerageInAtlas=true;
		if (bIsConchApp){
			/*__JS__ */this._ctx=pCanvas;
			}else {
			this._ctx=this.canvas.getContext('2d',undefined);
		};
		var t=Utils.measureText(this.char,this.font);
		this.cw=t.width *this.xs;
		this.ch=(t.height || this.fontSize)*this.ys;
		this.onresize(this.cw+this.CborderSize *2,this.ch+this.CborderSize *2);
		this.texture=new Texture(this);
	}

	__class(WebGLCharImage,'laya.webgl.resource.WebGLCharImage',_super);
	var __proto=WebGLCharImage.prototype;
	Laya.imps(__proto,{"laya.webgl.resource.IMergeAtlasBitmap":true})
	__proto.active=function(){
		this.texture.active();
	}

	__proto.recreateResource=function(){
		var bIsConchApp=Render.isConchApp;
		this.onresize(this.cw+this.CborderSize *2,this.ch+this.CborderSize *2);
		this.canvas && (this.canvas.height=this._h,this.canvas.width=this._w);
		if (bIsConchApp){
			var nFontSize=this.fontSize;
			if (this.xs !=1 || this.ys !=1){
				nFontSize=parseInt(nFontSize *((this.xs > this.ys)? this.xs :this.ys)+"");
			};
			var sFont="normal 100 "+nFontSize+"px Arial";
			if (this.borderColor){
				sFont+=" 1 "+this.borderColor;
			}
			this._ctx.font=sFont;
			this._ctx.textBaseline="top";
			this._ctx.fillStyle=this.fillColor;
			this._ctx.fillText(this.char,this.CborderSize,this.CborderSize,null,null,null);
			}else {
			this._ctx.save();
			(this._ctx).clearRect(0,0,this.cw+this.CborderSize *2,this.ch+this.CborderSize *2);
			this._ctx.font=this.font;
			if (Text.RightToLeft){
				this._ctx.textAlign="end";
			}
			this._ctx.textBaseline="top";
			this._ctx.translate(this.CborderSize,this.CborderSize);
			if (this.xs !=1 || this.ys !=1){
				this._ctx.scale(this.xs,this.ys);
			}
			if (this.fillColor && this.borderColor){
				this._ctx.strokeStyle=this.borderColor;
				this._ctx.lineWidth=this.lineWidth;
				this._ctx.strokeText(this.char,0,0,null,null,0,null);
				this._ctx.fillStyle=this.fillColor;
				this._ctx.fillText(this.char,0,0,null,null,null);
				}else {
				if (this.lineWidth===-1){
					this._ctx.fillStyle=this.fillColor ? this.fillColor :"white";
					this._ctx.fillText(this.char,0,0,null,null,null);
					}else {
					this._ctx.strokeStyle=this.borderColor?this.borderColor:'white';
					this._ctx.lineWidth=this.lineWidth;
					this._ctx.strokeText(this.char,0,0,null,null,0,null);
				}
			}
			if (this.underLine){
				this._ctx.lineWidth=1;
				this._ctx.strokeStyle=this.fillColor;
				this._ctx.beginPath();
				this._ctx.moveTo(0,this.fontSize+1);
				var nW=this._ctx.measureText(this.char).width+1;
				this._ctx.lineTo(nW,this.fontSize+1);
				this._ctx.stroke();
			}
			this._ctx.restore();
		}
		this.borderSize=this.CborderSize;
		this.completeCreate();
	}

	__proto.onresize=function(w,h){
		this._w=w;
		this._h=h;
		this._allowMerageInAtlas=true;
	}

	__proto.clearAtlasSource=function(){}
	/**
	*是否创建私有Source
	*@return 是否创建
	*/
	__getset(0,__proto,'allowMerageInAtlas',function(){
		return this._allowMerageInAtlas;
	});

	__getset(0,__proto,'atlasSource',function(){
		return this.canvas;
	});

	/**
	*是否创建私有Source,通常禁止修改
	*@param value 是否创建
	*/
	/**
	*是否创建私有Source
	*@return 是否创建
	*/
	__getset(0,__proto,'enableMerageInAtlas',function(){
		return this._enableMerageInAtlas;
		},function(value){
		this._enableMerageInAtlas=value;
	});

	WebGLCharImage.createOneChar=function(content,drawValue){
		var char=new WebGLCharImage(content,drawValue);
		return char;
	}

	return WebGLCharImage;
})(Bitmap)


//class laya.webgl.resource.WebGLRenderTarget extends laya.resource.Bitmap
var WebGLRenderTarget=(function(_super){
	function WebGLRenderTarget(width,height,surfaceFormat,surfaceType,depthStencilFormat,mipMap,repeat,minFifter,magFifter){
		//this._frameBuffer=null;
		//this._depthStencilBuffer=null;
		//this._surfaceFormat=0;
		//this._surfaceType=0;
		//this._depthStencilFormat=0;
		//this._mipMap=false;
		//this._repeat=false;
		//this._minFifter=0;
		//this._magFifter=0;
		(surfaceFormat===void 0)&& (surfaceFormat=/*laya.webgl.WebGLContext.RGBA*/0x1908);
		(surfaceType===void 0)&& (surfaceType=/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401);
		(depthStencilFormat===void 0)&& (depthStencilFormat=/*laya.webgl.WebGLContext.DEPTH_STENCIL*/0x84F9);
		(mipMap===void 0)&& (mipMap=false);
		(repeat===void 0)&& (repeat=false);
		(minFifter===void 0)&& (minFifter=-1);
		(magFifter===void 0)&& (magFifter=1);
		WebGLRenderTarget.__super.call(this);
		this._w=width;
		this._h=height;
		this._surfaceFormat=surfaceFormat;
		this._surfaceType=surfaceType;
		this._depthStencilFormat=depthStencilFormat;
		if (Render.isConchWebGL && this._depthStencilFormat===/*laya.webgl.WebGLContext.DEPTH_STENCIL*/0x84F9){
			this._depthStencilFormat=/*laya.webgl.WebGLContext.DEPTH_COMPONENT16*/0x81A5;
		}
		this._mipMap=mipMap;
		this._repeat=repeat;
		this._minFifter=minFifter;
		this._magFifter=magFifter;
	}

	__class(WebGLRenderTarget,'laya.webgl.resource.WebGLRenderTarget',_super);
	var __proto=WebGLRenderTarget.prototype;
	__proto.recreateResource=function(){
		var gl=WebGL.mainContext;
		this._frameBuffer || (this._frameBuffer=gl.createFramebuffer());
		this._source || (this._source=gl.createTexture());
		var preTarget=WebGLContext.curBindTexTarget;
		var preTexture=WebGLContext.curBindTexValue;
		WebGLContext.bindTexture(gl,/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,this._source);
		gl.texImage2D(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,0,/*laya.webgl.WebGLContext.RGBA*/0x1908,this._w,this._h,0,this._surfaceFormat,this._surfaceType,null);
		var minFifter=this._minFifter;
		var magFifter=this._magFifter;
		var repeat=this._repeat ? /*laya.webgl.WebGLContext.REPEAT*/0x2901 :/*laya.webgl.WebGLContext.CLAMP_TO_EDGE*/0x812F;
		var isPot=Arith.isPOT(this._w,this._h);
		if (isPot){
			if (this._mipMap)
				(minFifter!==-1)|| (minFifter=/*laya.webgl.WebGLContext.LINEAR_MIPMAP_LINEAR*/0x2703);
			else
			(minFifter!==-1)|| (minFifter=/*laya.webgl.WebGLContext.LINEAR*/0x2601);
			(magFifter!==-1)|| (magFifter=/*laya.webgl.WebGLContext.LINEAR*/0x2601);
			gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_MIN_FILTER*/0x2801,minFifter);
			gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_MAG_FILTER*/0x2800,magFifter);
			gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_WRAP_S*/0x2802,repeat);
			gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_WRAP_T*/0x2803,repeat);
			this._mipMap && gl.generateMipmap(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1);
			}else {
			(minFifter!==-1)|| (minFifter=/*laya.webgl.WebGLContext.LINEAR*/0x2601);
			(magFifter!==-1)|| (magFifter=/*laya.webgl.WebGLContext.LINEAR*/0x2601);
			gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_MIN_FILTER*/0x2801,minFifter);
			gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_MAG_FILTER*/0x2800,magFifter);
			gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_WRAP_S*/0x2802,/*laya.webgl.WebGLContext.CLAMP_TO_EDGE*/0x812F);
			gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_WRAP_T*/0x2803,/*laya.webgl.WebGLContext.CLAMP_TO_EDGE*/0x812F);
		}
		gl.bindFramebuffer(/*laya.webgl.WebGLContext.FRAMEBUFFER*/0x8D40,this._frameBuffer);
		gl.framebufferTexture2D(/*laya.webgl.WebGLContext.FRAMEBUFFER*/0x8D40,/*laya.webgl.WebGLContext.COLOR_ATTACHMENT0*/0x8CE0,/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,this._source,0);
		if (this._depthStencilFormat){
			this._depthStencilBuffer || (this._depthStencilBuffer=gl.createRenderbuffer());
			gl.bindRenderbuffer(/*laya.webgl.WebGLContext.RENDERBUFFER*/0x8D41,this._depthStencilBuffer);
			gl.renderbufferStorage(/*laya.webgl.WebGLContext.RENDERBUFFER*/0x8D41,this._depthStencilFormat,this._w,this._h);
			switch (this._depthStencilFormat){
				case /*laya.webgl.WebGLContext.DEPTH_COMPONENT16*/0x81A5:
					gl.framebufferRenderbuffer(/*laya.webgl.WebGLContext.FRAMEBUFFER*/0x8D40,/*laya.webgl.WebGLContext.DEPTH_ATTACHMENT*/0x8D00,/*laya.webgl.WebGLContext.RENDERBUFFER*/0x8D41,this._depthStencilBuffer);
					break ;
				case /*laya.webgl.WebGLContext.STENCIL_INDEX8*/0x8D48:
					gl.framebufferRenderbuffer(/*laya.webgl.WebGLContext.FRAMEBUFFER*/0x8D40,/*laya.webgl.WebGLContext.STENCIL_ATTACHMENT*/0x8D20,/*laya.webgl.WebGLContext.RENDERBUFFER*/0x8D41,this._depthStencilBuffer);
					break ;
				case /*laya.webgl.WebGLContext.DEPTH_STENCIL*/0x84F9:
					gl.framebufferRenderbuffer(/*laya.webgl.WebGLContext.FRAMEBUFFER*/0x8D40,/*laya.webgl.WebGLContext.DEPTH_STENCIL_ATTACHMENT*/0x821A,/*laya.webgl.WebGLContext.RENDERBUFFER*/0x8D41,this._depthStencilBuffer);
					break ;
				}
		}
		gl.bindFramebuffer(/*laya.webgl.WebGLContext.FRAMEBUFFER*/0x8D40,null);
		(preTarget && preTexture)&& (WebGLContext.bindTexture(gl,preTarget,preTexture));
		gl.bindRenderbuffer(/*laya.webgl.WebGLContext.RENDERBUFFER*/0x8D41,null);
		if (isPot && this._mipMap)
			this.memorySize=this._w *this._h *4 *(1+1 / 3);
		else
		this.memorySize=this._w *this._h *4;
		this.completeCreate();
	}

	__proto.disposeResource=function(){
		if (this._frameBuffer){
			WebGL.mainContext.deleteTexture(this._source);
			WebGL.mainContext.deleteFramebuffer(this._frameBuffer);
			WebGL.mainContext.deleteRenderbuffer(this._depthStencilBuffer);
			this._source=null;
			this._frameBuffer=null;
			this._depthStencilBuffer=null;
			this.memorySize=0;
		}
	}

	__getset(0,__proto,'depthStencilBuffer',function(){
		return this._depthStencilBuffer;
	});

	__getset(0,__proto,'frameBuffer',function(){
		return this._frameBuffer;
	});

	return WebGLRenderTarget;
})(Bitmap)


//class laya.webgl.resource.WebGLSubImage extends laya.resource.Bitmap
var WebGLSubImage=(function(_super){
	function WebGLSubImage(canvas,offsetX,offsetY,width,height,atlasImage,src){
		/**HTML Context*/
		//this._ctx=null;
		/***是否创建私有Source,值为false时不根据src创建私有WebGLTexture,同时销毁时也只清空source=null,不调用WebGL.mainContext.deleteTexture类似函数，调用资源激活前有效*/
		//this._allowMerageInAtlas=false;
		/**是否允许加入大图合集*/
		//this._enableMerageInAtlas=false;
		/**HTML Canvas，绘制子图载体,非私有数据载体*/
		//this.canvas=null;
		/**是否使用重复模式纹理寻址*/
		//this.repeat=false;
		/**是否使用mipLevel*/
		//this.mipmap=false;
		/**缩小过滤器*/
		//this.minFifter=0;
		/**放大过滤器*/
		//this.magFifter=0;
		//动态默认值，判断是否可生成miplevel
		//this.atlasImage=null;
		this.offsetX=0;
		this.offsetY=0;
		//this.src=null;
		WebGLSubImage.__super.call(this);
		this.repeat=true;
		this.mipmap=false;
		this.minFifter=-1;
		this.magFifter=-1;
		this.atlasImage=atlasImage;
		this.canvas=canvas;
		this._ctx=canvas.getContext('2d',undefined);
		this._w=width;
		this._h=height;
		this.offsetX=offsetX;
		this.offsetY=offsetY;
		this.src=src;
		this._enableMerageInAtlas=true;
		(AtlasResourceManager.enabled)&& (this._w < AtlasResourceManager.atlasLimitWidth && this._h < AtlasResourceManager.atlasLimitHeight)? this._allowMerageInAtlas=true :this._allowMerageInAtlas=false;
	}

	__class(WebGLSubImage,'laya.webgl.resource.WebGLSubImage',_super);
	var __proto=WebGLSubImage.prototype;
	Laya.imps(__proto,{"laya.webgl.resource.IMergeAtlasBitmap":true})
	/*override public function copyTo(dec:Bitmap):void {
	var d:WebGLSubImage=dec as WebGLSubImage;
	super.copyTo(dec);
	d._ctx=_ctx;
}*/


__proto.size=function(w,h){
	this._w=w;
	this._h=h;
	this._ctx && this._ctx.size(w,h);
	this.canvas && (this.canvas.height=h,this.canvas.width=w);
}


__proto.recreateResource=function(){
	this.size(this._w,this._h);
	this._ctx.drawImage(this.atlasImage,this.offsetX,this.offsetY,this._w,this._h,0,0,this._w,this._h);
	(!(this._allowMerageInAtlas && this._enableMerageInAtlas))? (this.createWebGlTexture()):(this.memorySize=0);
	this.completeCreate();
}


__proto.createWebGlTexture=function(){
	var gl=WebGL.mainContext;
	if (!this.canvas){
		throw "create GLTextur err:no data:"+this.canvas;
	};

	var glTex=this._source=gl.createTexture();
	var preTarget=WebGLContext.curBindTexTarget;
	var preTexture=WebGLContext.curBindTexValue;
	WebGLContext.bindTexture(gl,/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,glTex);
	if (Render.isConchWebGL){
		gl.texImage2DEx(true,/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,0,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401,this.canvas);
	}

	else {
		gl.pixelStorei(/*laya.webgl.WebGLContext.UNPACK_PREMULTIPLY_ALPHA_WEBGL*/0x9241,true);
		gl.texImage2D(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,0,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401,this.canvas);
		gl.pixelStorei(/*laya.webgl.WebGLContext.UNPACK_PREMULTIPLY_ALPHA_WEBGL*/0x9241,false);
	};

	var minFifter=this.minFifter;
	var magFifter=this.magFifter;
	var repeat=this.repeat ? /*laya.webgl.WebGLContext.REPEAT*/0x2901 :/*laya.webgl.WebGLContext.CLAMP_TO_EDGE*/0x812F;
	var isPOT=Arith.isPOT(this.width,this.height);
	if (isPOT){
		if (this.mipmap)
			(minFifter!==-1)|| (minFifter=/*laya.webgl.WebGLContext.LINEAR_MIPMAP_LINEAR*/0x2703);
		else
		(minFifter!==-1)|| (minFifter=/*laya.webgl.WebGLContext.LINEAR*/0x2601);
		(magFifter!==-1)|| (magFifter=/*laya.webgl.WebGLContext.LINEAR*/0x2601);
		gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_MAG_FILTER*/0x2800,magFifter);
		gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_MIN_FILTER*/0x2801,minFifter);
		gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_WRAP_S*/0x2802,repeat);
		gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_WRAP_T*/0x2803,repeat);
		this.mipmap && gl.generateMipmap(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1);
		}else {
		(minFifter!==-1)|| (minFifter=/*laya.webgl.WebGLContext.LINEAR*/0x2601);
		(magFifter!==-1)|| (magFifter=/*laya.webgl.WebGLContext.LINEAR*/0x2601);
		gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_MIN_FILTER*/0x2801,minFifter);
		gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_MAG_FILTER*/0x2800,magFifter);
		gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_WRAP_S*/0x2802,/*laya.webgl.WebGLContext.CLAMP_TO_EDGE*/0x812F);
		gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_WRAP_T*/0x2803,/*laya.webgl.WebGLContext.CLAMP_TO_EDGE*/0x812F);
	}

	(preTarget && preTexture)&& (WebGLContext.bindTexture(gl,preTarget,preTexture));
	this.canvas=null;
	if (isPOT && this.mipmap)
		this.memorySize=this._w *this._h *4 *(1+1 / 3);
	else
	this.memorySize=this._w *this._h *4;
}


__proto.disposeResource=function(){
	if (!(AtlasResourceManager.enabled && this._allowMerageInAtlas)&& this._source){
		WebGL.mainContext.deleteTexture(this._source);
		this._source=null;
		this.memorySize=0;
	}

}


//}
__proto.clearAtlasSource=function(){}
/**
*是否创建私有Source
*@return 是否创建
*/
__getset(0,__proto,'allowMerageInAtlas',function(){
	return this._allowMerageInAtlas;
});


//public var createFromPixel:Boolean=true;
__getset(0,__proto,'atlasSource',function(){
	return this.canvas;
});


/**
*是否创建私有Source,通常禁止修改
*@param value 是否创建
*/
/**
*是否创建私有Source
*@return 是否创建
*/
__getset(0,__proto,'enableMerageInAtlas',function(){
	return this._allowMerageInAtlas;
	},function(value){

	this._allowMerageInAtlas=value;
});


return WebGLSubImage;
})(Bitmap)


//class laya.webgl.shader.Shader extends laya.webgl.shader.BaseShader
var Shader=(function(_super){
	function Shader(vs,ps,saveName,nameMap){
		//this._nameMap=null;
		//shader参数别名，语义
		//this._vs=null;
		//this._ps=null;
		this._curActTexIndex=0;
		//this._reCompile=false;
		//存储一些私有变量
		this.tag={};
		//this._vshader=null;
		//this._pshader=null;
		this._program=null;
		this._params=null;
		this._paramsMap={};
		this._offset=0;
		//this._id=0;
		Shader.__super.call(this);
		if ((!vs)|| (!ps))throw "Shader Error";
		this._id=++Shader._count;
		this._vs=vs;
		this._ps=ps;
		this._nameMap=nameMap ? nameMap :{};
		saveName !=null && (Shader.sharders[saveName]=this);
	}

	__class(Shader,'laya.webgl.shader.Shader',_super);
	var __proto=Shader.prototype;
	__proto.recreateResource=function(){
		this._compile();
		this.completeCreate();
		this.memorySize=0;
	}

	//忽略尺寸尺寸
	__proto.disposeResource=function(){
		WebGL.mainContext.deleteShader(this._vshader);
		WebGL.mainContext.deleteShader(this._pshader);
		WebGL.mainContext.deleteProgram(this._program);
		this._vshader=this._pshader=this._program=null;
		this._params=null;
		this._paramsMap={};
		this.memorySize=0;
		this._curActTexIndex=0;
	}

	__proto._compile=function(){
		if (!this._vs || !this._ps || this._params)
			return;
		this._reCompile=true;
		this._params=[];
		var text=[this._vs,this._ps];
		var result;
		var gl=WebGL.mainContext;
		this._program=gl.createProgram();
		this._vshader=Shader._createShader(gl,text[0],/*laya.webgl.WebGLContext.VERTEX_SHADER*/0x8B31);
		this._pshader=Shader._createShader(gl,text[1],/*laya.webgl.WebGLContext.FRAGMENT_SHADER*/0x8B30);
		gl.attachShader(this._program,this._vshader);
		gl.attachShader(this._program,this._pshader);
		gl.linkProgram(this._program);
		if (!Render.isConchApp && !gl.getProgramParameter(this._program,/*laya.webgl.WebGLContext.LINK_STATUS*/0x8B82)){
			throw gl.getProgramInfoLog(this._program);
		};
		var one,i=0,j=0,n=0,location;
		var attribNum=0;
		if (Render.isConchApp){
			attribNum=gl.getProgramParameterEx(this._vs,this._ps,"",/*laya.webgl.WebGLContext.ACTIVE_ATTRIBUTES*/0x8B89);
		}
		else{
			attribNum=gl.getProgramParameter(this._program,/*laya.webgl.WebGLContext.ACTIVE_ATTRIBUTES*/0x8B89);
		}
		for (i=0;i < attribNum;i++){
			var attrib=null;
			if (Render.isConchApp){
				attrib=gl.getActiveAttribEx(this._vs,this._ps,"",i);
			}
			else{
				attrib=gl.getActiveAttrib(this._program,i);
			}
			location=gl.getAttribLocation(this._program,attrib.name);
			one={vartype:"attribute",glfun:null,ivartype:0,attrib:attrib,location:location,name:attrib.name,type:attrib.type,isArray:false,isSame:false,preValue:null,indexOfParams:0};
			this._params.push(one);
		};
		var nUniformNum=0;
		if (Render.isConchApp){
			nUniformNum=gl.getProgramParameterEx(this._vs,this._ps,"",/*laya.webgl.WebGLContext.ACTIVE_UNIFORMS*/0x8B86);
		}
		else{
			nUniformNum=gl.getProgramParameter(this._program,/*laya.webgl.WebGLContext.ACTIVE_UNIFORMS*/0x8B86);
		}
		for (i=0;i < nUniformNum;i++){
			var uniform=null;
			if (Render.isConchApp){
				uniform=gl.getActiveUniformEx(this._vs,this._ps,"",i);
			}
			else{
				uniform=gl.getActiveUniform(this._program,i);
			}
			location=gl.getUniformLocation(this._program,uniform.name);
			one={vartype:"uniform",glfun:null,ivartype:1,attrib:attrib,location:location,name:uniform.name,type:uniform.type,isArray:false,isSame:false,preValue:null,indexOfParams:0};
			if (one.name.indexOf('[0]')> 0){
				one.name=one.name.substr(0,one.name.length-3);
				one.isArray=true;
				one.location=gl.getUniformLocation(this._program,one.name);
			}
			this._params.push(one);
		}
		for (i=0,n=this._params.length;i < n;i++){
			one=this._params[i];
			one.indexOfParams=i;
			one.index=1;
			one.value=[one.location,null];
			one.codename=one.name;
			one.name=this._nameMap[one.codename] ? this._nameMap[one.codename] :one.codename;
			this._paramsMap[one.name]=one;
			one._this=this;
			one.uploadedValue=[];
			if (one.vartype==="attribute"){
				one.fun=this._attribute;
				continue ;
			}
			switch (one.type){
				case /*laya.webgl.WebGLContext.INT*/0x1404:
					one.fun=one.isArray ? this._uniform1iv :this._uniform1i;
					break ;
				case /*laya.webgl.WebGLContext.FLOAT*/0x1406:
					one.fun=one.isArray ? this._uniform1fv :this._uniform1f;
					break ;
				case /*laya.webgl.WebGLContext.FLOAT_VEC2*/0x8B50:
					one.fun=one.isArray ? this._uniform_vec2v:this._uniform_vec2;
					break ;
				case /*laya.webgl.WebGLContext.FLOAT_VEC3*/0x8B51:
					one.fun=one.isArray ? this._uniform_vec3v:this._uniform_vec3;
					break ;
				case /*laya.webgl.WebGLContext.FLOAT_VEC4*/0x8B52:
					one.fun=one.isArray ? this._uniform_vec4v:this._uniform_vec4;
					break ;
				case /*laya.webgl.WebGLContext.SAMPLER_2D*/0x8B5E:
					one.fun=this._uniform_sampler2D;
					break ;
				case /*laya.webgl.WebGLContext.SAMPLER_CUBE*/0x8B60:
					one.fun=this._uniform_samplerCube;
					break ;
				case /*laya.webgl.WebGLContext.FLOAT_MAT4*/0x8B5C:
					one.glfun=gl.uniformMatrix4fv;
					one.fun=this._uniformMatrix4fv;
					break ;
				case /*laya.webgl.WebGLContext.BOOL*/0x8B56:
					one.fun=this._uniform1i;
					break ;
				case /*laya.webgl.WebGLContext.FLOAT_MAT2*/0x8B5A:
				case /*laya.webgl.WebGLContext.FLOAT_MAT3*/0x8B5B:
					throw new Error("compile shader err!");
					break ;
				default :
					throw new Error("compile shader err!");
					break ;
				}
		}
	}

	/**
	*根据变量名字获得
	*@param name
	*@return
	*/
	__proto.getUniform=function(name){
		return this._paramsMap[name];
	}

	__proto._attribute=function(one,value){
		var gl=WebGL.mainContext;
		var enableAtributes=Buffer._enableAtributes;
		var location=one.location;
		(enableAtributes[location])||(gl.enableVertexAttribArray(location));
		gl.vertexAttribPointer(location,value[0],value[1],value[2],value[3],value[4]+this._offset);
		enableAtributes[location]=Buffer._bindVertexBuffer;
		return 1;
	}

	__proto._uniform1f=function(one,value){
		var uploadedValue=one.uploadedValue;
		if (uploadedValue[0]!==value){
			WebGL.mainContext.uniform1f(one.location,uploadedValue[0]=value);
			return 1;
		}
		return 0;
	}

	__proto._uniform1fv=function(one,value){
		if (value.length < 4){
			var uploadedValue=one.uploadedValue;
			if (uploadedValue[0]!==value[0] || uploadedValue[1]!==value[1] || uploadedValue[2]!==value[2] || uploadedValue[3]!==value[3]){
				WebGL.mainContext.uniform1fv(one.location,value);
				uploadedValue[0]=value[0];
				uploadedValue[1]=value[1];
				uploadedValue[2]=value[2];
				uploadedValue[3]=value[3];
				return 1;
			}
			return 0;
			}else {
			WebGL.mainContext.uniform1fv(one.location,value);
			return 1;
		}
	}

	__proto._uniform_vec2=function(one,value){
		var uploadedValue=one.uploadedValue;
		if (uploadedValue[0]!==value[0] || uploadedValue[1]!==value[1]){
			WebGL.mainContext.uniform2f(one.location,uploadedValue[0]=value[0],uploadedValue[1]=value[1]);
			return 1;
		}
		return 0;
	}

	__proto._uniform_vec2v=function(one,value){
		if (value.length < 2){
			var uploadedValue=one.uploadedValue;
			if (uploadedValue[0]!==value[0] || uploadedValue[1]!==value[1] || uploadedValue[2]!==value[2] || uploadedValue[3]!==value[3]){
				WebGL.mainContext.uniform2fv(one.location,value);
				uploadedValue[0]=value[0];
				uploadedValue[1]=value[1];
				uploadedValue[2]=value[2];
				uploadedValue[3]=value[3];
				return 1;
			}
			return 0;
			}else {
			WebGL.mainContext.uniform2fv(one.location,value);
			return 1;
		}
	}

	__proto._uniform_vec3=function(one,value){
		var uploadedValue=one.uploadedValue;
		if (uploadedValue[0]!==value[0] || uploadedValue[1]!==value[1] || uploadedValue[2]!==value[2]){
			WebGL.mainContext.uniform3f(one.location,uploadedValue[0]=value[0],uploadedValue[1]=value[1],uploadedValue[2]=value[2]);
			return 1;
		}
		return 0;
	}

	__proto._uniform_vec3v=function(one,value){
		WebGL.mainContext.uniform3fv(one.location,value);
		return 1;
	}

	__proto._uniform_vec4=function(one,value){
		var uploadedValue=one.uploadedValue;
		if (uploadedValue[0]!==value[0] || uploadedValue[1]!==value[1] || uploadedValue[2]!==value[2] || uploadedValue[3]!==value[3]){
			WebGL.mainContext.uniform4f(one.location,uploadedValue[0]=value[0],uploadedValue[1]=value[1],uploadedValue[2]=value[2],uploadedValue[3]=value[3]);
			return 1;
		}
		return 0;
	}

	__proto._uniform_vec4v=function(one,value){
		WebGL.mainContext.uniform4fv(one.location,value);
		return 1;
	}

	__proto._uniformMatrix2fv=function(one,value){
		WebGL.mainContext.uniformMatrix2fv(one.location,false,value);
		return 1;
	}

	__proto._uniformMatrix3fv=function(one,value){
		WebGL.mainContext.uniformMatrix3fv(one.location,false,value);
		return 1;
	}

	__proto._uniformMatrix4fv=function(one,value){
		WebGL.mainContext.uniformMatrix4fv(one.location,false,value);
		return 1;
	}

	__proto._uniform1i=function(one,value){
		var uploadedValue=one.uploadedValue;
		if (uploadedValue[0]!==value){
			WebGL.mainContext.uniform1i(one.location,uploadedValue[0]=value);
			return 1;
		}
		return 0;
	}

	__proto._uniform1iv=function(one,value){
		WebGL.mainContext.uniform1iv(one.location,value);
		return 1;
	}

	__proto._uniform_ivec2=function(one,value){
		var uploadedValue=one.uploadedValue;
		if (uploadedValue[0]!==value[0] || uploadedValue[1]!==value[1]){
			WebGL.mainContext.uniform2i(one.location,uploadedValue[0]=value[0],uploadedValue[1]=value[1]);
			return 1;
		}
		return 0;
	}

	__proto._uniform_ivec2v=function(one,value){
		WebGL.mainContext.uniform2iv(one.location,value);
		return 1;
	}

	__proto._uniform_vec3i=function(one,value){
		var uploadedValue=one.uploadedValue;
		if (uploadedValue[0]!==value[0] || uploadedValue[1]!==value[1] || uploadedValue[2]!==value[2]){
			WebGL.mainContext.uniform3i(one.location,uploadedValue[0]=value[0],uploadedValue[1]=value[1],uploadedValue[2]=value[2]);
			return 1;
		}
		return 0;
	}

	__proto._uniform_vec3vi=function(one,value){
		WebGL.mainContext.uniform3iv(one.location,value);
		return 1;
	}

	__proto._uniform_vec4i=function(one,value){
		var uploadedValue=one.uploadedValue;
		if (uploadedValue[0]!==value[0] || uploadedValue[1]!==value[1] || uploadedValue[2]!==value[2] || uploadedValue[3]!==value[3]){
			WebGL.mainContext.uniform4i(one.location,uploadedValue[0]=value[0],uploadedValue[1]=value[1],uploadedValue[2]=value[2],uploadedValue[3]=value[3]);
			return 1;
		}
		return 0;
	}

	__proto._uniform_vec4vi=function(one,value){
		WebGL.mainContext.uniform4iv(one.location,value);
		return 1;
	}

	__proto._uniform_sampler2D=function(one,value){
		var gl=WebGL.mainContext;
		var uploadedValue=one.uploadedValue;
		if (uploadedValue[0]==null){
			uploadedValue[0]=this._curActTexIndex;
			gl.uniform1i(one.location,this._curActTexIndex);
			gl.activeTexture(Shader._TEXTURES[this._curActTexIndex]);
			WebGLContext.bindTexture(gl,/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,value);
			this._curActTexIndex++;
			return 1;
			}else {
			gl.activeTexture(Shader._TEXTURES[uploadedValue[0]]);
			WebGLContext.bindTexture(gl,/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,value);
			return 0;
		}
	}

	__proto._uniform_samplerCube=function(one,value){
		var gl=WebGL.mainContext;
		var uploadedValue=one.uploadedValue;
		if (uploadedValue[0]==null){
			uploadedValue[0]=this._curActTexIndex;
			gl.uniform1i(one.location,this._curActTexIndex);
			gl.activeTexture(Shader._TEXTURES[this._curActTexIndex]);
			WebGLContext.bindTexture(gl,/*laya.webgl.WebGLContext.TEXTURE_CUBE_MAP*/0x8513,value);
			this._curActTexIndex++;
			return 1;
			}else {
			gl.activeTexture(Shader._TEXTURES[uploadedValue[0]]);
			WebGLContext.bindTexture(gl,/*laya.webgl.WebGLContext.TEXTURE_CUBE_MAP*/0x8513,value);
			return 0;
		}
	}

	__proto._noSetValue=function(one){
		console.log("no....:"+one.name);
	}

	//throw new Error("upload shader err,must set value:"+one.name);
	__proto.uploadOne=function(name,value){
		this.activeResource();
		WebGLContext.UseProgram(this._program);
		var one=this._paramsMap[name];
		one.fun.call(this,one,value);
	}

	__proto.uploadTexture2D=function(value){
		Stat.shaderCall++;
		var gl=WebGL.mainContext;
		gl.activeTexture(/*laya.webgl.WebGLContext.TEXTURE0*/0x84C0);
		WebGLContext.bindTexture(gl,/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,value);
	}

	/**
	*提交shader到GPU
	*@param shaderValue
	*/
	__proto.upload=function(shaderValue,params){
		BaseShader.activeShader=BaseShader.bindShader=this;
		this._lastUseFrameCount===Stat.loopCount || this.activeResource();
		WebGLContext.UseProgram(this._program);
		if (this._reCompile){
			params=this._params;
			this._reCompile=false;
			}else {
			params=params || this._params;
		};
		var gl=WebGL.mainContext;
		var one,value,n=params.length,shaderCall=0;
		for (var i=0;i < n;i++){
			one=params[i];
			if ((value=shaderValue[one.name])!==null)
				shaderCall+=one.fun.call(this,one,value);
		}
		Stat.shaderCall+=shaderCall;
	}

	/**
	*按数组的定义提交
	*@param shaderValue 数组格式[name,value,...]
	*/
	__proto.uploadArray=function(shaderValue,length,_bufferUsage){
		BaseShader.activeShader=this;
		BaseShader.bindShader=this;
		this.activeResource();
		WebGLContext.UseProgram(this._program);
		var params=this._params,value;
		var one,shaderCall=0;
		for (var i=length-2;i >=0;i-=2){
			one=this._paramsMap[shaderValue[i]];
			if (!one)
				continue ;
			value=shaderValue[i+1];
			if (value !=null){
				_bufferUsage && _bufferUsage[one.name] && _bufferUsage[one.name].bind();
				shaderCall+=one.fun.call(this,one,value);
			}
		}
		Stat.shaderCall+=shaderCall;
	}

	/**
	*得到编译后的变量及相关预定义
	*@return
	*/
	__proto.getParams=function(){
		return this._params;
	}

	Shader.getShader=function(name){
		return Shader.sharders[name];
	}

	Shader.create=function(vs,ps,saveName,nameMap){
		return new Shader(vs,ps,saveName,nameMap);
	}

	Shader.withCompile=function(nameID,define,shaderName,createShader){
		if (shaderName && Shader.sharders[shaderName])
			return Shader.sharders[shaderName];
		var pre=Shader._preCompileShader[0.0002 *nameID];
		if (!pre)
			throw new Error("withCompile shader err!"+nameID);
		return pre.createShader(define,shaderName,createShader);
	}

	Shader.withCompile2D=function(nameID,mainID,define,shaderName,createShader){
		if (shaderName && Shader.sharders[shaderName])
			return Shader.sharders[shaderName];
		var pre=Shader._preCompileShader[0.0002 *nameID+mainID];
		if (!pre)
			throw new Error("withCompile shader err!"+nameID+" "+mainID);
		return pre.createShader(define,shaderName,createShader);
	}

	Shader.addInclude=function(fileName,txt){
		ShaderCompile.addInclude(fileName,txt);
	}

	Shader.preCompile=function(nameID,vs,ps,nameMap){
		var id=0.0002 *nameID;
		Shader._preCompileShader[id]=new ShaderCompile(id,vs,ps,nameMap);
	}

	Shader.preCompile2D=function(nameID,mainID,vs,ps,nameMap){
		var id=0.0002 *nameID+mainID;
		Shader._preCompileShader[id]=new ShaderCompile(id,vs,ps,nameMap);
	}

	Shader._createShader=function(gl,str,type){
		var shader=gl.createShader(type);
		gl.shaderSource(shader,str);
		gl.compileShader(shader);
		return shader;
	}

	Shader._TEXTURES=[ /*laya.webgl.WebGLContext.TEXTURE0*/0x84C0,/*laya.webgl.WebGLContext.TEXTURE1*/0x84C1,/*laya.webgl.WebGLContext.TEXTURE2*/0x84C2,/*laya.webgl.WebGLContext.TEXTURE3*/0x84C3,/*laya.webgl.WebGLContext.TEXTURE4*/0x84C4,/*laya.webgl.WebGLContext.TEXTURE5*/0x84C5,/*laya.webgl.WebGLContext.TEXTURE6*/0x84C6,,/*laya.webgl.WebGLContext.TEXTURE7*/0x84C7,/*laya.webgl.WebGLContext.TEXTURE8*/0x84C8];
	Shader._count=0;
	Shader._preCompileShader={};
	Shader.SHADERNAME2ID=0.0002;
	Shader.sharders=(Shader.sharders=[],Shader.sharders.length=0x20,Shader.sharders);
	__static(Shader,
	['nameKey',function(){return this.nameKey=new StringKey();}
	]);
	return Shader;
})(BaseShader)


//class laya.webgl.utils.Buffer2D extends laya.webgl.utils.Buffer
var Buffer2D=(function(_super){
	function Buffer2D(){
		this._maxsize=0;
		this._upload=true;
		this._uploadSize=0;
		Buffer2D.__super.call(this);
		this.lock=true;
	}

	__class(Buffer2D,'laya.webgl.utils.Buffer2D',_super);
	var __proto=Buffer2D.prototype;
	/**
	*在当前的基础上需要多大空间，单位是byte
	*@param sz
	*@return 增加大小之前的写位置。单位是byte
	*/
	__proto.needSize=function(sz){
		var old=this._byteLength;
		if (sz){
			var needsz=this._byteLength+sz;
			needsz <=this._buffer.byteLength || (this._resizeBuffer(needsz << 1,true));
			this._byteLength=needsz;
		}
		return old;
	}

	__proto._bufferData=function(){
		this._maxsize=Math.max(this._maxsize,this._byteLength);
		if (Stat.loopCount % 30==0){
			if (this._buffer.byteLength > (this._maxsize+64)){
				this.memorySize=this._buffer.byteLength;
				this._buffer=this._buffer.slice(0,this._maxsize+64);
				this._checkArrayUse();
			}
			this._maxsize=this._byteLength;
		}
		if (this._uploadSize < this._buffer.byteLength){
			this._uploadSize=this._buffer.byteLength;
			Buffer._gl.bufferData(this._bufferType,this._uploadSize,this._bufferUsage);
			this.memorySize=this._uploadSize;
		}
		Buffer._gl.bufferSubData(this._bufferType,0,this._buffer);
	}

	__proto._bufferSubData=function(offset,dataStart,dataLength){
		(offset===void 0)&& (offset=0);
		(dataStart===void 0)&& (dataStart=0);
		(dataLength===void 0)&& (dataLength=0);
		this._maxsize=Math.max(this._maxsize,this._byteLength);
		if (Stat.loopCount % 30==0){
			if (this._buffer.byteLength > (this._maxsize+64)){
				this.memorySize=this._buffer.byteLength;
				this._buffer=this._buffer.slice(0,this._maxsize+64);
				this._checkArrayUse();
			}
			this._maxsize=this._byteLength;
		}
		if (this._uploadSize < this._buffer.byteLength){
			this._uploadSize=this._buffer.byteLength;
			Buffer._gl.bufferData(this._bufferType,this._uploadSize,this._bufferUsage);
			this.memorySize=this._uploadSize;
		}
		if (dataStart || dataLength){
			var subBuffer=this._buffer.slice(dataStart,dataLength);
			Buffer._gl.bufferSubData(this._bufferType,offset,subBuffer);
			}else {
			Buffer._gl.bufferSubData(this._bufferType,offset,this._buffer);
		}
	}

	__proto._checkArrayUse=function(){}
	__proto._bind_upload=function(){
		if (!this._upload)
			return false;
		this._upload=false;
		this._bind();
		this._bufferData();
		return true;
	}

	__proto._bind_subUpload=function(offset,dataStart,dataLength){
		(offset===void 0)&& (offset=0);
		(dataStart===void 0)&& (dataStart=0);
		(dataLength===void 0)&& (dataLength=0);
		if (!this._upload)
			return false;
		this._upload=false;
		this._bind();
		this._bufferSubData(offset,dataStart,dataLength);
		return true;
	}

	__proto._resizeBuffer=function(nsz,copy){
		if (nsz < this._buffer.byteLength)
			return this;
		this.memorySize=nsz;
		if (copy && this._buffer && this._buffer.byteLength > 0){
			var newbuffer=new ArrayBuffer(nsz);
			var n=new Uint8Array(newbuffer);
			n.set(new Uint8Array(this._buffer),0);
			this._buffer=newbuffer;
		}else
		this._buffer=new ArrayBuffer(nsz);
		this._checkArrayUse();
		this._upload=true;
		return this;
	}

	__proto.append=function(data){
		this._upload=true;
		var byteLen=0,n;
		byteLen=data.byteLength;
		if ((data instanceof Uint8Array)){
			this._resizeBuffer(this._byteLength+byteLen,true);
			n=new Uint8Array(this._buffer,this._byteLength);
			}else if ((data instanceof Uint16Array)){
			this._resizeBuffer(this._byteLength+byteLen,true);
			n=new Uint16Array(this._buffer,this._byteLength);
			}else if ((data instanceof Float32Array)){
			this._resizeBuffer(this._byteLength+byteLen,true);
			n=new Float32Array(this._buffer,this._byteLength);
		}
		n.set(data,0);
		this._byteLength+=byteLen;
		this._checkArrayUse();
	}

	/**
	*附加Uint16Array的数据。数据长度是len。byte的话要*2
	*@param data
	*@param len
	*/
	__proto.appendU16Array=function(data,len){
		this._resizeBuffer(this._byteLength+len*2,true);
		var u=new Uint16Array(this._buffer,this._byteLength,len);
		for (var i=0;i < len;i++){
			u[i]=data[i];
		}
		this._byteLength+=len *2;
		this._checkArrayUse();
	}

	__proto.appendEx=function(data,type){
		this._upload=true;
		var byteLen=0,n;
		byteLen=data.byteLength;
		this._resizeBuffer(this._byteLength+byteLen,true);
		n=new type(this._buffer,this._byteLength);
		n.set(data,0);
		this._byteLength+=byteLen;
		this._checkArrayUse();
	}

	__proto.appendEx2=function(data,type,dataLen,perDataLen){
		(perDataLen===void 0)&& (perDataLen=1);
		this._upload=true;
		var byteLen=0,n;
		byteLen=dataLen*perDataLen;
		this._resizeBuffer(this._byteLength+byteLen,true);
		n=new type(this._buffer,this._byteLength);
		var i=0;
		for (i=0;i < dataLen;i++){
			n[i]=data[i];
		}
		this._byteLength+=byteLen;
		this._checkArrayUse();
	}

	__proto.getBuffer=function(){
		return this._buffer;
	}

	__proto.setNeedUpload=function(){
		this._upload=true;
	}

	__proto.getNeedUpload=function(){
		return this._upload;
	}

	__proto.upload=function(){
		var scuess=this._bind_upload();
		Buffer._gl.bindBuffer(this._bufferType,null);
		Buffer._bindActive[this._bufferType]=null;
		BaseShader.activeShader=null
		return scuess;
	}

	__proto.subUpload=function(offset,dataStart,dataLength){
		(offset===void 0)&& (offset=0);
		(dataStart===void 0)&& (dataStart=0);
		(dataLength===void 0)&& (dataLength=0);
		var scuess=this._bind_subUpload();
		Buffer._gl.bindBuffer(this._bufferType,null);
		Buffer._bindActive[this._bufferType]=null;
		BaseShader.activeShader=null
		return scuess;
	}

	__proto.disposeResource=function(){
		_super.prototype.disposeResource.call(this);
		this._upload=true;
		this._uploadSize=0;
	}

	__proto.clear=function(){
		this._byteLength=0;
		this._upload=true;
	}

	__getset(0,__proto,'bufferLength',function(){
		return this._buffer.byteLength;
	});

	__getset(0,__proto,'byteLength',null,function(value){
		if (this._byteLength===value)
			return;
		value <=this._buffer.byteLength || (this._resizeBuffer(value *2+256,true));
		this._byteLength=value;
	});

	Buffer2D.__int__=function(gl){
		IndexBuffer2D.QuadrangleIB=IndexBuffer2D.create(/*laya.webgl.WebGLContext.STATIC_DRAW*/0x88E4);
		GlUtils.fillIBQuadrangle(IndexBuffer2D.QuadrangleIB,16);
	}

	Buffer2D.FLOAT32=4;
	Buffer2D.SHORT=2;
	return Buffer2D;
})(Buffer)


//class laya.webgl.shader.d2.value.GlowSV extends laya.webgl.shader.d2.value.TextureSV
var GlowSV=(function(_super){
	function GlowSV(args){
		this.u_blurX=false;
		this.u_color=null;
		this.u_offset=null;
		this.u_strength=NaN;
		this.u_texW=0;
		this.u_texH=0;
		GlowSV.__super.call(this,/*laya.webgl.shader.d2.ShaderDefines2D.FILTERGLOW*/0x08| /*laya.webgl.shader.d2.ShaderDefines2D.TEXTURE2D*/0x01);
	}

	__class(GlowSV,'laya.webgl.shader.d2.value.GlowSV',_super);
	var __proto=GlowSV.prototype;
	__proto.setValue=function(vo){
		_super.prototype.setValue.call(this,vo);
	}

	__proto.clear=function(){
		_super.prototype.clear.call(this);
	}

	return GlowSV;
})(TextureSV)


//class laya.webgl.shader.d2.value.TextSV extends laya.webgl.shader.d2.value.TextureSV
var TextSV=(function(_super){
	function TextSV(args){
		TextSV.__super.call(this,/*laya.webgl.shader.d2.ShaderDefines2D.COLORADD*/0x40);
		this.defines.add(/*laya.webgl.shader.d2.ShaderDefines2D.COLORADD*/0x40);
	}

	__class(TextSV,'laya.webgl.shader.d2.value.TextSV',_super);
	var __proto=TextSV.prototype;
	__proto.release=function(){
		TextSV.pool[TextSV._length++]=this;
		this.clear();
	}

	__proto.clear=function(){
		_super.prototype.clear.call(this);
	}

	TextSV.create=function(){
		if (TextSV._length)return TextSV.pool[--TextSV._length];
		else return new TextSV(null);
	}

	TextSV.pool=[];
	TextSV._length=0;
	return TextSV;
})(TextureSV)


//class laya.webgl.shader.d2.Shader2X extends laya.webgl.shader.Shader
var Shader2X=(function(_super){
	function Shader2X(vs,ps,saveName,nameMap){
		this._params2dQuick1=null;
		this._params2dQuick2=null;
		this._shaderValueWidth=NaN;
		this._shaderValueHeight=NaN;
		Shader2X.__super.call(this,vs,ps,saveName,nameMap);
	}

	__class(Shader2X,'laya.webgl.shader.d2.Shader2X',_super);
	var __proto=Shader2X.prototype;
	__proto.upload2dQuick1=function(shaderValue){
		this.upload(shaderValue,this._params2dQuick1 || this._make2dQuick1());
	}

	__proto._make2dQuick1=function(){
		if (!this._params2dQuick1){
			this.activeResource();
			this._params2dQuick1=[];
			var params=this._params,one;
			for (var i=0,n=params.length;i < n;i++){
				one=params[i];
				if (!Render.isFlash && (one.name==="size" || one.name==="position" || one.name==="texcoord"))continue ;
				this._params2dQuick1.push(one);
			}
		}
		return this._params2dQuick1;
	}

	__proto.disposeResource=function(){
		_super.prototype.disposeResource.call(this);
		this._params2dQuick1=null;
		this._params2dQuick2=null;
	}

	__proto.upload2dQuick2=function(shaderValue){
		this.upload(shaderValue,this._params2dQuick2 || this._make2dQuick2());
	}

	__proto._make2dQuick2=function(){
		if (!this._params2dQuick2){
			this.activeResource();
			this._params2dQuick2=[];
			var params=this._params,one;
			for (var i=0,n=params.length;i < n;i++){
				one=params[i];
				if (!Render.isFlash && (one.name==="size"))continue ;
				this._params2dQuick2.push(one);
			}
		}
		return this._params2dQuick2;
	}

	Shader2X.create=function(vs,ps,saveName,nameMap){
		return new Shader2X(vs,ps,saveName,nameMap);
	}

	return Shader2X;
})(Shader)


//class laya.webgl.utils.IndexBuffer2D extends laya.webgl.utils.Buffer2D
var IndexBuffer2D=(function(_super){
	function IndexBuffer2D(bufferUsage){
		this._uint8Array=null;
		this._uint16Array=null;
		(bufferUsage===void 0)&& (bufferUsage=/*laya.webgl.WebGLContext.STATIC_DRAW*/0x88E4);
		IndexBuffer2D.__super.call(this);
		this._bufferUsage=bufferUsage;
		this._bufferType=/*laya.webgl.WebGLContext.ELEMENT_ARRAY_BUFFER*/0x8893;
		Render.isFlash || (this._buffer=new ArrayBuffer(8));
	}

	__class(IndexBuffer2D,'laya.webgl.utils.IndexBuffer2D',_super);
	var __proto=IndexBuffer2D.prototype;
	__proto._checkArrayUse=function(){
		this._uint8Array && (this._uint8Array=new Uint8Array(this._buffer));
		this._uint16Array && (this._uint16Array=new Uint16Array(this._buffer));
	}

	__proto.getUint8Array=function(){
		return this._uint8Array || (this._uint8Array=new Uint8Array(this._buffer));
	}

	__proto.getUint16Array=function(){
		return this._uint16Array || (this._uint16Array=new Uint16Array(this._buffer));
	}

	__proto.destory=function(){
		this._uint16Array=null;
		this._uint8Array=null;
		this._buffer=null;
	}

	IndexBuffer2D.QuadrangleIB=null;
	IndexBuffer2D.create=function(bufferUsage){
		(bufferUsage===void 0)&& (bufferUsage=/*laya.webgl.WebGLContext.STATIC_DRAW*/0x88E4);
		return new IndexBuffer2D(bufferUsage);
	}

	return IndexBuffer2D;
})(Buffer2D)


//class laya.webgl.utils.VertexBuffer2D extends laya.webgl.utils.Buffer2D
var VertexBuffer2D=(function(_super){
	function VertexBuffer2D(vertexStride,bufferUsage){
		this._floatArray32=null;
		this._vertexStride=0;
		VertexBuffer2D.__super.call(this);
		this._vertexStride=vertexStride;
		this._bufferUsage=bufferUsage;
		this._bufferType=/*laya.webgl.WebGLContext.ARRAY_BUFFER*/0x8892;
		Render.isFlash || (this._buffer=new ArrayBuffer(8));
		this.getFloat32Array();
	}

	__class(VertexBuffer2D,'laya.webgl.utils.VertexBuffer2D',_super);
	var __proto=VertexBuffer2D.prototype;
	__proto.getFloat32Array=function(){
		return this._floatArray32 || (this._floatArray32=new Float32Array(this._buffer));
	}

	__proto.bind=function(ibBuffer){
		(ibBuffer)&& (ibBuffer._bind());
		this._bind();
	}

	__proto.insertData=function(data,pos){
		var vbdata=this.getFloat32Array();
		vbdata.set(data,pos);
		this._upload=true;
	}

	__proto.bind_upload=function(ibBuffer){
		(ibBuffer._bind_upload())|| (ibBuffer._bind());
		(this._bind_upload())|| (this._bind());
	}

	__proto._checkArrayUse=function(){
		this._floatArray32 && (this._floatArray32=new Float32Array(this._buffer));
	}

	__proto.disposeResource=function(){
		_super.prototype.disposeResource.call(this);
		var enableAtributes=Buffer._enableAtributes;
		if (!Render.isConchWebGL){
			for (var i=0;i < 10;i++){
				WebGL.mainContext.disableVertexAttribArray(i);
				enableAtributes[i]=null;
			}
		}
	}

	//}
	__proto.destory=function(){
		this._byteLength=0;
		this._upload=true;
		this._buffer=null;
		this._floatArray32=null;
	}

	__getset(0,__proto,'vertexStride',function(){
		return this._vertexStride;
	});

	VertexBuffer2D.create=function(vertexStride,bufferUsage){
		(bufferUsage===void 0)&& (bufferUsage=/*laya.webgl.WebGLContext.DYNAMIC_DRAW*/0x88E8);
		return new VertexBuffer2D(vertexStride,bufferUsage);
	}

	return VertexBuffer2D;
})(Buffer2D)


//class laya.webgl.resource.WebGLImage extends laya.resource.HTMLImage
var WebGLImage=(function(_super){
	function WebGLImage(data,def,format,mipmap){
		/**@private */
		this._format=0;
		/**@private */
		this._mipmap=false;
		/***是否创建私有Source,值为false时不根据src创建私有WebGLTexture,同时销毁时也只清空source=null,不调用WebGL.mainContext.deleteTexture类似函数，调用资源激活前有效*/
		this._allowMerageInAtlas=false;
		/**是否允许加入大图合集*/
		this._enableMerageInAtlas=false;
		/**是否使用重复模式纹理寻址*/
		this.repeat=false;
		/**@private */
		this._image=null;
		/**缩小过滤器*/
		this.minFifter=0;
		/**放大过滤器*/
		this.magFifter=0;
		(format===void 0)&& (format=/*laya.webgl.WebGLContext.RGBA*/0x1908);
		(mipmap===void 0)&& (mipmap=true);
		WebGLImage.__super.call(this,data,def);
		this._format=format;
		this._mipmap=mipmap;
		this.repeat=false;
		this.minFifter=-1;
		this.magFifter=-1;
		if ((typeof data=='string')){
			this._url=data;
			this._src=data;
			this._image=new Browser.window.Image();
			if (def){
				def.onload && (this.onload=def.onload);
				def.onerror && (this.onerror=def.onerror);
				def.onCreate && def.onCreate(this);
			}
			this._image.crossOrigin=(data && (data.indexOf("data:")==0))? null :"";
			(data)&& (this._image.src=data);
			}else if ((data instanceof ArrayBuffer)){
			this._src=def;
			this._url=this._src;
			var readData=new Byte(data);
			var magicNumber=readData.readUTFBytes(4);
			var version=readData.readUTFBytes(2);
			var dataType=readData.getInt16();
			readData.endian=/*laya.utils.Byte.BIG_ENDIAN*/"bigEndian";
			this._w=readData.getInt16();
			this._h=readData.getInt16();
			var originalWidth=readData.getInt16();
			var originalHeight=readData.getInt16();
			this._image=new Uint8Array(data,readData.pos);
			this._format=WebGL.compressEtc1.COMPRESSED_RGB_ETC1_WEBGL;
			(AtlasResourceManager.enabled)&& (this._w < AtlasResourceManager.atlasLimitWidth && this._h < AtlasResourceManager.atlasLimitHeight)? this._allowMerageInAtlas=true :this._allowMerageInAtlas=false;
			}else {
			this._src=def;
			this._url=this._src;
			this._image=data["source"] || data;
			this.onresize();
		}
		this._$5__enableMerageInAtlas=true;
	}

	__class(WebGLImage,'laya.webgl.resource.WebGLImage',_super);
	var __proto=WebGLImage.prototype;
	Laya.imps(__proto,{"laya.webgl.resource.IMergeAtlasBitmap":true})
	__proto._init_=function(src,def){}
	__proto._createWebGlTexture=function(){
		if (!this._image){
			throw "create GLTextur err:no data:"+this._image;
		};
		var gl=WebGL.mainContext;
		var glTex=this._source=gl.createTexture();
		var preTarget=WebGLContext.curBindTexTarget;
		var preTexture=WebGLContext.curBindTexValue;
		WebGLContext.bindTexture(gl,/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,glTex);
		if (Render.isConchWebGL){
			switch (this._format){
				case /*laya.webgl.WebGLContext.RGBA*/0x1908:
					gl.texImage2DEx(true,/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,0,this._format,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401,this._image);
					break ;
				case WebGL.compressEtc1.COMPRESSED_RGB_ETC1_WEBGL:
					gl.compressedTexImage2D(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,0,this._format,this._w,this._h,0,this._image);
					break ;
				}
		}
		else {
			gl.pixelStorei(/*laya.webgl.WebGLContext.UNPACK_PREMULTIPLY_ALPHA_WEBGL*/0x9241,true);
			switch (this._format){
				case /*laya.webgl.WebGLContext.RGBA*/0x1908:
					gl.texImage2D(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,0,this._format,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401,this._image);
					break ;
				case WebGL.compressEtc1.COMPRESSED_RGB_ETC1_WEBGL:
					gl.compressedTexImage2D(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,0,this._format,this._w,this._h,0,this._image);
					break ;
				}
			gl.pixelStorei(/*laya.webgl.WebGLContext.UNPACK_PREMULTIPLY_ALPHA_WEBGL*/0x9241,false);
		};
		var minFifter=this.minFifter;
		var magFifter=this.magFifter;
		var repeat=this.repeat ? /*laya.webgl.WebGLContext.REPEAT*/0x2901 :/*laya.webgl.WebGLContext.CLAMP_TO_EDGE*/0x812F;
		var isPot=Arith.isPOT(this._w,this._h);
		if (isPot){
			if (this.mipmap)
				(minFifter!==-1)|| (minFifter=/*laya.webgl.WebGLContext.LINEAR_MIPMAP_LINEAR*/0x2703);
			else
			(minFifter!==-1)|| (minFifter=/*laya.webgl.WebGLContext.LINEAR*/0x2601);
			(magFifter!==-1)|| (magFifter=/*laya.webgl.WebGLContext.LINEAR*/0x2601);
			gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_MIN_FILTER*/0x2801,minFifter);
			gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_MAG_FILTER*/0x2800,magFifter);
			gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_WRAP_S*/0x2802,repeat);
			gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_WRAP_T*/0x2803,repeat);
			this.mipmap && gl.generateMipmap(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1);
			}else {
			(minFifter!==-1)|| (minFifter=/*laya.webgl.WebGLContext.LINEAR*/0x2601);
			(magFifter!==-1)|| (magFifter=/*laya.webgl.WebGLContext.LINEAR*/0x2601);
			gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_MIN_FILTER*/0x2801,minFifter);
			gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_MAG_FILTER*/0x2800,magFifter);
			gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_WRAP_S*/0x2802,/*laya.webgl.WebGLContext.CLAMP_TO_EDGE*/0x812F);
			gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_WRAP_T*/0x2803,/*laya.webgl.WebGLContext.CLAMP_TO_EDGE*/0x812F);
		}
		(preTarget && preTexture)&& (WebGLContext.bindTexture(gl,preTarget,preTexture));
		this._image.onload=null;
		this._image=null;
		if (isPot && this.mipmap)
			this.memorySize=this._w *this._h *4 *(1+1 / 3);
		else
		this.memorySize=this._w *this._h *4;
		this._recreateLock=false;
	}

	/***重新创建资源，如果异步创建中被强制释放再创建，则需等待释放完成后再重新加载创建。*/
	__proto.recreateResource=function(){
		var _$this=this;
		if (this._src==null || this._src==="")
			return;
		this._needReleaseAgain=false;
		if (!this._image){
			this._recreateLock=true;
			var _this=this;
			this._image=new Browser.window.Image();
			this._image.crossOrigin=this._src.indexOf("data:")==0 ? null :"";
			this._image.onload=function (){
				if (_this._needReleaseAgain){
					_this._needReleaseAgain=false;
					_this._image.onload=null;
					_this._image=null;
					return;
				}
				(!(_this._allowMerageInAtlas && _this._enableMerageInAtlas))? (_this._createWebGlTexture()):(_$this.memorySize=0,_$this._recreateLock=false);
				_this.completeCreate();
			};
			this._image.src=this._src;
			}else {
			if (this._recreateLock){
				return;
			}
			(!(this._allowMerageInAtlas && this._$5__enableMerageInAtlas))? (this._createWebGlTexture()):(this.memorySize=0,this._recreateLock=false);
			this.completeCreate();
		}
	}

	/***销毁资源*/
	__proto.disposeResource=function(){
		if (this._recreateLock){
			this._needReleaseAgain=true;
		}
		if (this._source){
			WebGL.mainContext.deleteTexture(this._source);
			this._source=null;
			this._image=null;
			this.memorySize=0;
		}
	}

	/***调整尺寸*/
	__proto.onresize=function(){
		this._w=this._image.width;
		this._h=this._image.height;
		(AtlasResourceManager.enabled)&& (this._w < AtlasResourceManager.atlasLimitWidth && this._h < AtlasResourceManager.atlasLimitHeight)? this._allowMerageInAtlas=true :this._allowMerageInAtlas=false;
	}

	__proto.clearAtlasSource=function(){
		this._image=null;
	}

	/**
	*获取纹理格式。
	*/
	__getset(0,__proto,'format',function(){
		return this._format;
	});

	/**
	*是否创建私有Source,通常禁止修改
	*@param value 是否创建
	*/
	/**
	*是否创建私有Source
	*@return 是否创建
	*/
	__getset(0,__proto,'enableMerageInAtlas',function(){
		return this._$5__enableMerageInAtlas;
		},function(value){
		this._$5__enableMerageInAtlas=value;
	});

	/**
	*获取是否具有mipmap。
	*/
	__getset(0,__proto,'mipmap',function(){
		return this._mipmap;
	});

	/**
	*是否创建私有Source
	*@return 是否创建
	*/
	__getset(0,__proto,'allowMerageInAtlas',function(){
		return this._allowMerageInAtlas;
	});

	__getset(0,__proto,'atlasSource',function(){
		return this._image;
	});

	/***
	*设置onload函数
	*@param value onload函数
	*/
	__getset(0,__proto,'onload',null,function(value){
		var _$this=this;
		this._onload=value;
		this._image && (this._image.onload=this._onload !=null ? (function(){
			_$this.onresize();
			_$this._onload();
		}):null);
	});

	/***
	*设置onerror函数
	*@param value onerror函数
	*/
	__getset(0,__proto,'onerror',null,function(value){
		var _$this=this;
		this._onerror=value;
		this._image && (this._image.onerror=this._onerror !=null ? (function(){
			_$this._onerror()
		}):null);
	});

	return WebGLImage;
})(HTMLImage)


	Laya.__init([DrawText,AtlasGrid,WebGLContext2D,ShaderCompile]);
})(window,document,Laya);

if (typeof define === 'function' && define.amd){
	define('laya.core', ['require', "exports"], function(require, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        for (var i in Laya) {
			var o = Laya[i];
            o && o.__isclass && (exports[i] = o);
        }
    });
}

(function(window,document,Laya){
	var __un=Laya.un,__uns=Laya.uns,__static=Laya.static,__class=Laya.class,__getset=Laya.getset,__newvec=Laya.__newvec;

	var Bezier=laya.maths.Bezier,Browser=laya.utils.Browser,Byte=laya.utils.Byte,Event=laya.events.Event;
	var EventDispatcher=laya.events.EventDispatcher,Graphics=laya.display.Graphics,HTMLCanvas=laya.resource.HTMLCanvas;
	var Handler=laya.utils.Handler,Loader=laya.net.Loader,MathUtil=laya.maths.MathUtil,Matrix=laya.maths.Matrix;
	var Node=laya.display.Node,Point=laya.maths.Point,Rectangle=laya.maths.Rectangle,Render=laya.renders.Render;
	var RenderContext=laya.renders.RenderContext,Resource=laya.resource.Resource,RunDriver=laya.utils.RunDriver;
	var Sprite=laya.display.Sprite,Stat=laya.utils.Stat,Texture=laya.resource.Texture,URL=laya.net.URL,Utils=laya.utils.Utils;
/**
*@private
*@author ...
*/
//class laya.ani.AnimationContent
var AnimationContent=(function(){
	function AnimationContent(){
		this.nodes=null;
		this.name=null;
		this.playTime=NaN;
		this.bone3DMap=null;
		this.totalKeyframeDatasLength=0;
	}

	__class(AnimationContent,'laya.ani.AnimationContent');
	return AnimationContent;
})()


/**
*@private
*@author ...
*/
//class laya.ani.AnimationNodeContent
var AnimationNodeContent=(function(){
	function AnimationNodeContent(){
		this.name=null;
		this.parentIndex=0;
		this.parent=null;
		this.keyframeWidth=0;
		this.lerpType=0;
		this.interpolationMethod=null;
		this.childs=null;
		this.keyFrame=null;
		//=new Vector.<KeyFramesContent>;
		this.playTime=NaN;
		this.extenData=null;
		this.dataOffset=0;
	}

	__class(AnimationNodeContent,'laya.ani.AnimationNodeContent');
	return AnimationNodeContent;
})()


/**
*@private
*/
//class laya.ani.AnimationParser01
var AnimationParser01=(function(){
	function AnimationParser01(){}
	__class(AnimationParser01,'laya.ani.AnimationParser01');
	AnimationParser01.parse=function(templet,reader){
		var data=reader.__getBuffer();
		var i=0,j=0,k=0,n=0,l=0,m=0,o=0;
		var aniClassName=reader.readUTFString();
		templet._aniClassName=aniClassName;
		var strList=reader.readUTFString().split("\n");
		var aniCount=reader.getUint8();
		var publicDataPos=reader.getUint32();
		var publicExtDataPos=reader.getUint32();
		var publicData;
		if (publicDataPos > 0)
			publicData=data.slice(publicDataPos,publicExtDataPos);
		var publicRead=new Byte(publicData);
		if (publicExtDataPos > 0)
			templet._publicExtData=data.slice(publicExtDataPos,data.byteLength);
		templet._useParent=!!reader.getUint8();
		templet._anis.length=aniCount;
		for (i=0;i < aniCount;i++){
			var ani=templet._anis[i]=new AnimationContent();
			{};
			ani.nodes=new Array;
			var name=ani.name=strList[reader.getUint16()];
			templet._aniMap[name]=i;
			ani.bone3DMap={};
			ani.playTime=reader.getFloat32();
			var boneCount=ani.nodes.length=reader.getUint8();
			ani.totalKeyframeDatasLength=0;
			for (j=0;j < boneCount;j++){
				var node=ani.nodes[j]=new AnimationNodeContent();
				{};
				node.childs=[];
				var nameIndex=reader.getInt16();
				if (nameIndex >=0){
					node.name=strList[nameIndex];
					ani.bone3DMap[node.name]=j;
				}
				node.keyFrame=new Array;
				node.parentIndex=reader.getInt16();
				node.parentIndex==-1 ? node.parent=null :node.parent=ani.nodes[node.parentIndex]
				node.lerpType=reader.getUint8();
				var keyframeParamsOffset=reader.getUint32();
				publicRead.pos=keyframeParamsOffset;
				var keyframeDataCount=node.keyframeWidth=publicRead.getUint16();
				ani.totalKeyframeDatasLength+=keyframeDataCount;
				if (node.lerpType===0 || node.lerpType===1){
					node.interpolationMethod=[];
					node.interpolationMethod.length=keyframeDataCount;
					for (k=0;k < keyframeDataCount;k++)
					node.interpolationMethod[k]=AnimationTemplet.interpolation[publicRead.getUint8()];
				}
				if (node.parent !=null)
					node.parent.childs.push(node);
				var privateDataLen=reader.getUint16();
				if (privateDataLen > 0){
					node.extenData=data.slice(reader.pos,reader.pos+privateDataLen);
					reader.pos+=privateDataLen;
				};
				var keyframeCount=reader.getUint16();
				node.keyFrame.length=keyframeCount;
				var startTime=0;
				var keyFrame;
				for (k=0,n=keyframeCount;k < n;k++){
					keyFrame=node.keyFrame[k]=new KeyFramesContent();
					{};
					keyFrame.duration=reader.getFloat32();
					keyFrame.startTime=startTime;
					if (node.lerpType===2){
						keyFrame.interpolationData=[];
						var interDataLength=reader.getUint8();
						var lerpType=0;
						lerpType=reader.getFloat32();
						switch (lerpType){
							case 254:
								keyFrame.interpolationData.length=keyframeDataCount;
								for (o=0;o < keyframeDataCount;o++)
								keyFrame.interpolationData[o]=0;
								break ;
							case 255:
								keyFrame.interpolationData.length=keyframeDataCount;
								for (o=0;o < keyframeDataCount;o++)
								keyFrame.interpolationData[o]=5;
								break ;
							default :
								keyFrame.interpolationData.push(lerpType);
								for (m=1;m < interDataLength;m++){
									keyFrame.interpolationData.push(reader.getFloat32());
								}
							}
					}
					keyFrame.data=new Float32Array(keyframeDataCount);
					for (l=0;l < keyframeDataCount;l++){
						keyFrame.data[l]=reader.getFloat32();
						if (keyFrame.data[l] >-0.00000001 && keyFrame.data[l] < 0.00000001)keyFrame.data[l]=0;
					}
					startTime+=keyFrame.duration;
				}
				keyFrame.startTime=ani.playTime;
				node.playTime=ani.playTime;
				templet._calculateKeyFrame(node,keyframeCount,keyframeDataCount);
			}
		}
	}

	return AnimationParser01;
})()


/**
*@private
*/
//class laya.ani.AnimationParser02
var AnimationParser02=(function(){
	function AnimationParser02(){}
	__class(AnimationParser02,'laya.ani.AnimationParser02');
	AnimationParser02.READ_DATA=function(){
		AnimationParser02._DATA.offset=AnimationParser02._reader.getUint32();
		AnimationParser02._DATA.size=AnimationParser02._reader.getUint32();
	}

	AnimationParser02.READ_BLOCK=function(){
		var count=AnimationParser02._BLOCK.count=AnimationParser02._reader.getUint16();
		var blockStarts=AnimationParser02._BLOCK.blockStarts=[];
		var blockLengths=AnimationParser02._BLOCK.blockLengths=[];
		for (var i=0;i < count;i++){
			blockStarts.push(AnimationParser02._reader.getUint32());
			blockLengths.push(AnimationParser02._reader.getUint32());
		}
	}

	AnimationParser02.READ_STRINGS=function(){
		var offset=AnimationParser02._reader.getUint32();
		var count=AnimationParser02._reader.getUint16();
		var prePos=AnimationParser02._reader.pos;
		AnimationParser02._reader.pos=offset+AnimationParser02._DATA.offset;
		for (var i=0;i < count;i++)
		AnimationParser02._strings[i]=AnimationParser02._reader.readUTFString();
		AnimationParser02._reader.pos=prePos;
	}

	AnimationParser02.parse=function(templet,reader){
		AnimationParser02._templet=templet;
		AnimationParser02._reader=reader;
		var arrayBuffer=reader.__getBuffer();
		AnimationParser02.READ_DATA();
		AnimationParser02.READ_BLOCK();
		AnimationParser02.READ_STRINGS();
		for (var i=0,n=AnimationParser02._BLOCK.count;i < n;i++){
			var index=reader.getUint16();
			var blockName=AnimationParser02._strings[index];
			var fn=AnimationParser02["READ_"+blockName];
			if (fn==null)
				throw new Error("model file err,no this function:"+index+" "+blockName);
			else
			fn.call();
		}
	}

	AnimationParser02.READ_ANIMATIONS=function(){
		var reader=AnimationParser02._reader;
		var arrayBuffer=reader.__getBuffer();
		var i=0,j=0,k=0,n=0,l=0;
		var keyframeWidth=reader.getUint16();
		var interpolationMethod=[];
		interpolationMethod.length=keyframeWidth;
		for (i=0;i < keyframeWidth;i++)
		interpolationMethod[i]=AnimationTemplet.interpolation[reader.getByte()];
		var aniCount=reader.getUint8();
		AnimationParser02._templet._anis.length=aniCount;
		for (i=0;i < aniCount;i++){
			var ani=AnimationParser02._templet._anis[i]=
			{};
			ani.nodes=new Array;
			var aniName=ani.name=AnimationParser02._strings[reader.getUint16()];
			AnimationParser02._templet._aniMap[aniName]=i;
			ani.bone3DMap={};
			ani.playTime=reader.getFloat32();
			var boneCount=ani.nodes.length=reader.getInt16();
			ani.totalKeyframeDatasLength=0;
			for (j=0;j < boneCount;j++){
				var node=ani.nodes[j]=
				{};
				node.keyframeWidth=keyframeWidth;
				node.childs=[];
				var nameIndex=reader.getUint16();
				if (nameIndex >=0){
					node.name=AnimationParser02._strings[nameIndex];
					ani.bone3DMap[node.name]=j;
				}
				node.keyFrame=new Array;
				node.parentIndex=reader.getInt16();
				node.parentIndex==-1 ? node.parent=null :node.parent=ani.nodes[node.parentIndex]
				ani.totalKeyframeDatasLength+=keyframeWidth;
				node.interpolationMethod=interpolationMethod;
				if (node.parent !=null)
					node.parent.childs.push(node);
				var keyframeCount=reader.getUint16();
				node.keyFrame.length=keyframeCount;
				var keyFrame=null,lastKeyFrame=null;
				for (k=0,n=keyframeCount;k < n;k++){
					keyFrame=node.keyFrame[k]=
					{};
					keyFrame.startTime=reader.getFloat32();
					(lastKeyFrame)&& (lastKeyFrame.duration=keyFrame.startTime-lastKeyFrame.startTime);
					var offset=AnimationParser02._DATA.offset;
					var keyframeDataOffset=reader.getUint32();
					var keyframeDataLength=keyframeWidth *4;
					var keyframeArrayBuffer=arrayBuffer.slice(offset+keyframeDataOffset,offset+keyframeDataOffset+keyframeDataLength);
					keyFrame.data=new Float32Array(keyframeArrayBuffer);
					lastKeyFrame=keyFrame;
				}
				keyFrame.duration=0;
				node.playTime=ani.playTime;
				AnimationParser02._templet._calculateKeyFrame(node,keyframeCount,keyframeWidth);
			}
		}
	}

	AnimationParser02._templet=null;
	AnimationParser02._reader=null;
	AnimationParser02._strings=[];
	__static(AnimationParser02,
	['_BLOCK',function(){return this._BLOCK={count:0};},'_DATA',function(){return this._DATA={offset:0,size:0};}
	]);
	return AnimationParser02;
})()


/**
*@private
*/
//class laya.ani.AnimationState
var AnimationState=(function(){
	function AnimationState(){}
	__class(AnimationState,'laya.ani.AnimationState');
	AnimationState.stopped=0;
	AnimationState.paused=1;
	AnimationState.playing=2;
	return AnimationState;
})()


/**
*@private
*/
//class laya.ani.bone.Bone
var Bone=(function(){
	function Bone(){
		this.name=null;
		this.root=null;
		this.parentBone=null;
		this.length=10;
		this.transform=null;
		this.inheritScale=true;
		this.inheritRotation=true;
		this.rotation=NaN;
		this.resultRotation=NaN;
		this.d=-1;
		this._tempMatrix=null;
		this._sprite=null;
		this.resultTransform=new Transform();
		this.resultMatrix=new Matrix();
		this._children=[];
	}

	__class(Bone,'laya.ani.bone.Bone');
	var __proto=Bone.prototype;
	__proto.setTempMatrix=function(matrix){
		this._tempMatrix=matrix;
		var i=0,n=0;
		var tBone;
		for (i=0,n=this._children.length;i < n;i++){
			tBone=this._children[i];
			tBone.setTempMatrix(this._tempMatrix);
		}
	}

	__proto.update=function(pMatrix){
		this.rotation=this.transform.skX;
		var tResultMatrix;
		if (pMatrix){
			tResultMatrix=this.resultTransform.getMatrix();
			Matrix.mul(tResultMatrix,pMatrix,this.resultMatrix);
			this.resultRotation=this.rotation;
		}
		else {
			this.resultRotation=this.rotation+this.parentBone.resultRotation;
			if (this.parentBone){
				if (this.inheritRotation && this.inheritScale){
					tResultMatrix=this.resultTransform.getMatrix();
					Matrix.mul(tResultMatrix,this.parentBone.resultMatrix,this.resultMatrix);
				}
				else {
					var temp=0;
					var parent=this.parentBone;
					var tAngle=NaN;
					var cos=NaN;
					var sin=NaN;
					var tParentMatrix=this.parentBone.resultMatrix;
					tResultMatrix=this.resultTransform.getMatrix();
					var worldX=tParentMatrix.a *tResultMatrix.tx+tParentMatrix.c *tResultMatrix.ty+tParentMatrix.tx;
					var worldY=tParentMatrix.b *tResultMatrix.tx+tParentMatrix.d *tResultMatrix.ty+tParentMatrix.ty;
					var tTestMatrix=new Matrix();
					if (this.inheritRotation){
						tAngle=Math.atan2(parent.resultMatrix.b,parent.resultMatrix.a);
						cos=Math.cos(tAngle),sin=Math.sin(tAngle);
						tTestMatrix.setTo(cos,sin,-sin,cos,0,0);
						Matrix.mul(this._tempMatrix,tTestMatrix,Matrix.TEMP);
						Matrix.TEMP.copyTo(tTestMatrix);
						tResultMatrix=this.resultTransform.getMatrix();
						Matrix.mul(tResultMatrix,tTestMatrix,this.resultMatrix);
						if (this.resultTransform.scX *this.resultTransform.scY < 0){
							this.resultMatrix.rotate(Math.PI*0.5);
						}
						this.resultMatrix.tx=worldX;
						this.resultMatrix.ty=worldY;
					}
					else if (this.inheritScale){
						tResultMatrix=this.resultTransform.getMatrix();
						Matrix.TEMP.identity();
						Matrix.TEMP.d=this.d;
						Matrix.mul(tResultMatrix,Matrix.TEMP,this.resultMatrix);
						this.resultMatrix.tx=worldX;
						this.resultMatrix.ty=worldY;
					}
					else {
						tResultMatrix=this.resultTransform.getMatrix();
						Matrix.TEMP.identity();
						Matrix.TEMP.d=this.d;
						Matrix.mul(tResultMatrix,Matrix.TEMP,this.resultMatrix);
						this.resultMatrix.tx=worldX;
						this.resultMatrix.ty=worldY;
					}
				}
			}
			else {
				tResultMatrix=this.resultTransform.getMatrix();
				tResultMatrix.copyTo(this.resultMatrix);
			}
		};
		var i=0,n=0;
		var tBone;
		for (i=0,n=this._children.length;i < n;i++){
			tBone=this._children[i];
			tBone.update();
		}
	}

	__proto.updateChild=function(){
		var i=0,n=0;
		var tBone;
		for (i=0,n=this._children.length;i < n;i++){
			tBone=this._children[i];
			tBone.update();
		}
	}

	__proto.setRotation=function(rd){
		if (this._sprite){
			this._sprite.rotation=rd *180 / Math.PI;
		}
	}

	__proto.updateDraw=function(x,y){
		if (!Bone.ShowBones || Bone.ShowBones[this.name]){
			if (this._sprite){
				this._sprite.x=x+this.resultMatrix.tx;
				this._sprite.y=y+this.resultMatrix.ty;
			}
			else {
				this._sprite=new Sprite();
				this._sprite.graphics.drawCircle(0,0,5,"#ff0000");
				this._sprite.graphics.drawLine(0,0,this.length,0,"#00ff00");
				this._sprite.graphics.fillText(this.name,0,0,"20px Arial","#00ff00","center");
				Laya.stage.addChild(this._sprite);
				this._sprite.x=x+this.resultMatrix.tx;
				this._sprite.y=y+this.resultMatrix.ty;
			}
		};
		var i=0,n=0;
		var tBone;
		for (i=0,n=this._children.length;i < n;i++){
			tBone=this._children[i];
			tBone.updateDraw(x,y);
		}
	}

	__proto.addChild=function(bone){
		this._children.push(bone);
		bone.parentBone=this;
	}

	__proto.findBone=function(boneName){
		if (this.name==boneName){
			return this;
		}
		else {
			var i=0,n=0;
			var tBone;
			var tResult;
			for (i=0,n=this._children.length;i < n;i++){
				tBone=this._children[i];
				tResult=tBone.findBone(boneName);
				if (tResult){
					return tResult;
				}
			}
		}
		return null;
	}

	__proto.localToWorld=function(local){
		var localX=local[0];
		var localY=local[1];
		local[0]=localX *this.resultMatrix.a+localY *this.resultMatrix.c+this.resultMatrix.tx;
		local[1]=localX *this.resultMatrix.b+localY *this.resultMatrix.d+this.resultMatrix.ty;
	}

	Bone.ShowBones={};
	return Bone;
})()


/**
*@private
*/
//class laya.ani.bone.BoneSlot
var BoneSlot=(function(){
	function BoneSlot(){
		/**插槽名称 */
		this.name=null;
		/**插槽绑定的骨骼名称 */
		this.parent=null;
		/**插糟显示数据数据的名称 */
		this.attachmentName=null;
		/**原始数据的索引 */
		this.srcDisplayIndex=-1;
		/**判断对象是否是原对象 */
		this.type="src";
		/**模板的指针 */
		this.templet=null;
		/**当前插槽对应的数据 */
		this.currSlotData=null;
		/**当前插槽显示的纹理 */
		this.currTexture=null;
		/**显示对象对应的数据 */
		this.currDisplayData=null;
		/**显示皮肤的索引 */
		this.displayIndex=-1;
		/**用户自定义的皮肤 */
		this._diyTexture=null;
		this._parentMatrix=null;
		this._resultMatrix=null;
		/**索引替换表 */
		this._replaceDic={};
		/**当前diyTexture的动画纹理 */
		this._curDiyUV=null;
		this._curDiyVS=null;
		/**实时模式下，复用使用 */
		this._skinSprite=null;
		/**@private 变形动画数据 */
		this.deformData=null;
		this._mVerticleArr=null;
	}

	__class(BoneSlot,'laya.ani.bone.BoneSlot');
	var __proto=BoneSlot.prototype;
	/**
	*设置要显示的插槽数据
	*@param slotData
	*@param disIndex
	*@param freshIndex 是否重置纹理
	*/
	__proto.showSlotData=function(slotData,freshIndex){
		(freshIndex===void 0)&& (freshIndex=true);
		this.currSlotData=slotData;
		if(freshIndex)
			this.displayIndex=this.srcDisplayIndex;
		this.currDisplayData=null;
		this.currTexture=null;
	}

	/**
	*通过名字显示指定对象
	*@param name
	*/
	__proto.showDisplayByName=function(name){
		if (this.currSlotData){
			this.showDisplayByIndex(this.currSlotData.getDisplayByName(name));
		}
	}

	/**
	*替换贴图名
	*@param tarName 要替换的贴图名
	*@param newName 替换后的贴图名
	*/
	__proto.replaceDisplayByName=function(tarName,newName){
		if (!this.currSlotData)return;
		var preIndex=0;
		preIndex=this.currSlotData.getDisplayByName(tarName);
		var newIndex=0;
		newIndex=this.currSlotData.getDisplayByName(newName);
		this.replaceDisplayByIndex(preIndex,newIndex);
	}

	/**
	*替换贴图索引
	*@param tarIndex 要替换的索引
	*@param newIndex 替换后的索引
	*/
	__proto.replaceDisplayByIndex=function(tarIndex,newIndex){
		if (!this.currSlotData)return;
		this._replaceDic[tarIndex]=newIndex;
		if (this.displayIndex==tarIndex){
			this.showDisplayByIndex(tarIndex);
		}
	}

	/**
	*指定显示对象
	*@param index
	*/
	__proto.showDisplayByIndex=function(index){
		if (this._replaceDic[index]!=null)index=this._replaceDic[index];
		if (this.currSlotData && index >-1 && index < this.currSlotData.displayArr.length){
			this.displayIndex=index;
			this.currDisplayData=this.currSlotData.displayArr[index];
			if (this.currDisplayData){
				var tName=this.currDisplayData.name;
				this.currTexture=this.templet.getTexture(tName);
				if (this.currTexture && this.currDisplayData.type==0 && this.currDisplayData.uvs && (!Render.isConchApp || (Render.isConchApp && Sprite.RUNTIMEVERION > "0.9.15"))){
					this.currTexture=this.currDisplayData.createTexture(this.currTexture);
				}
			}
			}else {
			this.displayIndex=-1;
			this.currDisplayData=null;
			this.currTexture=null;
		}
	}

	/**
	*替换皮肤
	*@param _texture
	*/
	__proto.replaceSkin=function(_texture){
		this._diyTexture=_texture;
		if (this._curDiyUV)this._curDiyUV.length=0;
		if (this.currDisplayData&&this._diyTexture==this.currDisplayData.texture){
			this._diyTexture=null;
		}
	}

	/**
	*保存父矩阵的索引
	*@param parentMatrix
	*/
	__proto.setParentMatrix=function(parentMatrix){
		this._parentMatrix=parentMatrix;
	}

	/**
	*把纹理画到Graphics上
	*@param graphics
	*@param noUseSave
	*/
	__proto.draw=function(graphics,boneMatrixArray,noUseSave,alpha){
		(noUseSave===void 0)&& (noUseSave=false);
		(alpha===void 0)&& (alpha=1);
		if ((this._diyTexture==null && this.currTexture==null)|| this.currDisplayData==null){
			if (!(this.currDisplayData && this.currDisplayData.type==3)){
				return;
			}
		};
		var tTexture=this.currTexture;
		if (this._diyTexture)tTexture=this._diyTexture;
		var tSkinSprite;
		switch (this.currDisplayData.type){
			case 0:
				if (graphics){
					var tCurrentMatrix=this.getDisplayMatrix();
					if (this._parentMatrix){
						var tRotateKey=false;
						if (tCurrentMatrix){
							Matrix.mul(tCurrentMatrix,this._parentMatrix,Matrix.TEMP);
							var tResultMatrix;
							if (noUseSave){
								if (this._resultMatrix==null)this._resultMatrix=new Matrix();
								tResultMatrix=this._resultMatrix;
								}else {
								tResultMatrix=new Matrix();
							}
							if ((!Render.isWebGL && this.currDisplayData.uvs)|| (Render.isWebGL && this._diyTexture && this.currDisplayData.uvs)){
								var tTestMatrix=BoneSlot._tempMatrix;
								tTestMatrix.identity();
								if (this.currDisplayData.uvs[1] > this.currDisplayData.uvs[5]){
									tTestMatrix.d=-1;
								}
								if (this.currDisplayData.uvs[0] > this.currDisplayData.uvs[4]
									&& this.currDisplayData.uvs[1] > this.currDisplayData.uvs[5]){
									tRotateKey=true;
									tTestMatrix.rotate(-Math.PI/2);
								}
								Matrix.mul(tTestMatrix,Matrix.TEMP,tResultMatrix);
								}else {
								Matrix.TEMP.copyTo(tResultMatrix);
							}
							if (tRotateKey){
								graphics.drawTexture(tTexture,-this.currDisplayData.height / 2,-this.currDisplayData.width / 2,this.currDisplayData.height,this.currDisplayData.width,tResultMatrix);
								}else {
								graphics.drawTexture(tTexture,-this.currDisplayData.width / 2,-this.currDisplayData.height / 2,this.currDisplayData.width,this.currDisplayData.height,tResultMatrix);
							}
						}
					}
				}
				break ;
			case 1:
				if (noUseSave){
					if (this._skinSprite==null){
						this._skinSprite=BoneSlot.createSkinMesh();
					}
					tSkinSprite=this._skinSprite;
					}else {
					tSkinSprite=BoneSlot.createSkinMesh();
				}
				if (tSkinSprite==null){
					return;
				};
				var tIBArray;
				var tRed=1;
				var tGreed=1;
				var tBlue=1;
				var tAlpha=1;
				if (this.currDisplayData.bones==null){
					var tVertices=this.currDisplayData.weights;
					if (this.deformData){
						tVertices=this.deformData;
					};
					var tUVs;
					if (this._diyTexture){
						if (!this._curDiyUV){
							this._curDiyUV=[];
						}
						if (this._curDiyUV.length==0){
							this._curDiyUV=UVTools.getRelativeUV(this.currTexture.uv,this.currDisplayData.uvs,this._curDiyUV);
							this._curDiyUV=UVTools.getAbsoluteUV(this._diyTexture.uv,this._curDiyUV,this._curDiyUV);
						}
						tUVs=this._curDiyUV;
						}else{
						tUVs=this.currDisplayData.uvs;
					}
					this._mVerticleArr=tVertices;
					var tTriangleNum=this.currDisplayData.triangles.length / 3;
					tIBArray=this.currDisplayData.triangles;
					tSkinSprite.init2(tTexture,null ,tIBArray,this._mVerticleArr,tUVs);
					var tCurrentMatrix2=this.getDisplayMatrix();
					if (this._parentMatrix){
						if (tCurrentMatrix2){
							Matrix.mul(tCurrentMatrix2,this._parentMatrix,Matrix.TEMP);
							var tResultMatrix2;
							if (noUseSave){
								if (this._resultMatrix==null)this._resultMatrix=new Matrix();
								tResultMatrix2=this._resultMatrix;
								}else {
								tResultMatrix2=new Matrix();
							}
							Matrix.TEMP.copyTo(tResultMatrix2);
							tSkinSprite.transform=tResultMatrix2;
						}
					}
					}else {
					this.skinMesh(boneMatrixArray,tSkinSprite,alpha);
				}
				graphics.drawSkin(tSkinSprite);
				break ;
			case 2:
				if (noUseSave){
					if (this._skinSprite==null){
						this._skinSprite=BoneSlot.createSkinMesh();
					}
					tSkinSprite=this._skinSprite;
					}else {
					tSkinSprite=BoneSlot.createSkinMesh();
				}
				if (tSkinSprite==null){
					return;
				}
				this.skinMesh(boneMatrixArray,tSkinSprite,alpha);
				graphics.drawSkin(tSkinSprite);
				break ;
			case 3:
				break ;
			}
	}

	/**
	*显示蒙皮动画
	*@param boneMatrixArray 当前帧的骨骼矩阵
	*/
	__proto.skinMesh=function(boneMatrixArray,skinSprite,alpha){
		var tTexture=this.currTexture;
		var tBones=this.currDisplayData.bones;
		var tUvs;
		if (this._diyTexture){
			tTexture=this._diyTexture;
			if (!this._curDiyUV){
				this._curDiyUV=[];
			}
			if (this._curDiyUV.length==0){
				this._curDiyUV=UVTools.getRelativeUV(this.currTexture.uv,this.currDisplayData.uvs,this._curDiyUV);
				this._curDiyUV=UVTools.getAbsoluteUV(this._diyTexture.uv,this._curDiyUV,this._curDiyUV);
			}
			tUvs=this._curDiyUV;
			}else{
			tUvs=this.currDisplayData.uvs;
		};
		var tWeights=this.currDisplayData.weights;
		var tTriangles=this.currDisplayData.triangles;
		var tIBArray;
		var tRx=0;
		var tRy=0;
		var nn=0;
		var tMatrix;
		var tX=NaN;
		var tY=NaN;
		var tB=0;
		var tWeight=0;
		var tVertices=[];
		var i=0,j=0,n=0;
		var tRed=1;
		var tGreed=1;
		var tBlue=1;
		var tAlpha=alpha;
		if (this.deformData && this.deformData.length > 0){
			var f=0;
			for (i=0,n=tBones.length;i < n;){
				nn=tBones[i++]+i;
				tRx=0,tRy=0;
				for (;i < nn;i++){
					tMatrix=boneMatrixArray[tBones[i]]
					tX=tWeights[tB]+this.deformData[f++];
					tY=tWeights[tB+1]+this.deformData[f++];
					tWeight=tWeights[tB+2];
					tRx+=(tX *tMatrix.a+tY *tMatrix.c+tMatrix.tx)*tWeight;
					tRy+=(tX *tMatrix.b+tY *tMatrix.d+tMatrix.ty)*tWeight;
					tB+=3;
				}
				tVertices.push(tRx,tRy);
			}
			}else {
			for (i=0,n=tBones.length;i < n;){
				nn=tBones[i++]+i;
				tRx=0,tRy=0;
				for (;i < nn;i++){
					tMatrix=boneMatrixArray[tBones[i]]
					tX=tWeights[tB];
					tY=tWeights[tB+1];
					tWeight=tWeights[tB+2];
					tRx+=(tX *tMatrix.a+tY *tMatrix.c+tMatrix.tx)*tWeight;
					tRy+=(tX *tMatrix.b+tY *tMatrix.d+tMatrix.ty)*tWeight;
					tB+=3;
				}
				tVertices.push(tRx,tRy);
			}
		}
		this._mVerticleArr=tVertices;
		tIBArray=tTriangles;
		skinSprite.init2(tTexture,null,tIBArray,this._mVerticleArr,tUvs);
	}

	/**
	*画骨骼的起始点，方便调试
	*@param graphics
	*/
	__proto.drawBonePoint=function(graphics){
		if (graphics && this._parentMatrix){
			graphics.drawCircle(this._parentMatrix.tx,this._parentMatrix.ty,5,"#ff0000");
		}
	}

	/**
	*得到显示对象的矩阵
	*@return
	*/
	__proto.getDisplayMatrix=function(){
		if (this.currDisplayData){
			return this.currDisplayData.transform.getMatrix();
		}
		return null;
	}

	/**
	*得到插糟的矩阵
	*@return
	*/
	__proto.getMatrix=function(){
		return this._resultMatrix;
	}

	/**
	*用原始数据拷贝出一个
	*@return
	*/
	__proto.copy=function(){
		var tBoneSlot=new BoneSlot();
		tBoneSlot.type="copy";
		tBoneSlot.name=this.name;
		tBoneSlot.attachmentName=this.attachmentName;
		tBoneSlot.srcDisplayIndex=this.srcDisplayIndex;
		tBoneSlot.parent=this.parent;
		tBoneSlot.displayIndex=this.displayIndex;
		tBoneSlot.templet=this.templet;
		tBoneSlot.currSlotData=this.currSlotData;
		tBoneSlot.currTexture=this.currTexture;
		tBoneSlot.currDisplayData=this.currDisplayData;
		return tBoneSlot;
	}

	BoneSlot.createSkinMesh=function(){
		if (Render.isWebGL || Render.isConchApp){
			return RunDriver.skinAniSprite();
			}else{
			if (!Render.isWebGL){
				if (Skeleton.useSimpleMeshInCanvas){
					return new SimpleSkinMeshCanvas();
					}else{
					return new SkinMeshCanvas();
				}
			}
		}
		return null;
	}

	__static(BoneSlot,
	['_tempMatrix',function(){return this._tempMatrix=new Matrix();}
	]);
	return BoneSlot;
})()


/**
*@private
*canvas mesh渲染器
*/
//class laya.ani.bone.canvasmesh.CanvasMeshRender
var CanvasMeshRender=(function(){
	function CanvasMeshRender(){
		/**
		*mesh数据
		*/
		this.mesh=null;
		/**
		*矩阵
		*/
		this.transform=null;
		/**
		*绘图环境
		*/
		this.context=null;
		/**
		*绘制mesh的模式 0:顶点索引模式 1：无顶点索引模式
		*/
		this.mode=0;
	}

	__class(CanvasMeshRender,'laya.ani.bone.canvasmesh.CanvasMeshRender');
	var __proto=CanvasMeshRender.prototype;
	/**
	*将mesh数据渲染到context上面
	*@param context
	*
	*/
	__proto.renderToContext=function(context){
		this.context=context.ctx||context;
		if (this.mesh){
			if (this.mode==0){
				this._renderWithIndexes(this.mesh);
				}else{
				this._renderNoIndexes(this.mesh);
			}
		}
	}

	/**
	*无顶点索引的模式
	*@param mesh
	*
	*/
	__proto._renderNoIndexes=function(mesh){
		var i=0,len=mesh.vertices.length / 2;
		var index=0;
		for (i=0;i < len-2;i++){
			index=i *2;
			this._renderDrawTriangle(mesh,index,(index+2),(index+4));
		}
	}

	/**
	*使用顶点索引模式绘制
	*@param mesh
	*
	*/
	__proto._renderWithIndexes=function(mesh){
		var indexes=mesh.indexes;
		var i=0,len=indexes.length;
		for (i=0;i < len;i+=3){
			var index0=indexes[i] *2;
			var index1=indexes[i+1] *2;
			var index2=indexes[i+2] *2;
			this._renderDrawTriangle(mesh,index0,index1,index2);
		}
	}

	/**
	*绘制三角形
	*@param mesh mesh
	*@param index0 顶点0
	*@param index1 顶点1
	*@param index2 顶点2
	*
	*/
	__proto._renderDrawTriangle=function(mesh,index0,index1,index2){
		var context=this.context;
		var uvs=mesh.uvs;
		var vertices=mesh.vertices;
		var texture=mesh.texture;
		var source=texture.bitmap;
		var textureSource=source.source;
		var textureWidth=texture.width;
		var textureHeight=texture.height;
		var sourceWidth=source.width;
		var sourceHeight=source.height;
		var u0=NaN;
		var u1=NaN;
		var u2=NaN;
		var v0=NaN;
		var v1=NaN;
		var v2=NaN;
		if (mesh.useUvTransform){
			var ut=mesh.uvTransform;
			u0=((uvs[index0] *ut.a)+(uvs[index0+1] *ut.c)+ut.tx)*sourceWidth;
			u1=((uvs[index1] *ut.a)+(uvs[index1+1] *ut.c)+ut.tx)*sourceWidth;
			u2=((uvs[index2] *ut.a)+(uvs[index2+1] *ut.c)+ut.tx)*sourceWidth;
			v0=((uvs[index0] *ut.b)+(uvs[index0+1] *ut.d)+ut.ty)*sourceHeight;
			v1=((uvs[index1] *ut.b)+(uvs[index1+1] *ut.d)+ut.ty)*sourceHeight;
			v2=((uvs[index2] *ut.b)+(uvs[index2+1] *ut.d)+ut.ty)*sourceHeight;
		}
		else {
			u0=uvs[index0] *sourceWidth;
			u1=uvs[index1] *sourceWidth;
			u2=uvs[index2] *sourceWidth;
			v0=uvs[index0+1] *sourceHeight;
			v1=uvs[index1+1] *sourceHeight;
			v2=uvs[index2+1] *sourceHeight;
		};
		var x0=vertices[index0];
		var x1=vertices[index1];
		var x2=vertices[index2];
		var y0=vertices[index0+1];
		var y1=vertices[index1+1];
		var y2=vertices[index2+1];
		if (mesh.canvasPadding > 0){
			var paddingX=mesh.canvasPadding;
			var paddingY=mesh.canvasPadding;
			var centerX=(x0+x1+x2)/ 3;
			var centerY=(y0+y1+y2)/ 3;
			var normX=x0-centerX;
			var normY=y0-centerY;
			var dist=Math.sqrt((normX *normX)+(normY *normY));
			x0=centerX+((normX / dist)*(dist+paddingX));
			y0=centerY+((normY / dist)*(dist+paddingY));
			normX=x1-centerX;
			normY=y1-centerY;
			dist=Math.sqrt((normX *normX)+(normY *normY));
			x1=centerX+((normX / dist)*(dist+paddingX));
			y1=centerY+((normY / dist)*(dist+paddingY));
			normX=x2-centerX;
			normY=y2-centerY;
			dist=Math.sqrt((normX *normX)+(normY *normY));
			x2=centerX+((normX / dist)*(dist+paddingX));
			y2=centerY+((normY / dist)*(dist+paddingY));
		}
		context.save();
		if (this.transform){
			var mt=this.transform;
			context.transform(mt.a,mt.b,mt.c,mt.d,mt.tx,mt.ty);
		}
		context.beginPath();
		context.moveTo(x0,y0);
		context.lineTo(x1,y1);
		context.lineTo(x2,y2);
		context.closePath();
		context.clip();
		var delta=(u0 *v1)+(v0 *u2)+(u1 *v2)-(v1 *u2)-(v0 *u1)-(u0 *v2);
		var dDelta=1 / delta;
		var deltaA=(x0 *v1)+(v0 *x2)+(x1 *v2)-(v1 *x2)-(v0 *x1)-(x0 *v2);
		var deltaB=(u0 *x1)+(x0 *u2)+(u1 *x2)-(x1 *u2)-(x0 *u1)-(u0 *x2);
		var deltaC=(u0 *v1 *x2)+(v0 *x1 *u2)+(x0 *u1 *v2)-(x0 *v1 *u2)-(v0 *u1 *x2)-(u0 *x1 *v2);
		var deltaD=(y0 *v1)+(v0 *y2)+(y1 *v2)-(v1 *y2)-(v0 *y1)-(y0 *v2);
		var deltaE=(u0 *y1)+(y0 *u2)+(u1 *y2)-(y1 *u2)-(y0 *u1)-(u0 *y2);
		var deltaF=(u0 *v1 *y2)+(v0 *y1 *u2)+(y0 *u1 *v2)-(y0 *v1 *u2)-(v0 *u1 *y2)-(u0 *y1 *v2);
		context.transform(deltaA *dDelta,deltaD *dDelta,deltaB *dDelta,deltaE*dDelta,deltaC *dDelta,deltaF *dDelta);
		context.drawImage(textureSource,texture.uv[0]*sourceWidth,texture.uv[1]*sourceHeight,textureWidth,textureHeight,texture.uv[0]*sourceWidth,texture.uv[1]*sourceHeight,textureWidth,textureHeight);
		context.restore();
	}

	return CanvasMeshRender;
})()


/**
*@private
*/
//class laya.ani.bone.canvasmesh.MeshData
var MeshData=(function(){
	function MeshData(){
		/**
		*纹理
		*/
		this.texture=null;
		/**
		*uv数据
		*/
		this.uvs=[0,0,1,0,1,1,0,1];
		/**
		*顶点数据
		*/
		this.vertices=[0,0,100,0,100,100,0,100];
		/**
		*顶点索引
		*/
		this.indexes=[0,1,3,3,1,2];
		/**
		*uv变换矩阵
		*/
		this.uvTransform=null;
		/**
		*是否有uv变化矩阵
		*/
		this.useUvTransform=false;
		/**
		*扩展像素,用来去除黑边
		*/
		this.canvasPadding=1;
	}

	__class(MeshData,'laya.ani.bone.canvasmesh.MeshData');
	var __proto=MeshData.prototype;
	/**
	*计算mesh的Bounds
	*@return
	*
	*/
	__proto.getBounds=function(){
		return Rectangle._getWrapRec(this.vertices);
	}

	return MeshData;
})()


/**
*@private
*/
//class laya.ani.bone.DeformAniData
var DeformAniData=(function(){
	function DeformAniData(){
		this.skinName=null;
		this.deformSlotDataList=[];
	}

	__class(DeformAniData,'laya.ani.bone.DeformAniData');
	return DeformAniData;
})()


/**
*@private
*/
//class laya.ani.bone.DeformSlotData
var DeformSlotData=(function(){
	function DeformSlotData(){
		this.deformSlotDisplayList=[];
	}

	__class(DeformSlotData,'laya.ani.bone.DeformSlotData');
	return DeformSlotData;
})()


/**
*@private
*/
//class laya.ani.bone.DeformSlotDisplayData
var DeformSlotDisplayData=(function(){
	function DeformSlotDisplayData(){
		this.boneSlot=null;
		this.slotIndex=-1;
		this.attachment=null;
		this.deformData=null;
		this.frameIndex=0;
		this.timeList=[];
		this.vectices=[];
		this.tweenKeyList=[];
	}

	__class(DeformSlotDisplayData,'laya.ani.bone.DeformSlotDisplayData');
	var __proto=DeformSlotDisplayData.prototype;
	__proto.binarySearch1=function(values,target){
		var low=0;
		var high=values.length-2;
		if (high==0)
			return 1;
		var current=high >>> 1;
		while (true){
			if (values[Math.floor(current+1)] <=target)
				low=current+1;
			else
			high=current;
			if (low==high)
				return low+1;
			current=(low+high)>>> 1;
		}
		return 0;
	}

	// Can't happen.
	__proto.apply=function(time,boneSlot,alpha){
		(alpha===void 0)&& (alpha=1);
		time+=0.05;
		if (this.timeList.length <=0){
			return;
		};
		var i=0;
		var n=0;
		var tTime=this.timeList[0];
		if (time < tTime){
			return;
		};
		var tVertexCount=this.vectices[0].length;
		var tVertices=[];
		var tFrameIndex=this.binarySearch1(this.timeList,time);
		this.frameIndex=tFrameIndex;
		if (time >=this.timeList[this.timeList.length-1]){
			var lastVertices=this.vectices[this.vectices.length-1];
			if (alpha < 1){
				for (i=0;i < tVertexCount;i++){
					tVertices[i]+=(lastVertices[i]-tVertices[i])*alpha;
				}
				}else {
				for (i=0;i < tVertexCount;i++){
					tVertices[i]=lastVertices[i];
				}
			}
			this.deformData=tVertices;
			return;
		};
		var tTweenKey=this.tweenKeyList[this.frameIndex];
		var tPrevVertices=this.vectices[this.frameIndex-1];
		var tNextVertices=this.vectices[this.frameIndex];
		var tPreFrameTime=this.timeList[this.frameIndex-1];
		var tFrameTime=this.timeList[this.frameIndex];
		if (this.tweenKeyList[tFrameIndex-1]){
			alpha=(time-tPreFrameTime)/ (tFrameTime-tPreFrameTime);
			}else {
			alpha=0;
		};
		var tPrev=NaN;
		for (i=0;i < tVertexCount;i++){
			tPrev=tPrevVertices[i];
			tVertices[i]=tPrev+(tNextVertices[i]-tPrev)*alpha;
		}
		this.deformData=tVertices;
	}

	return DeformSlotDisplayData;
})()


/**
*@private
*/
//class laya.ani.bone.DrawOrderData
var DrawOrderData=(function(){
	function DrawOrderData(){
		this.time=NaN;
		this.drawOrder=[];
	}

	__class(DrawOrderData,'laya.ani.bone.DrawOrderData');
	return DrawOrderData;
})()


/**
*@private
*/
//class laya.ani.bone.EventData
var EventData=(function(){
	function EventData(){
		this.name=null;
		this.intValue=0;
		this.floatValue=NaN;
		this.stringValue=null;
		this.time=NaN;
	}

	__class(EventData,'laya.ani.bone.EventData');
	return EventData;
})()


/**
*@private
*/
//class laya.ani.bone.IkConstraint
var IkConstraint=(function(){
	function IkConstraint(data,bones){
		this._targetBone=null;
		this._bones=null;
		this._data=null;
		this.name=null;
		this.mix=NaN;
		this.bendDirection=NaN;
		this.isSpine=true;
		//debug相关代码
		this._sp=null;
		this.isDebug=false;
		this._data=data;
		this._targetBone=bones[data.targetBoneIndex];
		this.isSpine=data.isSpine;
		if (this._bones==null)this._bones=[];
		this._bones.length=0;
		for (var i=0,n=data.boneIndexs.length;i < n;i++){
			this._bones.push(bones[data.boneIndexs[i]]);
		}
		this.name=data.name;
		this.mix=data.mix;
		this.bendDirection=data.bendDirection;
	}

	__class(IkConstraint,'laya.ani.bone.IkConstraint');
	var __proto=IkConstraint.prototype;
	__proto.apply=function(){
		switch (this._bones.length){
			case 1:
				this._applyIk1(this._bones[0],this._targetBone.resultMatrix.tx,this._targetBone.resultMatrix.ty,this.mix);
				break ;
			case 2:
				if (this.isSpine){
					this._applyIk2(this._bones[0],this._bones[1],this._targetBone.resultMatrix.tx,this._targetBone.resultMatrix.ty,this.bendDirection,this.mix);
					}else{
					this._applyIk3(this._bones[0],this._bones[1],this._targetBone.resultMatrix.tx,this._targetBone.resultMatrix.ty,this.bendDirection,this.mix);
				}
				break ;
			}
	}

	__proto._applyIk1=function(bone,targetX,targetY,alpha){
		var pp=bone.parentBone;
		var id=1 / (pp.resultMatrix.a *pp.resultMatrix.d-pp.resultMatrix.b *pp.resultMatrix.c);
		var x=targetX-pp.resultMatrix.tx;
		var y=targetY-pp.resultMatrix.ty;
		var tx=(x *pp.resultMatrix.d-y *pp.resultMatrix.c)*id-bone.transform.x;
		var ty=(y *pp.resultMatrix.a-x *pp.resultMatrix.b)*id-bone.transform.y;
		var rotationIK=Math.atan2(ty,tx)*IkConstraint.radDeg-0-bone.transform.skX;
		if (bone.transform.scX < 0)rotationIK+=180;
		if (rotationIK > 180)
			rotationIK-=360;
		else if (rotationIK <-180)rotationIK+=360;
		bone.transform.skX=bone.transform.skY=bone.transform.skX+rotationIK *alpha;
		bone.update();
	}

	__proto.updatePos=function(x,y){
		if (this._sp){
			this._sp.pos(x,y);
		}
	}

	__proto._applyIk2=function(parent,child,targetX,targetY,bendDir,alpha){
		if (alpha==0){
			return;
		};
		var px=parent.resultTransform.x,py=parent.resultTransform.y;
		var psx=parent.transform.scX,psy=parent.transform.scY;
		var csx=child.transform.scX;
		var os1=0,os2=0,s2=0;
		if (psx < 0){
			psx=-psx;
			os1=180;
			s2=-1;
			}else {
			os1=0;
			s2=1;
		}
		if (psy < 0){
			psy=-psy;
			s2=-s2;
		}
		if (csx < 0){
			csx=-csx;
			os2=180;
			}else {
			os2=0
		};
		var cx=child.resultTransform.x,cy=NaN,cwx=NaN,cwy=NaN;
		var a=parent.resultMatrix.a,b=parent.resultMatrix.c;
		var c=parent.resultMatrix.b,d=parent.resultMatrix.d;
		var u=Math.abs(psx-psy)<=0.0001;
		if (!u){
			cy=0;
			cwx=a *cx+parent.resultMatrix.tx;
			cwy=c *cx+parent.resultMatrix.ty;
			}else {
			cy=child.resultTransform.y;
			cwx=a *cx+b *cy+parent.resultMatrix.tx;
			cwy=c *cx+d *cy+parent.resultMatrix.ty;
		}
		if (this.isDebug){
			if (!this._sp){
				this._sp=new Sprite();
				Laya.stage.addChild(this._sp);
			}
			this._sp.graphics.clear();
			this._sp.graphics.drawCircle(targetX,targetY,15,"#ffff00");
			this._sp.graphics.drawCircle(cwx,cwy,15,"#ff00ff");
		}
		parent.setRotation(Math.atan2(cwy-parent.resultMatrix.ty,cwx-parent.resultMatrix.tx));
		var pp=parent.parentBone;
		a=pp.resultMatrix.a;
		b=pp.resultMatrix.c;
		c=pp.resultMatrix.b;
		d=pp.resultMatrix.d;
		var id=1 / (a *d-b *c);
		var x=targetX-pp.resultMatrix.tx,y=targetY-pp.resultMatrix.ty;
		var tx=(x *d-y *b)*id-px;
		var ty=(y *a-x *c)*id-py;
		x=cwx-pp.resultMatrix.tx;
		y=cwy-pp.resultMatrix.ty;
		var dx=(x *d-y *b)*id-px;
		var dy=(y *a-x *c)*id-py;
		var l1=Math.sqrt(dx *dx+dy *dy);
		var l2=child.length *csx;
		var a1=NaN,a2=NaN;
		if (u){
			l2 *=psx;
			var cos=(tx *tx+ty *ty-l1 *l1-l2 *l2)/ (2 *l1 *l2);
			if (cos <-1)
				cos=-1;
			else if (cos > 1)cos=1;
			a2=Math.acos(cos)*bendDir;
			a=l1+l2 *cos;
			b=l2 *Math.sin(a2);
			a1=Math.atan2(ty *a-tx *b,tx *a+ty *b);
			}else {
			a=psx *l2;
			b=psy *l2;
			var aa=a *a,bb=b *b,dd=tx *tx+ty *ty,ta=Math.atan2(ty,tx);
			c=bb *l1 *l1+aa *dd-aa *bb;
			var c1=-2 *bb *l1,c2=bb-aa;
			d=c1 *c1-4 *c2 *c;
			if (d > 0){
				var q=Math.sqrt(d);
				if (c1 < 0)q=-q;
				q=-(c1+q)/ 2;
				var r0=q / c2,r1=c / q;
				var r=Math.abs(r0)< Math.abs(r1)? r0 :r1;
				if (r *r <=dd){
					y=Math.sqrt(dd-r *r)*bendDir;
					a1=ta-Math.atan2(y,r);
					a2=Math.atan2(y / psy,(r-l1)/ psx);
				}
			};
			var minAngle=0,minDist=Number.MAX_VALUE,minX=0,minY=0;
			var maxAngle=0,maxDist=0,maxX=0,maxY=0;
			x=l1+a;
			d=x *x;
			if (d > maxDist){
				maxAngle=0;
				maxDist=d;
				maxX=x;
			}
			x=l1-a;
			d=x *x;
			if (d < minDist){
				minAngle=Math.PI;
				minDist=d;
				minX=x;
			};
			var angle=Math.acos(-a *l1 / (aa-bb));
			x=a *Math.cos(angle)+l1;
			y=b *Math.sin(angle);
			d=x *x+y *y;
			if (d < minDist){
				minAngle=angle;
				minDist=d;
				minX=x;
				minY=y;
			}
			if (d > maxDist){
				maxAngle=angle;
				maxDist=d;
				maxX=x;
				maxY=y;
			}
			if (dd <=(minDist+maxDist)/ 2){
				a1=ta-Math.atan2(minY *bendDir,minX);
				a2=minAngle *bendDir;
				}else {
				a1=ta-Math.atan2(maxY *bendDir,maxX);
				a2=maxAngle *bendDir;
			}
		};
		var os=Math.atan2(cy,cx)*s2;
		var rotation=parent.resultTransform.skX;
		a1=(a1-os)*IkConstraint.radDeg+os1-rotation;
		if (a1 > 180)
			a1-=360;
		else if (a1 <-180)a1+=360;
		parent.resultTransform.x=px;
		parent.resultTransform.y=py;
		parent.resultTransform.skX=parent.resultTransform.skY=rotation+a1 *alpha;
		rotation=child.resultTransform.skX;
		rotation=rotation % 360;
		a2=((a2+os)*IkConstraint.radDeg-0)*s2+os2-rotation;
		if (a2 > 180)
			a2-=360;
		else if (a2 <-180)a2+=360;
		child.resultTransform.x=cx;
		child.resultTransform.y=cy;
		child.resultTransform.skX=child.resultTransform.skY=child.resultTransform.skY+a2 *alpha;
		parent.update();
	}

	__proto._applyIk3=function(parent,child,targetX,targetY,bendDir,alpha){
		if (alpha==0){
			return;
		};
		var cwx=NaN,cwy=NaN;
		var x=child.resultMatrix.a *child.length;
		var y=child.resultMatrix.b *child.length;
		var lLL=x *x+y *y;
		var lL=Math.sqrt(lLL);
		var parentX=parent.resultMatrix.tx;
		var parentY=parent.resultMatrix.ty;
		var childX=child.resultMatrix.tx;
		var childY=child.resultMatrix.ty;
		var dX=childX-parentX;
		var dY=childY-parentY;
		var lPP=dX *dX+dY *dY;
		var lP=Math.sqrt(lPP);
		dX=targetX-parent.resultMatrix.tx;
		dY=targetY-parent.resultMatrix.ty;
		var lTT=dX *dX+dY *dY;
		var lT=Math.sqrt(lTT);
		var ikRadianA=0;
		if (lL+lP <=lT || lT+lL <=lP || lT+lP <=lL){
			var rate=NaN;
			if (lL+lP <=lT){
				rate=1;
				}else{
				rate=-1;
			}
			childX=parentX+rate*(targetX-parentX)*lP / lT;
			childY=parentY+rate*(targetY-parentY)*lP / lT;
		}
		else{
			var h=(lPP-lLL+lTT)/ (2 *lTT);
			var r=Math.sqrt(lPP-h *h *lTT)/ lT;
			var hX=parentX+(dX *h);
			var hY=parentY+(dY *h);
			var rX=-dY *r;
			var rY=dX *r;
			if (bendDir>0){
				childX=hX-rX;
				childY=hY-rY;
			}
			else{
				childX=hX+rX;
				childY=hY+rY;
			}
		}
		cwx=childX;
		cwy=childY;
		if (this.isDebug){
			if (!this._sp){
				this._sp=new Sprite();
				Laya.stage.addChild(this._sp);
			}
			this._sp.graphics.clear();
			this._sp.graphics.drawCircle(parentX,parentY,15,"#ff00ff");
			this._sp.graphics.drawCircle(targetX,targetY,15,"#ffff00");
			this._sp.graphics.drawCircle(cwx,cwy,15,"#ff00ff");
		};
		var pRotation=NaN;
		pRotation=Math.atan2(cwy-parent.resultMatrix.ty,cwx-parent.resultMatrix.tx);
		parent.setRotation(pRotation);
		var pTarMatrix;
		pTarMatrix=IkConstraint._tempMatrix;
		pTarMatrix.identity();
		pTarMatrix.rotate(pRotation);
		pTarMatrix.scale(parent.resultMatrix.getScaleX(),parent.resultMatrix.getScaleY());
		pTarMatrix.translate(parent.resultMatrix.tx,parent.resultMatrix.ty);
		pTarMatrix.copyTo(parent.resultMatrix);
		parent.updateChild();
		var childRotation=NaN;
		childRotation=Math.atan2(targetY-cwy,targetX-cwx);
		child.setRotation(childRotation);
		var childTarMatrix;
		childTarMatrix=IkConstraint._tempMatrix;
		childTarMatrix.identity();
		childTarMatrix.rotate(childRotation);
		childTarMatrix.scale(child.resultMatrix.getScaleX(),child.resultMatrix.getScaleY());
		childTarMatrix.translate(cwx,cwy);
		pTarMatrix.copyTo(child.resultMatrix);
		child.updateChild();
	}

	__static(IkConstraint,
	['radDeg',function(){return this.radDeg=180 / Math.PI;},'degRad',function(){return this.degRad=Math.PI / 180;},'_tempMatrix',function(){return this._tempMatrix=new Matrix();}
	]);
	return IkConstraint;
})()


/**
*@private
*/
//class laya.ani.bone.IkConstraintData
var IkConstraintData=(function(){
	function IkConstraintData(){
		this.name=null;
		this.targetBoneName=null;
		this.bendDirection=1;
		this.mix=1;
		this.isSpine=true;
		this.targetBoneIndex=-1;
		this.boneNames=[];
		this.boneIndexs=[];
	}

	__class(IkConstraintData,'laya.ani.bone.IkConstraintData');
	return IkConstraintData;
})()


/**
*@private
*Mesh数据处理工具
*@version 1.0
*
*@created 2017-4-28 下午2:46:23
*/
//class laya.ani.bone.MeshTools
var MeshTools=(function(){
	function MeshTools(){}
	__class(MeshTools,'laya.ani.bone.MeshTools');
	MeshTools.findEdge=function(verticles,offI,min){
		(offI===void 0)&& (offI=0);
		(min===void 0)&& (min=true);
		var i=0,len=0;
		var tIndex=0;
		len=verticles.length;
		tIndex=-1;
		for (i=0;i < len;i+=2){
			if (tIndex < 0 || (min==(verticles[tIndex+offI] < verticles[i+offI]))){
				tIndex=i;
			}
		}
		return tIndex;
	}

	MeshTools.findBestTriangle=function(verticles){
		var topI=0;
		topI=MeshTools.findEdge(verticles,1,true);
		var bottomI=0;
		bottomI=MeshTools.findEdge(verticles,1,false);
		var leftI=0;
		leftI=MeshTools.findEdge(verticles,0,true);
		var rightI=0;
		rightI=MeshTools.findEdge(verticles,0,false);
		var rst;
		rst=MeshTools._bestTriangle;
		rst.length=0;
		rst.push(leftI,rightI);
		if (rst.indexOf(topI)< 0)rst.push(topI);
		if (rst.indexOf(bottomI)< 0)rst.push(bottomI);
		return rst;
	}

	MeshTools.solveMesh=function(mesh,rst){
		rst=rst||[];
		rst.length=0;
		var mUv;
		mUv=mesh.uvs;
		var mVer;
		mVer=mesh.vertices;
		var uvAbs;
		var indexs;
		indexs=MeshTools.findBestTriangle(mUv);
		var index0=0;
		var index1=0;
		var index2=0;
		index0=indexs[0];
		index1=indexs[1];
		index2=indexs[2];
		MeshTools._absArr.length=0;
		var newVerticles;
		if (MeshTools.isNormalUV(mesh.texture.uv)){
			MeshTools.adptTexture(mesh);
		}
		uvAbs=MeshTools.solvePoints(mesh.texture.uv,mUv[index0],mUv[index0+1],mUv[index1]-mUv[index0],mUv[index1+1]-mUv[index0+1],mUv[index2]-mUv[index0],mUv[index2+1]-mUv[index0+1],MeshTools._absArr);
		newVerticles=MeshTools.transPoints(uvAbs,mVer[index0],mVer[index0+1],mVer[index1]-mVer[index0],mVer[index1+1]-mVer[index0+1],mVer[index2]-mVer[index0],mVer[index2+1]-mVer[index0+1],rst);
		return newVerticles;
	}

	MeshTools.findWrapRect=function(verticles){
		var topI=0;
		topI=MeshTools.findEdge(verticles,1,true);
		var bottomI=0;
		bottomI=MeshTools.findEdge(verticles,1,false);
		var leftI=0;
		leftI=MeshTools.findEdge(verticles,0,true);
		var rightI=0;
		rightI=MeshTools.findEdge(verticles,0,false);
		var left=NaN;
		left=verticles[leftI];
		var right=NaN;
		right=verticles[rightI];
		var top=NaN;
		top=verticles[topI+1];
		var bottom=NaN;
		bottom=verticles[bottomI+1];
		var rst;
		return [right,bottom,left-right,top-bottom];
	}

	MeshTools.adptTexture=function(mesh){
		var rec;
		rec=MeshTools.findWrapRect(mesh.uvs);
		var oTex;
		var nTex;
		oTex=mesh.texture;
		var oWidth=oTex.width;
		var oHeight=oTex.height;
		nTex=Texture.create(oTex,rec[0] *oWidth,rec[1] *oHeight,rec[2] *oWidth,rec[3] *oHeight);
		mesh.texture=nTex;
	}

	MeshTools.isNormalUV=function(uv){
		return uv[0]==0 && uv[1]==0 && uv[4]==1 && uv[5]==1;
	}

	MeshTools.solvePoints=function(pointList,oX,oY,v1x,v1y,v2x,v2y,rst){
		rst=rst||[];
		var i=0,len=0;
		len=pointList.length;
		var tRst;
		for (i=0;i < len;i+=2){
			tRst=MeshTools.solve2(pointList[i],pointList[i+1],oX,oY,v1x,v1y,v2x,v2y);
			rst.push(tRst[0],tRst[1]);
		}
		return rst;
	}

	MeshTools.transPoints=function(abs,oX,oY,v1x,v1y,v2x,v2y,rst){
		rst=rst|| [];
		var i=0,len=0;
		len=abs.length;
		var tRst;
		for (i=0;i < len;i+=2){
			tRst=MeshTools.transPoint(abs[i],abs[i+1],oX,oY,v1x,v1y,v2x,v2y,rst);
		}
		return rst;
	}

	MeshTools.transPoint=function(a,b,oX,oY,v1x,v1y,v2x,v2y,rst){
		rst=rst|| [];
		var nX=NaN;
		var nY=NaN;
		nX=oX+v1x *a+v2x *b;
		nY=oY+v1y *a+v2y *b;
		rst.push(nX,nY)
		return rst;
	}

	MeshTools.solve2=function(rx,ry,oX,oY,v1x,v1y,v2x,v2y,rv,rst){
		(rv===void 0)&& (rv=false);
		rst=rst||[];
		var a=NaN,b=NaN;
		if (v1x==0){
			return MeshTools.solve2(rx,ry,oX,oY,v2x,v2y,v1x,v1y,true,rst);
		};
		var dX=NaN;
		var dY=NaN;
		dX=rx-oX;
		dY=ry-oY;
		b=(dY-dX *v1y / v1x)/ (v2y-v2x *v1y / v1x);
		a=(dX-b *v2x)/ v1x;
		if(rv){
			rst.push(b,a);
			}else{
			rst.push(a,b);
		}
		return rst;
	}

	MeshTools.solve=function(pointC,point0,v1,v2){
		return MeshTools.solve2(pointC.x,pointC.y,point0.x,point0.y,v1.x,v1.y,v2.x,v2.y);
	}

	MeshTools._bestTriangle=[];
	MeshTools._absArr=[];
	return MeshTools;
})()


/**
*@private
*路径作用器
*1，生成根据骨骼计算控制点
*2，根据控制点生成路径，并计算路径上的节点
*3，根据节点，重新调整骨骼位置
*/
//class laya.ani.bone.PathConstraint
var PathConstraint=(function(){
	function PathConstraint(data,bones){
		this.target=null;
		this.data=null;
		this.bones=null;
		this.position=NaN;
		this.spacing=NaN;
		this.rotateMix=NaN;
		this.translateMix=NaN;
		this._debugKey=false;
		this._spaces=null;
		this._segments=[];
		this._curves=[];
		this.data=data;
		this.position=data.position;
		this.spacing=data.spacing;
		this.rotateMix=data.rotateMix;
		this.translateMix=data.translateMix;
		this.bones=[];
		var tBoneIds=this.data.bones;
		for (var i=0,n=tBoneIds.length;i < n;i++){
			this.bones.push(bones[tBoneIds[i]]);
		}
	}

	__class(PathConstraint,'laya.ani.bone.PathConstraint');
	var __proto=PathConstraint.prototype;
	/**
	*计算骨骼在路径上的节点
	*@param boneSlot
	*@param boneMatrixArray
	*@param graphics
	*/
	__proto.apply=function(boneList,graphics){
		if (!this.target)
			return;
		var tTranslateMix=this.translateMix;
		var tRotateMix=this.translateMix;
		var tTranslate=tTranslateMix > 0;
		var tRotate=tRotateMix > 0;
		var tSpacingMode=this.data.spacingMode;
		var tLengthSpacing=tSpacingMode=="length";
		var tRotateMode=this.data.rotateMode;
		var tTangents=tRotateMode=="tangent";
		var tScale=tRotateMode=="chainScale";
		var lengths=[];
		var boneCount=this.bones.length;
		var spacesCount=tTangents ? boneCount :boneCount+1;
		var spaces=[];
		this._spaces=spaces;
		spaces[0]=this.position;
		var spacing=this.spacing;
		if (tScale || tLengthSpacing){
			for (var i=0,n=spacesCount-1;i < n;){
				var bone=this.bones[i];
				var length=bone.length;
				var x=length *bone.resultMatrix.a;
				var y=length *bone.resultMatrix.b;
				length=Math.sqrt(x *x+y *y);
				if (tScale)
					lengths[i]=length;
				spaces[++i]=tLengthSpacing ? Math.max(0,length+spacing):spacing;
			}
		}
		else {
			for (i=1;i < spacesCount;i++){
				spaces[i]=spacing;
			}
		};
		var positions=this.computeWorldPositions(this.target,boneList,graphics,spacesCount,tTangents,this.data.positionMode=="percent",tSpacingMode=="percent");
		if (this._debugKey){
			for (i=0;i < positions.length;i++){
				graphics.drawCircle(positions[i++],positions[i++],5,"#00ff00");
			};
			var tLinePos=[];
			for (i=0;i < positions.length;i++){
				tLinePos.push(positions[i++],positions[i++]);
			}
			graphics.drawLines(0,0,tLinePos,"#ff0000");
		};
		var skeletonX=NaN;
		var skeletonY=NaN;
		var boneX=positions[0];
		var boneY=positions[1];
		var offsetRotation=this.data.offsetRotation;
		var tip=tRotateMode=="chain" && offsetRotation==0;
		var p=NaN;
		for (i=0,p=3;i < boneCount;i++,p+=3){
			bone=this.bones[i];
			bone.resultMatrix.tx+=(boneX-bone.resultMatrix.tx)*tTranslateMix;
			bone.resultMatrix.ty+=(boneY-bone.resultMatrix.ty)*tTranslateMix;
			x=positions[p];
			y=positions[p+1];
			var dx=x-boneX,dy=y-boneY;
			if (tScale){
				length=lengths[i];
				if (length !=0){
					var s=(Math.sqrt(dx *dx+dy *dy)/ length-1)*tRotateMix+1;
					bone.resultMatrix.a *=s;
					bone.resultMatrix.c *=s;
				}
			}
			boneX=x;
			boneY=y;
			if (tRotate){
				var a=bone.resultMatrix.a;
				var b=bone.resultMatrix.c;
				var c=bone.resultMatrix.b;
				var d=bone.resultMatrix.d;
				var r=NaN;
				var cos=NaN;
				var sin=NaN;
				if (tTangents){
					r=positions[p-1];
				}
				else if (spaces[i+1]==0){
					r=positions[p+2];
				}
				else {
					r=Math.atan2(dy,dx);
				}
				r-=Math.atan2(c,a)-offsetRotation / 180 *Math.PI;
				if (tip){
					cos=Math.cos(r);
					sin=Math.sin(r);
					length=bone.length;
					boneX+=(length *(cos *a-sin *c)-dx)*tRotateMix;
					boneY+=(length *(sin *a+cos *c)-dy)*tRotateMix;
				}
				if (r > Math.PI){
					r-=(Math.PI *2);
				}
				else if (r <-Math.PI){
					r+=(Math.PI *2);
				}
				r *=tRotateMix;
				cos=Math.cos(r);
				sin=Math.sin(r);
				bone.resultMatrix.a=cos *a-sin *c;
				bone.resultMatrix.c=cos *b-sin *d;
				bone.resultMatrix.b=sin *a+cos *c;
				bone.resultMatrix.d=sin *b+cos *d;
			}
		}
	}

	/**
	*计算顶点的世界坐标
	*@param boneSlot
	*@param boneList
	*@param start
	*@param count
	*@param worldVertices
	*@param offset
	*/
	__proto.computeWorldVertices2=function(boneSlot,boneList,start,count,worldVertices,offset){
		var tBones=boneSlot.currDisplayData.bones;
		var tWeights=boneSlot.currDisplayData.weights;
		var tTriangles=boneSlot.currDisplayData.triangles;
		var tMatrix;
		var i=0;
		var v=0;
		var skip=0;
		var n=0;
		var w=0;
		var b=0;
		var wx=0;
		var wy=0;
		var vx=0;
		var vy=0;
		var bone;
		var len=0;
		if (tBones==null){
			if (!tTriangles)tTriangles=tWeights;
			if (boneSlot.deformData)
				tTriangles=boneSlot.deformData;
			var parentName;
			parentName=boneSlot.parent;
			if (boneList){
				len=boneList.length;
				for (i=0;i < len;i++){
					if (boneList[i].name==parentName){
						bone=boneList[i];
						break ;
					}
				}
			};
			var tBoneMt;
			if (bone){
				tBoneMt=bone.resultMatrix;
			}
			if (!tBoneMt)tBoneMt=PathConstraint._tempMt;
			var x=tBoneMt.tx;
			var y=tBoneMt.ty;
			var a=tBoneMt.a,bb=tBoneMt.b,c=tBoneMt.c,d=tBoneMt.d;
			if(bone)d*=bone.d;
			for (v=start,w=offset;w < count;v+=2,w+=2){
				vx=tTriangles[v],vy=tTriangles[v+1];
				worldVertices[w]=vx *a+vy *bb+x;
				worldVertices[w+1]=-(vx *c+vy *d+y);
			}
			return;
		}
		for (i=0;i < start;i+=2){
			n=tBones[v];
			v+=n+1;
			skip+=n;
		};
		var skeletonBones=boneList;
		for (w=offset,b=skip *3;w < count;w+=2){
			wx=0,wy=0;
			n=tBones[v++];
			n+=v;
			for (;v < n;v++,b+=3){
				tMatrix=skeletonBones[tBones[v]].resultMatrix;
				vx=tWeights[b];
				vy=tWeights[b+1];
				var weight=tWeights[b+2];
				wx+=(vx *tMatrix.a+vy *tMatrix.c+tMatrix.tx)*weight;
				wy+=(vx *tMatrix.b+vy *tMatrix.d+tMatrix.ty)*weight;
			}
			worldVertices[w]=wx;
			worldVertices[w+1]=wy;
		}
	}

	/**
	*计算路径上的节点
	*@param boneSlot
	*@param boneList
	*@param graphics
	*@param spacesCount
	*@param tangents
	*@param percentPosition
	*@param percentSpacing
	*@return
	*/
	__proto.computeWorldPositions=function(boneSlot,boneList,graphics,spacesCount,tangents,percentPosition,percentSpacing){
		var tBones=boneSlot.currDisplayData.bones;
		var tWeights=boneSlot.currDisplayData.weights;
		var tTriangles=boneSlot.currDisplayData.triangles;
		var tRx=0;
		var tRy=0;
		var nn=0;
		var tMatrix;
		var tX=NaN;
		var tY=NaN;
		var tB=0;
		var tWeight=0;
		var tVertices=[];
		var i=0,j=0,n=0;
		var verticesLength=boneSlot.currDisplayData.verLen;
		var target=boneSlot;
		var position=this.position;
		var spaces=this._spaces;
		var world=[];
		var out=[];
		var closed=false;
		var curveCount=verticesLength / 6;
		var prevCurve=-1;
		var pathLength=NaN;
		var o=0,curve=0;
		var p=NaN;
		var space=NaN;
		var prev=NaN;
		var length=NaN;
		if (!true){
			var lengths=boneSlot.currDisplayData.lengths;
			curveCount-=closed ? 1 :2;
			pathLength=lengths[curveCount];
			if (percentPosition)
				position *=pathLength;
			if (percentSpacing){
				for (i=0;i < spacesCount;i++)
				spaces[i] *=pathLength;
			}
			world.length=8;
			for (i=0,o=0,curve=0;i < spacesCount;i++,o+=3){
				space=spaces[i];
				position+=space;
				p=position;
				if (closed){
					p %=pathLength;
					if (p < 0)
						p+=pathLength;
					curve=0;
				}
				else if (p < 0){
					if (prevCurve !=PathConstraint.BEFORE){
						prevCurve=PathConstraint.BEFORE;
						this.computeWorldVertices2(target,boneList,2,4,world,0);
					}
					this.addBeforePosition(p,world,0,out,o);
					continue ;
				}
				else if (p > pathLength){
					if (prevCurve !=PathConstraint.AFTER){
						prevCurve=PathConstraint.AFTER;
						this.computeWorldVertices2(target,boneList,verticesLength-6,4,world,0);
					}
					this.addAfterPosition(p-pathLength,world,0,out,o);
					continue ;
				}
				for (;;curve++){
					length=lengths[curve];
					if (p > length)
						continue ;
					if (curve==0)
						p /=length;
					else {
						prev=lengths[curve-1];
						p=(p-prev)/ (length-prev);
					}
					break ;
				}
				if (curve !=prevCurve){
					prevCurve=curve;
					if (closed && curve==curveCount){
						this.computeWorldVertices2(target,boneList,verticesLength-4,4,world,0);
						this.computeWorldVertices2(target,boneList,0,4,world,4);
					}
					else
					this.computeWorldVertices2(target,boneList,curve *6+2,8,world,0);
				}
				this.addCurvePosition(p,world[0],world[1],world[2],world[3],world[4],world[5],world[6],world[7],out,o,tangents || (i > 0 && space==0));
			}
			return out;
		}
		if (closed){
			verticesLength+=2;
			world[verticesLength-2]=world[0];
			world[verticesLength-1]=world[1];
		}
		else {
			curveCount--;
			verticesLength-=4;
			this.computeWorldVertices2(boneSlot,boneList,2,verticesLength,tVertices,0);
			if (this._debugKey){
				for (i=0;i < tVertices.length;){
					graphics.drawCircle(tVertices[i++],tVertices[i++],10,"#ff0000");
				}
			}
			world=tVertices;
		}
		this._curves.length=curveCount;
		var curves=this._curves;
		pathLength=0;
		var x1=world[0],y1=world[1],cx1=0,cy1=0,cx2=0,cy2=0,x2=0,y2=0;
		var tmpx=NaN,tmpy=NaN,dddfx=NaN,dddfy=NaN,ddfx=NaN,ddfy=NaN,dfx=NaN,dfy=NaN;
		var w=0;
		for (i=0,w=2;i < curveCount;i++,w+=6){
			cx1=world[w];
			cy1=world[w+1];
			cx2=world[w+2];
			cy2=world[w+3];
			x2=world[w+4];
			y2=world[w+5];
			tmpx=(x1-cx1 *2+cx2)*0.1875;
			tmpy=(y1-cy1 *2+cy2)*0.1875;
			dddfx=((cx1-cx2)*3-x1+x2)*0.09375;
			dddfy=((cy1-cy2)*3-y1+y2)*0.09375;
			ddfx=tmpx *2+dddfx;
			ddfy=tmpy *2+dddfy;
			dfx=(cx1-x1)*0.75+tmpx+dddfx *0.16666667;
			dfy=(cy1-y1)*0.75+tmpy+dddfy *0.16666667;
			pathLength+=Math.sqrt(dfx *dfx+dfy *dfy);
			dfx+=ddfx;
			dfy+=ddfy;
			ddfx+=dddfx;
			ddfy+=dddfy;
			pathLength+=Math.sqrt(dfx *dfx+dfy *dfy);
			dfx+=ddfx;
			dfy+=ddfy;
			pathLength+=Math.sqrt(dfx *dfx+dfy *dfy);
			dfx+=ddfx+dddfx;
			dfy+=ddfy+dddfy;
			pathLength+=Math.sqrt(dfx *dfx+dfy *dfy);
			curves[i]=pathLength;
			x1=x2;
			y1=y2;
		}
		if (percentPosition)
			position *=pathLength;
		if (percentSpacing){
			for (i=0;i < spacesCount;i++)
			spaces[i] *=pathLength;
		};
		var segments=this._segments;
		var curveLength=0;
		var segment=0;
		for (i=0,o=0,curve=0,segment=0;i < spacesCount;i++,o+=3){
			space=spaces[i];
			position+=space;
			p=position;
			if (closed){
				p %=pathLength;
				if (p < 0)
					p+=pathLength;
				curve=0;
			}
			else if (p < 0){
				this.addBeforePosition(p,world,0,out,o);
				continue ;
			}
			else if (p > pathLength){
				this.addAfterPosition(p-pathLength,world,verticesLength-4,out,o);
				continue ;
			}
			for (;;curve++){
				length=curves[curve];
				if (p > length)
					continue ;
				if (curve==0)
					p /=length;
				else {
					prev=curves[curve-1];
					p=(p-prev)/ (length-prev);
				}
				break ;
			}
			if (curve !=prevCurve){
				prevCurve=curve;
				var ii=curve *6;
				x1=world[ii];
				y1=world[ii+1];
				cx1=world[ii+2];
				cy1=world[ii+3];
				cx2=world[ii+4];
				cy2=world[ii+5];
				x2=world[ii+6];
				y2=world[ii+7];
				tmpx=(x1-cx1 *2+cx2)*0.03;
				tmpy=(y1-cy1 *2+cy2)*0.03;
				dddfx=((cx1-cx2)*3-x1+x2)*0.006;
				dddfy=((cy1-cy2)*3-y1+y2)*0.006;
				ddfx=tmpx *2+dddfx;
				ddfy=tmpy *2+dddfy;
				dfx=(cx1-x1)*0.3+tmpx+dddfx *0.16666667;
				dfy=(cy1-y1)*0.3+tmpy+dddfy *0.16666667;
				curveLength=Math.sqrt(dfx *dfx+dfy *dfy);
				segments[0]=curveLength;
				for (ii=1;ii < 8;ii++){
					dfx+=ddfx;
					dfy+=ddfy;
					ddfx+=dddfx;
					ddfy+=dddfy;
					curveLength+=Math.sqrt(dfx *dfx+dfy *dfy);
					segments[ii]=curveLength;
				}
				dfx+=ddfx;
				dfy+=ddfy;
				curveLength+=Math.sqrt(dfx *dfx+dfy *dfy);
				segments[8]=curveLength;
				dfx+=ddfx+dddfx;
				dfy+=ddfy+dddfy;
				curveLength+=Math.sqrt(dfx *dfx+dfy *dfy);
				segments[9]=curveLength;
				segment=0;
			}
			p *=curveLength;
			for (;;segment++){
				length=segments[segment];
				if (p > length)
					continue ;
				if (segment==0)
					p /=length;
				else {
					prev=segments[segment-1];
					p=segment+(p-prev)/ (length-prev);
				}
				break ;
			}
			this.addCurvePosition(p *0.1,x1,y1,cx1,cy1,cx2,cy2,x2,y2,out,o,tangents || (i > 0 && space==0));
		}
		return out;
	}

	__proto.addBeforePosition=function(p,temp,i,out,o){
		var x1=temp[i],y1=temp[i+1],dx=temp[i+2]-x1,dy=temp[i+3]-y1,r=Math.atan2(dy,dx);
		out[o]=x1+p *Math.cos(r);
		out[o+1]=y1+p *Math.sin(r);
		out[o+2]=r;
	}

	__proto.addAfterPosition=function(p,temp,i,out,o){
		var x1=temp[i+2],y1=temp[i+3],dx=x1-temp[i],dy=y1-temp[i+1],r=Math.atan2(dy,dx);
		out[o]=x1+p *Math.cos(r);
		out[o+1]=y1+p *Math.sin(r);
		out[o+2]=r;
	}

	__proto.addCurvePosition=function(p,x1,y1,cx1,cy1,cx2,cy2,x2,y2,out,o,tangents){
		if (p==0)
			p=0.0001;
		var tt=p *p,ttt=tt *p,u=1-p,uu=u *u,uuu=uu *u;
		var ut=u *p,ut3=ut *3,uut3=u *ut3,utt3=ut3 *p;
		var x=x1 *uuu+cx1 *uut3+cx2 *utt3+x2 *ttt,y=y1 *uuu+cy1 *uut3+cy2 *utt3+y2 *ttt;
		out[o]=x;
		out[o+1]=y;
		if (tangents){
			out[o+2]=Math.atan2(y-(y1 *uu+cy1 *ut *2+cy2 *tt),x-(x1 *uu+cx1 *ut *2+cx2 *tt));
		}
		else {
			out[o+2]=0;
		}
	}

	PathConstraint.NONE=-1;
	PathConstraint.BEFORE=-2;
	PathConstraint.AFTER=-3;
	__static(PathConstraint,
	['_tempMt',function(){return this._tempMt=new Matrix();}
	]);
	return PathConstraint;
})()


/**
*@private
*/
//class laya.ani.bone.PathConstraintData
var PathConstraintData=(function(){
	function PathConstraintData(){
		this.name=null;
		this.target=null;
		this.positionMode=null;
		this.spacingMode=null;
		this.rotateMode=null;
		this.offsetRotation=NaN;
		this.position=NaN;
		this.spacing=NaN;
		this.rotateMix=NaN;
		this.translateMix=NaN;
		this.bones=[];
	}

	__class(PathConstraintData,'laya.ani.bone.PathConstraintData');
	return PathConstraintData;
})()


/**
*@private
*/
//class laya.ani.bone.SkinData
var SkinData=(function(){
	function SkinData(){
		this.name=null;
		this.slotArr=[];
	}

	__class(SkinData,'laya.ani.bone.SkinData');
	return SkinData;
})()


/**
*@private
*/
//class laya.ani.bone.SkinSlotDisplayData
var SkinSlotDisplayData=(function(){
	function SkinSlotDisplayData(){
		this.name=null;
		this.attachmentName=null;
		this.type=0;
		this.transform=null;
		this.width=NaN;
		this.height=NaN;
		this.texture=null;
		this.bones=null;
		this.uvs=null;
		this.weights=null;
		this.triangles=null;
		this.vertices=null;
		this.lengths=null;
		this.verLen=0;
	}

	__class(SkinSlotDisplayData,'laya.ani.bone.SkinSlotDisplayData');
	var __proto=SkinSlotDisplayData.prototype;
	__proto.createTexture=function(currTexture){
		if (this.texture)return this.texture;
		this.texture=new Texture(currTexture.bitmap,this.uvs);
		if (this.uvs[0] > this.uvs[4]
			&& this.uvs[1] > this.uvs[5]){
			this.texture.width=currTexture.height;
			this.texture.height=currTexture.width;
			this.texture.offsetX=-currTexture.offsetX;
			this.texture.offsetY=-currTexture.offsetY;
			this.texture.sourceWidth=currTexture.sourceHeight;
			this.texture.sourceHeight=currTexture.sourceWidth;
			}else {
			this.texture.width=currTexture.width;
			this.texture.height=currTexture.height;
			this.texture.offsetX=-currTexture.offsetX;
			this.texture.offsetY=-currTexture.offsetY;
			this.texture.sourceWidth=currTexture.sourceWidth;
			this.texture.sourceHeight=currTexture.sourceHeight;
		}
		if (!Render.isWebGL){
			if (this.uvs[1] > this.uvs[5]){
				this.texture.offsetY=this.texture.sourceHeight-this.texture.height-this.texture.offsetY;
			}
		}
		return this.texture;
	}

	__proto.destory=function(){
		if (this.texture)this.texture.destroy();
	}

	return SkinSlotDisplayData;
})()


/**
*@private
*/
//class laya.ani.bone.SlotData
var SlotData=(function(){
	function SlotData(){
		this.name=null;
		this.displayArr=[];
	}

	__class(SlotData,'laya.ani.bone.SlotData');
	var __proto=SlotData.prototype;
	__proto.getDisplayByName=function(name){
		var tDisplay;
		for (var i=0,n=this.displayArr.length;i < n;i++){
			tDisplay=this.displayArr[i];
			if (tDisplay.attachmentName==name){
				return i;
			}
		}
		return-1;
	}

	return SlotData;
})()


/**
*@private
*/
//class laya.ani.bone.TfConstraint
var TfConstraint=(function(){
	function TfConstraint(data,bones){
		this._data=null;
		this._bones=null;
		this.target=null;
		this.rotateMix=NaN;
		this.translateMix=NaN;
		this.scaleMix=NaN;
		this.shearMix=NaN;
		this._temp=__newvec(2,0);
		this._data=data;
		if (this._bones==null){
			this._bones=[];
		}
		this.target=bones[data.targetIndex];
		var j=0,n=0;
		for (j=0,n=data.boneIndexs.length;j < n;j++){
			this._bones.push(bones[data.boneIndexs[j]]);
		}
		this.rotateMix=data.rotateMix;
		this.translateMix=data.translateMix;
		this.scaleMix=data.scaleMix;
		this.shearMix=data.shearMix;
	}

	__class(TfConstraint,'laya.ani.bone.TfConstraint');
	var __proto=TfConstraint.prototype;
	__proto.apply=function(){
		var tTfBone;
		var ta=this.target.resultMatrix.a,tb=this.target.resultMatrix.b,tc=this.target.resultMatrix.c,td=this.target.resultMatrix.d;
		for (var j=0,n=this._bones.length;j < n;j++){
			tTfBone=this._bones[j];
			if (this.rotateMix > 0){
				var a=tTfBone.resultMatrix.a,b=tTfBone.resultMatrix.b,c=tTfBone.resultMatrix.c,d=tTfBone.resultMatrix.d;
				var r=Math.atan2(tc,ta)-Math.atan2(c,a)+this._data.offsetRotation *Math.PI / 180;
				if (r > Math.PI)
					r-=Math.PI *2;
				else if (r <-Math.PI)r+=Math.PI *2;
				r *=this.rotateMix;
				var cos=Math.cos(r),sin=Math.sin(r);
				tTfBone.resultMatrix.a=cos *a-sin *c;
				tTfBone.resultMatrix.b=cos *b-sin *d;
				tTfBone.resultMatrix.c=sin *a+cos *c;
				tTfBone.resultMatrix.d=sin *b+cos *d;
			}
			if (this.translateMix){
				this._temp[0]=this._data.offsetX;
				this._temp[1]=this._data.offsetY;
				this.target.localToWorld(this._temp);
				tTfBone.resultMatrix.tx+=(this._temp[0]-tTfBone.resultMatrix.tx)*this.translateMix;
				tTfBone.resultMatrix.ty+=(this._temp[1]-tTfBone.resultMatrix.ty)*this.translateMix;
				tTfBone.updateChild();
			}
			if (this.scaleMix > 0){
				var bs=Math.sqrt(tTfBone.resultMatrix.a *tTfBone.resultMatrix.a+tTfBone.resultMatrix.c *tTfBone.resultMatrix.c);
				var ts=Math.sqrt(ta *ta+tc *tc);
				var s=bs > 0.00001 ? (bs+(ts-bs+this._data.offsetScaleX)*this.scaleMix)/ bs :0;
				tTfBone.resultMatrix.a *=s;
				tTfBone.resultMatrix.c *=s;
				bs=Math.sqrt(tTfBone.resultMatrix.b *tTfBone.resultMatrix.b+tTfBone.resultMatrix.d *tTfBone.resultMatrix.d);
				ts=Math.sqrt(tb *tb+td *td);
				s=bs > 0.00001 ? (bs+(ts-bs+this._data.offsetScaleY)*this.scaleMix)/ bs :0;
				tTfBone.resultMatrix.b *=s;
				tTfBone.resultMatrix.d *=s;
			}
			if (this.shearMix > 0){
				b=tTfBone.resultMatrix.b,d=tTfBone.resultMatrix.d;
				var by=Math.atan2(d,b);
				r=Math.atan2(td,tb)-Math.atan2(tc,ta)-(by-Math.atan2(tTfBone.resultMatrix.c,tTfBone.resultMatrix.a));
				if (r > Math.PI)
					r-=Math.PI *2;
				else if (r <-Math.PI)r+=Math.PI *2;
				r=by+(r+this._data.offsetShearY *Math.PI / 180)*this.shearMix;
				s=Math.sqrt(b *b+d *d);
				tTfBone.resultMatrix.b=Math.cos(r)*s;
				tTfBone.resultMatrix.d=Math.sin(r)*s;
			}
		}
	}

	return TfConstraint;
})()


/**
*@private
*/
//class laya.ani.bone.TfConstraintData
var TfConstraintData=(function(){
	function TfConstraintData(){
		this.name=null;
		this.targetIndex=0;
		this.rotateMix=NaN;
		this.translateMix=NaN;
		this.scaleMix=NaN;
		this.shearMix=NaN;
		this.offsetRotation=NaN;
		this.offsetX=NaN;
		this.offsetY=NaN;
		this.offsetScaleX=NaN;
		this.offsetScaleY=NaN;
		this.offsetShearY=NaN;
		this.boneIndexs=[];
	}

	__class(TfConstraintData,'laya.ani.bone.TfConstraintData');
	return TfConstraintData;
})()


/**
*@private
*/
//class laya.ani.bone.Transform
var Transform=(function(){
	function Transform(){
		this.skX=0;
		this.skY=0;
		this.scX=1;
		this.scY=1;
		this.x=0;
		this.y=0;
		this.skewX=0;
		this.skewY=0;
		this.mMatrix=null;
	}

	__class(Transform,'laya.ani.bone.Transform');
	var __proto=Transform.prototype;
	__proto.initData=function(data){
		if (data.x !=undefined){
			this.x=data.x;
		}
		if (data.y !=undefined){
			this.y=data.y;
		}
		if (data.skX !=undefined){
			this.skX=data.skX;
		}
		if (data.skY !=undefined){
			this.skY=data.skY;
		}
		if (data.scX !=undefined){
			this.scX=data.scX;
		}
		if (data.scY !=undefined){
			this.scY=data.scY;
		}
	}

	__proto.getMatrix=function(){
		var tMatrix;
		if (this.mMatrix){
			tMatrix=this.mMatrix;
			}else {
			tMatrix=this.mMatrix=new Matrix();
		}
		tMatrix.identity();
		tMatrix.scale(this.scX,this.scY);
		if (this.skewX || this.skewY){
			this.skew(tMatrix,this.skewX *Math.PI / 180,this.skewY *Math.PI / 180);
		}
		tMatrix.rotate(this.skX *Math.PI / 180);
		tMatrix.translate(this.x,this.y);
		return tMatrix;
	}

	__proto.skew=function(m,x,y){
		var sinX=Math.sin(y);
		var cosX=Math.cos(y);
		var sinY=Math.sin(x);
		var cosY=Math.cos(x);
		m.setTo(m.a *cosY-m.b *sinX,
		m.a *sinY+m.b *cosX,
		m.c *cosY-m.d *sinX,
		m.c *sinY+m.d *cosX,
		m.tx *cosY-m.ty *sinX,
		m.tx *sinY+m.ty *cosX);
		return m;
	}

	return Transform;
})()


/**
*用于UV转换的工具类
*@private
*/
//class laya.ani.bone.UVTools
var UVTools=(function(){
	function UVTools(){}
	__class(UVTools,'laya.ani.bone.UVTools');
	UVTools.getRelativeUV=function(bigUV,smallUV,rst){
		var startX=bigUV[0];
		var width=bigUV[2]-bigUV[0];
		var startY=bigUV[1];
		var height=bigUV[5]-bigUV[1];
		if(!rst)rst=[];
		rst.length=smallUV.length;
		var i=0,len=0;
		len=rst.length;
		var dWidth=1 / width;
		var dHeight=1 / height;
		for (i=0;i < len;i+=2){
			rst[i]=(smallUV[i]-startX)*dWidth;
			rst[i+1]=(smallUV[i+1]-startY)*dHeight;
		}
		return rst;
	}

	UVTools.getAbsoluteUV=function(bigUV,smallUV,rst){
		if (bigUV[0]==0 && bigUV[1]==0 && bigUV[4]==1 && bigUV[5]==1){
			if (rst){
				Utils.copyArray(rst,smallUV);
				return rst;
				}else{
				return smallUV;
			}
		};
		var startX=bigUV[0];
		var width=bigUV[2]-bigUV[0];
		var startY=bigUV[1];
		var height=bigUV[5]-bigUV[1];
		if(!rst)rst=[];
		rst.length=smallUV.length;
		var i=0,len=0;
		len=rst.length;
		for (i=0;i < len;i+=2){
			rst[i]=smallUV[i]*width+startX;
			rst[i+1]=smallUV[i+1]*height+startY;
		}
		return rst;
	}

	return UVTools;
})()


/**
*@private
*@author ...
*/
//class laya.ani.KeyFramesContent
var KeyFramesContent=(function(){
	function KeyFramesContent(){
		this.startTime=NaN;
		this.duration=NaN;
		this.interpolationData=null;
		//私有插值方式 [type0(插值类型),Data0(插值数据,可为空)，type1(插值类型),Data1(插值数据,可为空)] 注意：254全线性插值，255全不插值
		this.data=null;
		//=new Float32Array();
		this.nextData=null;
	}

	__class(KeyFramesContent,'laya.ani.KeyFramesContent');
	return KeyFramesContent;
})()


/**
*@private
*...
*@author ww
*/
//class laya.ani.math.BezierLerp
var BezierLerp=(function(){
	function BezierLerp(){}
	__class(BezierLerp,'laya.ani.math.BezierLerp');
	BezierLerp.getBezierRate=function(t,px0,py0,px1,py1){
		var key=BezierLerp._getBezierParamKey(px0,py0,px1,py1);
		var vKey=key *100+t;
		if (BezierLerp._bezierResultCache[vKey])return BezierLerp._bezierResultCache[vKey];
		var points=BezierLerp._getBezierPoints(px0,py0,px1,py1,key);
		var i=0,len=0;
		len=points.length;
		for (i=0;i < len;i+=2){
			if (t <=points[i]){
				BezierLerp._bezierResultCache[vKey]=points[i+1];
				return points[i+1];
			}
		}
		BezierLerp._bezierResultCache[vKey]=1;
		return 1;
	}

	BezierLerp._getBezierParamKey=function(px0,py0,px1,py1){
		return (((px0 *100+py0)*100+px1)*100+py1)*100;
	}

	BezierLerp._getBezierPoints=function(px0,py0,px1,py1,key){
		if (BezierLerp._bezierPointsCache[key])return BezierLerp._bezierPointsCache[key];
		var controlPoints;
		controlPoints=[0,0,px0,py0,px1,py1,1,1];
		var bz;
		bz=new Bezier();
		var points;
		points=bz.getBezierPoints(controlPoints,100,3);
		BezierLerp._bezierPointsCache[key]=points;
		return points;
	}

	BezierLerp._bezierResultCache={};
	BezierLerp._bezierPointsCache={};
	return BezierLerp;
})()


/**
*<code>AnimationPlayer</code> 类用于动画播放器。
*/
//class laya.ani.AnimationPlayer extends laya.events.EventDispatcher
var AnimationPlayer=(function(_super){
	function AnimationPlayer(){
		/**@private */
		this._destroyed=false;
		/**数据模板*/
		this._templet=null;
		/**当前精确时间，不包括重播时间*/
		this._currentTime=NaN;
		/**当前帧时间，不包括重播时间*/
		this._currentFrameTime=NaN;
		/**动画播放的起始时间位置*/
		this._playStart=NaN;
		/**动画播放的结束时间位置*/
		this._playEnd=NaN;
		/**动画播放一次的总时间*/
		this._playDuration=NaN;
		/**动画播放总时间*/
		this._overallDuration=NaN;
		/**是否在一帧结束时停止*/
		this._stopWhenCircleFinish=false;
		/**已播放时间，包括重播时间*/
		this._elapsedPlaybackTime=NaN;
		/**播放时帧数*/
		this._startUpdateLoopCount=NaN;
		/**当前动画索引*/
		this._currentAnimationClipIndex=0;
		/**当前帧数*/
		this._currentKeyframeIndex=0;
		/**是否暂停*/
		this._paused=false;
		/**默认帧率,必须大于0*/
		this._cacheFrameRate=0;
		/**帧率间隔时间*/
		this._cacheFrameRateInterval=NaN;
		/**缓存播放速率*/
		this._cachePlayRate=NaN;
		this._fullFrames=null;
		/**是否缓存*/
		this.isCache=true;
		/**播放速率*/
		this.playbackRate=1.0;
		/**停止时是否归零*/
		this.returnToZeroStopped=false;
		AnimationPlayer.__super.call(this);
		this._destroyed=false;
		this._currentAnimationClipIndex=-1;
		this._currentKeyframeIndex=-1;
		this._currentTime=0.0;
		this._overallDuration=Number.MAX_VALUE;
		this._stopWhenCircleFinish=false;
		this._elapsedPlaybackTime=0;
		this._startUpdateLoopCount=-1;
		this._cachePlayRate=1.0;
		this.cacheFrameRate=60;
		this.returnToZeroStopped=false;
	}

	__class(AnimationPlayer,'laya.ani.AnimationPlayer',_super);
	var __proto=AnimationPlayer.prototype;
	Laya.imps(__proto,{"laya.resource.IDestroy":true})
	/**
	*@private
	*/
	__proto._onTempletLoadedComputeFullKeyframeIndices=function(cachePlayRate,cacheFrameRate,templet){
		if (this._templet===templet && this._cachePlayRate===cachePlayRate && this._cacheFrameRate===cacheFrameRate)
			this._computeFullKeyframeIndices();
	}

	/**
	*@private
	*/
	__proto._computeFullKeyframeIndices=function(){
		var anifullFrames=this._fullFrames=[];
		var templet=this._templet;
		var cacheFrameInterval=this._cacheFrameRateInterval *this._cachePlayRate;
		for (var i=0,iNum=templet.getAnimationCount();i < iNum;i++){
			var aniFullFrame=[];
			for (var j=0,jNum=templet.getAnimation(i).nodes.length;j < jNum;j++){
				var node=templet.getAnimation(i).nodes[j];
				var frameCount=Math.floor(node.playTime / cacheFrameInterval+0.01);
				var nodeFullFrames=new Uint16Array(frameCount+1);
				var lastFrameIndex=-1;
				for (var n=0,nNum=node.keyFrame.length;n < nNum;n++){
					var keyFrame=node.keyFrame[n];
					var tm=keyFrame.startTime;
					var endTm=tm+keyFrame.duration+cacheFrameInterval;
					do {
						var frameIndex=Math.floor(tm / cacheFrameInterval+0.5);
						for (var k=lastFrameIndex+1;k < frameIndex;k++)
						nodeFullFrames[k]=n;
						lastFrameIndex=frameIndex;
						nodeFullFrames[frameIndex]=n;
						tm+=cacheFrameInterval;
					}while (tm <=endTm);
				}
				aniFullFrame.push(nodeFullFrames);
			}
			anifullFrames.push(aniFullFrame);
		}
	}

	/**
	*@private
	*/
	__proto._onAnimationTempletLoaded=function(){
		(this.destroyed)|| (this._calculatePlayDuration());
	}

	/**
	*@private
	*/
	__proto._calculatePlayDuration=function(){
		if (this.state!==/*laya.ani.AnimationState.stopped*/0){
			var oriDuration=this._templet.getAniDuration(this._currentAnimationClipIndex);
			(this._playEnd===0)&& (this._playEnd=oriDuration);
			if (this._playEnd > oriDuration)
				this._playEnd=oriDuration;
			this._playDuration=this._playEnd-this._playStart;
		}
	}

	/**
	*@private
	*/
	__proto._setPlayParams=function(time,cacheFrameInterval){
		this._currentTime=time;
		this._currentKeyframeIndex=Math.max(Math.floor((this.currentPlayTime)/ cacheFrameInterval+0.01),0);
		this._currentFrameTime=this._currentKeyframeIndex *cacheFrameInterval;
	}

	/**
	*@private
	*/
	__proto._setPlayParamsWhenStop=function(currentAniClipPlayDuration,cacheFrameInterval){
		this._currentTime=currentAniClipPlayDuration;
		this._currentKeyframeIndex=Math.max(Math.floor(currentAniClipPlayDuration / cacheFrameInterval+0.01),0);
		this._currentFrameTime=this._currentKeyframeIndex *cacheFrameInterval;
		this._currentAnimationClipIndex=-1;
	}

	/**
	*@private
	*/
	__proto._update=function(elapsedTime){
		if (this._currentAnimationClipIndex===-1 || this._paused || !this._templet || !this._templet.loaded)
			return;
		var cacheFrameInterval=this._cacheFrameRateInterval *this._cachePlayRate;
		var time=0;
		(this._startUpdateLoopCount!==Stat.loopCount)&& (time=elapsedTime *this.playbackRate,this._elapsedPlaybackTime+=time);
		var currentAniClipPlayDuration=this.playDuration;
		if ((this._overallDuration!==0 && this._elapsedPlaybackTime >=this._overallDuration)|| (this._overallDuration===0 && this._elapsedPlaybackTime >=currentAniClipPlayDuration)){
			this._setPlayParamsWhenStop(currentAniClipPlayDuration,cacheFrameInterval);
			this.event(/*laya.events.Event.STOPPED*/"stopped");
			return;
		}
		time+=this._currentTime;
		if (currentAniClipPlayDuration > 0){
			if (time >=currentAniClipPlayDuration){
				do {
					time-=currentAniClipPlayDuration;
					if (this._stopWhenCircleFinish){
						this._setPlayParamsWhenStop(currentAniClipPlayDuration,cacheFrameInterval);
						this._stopWhenCircleFinish=false;
						this.event(/*laya.events.Event.STOPPED*/"stopped");
						return;
					}
					if (time < currentAniClipPlayDuration){
						this._setPlayParams(time,cacheFrameInterval);
						this.event(/*laya.events.Event.COMPLETE*/"complete");
					}
				}while (time >=currentAniClipPlayDuration)
				}else {
				this._setPlayParams(time,cacheFrameInterval);
			}
			}else {
			if (this._stopWhenCircleFinish){
				this._setPlayParamsWhenStop(currentAniClipPlayDuration,cacheFrameInterval);
				this._stopWhenCircleFinish=false;
				this.event(/*laya.events.Event.STOPPED*/"stopped");
				return;
			}
			this._currentTime=this._currentFrameTime=this._currentKeyframeIndex=0;
			this.event(/*laya.events.Event.COMPLETE*/"complete");
		}
	}

	/**
	*@private
	*/
	__proto._destroy=function(){
		this.offAll();
		this._templet=null;
		this._fullFrames=null;
		this._destroyed=true;
	}

	/**
	*播放动画。
	*@param index 动画索引。
	*@param playbackRate 播放速率。
	*@param duration 播放时长（0为1次,Number.MAX_VALUE为循环播放）。
	*@param playStart 播放的起始时间位置。
	*@param playEnd 播放的结束时间位置。（0为动画一次循环的最长结束时间位置）。
	*/
	__proto.play=function(index,playbackRate,overallDuration,playStart,playEnd){
		(index===void 0)&& (index=0);
		(playbackRate===void 0)&& (playbackRate=1.0);
		(overallDuration===void 0)&& (overallDuration=2147483647);
		(playStart===void 0)&& (playStart=0);
		(playEnd===void 0)&& (playEnd=0);
		if (!this._templet)
			throw new Error("AnimationPlayer:templet must not be null,maybe you need to set url.");
		if (overallDuration < 0 || playStart < 0 || playEnd < 0)
			throw new Error("AnimationPlayer:overallDuration,playStart and playEnd must large than zero.");
		if ((playEnd!==0)&& (playStart > playEnd))
			throw new Error("AnimationPlayer:start must less than end.");
		this._currentTime=0;
		this._currentFrameTime=0;
		this._elapsedPlaybackTime=0;
		this.playbackRate=playbackRate;
		this._overallDuration=overallDuration;
		this._playStart=playStart;
		this._playEnd=playEnd;
		this._paused=false;
		this._currentAnimationClipIndex=index;
		this._currentKeyframeIndex=0;
		this._startUpdateLoopCount=Stat.loopCount;
		this.event(/*laya.events.Event.PLAYED*/"played");
		if (this._templet.loaded)
			this._calculatePlayDuration();
		else
		this._templet.once(/*laya.events.Event.LOADED*/"loaded",this,this._onAnimationTempletLoaded);
		this._update(0);
	}

	/**
	*播放动画。
	*@param index 动画索引。
	*@param playbackRate 播放速率。
	*@param duration 播放时长（0为1次,Number.MAX_VALUE为循环播放）。
	*@param playStartFrame 播放的原始起始帧率位置。
	*@param playEndFrame 播放的原始结束帧率位置。（0为动画一次循环的最长结束时间位置）。
	*/
	__proto.playByFrame=function(index,playbackRate,overallDuration,playStartFrame,playEndFrame,fpsIn3DBuilder){
		(index===void 0)&& (index=0);
		(playbackRate===void 0)&& (playbackRate=1.0);
		(overallDuration===void 0)&& (overallDuration=2147483647);
		(playStartFrame===void 0)&& (playStartFrame=0);
		(playEndFrame===void 0)&& (playEndFrame=0);
		(fpsIn3DBuilder===void 0)&& (fpsIn3DBuilder=30);
		var interval=1000.0 / fpsIn3DBuilder;
		this.play(index,playbackRate,overallDuration,playStartFrame *interval,playEndFrame *interval);
	}

	/**
	*停止播放当前动画
	*@param immediate 是否立即停止
	*/
	__proto.stop=function(immediate){
		(immediate===void 0)&& (immediate=true);
		if (immediate){
			this._currentTime=this._currentFrameTime=this._currentKeyframeIndex=0;
			this._currentAnimationClipIndex=-1;
			this.event(/*laya.events.Event.STOPPED*/"stopped");
			}else {
			this._stopWhenCircleFinish=true;
		}
	}

	/**
	*动画播放的结束时间位置。
	*@return 结束时间位置。
	*/
	__getset(0,__proto,'playEnd',function(){
		return this._playEnd;
	});

	/**
	*设置动画数据模板,注意：修改此值会有计算开销。
	*@param value 动画数据模板
	*/
	/**
	*获取动画数据模板
	*@param value 动画数据模板
	*/
	__getset(0,__proto,'templet',function(){
		return this._templet;
		},function(value){
		if (!this.state===/*laya.ani.AnimationState.stopped*/0)
			this.stop(true);
		if (this._templet!==value){
			this._templet=value;
			if (value.loaded)
				this._computeFullKeyframeIndices();
			else
			value.once(/*laya.events.Event.LOADED*/"loaded",this,this._onTempletLoadedComputeFullKeyframeIndices,[this._cachePlayRate,this._cacheFrameRate]);
		}
	});

	/**
	*动画播放的起始时间位置。
	*@return 起始时间位置。
	*/
	__getset(0,__proto,'playStart',function(){
		return this._playStart;
	});

	/**
	*获取动画播放一次的总时间
	*@return 动画播放一次的总时间
	*/
	__getset(0,__proto,'playDuration',function(){
		return this._playDuration;
	});

	/**
	*获取当前播放状态
	*@return 当前播放状态
	*/
	__getset(0,__proto,'state',function(){
		if (this._currentAnimationClipIndex===-1)
			return /*laya.ani.AnimationState.stopped*/0;
		if (this._paused)
			return /*laya.ani.AnimationState.paused*/1;
		return /*laya.ani.AnimationState.playing*/2;
	});

	/**
	*获取当前帧数
	*@return 当前帧数
	*/
	__getset(0,__proto,'currentKeyframeIndex',function(){
		return this._currentKeyframeIndex;
	});

	/**
	*获取动画播放的总总时间
	*@return 动画播放的总时间
	*/
	__getset(0,__proto,'overallDuration',function(){
		return this._overallDuration;
	});

	/**
	*获取当前帧时间，不包括重播时间
	*@return value 当前时间
	*/
	__getset(0,__proto,'currentFrameTime',function(){
		return this._currentFrameTime;
	});

	/**
	*获取当前动画索引
	*@return value 当前动画索引
	*/
	__getset(0,__proto,'currentAnimationClipIndex',function(){
		return this._currentAnimationClipIndex;
	});

	/**
	*获取当前精确时间，不包括重播时间
	*@return value 当前时间
	*/
	__getset(0,__proto,'currentPlayTime',function(){
		return this._currentTime+this._playStart;
	});

	/**
	*设置缓存播放速率,默认值为1.0,注意：修改此值会有计算开销。*
	*@return value 缓存播放速率。
	*/
	/**
	*获取缓存播放速率。*
	*@return 缓存播放速率。
	*/
	__getset(0,__proto,'cachePlayRate',function(){
		return this._cachePlayRate;
		},function(value){
		if (this._cachePlayRate!==value){
			this._cachePlayRate=value;
			if (this._templet)
				if (this._templet.loaded)
			this._computeFullKeyframeIndices();
			else
			this._templet.once(/*laya.events.Event.LOADED*/"loaded",this,this._onTempletLoadedComputeFullKeyframeIndices,[value,this._cacheFrameRate]);
		}
	});

	/**
	*设置默认帧率,每秒60帧,注意：修改此值会有计算开销。*
	*@return value 缓存帧率
	*/
	/**
	*获取默认帧率*
	*@return value 默认帧率
	*/
	__getset(0,__proto,'cacheFrameRate',function(){
		return this._cacheFrameRate;
		},function(value){
		if (this._cacheFrameRate!==value){
			this._cacheFrameRate=value;
			this._cacheFrameRateInterval=1000.0 / this._cacheFrameRate;
			if (this._templet)
				if (this._templet.loaded)
			this._computeFullKeyframeIndices();
			else
			this._templet.once(/*laya.events.Event.LOADED*/"loaded",this,this._onTempletLoadedComputeFullKeyframeIndices,[this._cachePlayRate,value]);
		}
	});

	/**
	*设置当前播放位置
	*@param value 当前时间
	*/
	__getset(0,__proto,'currentTime',null,function(value){
		if (this._currentAnimationClipIndex===-1 || !this._templet || !this._templet.loaded)
			return;
		if (value < this._playStart || value > this._playEnd)
			throw new Error("AnimationPlayer:value must large than playStartTime,small than playEndTime.");
		this._startUpdateLoopCount=Stat.loopCount;
		var cacheFrameInterval=this._cacheFrameRateInterval *this._cachePlayRate;
		this._currentTime=value;
		this._currentKeyframeIndex=Math.max(Math.floor(this.currentPlayTime / cacheFrameInterval),0);
		this._currentFrameTime=this._currentKeyframeIndex *cacheFrameInterval;
	});

	/**
	*设置是否暂停
	*@param value 是否暂停
	*/
	/**
	*获取当前是否暂停
	*@return 是否暂停
	*/
	__getset(0,__proto,'paused',function(){
		return this._paused;
		},function(value){
		this._paused=value;
		value && this.event(/*laya.events.Event.PAUSED*/"paused");
	});

	/**
	*获取缓存帧率间隔时间
	*@return 缓存帧率间隔时间
	*/
	__getset(0,__proto,'cacheFrameRateInterval',function(){
		return this._cacheFrameRateInterval;
	});

	/**
	*获取是否已销毁。
	*@return 是否已销毁。
	*/
	__getset(0,__proto,'destroyed',function(){
		return this._destroyed;
	});

	return AnimationPlayer;
})(EventDispatcher)


/**
*@private
*/
//class laya.ani.GraphicsAni extends laya.display.Graphics
var GraphicsAni=(function(_super){
	function GraphicsAni(){
		GraphicsAni.__super.call(this);
		if (Render.isConchNode){
			this["drawSkin"]=function (skin){
				skin.transform || (skin.transform=Matrix.EMPTY);
				/*__JS__ */this._addCmd([skin]);
				this.setSkinMesh&&this.setSkinMesh(skin._ps,skin.mVBData,skin.mEleNum,0,skin.mTexture,skin.transform);
			};
		}
	}

	__class(GraphicsAni,'laya.ani.GraphicsAni',_super);
	var __proto=GraphicsAni.prototype;
	/**
	*@private
	*画自定义蒙皮动画
	*@param skin
	*/
	__proto.drawSkin=function(skin){
		var arr=[skin];
		this._saveToCmd(Render._context._drawSkin,arr);
	}

	GraphicsAni.create=function(){
		var rs=GraphicsAni._caches.pop();
		return rs||new GraphicsAni();
	}

	GraphicsAni.recycle=function(graphics){
		graphics.clear();
		GraphicsAni._caches.push(graphics);
	}

	GraphicsAni._caches=[];
	return GraphicsAni;
})(Graphics)


/**
*@private
*Canvas版本的SkinMesh
*/
//class laya.ani.bone.canvasmesh.SkinMeshCanvas extends laya.ani.bone.canvasmesh.CanvasMeshRender
var SkinMeshCanvas=(function(_super){
	function SkinMeshCanvas(){
		SkinMeshCanvas.__super.call(this);
		this.mesh=new MeshData();
	}

	__class(SkinMeshCanvas,'laya.ani.bone.canvasmesh.SkinMeshCanvas',_super);
	var __proto=SkinMeshCanvas.prototype;
	__proto.init2=function(texture,vs,ps,verticles,uvs){
		if (this.transform){
			this.transform=null;
		};
		var _ps;
		if (ps){
			_ps=ps;
			}else {
			_ps=[];
			_ps.push(0,1,3,3,1,2);
		}
		this.mesh.texture=texture;
		this.mesh.indexes=_ps;
		this.mesh.vertices=verticles;
		this.mesh.uvs=uvs;
	}

	__proto.render=function(context,x,y){
		if(!this.mesh.texture)return;
		if(!this.transform){
			this.transform=SkinMeshCanvas._tempMatrix;
			this.transform.identity();
			this.transform.translate(x,y);
			this.renderToContext(context);
			this.transform.translate(-x,-y);
			this.transform=null;
			}else{
			this.transform.translate(x,y);
			this.renderToContext(context);
			this.transform.translate(-x,-y);
		}
	}

	__static(SkinMeshCanvas,
	['_tempMatrix',function(){return this._tempMatrix=new Matrix();}
	]);
	return SkinMeshCanvas;
})(CanvasMeshRender)


/**
*<code>AnimationTemplet</code> 类用于动画模板资源。
*/
//class laya.ani.AnimationTemplet extends laya.resource.Resource
var AnimationTemplet=(function(_super){
	function AnimationTemplet(){
		/**@private */
		//this._aniVersion=null;
		/**@private */
		this._aniMap={};
		/**@private */
		//this._publicExtData=null;
		/**@private */
		//this._useParent=false;
		/**@private */
		//this.unfixedCurrentFrameIndexes=null;
		/**@private */
		//this.unfixedCurrentTimes=null;
		/**@private */
		//this.unfixedKeyframes=null;
		/**@private */
		this.unfixedLastAniIndex=-1;
		/**@private */
		//this._aniClassName=null;
		/**@private */
		//this._animationDatasCache=null;
		AnimationTemplet.__super.call(this);
		this._anis=new Array;
	}

	__class(AnimationTemplet,'laya.ani.AnimationTemplet',_super);
	var __proto=AnimationTemplet.prototype;
	/**
	*@private
	*/
	__proto.parse=function(data){
		var reader=new Byte(data);
		this._aniVersion=reader.readUTFString();
		AnimationParser01.parse(this,reader);
	}

	/**
	*@private
	*/
	__proto._calculateKeyFrame=function(node,keyframeCount,keyframeDataCount){
		var keyFrames=node.keyFrame;
		keyFrames[keyframeCount]=keyFrames[0];
		for (var i=0;i < keyframeCount;i++){
			var keyFrame=keyFrames[i];
			keyFrame.nextData=(keyFrame.duration===0)? keyFrame.data :keyFrames[i+1].data;
		}
		keyFrames.length--;
	}

	/**
	*@inheritDoc
	*/
	__proto.onAsynLoaded=function(url,data,params){
		var reader=new Byte(data);
		this._aniVersion=reader.readUTFString();
		switch (this._aniVersion){
			case "LAYAANIMATION:02":
				AnimationParser02.parse(this,reader);
				break ;
			default :
				AnimationParser01.parse(this,reader);
			}
		this._endLoaded();
	}

	/**
	*@inheritDoc
	*/
	__proto.disposeResource=function(){
		this._aniVersion=null;
		this._anis=null;
		this._aniMap=null;
		this._publicExtData=null;
		this.unfixedCurrentFrameIndexes=null;
		this.unfixedCurrentTimes=null;
		this.unfixedKeyframes=null;
		this._aniClassName=null;
		this._animationDatasCache=null;
	}

	__proto.getAnimationCount=function(){
		return this._anis.length;
	}

	__proto.getAnimation=function(aniIndex){
		return this._anis[aniIndex];
	}

	__proto.getAniDuration=function(aniIndex){
		return this._anis[aniIndex].playTime;
	}

	__proto.getNodes=function(aniIndex){
		return this._anis[aniIndex].nodes;
	}

	__proto.getNodeIndexWithName=function(aniIndex,name){
		return this._anis[aniIndex].bone3DMap[name];
	}

	__proto.getNodeCount=function(aniIndex){
		return this._anis[aniIndex].nodes.length;
	}

	__proto.getTotalkeyframesLength=function(aniIndex){
		return this._anis[aniIndex].totalKeyframeDatasLength;
	}

	__proto.getPublicExtData=function(){
		return this._publicExtData;
	}

	__proto.getAnimationDataWithCache=function(key,cacheDatas,aniIndex,frameIndex){
		var aniDatas=cacheDatas[aniIndex];
		if (!aniDatas){
			return null;
			}else {
			var keyDatas=aniDatas[key];
			if (!keyDatas)
				return null;
			else {
				return keyDatas[frameIndex];
			}
		}
	}

	__proto.setAnimationDataWithCache=function(key,cacheDatas,aniIndex,frameIndex,data){
		var aniDatas=(cacheDatas[aniIndex])|| (cacheDatas[aniIndex]={});
		var aniDatasCache=(aniDatas[key])|| (aniDatas[key]=[]);
		aniDatasCache[frameIndex]=data;
	}

	__proto.getOriginalData=function(aniIndex,originalData,nodesFrameIndices,frameIndex,playCurTime){
		var oneAni=this._anis[aniIndex];
		var nodes=oneAni.nodes;
		var j=0;
		for (var i=0,n=nodes.length,outOfs=0;i < n;i++){
			var node=nodes[i];
			var key;
			key=node.keyFrame[nodesFrameIndices[i][frameIndex]];
			node.dataOffset=outOfs;
			var dt=playCurTime-key.startTime;
			var lerpType=node.lerpType;
			if (lerpType){
				switch (lerpType){
					case 0:
					case 1:
						for (j=0;j < node.keyframeWidth;)
						j+=node.interpolationMethod[j](node,j,originalData,outOfs+j,key.data,dt,null,key.duration,key.nextData);
						break ;
					case 2:;
						var interpolationData=key.interpolationData;
						var interDataLen=interpolationData.length;
						var dataIndex=0;
						for (j=0;j < interDataLen;){
							var type=interpolationData[j];
						switch (type){
							case 6:
								j+=AnimationTemplet.interpolation[type](node,dataIndex,originalData,outOfs+dataIndex,key.data,dt,null,key.duration,key.nextData,interpolationData,j+1);
								break ;
							case 7:
								j+=AnimationTemplet.interpolation[type](node,dataIndex,originalData,outOfs+dataIndex,key.data,dt,null,key.duration,key.nextData,interpolationData,j+1);
								break ;
							default :
								j+=AnimationTemplet.interpolation[type](node,dataIndex,originalData,outOfs+dataIndex,key.data,dt,null,key.duration,key.nextData);
							}
						dataIndex++;
					}
					break ;
				}
				}else {
				for (j=0;j < node.keyframeWidth;)
				j+=node.interpolationMethod[j](node,j,originalData,outOfs+j,key.data,dt,null,key.duration,key.nextData);
			}
			outOfs+=node.keyframeWidth;
		}
	}

	__proto.getNodesCurrentFrameIndex=function(aniIndex,playCurTime){
		var ani=this._anis[aniIndex];
		var nodes=ani.nodes;
		if (aniIndex!==this.unfixedLastAniIndex){
			this.unfixedCurrentFrameIndexes=new Uint32Array(nodes.length);
			this.unfixedCurrentTimes=new Float32Array(nodes.length);
			this.unfixedLastAniIndex=aniIndex;
		}
		for (var i=0,n=nodes.length,outOfs=0;i < n;i++){
			var node=nodes[i];
			if (playCurTime < this.unfixedCurrentTimes[i])
				this.unfixedCurrentFrameIndexes[i]=0;
			this.unfixedCurrentTimes[i]=playCurTime;
			while ((this.unfixedCurrentFrameIndexes[i] < node.keyFrame.length)){
				if (node.keyFrame[this.unfixedCurrentFrameIndexes[i]].startTime > this.unfixedCurrentTimes[i])
					break ;
				this.unfixedCurrentFrameIndexes[i]++;
			}
			this.unfixedCurrentFrameIndexes[i]--;
		}
		return this.unfixedCurrentFrameIndexes;
	}

	__proto.getOriginalDataUnfixedRate=function(aniIndex,originalData,playCurTime){
		var oneAni=this._anis[aniIndex];
		var nodes=oneAni.nodes;
		if (aniIndex!==this.unfixedLastAniIndex){
			this.unfixedCurrentFrameIndexes=new Uint32Array(nodes.length);
			this.unfixedCurrentTimes=new Float32Array(nodes.length);
			this.unfixedKeyframes=__newvec(nodes.length);
			this.unfixedLastAniIndex=aniIndex;
		};
		var j=0;
		for (var i=0,n=nodes.length,outOfs=0;i < n;i++){
			var node=nodes[i];
			if (playCurTime < this.unfixedCurrentTimes[i])
				this.unfixedCurrentFrameIndexes[i]=0;
			this.unfixedCurrentTimes[i]=playCurTime;
			while (this.unfixedCurrentFrameIndexes[i] < node.keyFrame.length){
				if (node.keyFrame[this.unfixedCurrentFrameIndexes[i]].startTime > this.unfixedCurrentTimes[i])
					break ;
				this.unfixedKeyframes[i]=node.keyFrame[this.unfixedCurrentFrameIndexes[i]];
				this.unfixedCurrentFrameIndexes[i]++;
			};
			var key=this.unfixedKeyframes[i];
			node.dataOffset=outOfs;
			var dt=playCurTime-key.startTime;
			var lerpType=node.lerpType;
			if (lerpType){
				switch (node.lerpType){
					case 0:
					case 1:
						for (j=0;j < node.keyframeWidth;)
						j+=node.interpolationMethod[j](node,j,originalData,outOfs+j,key.data,dt,null,key.duration,key.nextData);
						break ;
					case 2:;
						var interpolationData=key.interpolationData;
						var interDataLen=interpolationData.length;
						var dataIndex=0;
						for (j=0;j < interDataLen;){
							var type=interpolationData[j];
						switch (type){
							case 6:
								j+=AnimationTemplet.interpolation[type](node,dataIndex,originalData,outOfs+dataIndex,key.data,dt,null,key.duration,key.nextData,interpolationData,j+1);
								break ;
							case 7:
								j+=AnimationTemplet.interpolation[type](node,dataIndex,originalData,outOfs+dataIndex,key.data,dt,null,key.duration,key.nextData,interpolationData,j+1);
								break ;
							default :
								j+=AnimationTemplet.interpolation[type](node,dataIndex,originalData,outOfs+dataIndex,key.data,dt,null,key.duration,key.nextData);
							}
						dataIndex++;
					}
					break ;
				}
				}else {
				for (j=0;j < node.keyframeWidth;)
				j+=node.interpolationMethod[j](node,j,originalData,outOfs+j,key.data,dt,null,key.duration,key.nextData);
			}
			outOfs+=node.keyframeWidth;
		}
	}

	AnimationTemplet._LinearInterpolation_0=function(bone,index,out,outOfs,data,dt,dData,duration,nextData,interData){
		var amount=duration===0 ? 0 :dt / duration;
		out[outOfs]=(1.0-amount)*data[index]+amount *nextData[index];
		return 1;
	}

	AnimationTemplet._QuaternionInterpolation_1=function(bone,index,out,outOfs,data,dt,dData,duration,nextData,interData){
		var amount=duration===0 ? 0 :dt / duration;
		MathUtil.slerpQuaternionArray(data,index,nextData,index,amount,out,outOfs);
		return 4;
	}

	AnimationTemplet._AngleInterpolation_2=function(bone,index,out,outOfs,data,dt,dData,duration,nextData,interData){
		return 0;
	}

	AnimationTemplet._RadiansInterpolation_3=function(bone,index,out,outOfs,data,dt,dData,duration,nextData,interData){
		return 0;
	}

	AnimationTemplet._Matrix4x4Interpolation_4=function(bone,index,out,outOfs,data,dt,dData,duration,nextData,interData){
		for (var i=0;i < 16;i++,index++)
		out[outOfs+i]=data[index]+dt *dData[index];
		return 16;
	}

	AnimationTemplet._NoInterpolation_5=function(bone,index,out,outOfs,data,dt,dData,duration,nextData,interData){
		out[outOfs]=data[index];
		return 1;
	}

	AnimationTemplet._BezierInterpolation_6=function(bone,index,out,outOfs,data,dt,dData,duration,nextData,interData,offset){
		(offset===void 0)&& (offset=0);
		out[outOfs]=data[index]+(nextData[index]-data[index])*BezierLerp.getBezierRate(dt / duration,interData[offset],interData[offset+1],interData[offset+2],interData[offset+3]);
		return 5;
	}

	AnimationTemplet._BezierInterpolation_7=function(bone,index,out,outOfs,data,dt,dData,duration,nextData,interData,offset){
		(offset===void 0)&& (offset=0);
		out[outOfs]=interData[offset+4]+interData[offset+5] *BezierLerp.getBezierRate((dt *0.001+interData[offset+6])/ interData[offset+7],interData[offset],interData[offset+1],interData[offset+2],interData[offset+3]);
		return 9;
	}

	AnimationTemplet.load=function(url){
		return Laya.loader.create(url,null,null,AnimationTemplet);
	}

	AnimationTemplet.interpolation=[AnimationTemplet._LinearInterpolation_0,AnimationTemplet._QuaternionInterpolation_1,AnimationTemplet._AngleInterpolation_2,AnimationTemplet._RadiansInterpolation_3,AnimationTemplet._Matrix4x4Interpolation_4,AnimationTemplet._NoInterpolation_5,AnimationTemplet._BezierInterpolation_6,AnimationTemplet._BezierInterpolation_7];
	return AnimationTemplet;
})(Resource)


/**
*@private
*将mesh元素缓存到canvas中并进行绘制
*/
//class laya.ani.bone.canvasmesh.CacheAbleSkinMesh extends laya.ani.bone.canvasmesh.SkinMeshCanvas
var CacheAbleSkinMesh=(function(_super){
	function CacheAbleSkinMesh(){
		this.isCached=false;
		this.canvas=null;
		this.tex=null;
		this.rec=null;
		CacheAbleSkinMesh.__super.call(this);
	}

	__class(CacheAbleSkinMesh,'laya.ani.bone.canvasmesh.CacheAbleSkinMesh',_super);
	var __proto=CacheAbleSkinMesh.prototype;
	__proto.getCanvasPic=function(){
		var canvas=new HTMLCanvas("2D");
		var ctx=canvas.getContext('2d');
		this.rec=this.mesh.getBounds();
		debugger;
		canvas.size(this.rec.width,this.rec.height);
		var preTransform;
		preTransform=this.transform;
		this.transform=CacheAbleSkinMesh.tempMt;
		this.transform.identity();
		this.transform.translate(-this.rec.x,-this.rec.y);
		this.renderToContext(ctx);
		this.transform.translate(+this.rec.x,+this.rec.y);
		this.transform=preTransform;
		return new Texture(canvas);
	}

	__proto.render=function(context,x,y){
		if (!this.mesh.texture)return;
		if (!this.isCached){
			this.isCached=true;
			this.tex=this.getCanvasPic();
		}
		if(!this.transform){
			this.transform=SkinMeshCanvas._tempMatrix;
			this.transform.identity();
			this.transform.translate(x,y);
			this._renderTextureToContext(context);
			this.transform.translate(-x,-y);
			this.transform=null;
			}else{
			this.transform.translate(x,y);
			this._renderTextureToContext(context);
			this.transform.translate(-x,-y);
		}
	}

	__proto._renderTextureToContext=function(context){
		this.context=context.ctx || context;
		context.save();
		var texture;
		texture=this.tex;
		if (this.transform){
			var mt=this.transform;
			context.transform(mt.a,mt.b,mt.c,mt.d,mt.tx,mt.ty);
		}
		this.rec=this.mesh.getBounds();
		context.translate(this.rec.x,this.rec.y);
		context.drawTexture(texture,0,0,texture.width,texture.height,0,0);
		context.restore();
	}

	__static(CacheAbleSkinMesh,
	['tempMt',function(){return this.tempMt=new Matrix();}
	]);
	return CacheAbleSkinMesh;
})(SkinMeshCanvas)


/**
*@private
*简化mesh绘制，多顶点mesh改为四顶点mesh，只绘制矩形不绘制三角形
*/
//class laya.ani.bone.canvasmesh.SimpleSkinMeshCanvas extends laya.ani.bone.canvasmesh.SkinMeshCanvas
var SimpleSkinMeshCanvas=(function(_super){
	function SimpleSkinMeshCanvas(){
		/**
		*当前mesh数据是否可用
		*/
		this.cacheOK=false;
		/**
		*当前渲染数据是否可用
		*/
		this.cacheCmdOK=false;
		/**
		*transform参数缓存
		*/
		this.transformCmds=[];
		/**
		*drawImage参数缓存
		*/
		this.drawCmds=[]
		SimpleSkinMeshCanvas.__super.call(this);
		this.tempMesh=new MeshData();
	}

	__class(SimpleSkinMeshCanvas,'laya.ani.bone.canvasmesh.SimpleSkinMeshCanvas',_super);
	var __proto=SimpleSkinMeshCanvas.prototype;
	__proto.init2=function(texture,vs,ps,verticles,uvs){
		_super.prototype.init2.call(this,texture,vs,ps,verticles,uvs);
		this.cacheOK=false;
		this.cacheCmdOK=false;
		this.transformCmds.length=6;
		this.drawCmds.length=9;
	}

	__proto.renderToContext=function(context){
		this.context=context.ctx || context;
		if (this.mesh){
			if (this.mesh.uvs.length <=8){
				if (this.mode==0){
					this._renderWithIndexes(this.mesh);
				}
				else {
					this._renderNoIndexes(this.mesh);
				}
				return;
			}
			if (!this.cacheOK){
				this.tempMesh.texture=this.mesh.texture;
				this.tempMesh.uvs=this.mesh.texture.uv;
				this.tempMesh.vertices=MeshTools.solveMesh(this.mesh,this.tempMesh.vertices);
				this.cacheOK=true;
			}
			if (this.mode==0){
				this._renderWithIndexes(this.tempMesh);
			}
			else {
				this._renderNoIndexes(this.tempMesh);
			}
		}
	}

	__proto._renderWithIndexes=function(mesh){
		if(this.cacheCmdOK){
			this.renderByCache(mesh);
			return;
		};
		var indexes=mesh.indexes;
		var i=0,len=indexes.length;
		if (len > 1)
			len=1;
		for (i=0;i < len;i+=3){
			var index0=indexes[i] *2;
			var index1=indexes[i+1] *2;
			var index2=indexes[i+2] *2;
			this._renderDrawTriangle(mesh,index0,index1,index2);
		}
		this.cacheCmdOK=true;
	}

	__proto._renderDrawTriangle=function(mesh,index0,index1,index2){
		var context=this.context;
		var uvs=mesh.uvs;
		var vertices=mesh.vertices;
		var texture=mesh.texture;
		var source=texture.bitmap;
		var textureSource=source.source;
		var textureWidth=texture.width;
		var textureHeight=texture.height;
		var sourceWidth=source.width;
		var sourceHeight=source.height;
		var u0=NaN;
		var u1=NaN;
		var u2=NaN;
		var v0=NaN;
		var v1=NaN;
		var v2=NaN;
		if (mesh.useUvTransform){
			var ut=mesh.uvTransform;
			u0=((uvs[index0] *ut.a)+(uvs[index0+1] *ut.c)+ut.tx)*sourceWidth;
			u1=((uvs[index1] *ut.a)+(uvs[index1+1] *ut.c)+ut.tx)*sourceWidth;
			u2=((uvs[index2] *ut.a)+(uvs[index2+1] *ut.c)+ut.tx)*sourceWidth;
			v0=((uvs[index0] *ut.b)+(uvs[index0+1] *ut.d)+ut.ty)*sourceHeight;
			v1=((uvs[index1] *ut.b)+(uvs[index1+1] *ut.d)+ut.ty)*sourceHeight;
			v2=((uvs[index2] *ut.b)+(uvs[index2+1] *ut.d)+ut.ty)*sourceHeight;
		}
		else {
			u0=uvs[index0] *sourceWidth;
			u1=uvs[index1] *sourceWidth;
			u2=uvs[index2] *sourceWidth;
			v0=uvs[index0+1] *sourceHeight;
			v1=uvs[index1+1] *sourceHeight;
			v2=uvs[index2+1] *sourceHeight;
		};
		var x0=vertices[index0];
		var x1=vertices[index1];
		var x2=vertices[index2];
		var y0=vertices[index0+1];
		var y1=vertices[index1+1];
		var y2=vertices[index2+1];
		var delta=(u0 *v1)+(v0 *u2)+(u1 *v2)-(v1 *u2)-(v0 *u1)-(u0 *v2);
		var dDelta=1 / delta;
		var deltaA=(x0 *v1)+(v0 *x2)+(x1 *v2)-(v1 *x2)-(v0 *x1)-(x0 *v2);
		var deltaB=(u0 *x1)+(x0 *u2)+(u1 *x2)-(x1 *u2)-(x0 *u1)-(u0 *x2);
		var deltaC=(u0 *v1 *x2)+(v0 *x1 *u2)+(x0 *u1 *v2)-(x0 *v1 *u2)-(v0 *u1 *x2)-(u0 *x1 *v2);
		var deltaD=(y0 *v1)+(v0 *y2)+(y1 *v2)-(v1 *y2)-(v0 *y1)-(y0 *v2);
		var deltaE=(u0 *y1)+(y0 *u2)+(u1 *y2)-(y1 *u2)-(y0 *u1)-(u0 *y2);
		var deltaF=(u0 *v1 *y2)+(v0 *y1 *u2)+(y0 *u1 *v2)-(y0 *v1 *u2)-(v0 *u1 *y2)-(u0 *y1 *v2);
		this.transformCmds[0]=deltaA *dDelta;
		this.transformCmds[1]=deltaD *dDelta;
		this.transformCmds[2]=deltaB *dDelta;
		this.transformCmds[3]=deltaE *dDelta;
		this.transformCmds[4]=deltaC *dDelta;
		this.transformCmds[5]=deltaF *dDelta;
		this.drawCmds[0]=textureSource;
		this.drawCmds[1]=texture.uv[0] *sourceWidth;
		this.drawCmds[2]=texture.uv[1] *sourceHeight;
		this.drawCmds[3]=textureWidth;
		this.drawCmds[4]=textureHeight;
		this.drawCmds[5]=texture.uv[0] *sourceWidth;
		this.drawCmds[6]=texture.uv[1] *sourceHeight;
		this.drawCmds[7]=textureWidth;
		this.drawCmds[8]=textureHeight;
		context.save();
		if (this.transform){
			var mt=this.transform;
			context.transform(mt.a,mt.b,mt.c,mt.d,mt.tx,mt.ty);
		}
		context.transform.apply(context,this.transformCmds);
		context.drawImage.apply(context,this.drawCmds);
		context.restore();
	}

	/**
	*绘制缓存的命令
	*@param mesh
	*
	*/
	__proto.renderByCache=function(mesh){
		var context=this.context;
		context.save();
		if (this.transform){
			var mt=this.transform;
			context.transform(mt.a,mt.b,mt.c,mt.d,mt.tx,mt.ty);
		}
		context.transform.apply(context,this.transformCmds);
		context.drawImage.apply(context,this.drawCmds);
		context.restore();
	}

	return SimpleSkinMeshCanvas;
})(SkinMeshCanvas)


/**
*骨骼动画由<code>Templet</code>，<code>AnimationPlayer</code>，<code>Skeleton</code>三部分组成。
*/
//class laya.ani.bone.Skeleton extends laya.display.Sprite
var Skeleton=(function(_super){
	function Skeleton(templet,aniMode){
		this._templet=null;
		/**@private */
		this._player=null;
		/**@private */
		this._curOriginalData=null;
		//当前骨骼的偏移数据
		this._boneMatrixArray=[];
		//当前骨骼动画的最终结果数据
		this._lastTime=0;
		//上次的帧时间
		this._currAniName=null;
		this._currAniIndex=-1;
		this._pause=true;
		/**@private */
		this._aniClipIndex=-1;
		/**@private */
		this._clipIndex=-1;
		this._skinIndex=0;
		this._skinName="default";
		this._aniMode=0;
		//当前动画自己的缓冲区
		this._graphicsCache=null;
		this._boneSlotDic=null;
		this._bindBoneBoneSlotDic=null;
		this._boneSlotArray=null;
		this._index=-1;
		this._total=-1;
		this._indexControl=false;
		//加载路径
		this._aniPath=null;
		this._texturePath=null;
		this._complete=null;
		this._loadAniMode=0;
		this._yReverseMatrix=null;
		this._ikArr=null;
		this._tfArr=null;
		this._pathDic=null;
		this._rootBone=null;
		/**@private */
		this._boneList=null;
		/**@private */
		this._aniSectionDic=null;
		this._eventIndex=0;
		this._drawOrderIndex=0;
		this._drawOrder=null;
		this._lastAniClipIndex=-1;
		this._lastUpdateAniClipIndex=-1;
		Skeleton.__super.call(this);
		(aniMode===void 0)&& (aniMode=0);
		if (templet)this.init(templet,aniMode);
	}

	__class(Skeleton,'laya.ani.bone.Skeleton',_super);
	var __proto=Skeleton.prototype;
	/**
	*初始化动画
	*@param templet 模板
	*@param aniMode 动画模式
	*<table>
	*<tr><th>模式</th><th>描述</th></tr>
	*<tr>
	*<td>0</td> <td>使用模板缓冲的数据，模板缓冲的数据，不允许修改（内存开销小，计算开销小，不支持换装）</td>
	*</tr>
	*<tr>
	*<td>1</td> <td>使用动画自己的缓冲区，每个动画都会有自己的缓冲区，相当耗费内存 （内存开销大，计算开销小，支持换装）</td>
	*</tr>
	*<tr>
	*<td>2</td> <td>使用动态方式，去实时去画（内存开销小，计算开销大，支持换装,不建议使用）</td>
	*</tr>
	*</table>
	*/
	__proto.init=function(templet,aniMode){
		(aniMode===void 0)&& (aniMode=0);
		var i=0,n=0;
		if (aniMode==1){
			this._graphicsCache=[];
			for (i=0,n=templet.getAnimationCount();i < n;i++){
				this._graphicsCache.push([]);
			}
		}
		this._yReverseMatrix=templet.yReverseMatrix;
		this._aniMode=aniMode;
		this._templet=templet;
		this._player=new AnimationPlayer();
		this._player.cacheFrameRate=templet.rate;
		this._player.templet=templet;
		this._player.play();
		this._parseSrcBoneMatrix();
		this._boneList=templet.mBoneArr;
		this._rootBone=templet.mRootBone;
		this._aniSectionDic=templet.aniSectionDic;
		if (templet.ikArr.length > 0){
			this._ikArr=[];
			for (i=0,n=templet.ikArr.length;i < n;i++){
				this._ikArr.push(new IkConstraint(templet.ikArr[i],this._boneList));
			}
		}
		if (templet.pathArr.length > 0){
			var tPathData;
			var tPathConstraint;
			if (this._pathDic==null)this._pathDic={};
			var tBoneSlot;
			for (i=0,n=templet.pathArr.length;i < n;i++){
				tPathData=templet.pathArr[i];
				tPathConstraint=new PathConstraint(tPathData,this._boneList);
				tBoneSlot=this._boneSlotDic[tPathData.name];
				if (tBoneSlot){
					tPathConstraint=new PathConstraint(tPathData,this._boneList);
					tPathConstraint.target=tBoneSlot;
				}
				this._pathDic[tPathData.name]=tPathConstraint;
			}
		}
		if (templet.tfArr.length > 0){
			this._tfArr=[];
			for (i=0,n=templet.tfArr.length;i < n;i++){
				this._tfArr.push(new TfConstraint(templet.tfArr[i],this._boneList));
			}
		}
		if (templet.skinDataArray.length > 0){
			var tSkinData=this._templet.skinDataArray[this._skinIndex];
			this._skinName=tSkinData.name;
		}
		this._player.on(/*laya.events.Event.PLAYED*/"played",this,this._onPlay);
		this._player.on(/*laya.events.Event.STOPPED*/"stopped",this,this._onStop);
		this._player.on(/*laya.events.Event.PAUSED*/"paused",this,this._onPause);
	}

	/**
	*通过加载直接创建动画
	*@param path 要加载的动画文件路径
	*@param complete 加载完成的回调函数
	*@param aniMode 与<code>Skeleton.init</code>的<code>aniMode</code>作用一致
	*/
	__proto.load=function(path,complete,aniMode){
		(aniMode===void 0)&& (aniMode=0);
		this._aniPath=path;
		this._complete=complete;
		this._loadAniMode=aniMode;
		Laya.loader.load([{url:path,type:/*laya.net.Loader.BUFFER*/"arraybuffer"}],Handler.create(this,this._onLoaded));
	}

	/**
	*加载完成
	*/
	__proto._onLoaded=function(){
		var arraybuffer=Loader.getRes(this._aniPath);
		if (arraybuffer==null)return;
		if (Templet.TEMPLET_DICTIONARY==null){
			Templet.TEMPLET_DICTIONARY={};
		};
		var tFactory;
		tFactory=Templet.TEMPLET_DICTIONARY[this._aniPath];
		if (tFactory){
			if (tFactory.isParseFail){
				this._parseFail();
				}else {
				if (tFactory.isParserComplete){
					this._parseComplete();
					}else {
					tFactory.on(/*laya.events.Event.COMPLETE*/"complete",this,this._parseComplete);
					tFactory.on(/*laya.events.Event.ERROR*/"error",this,this._parseFail);
				}
			}
			}else {
			tFactory=new Templet();
			tFactory._setUrl(this._aniPath);
			Templet.TEMPLET_DICTIONARY[this._aniPath]=tFactory;
			tFactory.on(/*laya.events.Event.COMPLETE*/"complete",this,this._parseComplete);
			tFactory.on(/*laya.events.Event.ERROR*/"error",this,this._parseFail);
			tFactory.isParserComplete=false;
			tFactory.parseData(null,arraybuffer);
		}
	}

	/**
	*解析完成
	*/
	__proto._parseComplete=function(){
		var tTemple=Templet.TEMPLET_DICTIONARY[this._aniPath];
		if (tTemple){
			this.init(tTemple,this._loadAniMode);
			this.play(0,true);
		}
		this._complete && this._complete.runWith(this);
	}

	/**
	*解析失败
	*/
	__proto._parseFail=function(){
		console.log("[Error]:"+this._aniPath+"解析失败");
	}

	/**
	*传递PLAY事件
	*/
	__proto._onPlay=function(){
		this.event(/*laya.events.Event.PLAYED*/"played");
	}

	/**
	*传递STOP事件
	*/
	__proto._onStop=function(){
		var tEventData;
		var tEventAniArr=this._templet.eventAniArr;
		var tEventArr=tEventAniArr[this._aniClipIndex];
		if (tEventArr && this._eventIndex < tEventArr.length){
			for (;this._eventIndex < tEventArr.length;this._eventIndex++){
				tEventData=tEventArr[this._eventIndex];
				if (tEventData.time >=this._player.playStart && tEventData.time <=this._player.playEnd){
					this.event(/*laya.events.Event.LABEL*/"label",tEventData);
				}
			}
		}
		this._eventIndex=0;
		this._drawOrder=null;
		this.event(/*laya.events.Event.STOPPED*/"stopped");
	}

	/**
	*传递PAUSE事件
	*/
	__proto._onPause=function(){
		this.event(/*laya.events.Event.PAUSED*/"paused");
	}

	/**
	*创建骨骼的矩阵，保存每次计算的最终结果
	*/
	__proto._parseSrcBoneMatrix=function(){
		var i=0,n=0;
		n=this._templet.srcBoneMatrixArr.length;
		for (i=0;i < n;i++){
			this._boneMatrixArray.push(new Matrix());
		}
		if (this._aniMode==0){
			this._boneSlotDic=this._templet.boneSlotDic;
			this._bindBoneBoneSlotDic=this._templet.bindBoneBoneSlotDic;
			this._boneSlotArray=this._templet.boneSlotArray;
			}else {
			if (this._boneSlotDic==null)this._boneSlotDic={};
			if (this._bindBoneBoneSlotDic==null)this._bindBoneBoneSlotDic={};
			if (this._boneSlotArray==null)this._boneSlotArray=[];
			var tArr=this._templet.boneSlotArray;
			var tBS;
			var tBSArr;
			for (i=0,n=tArr.length;i < n;i++){
				tBS=tArr[i];
				tBSArr=this._bindBoneBoneSlotDic[tBS.parent];
				if (tBSArr==null){
					this._bindBoneBoneSlotDic[tBS.parent]=tBSArr=[];
				}
				this._boneSlotDic[tBS.name]=tBS=tBS.copy();
				tBSArr.push(tBS);
				this._boneSlotArray.push(tBS);
			}
		}
	}

	__proto._emitMissedEvents=function(startTime,endTime,startIndex){
		(startIndex===void 0)&& (startIndex=0);
		var tEventAniArr=this._templet.eventAniArr;
		var tEventArr=tEventAniArr[this._player.currentAnimationClipIndex];
		if (tEventArr){
			var i=0,len=0;
			var tEventData;
			len=tEventArr.length;
			for (i=startIndex;i < len;i++){
				tEventData=tEventArr[i];
				if (tEventData.time >=this._player.playStart && tEventData.time <=this._player.playEnd){
					this.event(/*laya.events.Event.LABEL*/"label",tEventData);
				}
			}
		}
	}

	/**
	*更新动画
	*@param autoKey true为正常更新，false为index手动更新
	*/
	__proto._update=function(autoKey){
		(autoKey===void 0)&& (autoKey=true);
		if (this._pause)return;
		if (autoKey && this._indexControl){
			return;
		};
		var tCurrTime=this.timer.currTimer;
		var preIndex=this._player.currentKeyframeIndex;
		var dTime=tCurrTime-this._lastTime;
		if (autoKey){
			this._player._update(dTime);
			}else {
			preIndex=-1;
		}
		this._lastTime=tCurrTime;
		if (!this._player)return;
		this._index=this._clipIndex=this._player.currentKeyframeIndex;
		if (this._index < 0)return;
		if (dTime > 0 && this._clipIndex==preIndex && this._lastUpdateAniClipIndex==this._aniClipIndex){
			return;
		}
		this._lastUpdateAniClipIndex=this._aniClipIndex;
		if (preIndex > this._clipIndex && this._eventIndex !=0){
			this._emitMissedEvents(this._player.playStart,this._player.playEnd,this._eventIndex);
			this._eventIndex=0;
		};
		var tEventData;
		var tEventAniArr=this._templet.eventAniArr;
		var tEventArr=tEventAniArr[this._aniClipIndex];
		if (tEventArr && this._eventIndex < tEventArr.length){
			tEventData=tEventArr[this._eventIndex];
			if (tEventData.time >=this._player.playStart && tEventData.time <=this._player.playEnd){
				if (this._player.currentPlayTime >=tEventData.time){
					this.event(/*laya.events.Event.LABEL*/"label",tEventData);
					this._eventIndex++;
				}
				}else {
				this._eventIndex++;
			}
		};
		var tGraphics;
		if (this._aniMode==0){
			tGraphics=this._templet.getGrahicsDataWithCache(this._aniClipIndex,this._clipIndex);
			if (tGraphics){
				if (this.graphics !=tGraphics){
					this.graphics=tGraphics;
				}
				return;
				}else {
				var i=0,minIndex=0;
				minIndex=this._clipIndex;
				while ((!this._templet.getGrahicsDataWithCache(this._aniClipIndex,minIndex-1))&& (minIndex > 0)){
					minIndex--;
				}
				if (minIndex < this._clipIndex){
					for (i=minIndex;i < this._clipIndex;i++){
						this._createGraphics(i);
					}
				}
			}
			}else if (this._aniMode==1){
			tGraphics=this._getGrahicsDataWithCache(this._aniClipIndex,this._clipIndex);
			if (tGraphics){
				if (this.graphics !=tGraphics){
					this.graphics=tGraphics;
				}
				return;
				}else {
				minIndex=this._clipIndex;
				while ((!this._getGrahicsDataWithCache(this._aniClipIndex,minIndex-1))&& (minIndex > 0)){
					minIndex--;
				}
				if (minIndex < this._clipIndex){
					for (i=minIndex;i < this._clipIndex;i++){
						this._createGraphics(i);
					}
				}
			}
		}
		this._createGraphics();
	}

	/**
	*@private
	*创建grahics图像
	*/
	__proto._createGraphics=function(_clipIndex){
		(_clipIndex===void 0)&& (_clipIndex=-1);
		if (_clipIndex==-1)_clipIndex=this._clipIndex;
		var curTime=_clipIndex *this._player.cacheFrameRateInterval;
		var tDrawOrderData;
		var tDrawOrderAniArr=this._templet.drawOrderAniArr;
		var tDrawOrderArr=tDrawOrderAniArr[this._aniClipIndex];
		if (tDrawOrderArr && tDrawOrderArr.length > 0){
			this._drawOrderIndex=0;
			tDrawOrderData=tDrawOrderArr[this._drawOrderIndex];
			while (curTime >=tDrawOrderData.time){
				this._drawOrder=tDrawOrderData.drawOrder;
				this._drawOrderIndex++;
				if (this._drawOrderIndex >=tDrawOrderArr.length){
					break ;
				}
				tDrawOrderData=tDrawOrderArr[this._drawOrderIndex];
			}
		};
		var tGraphics;
		if (this._aniMode==0 || this._aniMode==1){
			this.graphics=GraphicsAni.create();
			}else {
			if ((this.graphics instanceof laya.ani.GraphicsAni )){
				this.graphics.clear();
				}else {
				this.graphics=GraphicsAni.create();
			}
		}
		tGraphics=this.graphics;
		var bones=this._templet.getNodes(this._aniClipIndex);
		this._templet.getOriginalData(this._aniClipIndex,this._curOriginalData,this._player._fullFrames[this._aniClipIndex],_clipIndex,curTime);
		var tSectionArr=this._aniSectionDic[this._aniClipIndex];
		var tParentMatrix;
		var tStartIndex=0;
		var i=0,j=0,k=0,n=0;
		var tDBBoneSlot;
		var tDBBoneSlotArr;
		var tParentTransform;
		var tSrcBone;
		var boneCount=this._templet.srcBoneMatrixArr.length;
		for (i=0,n=tSectionArr[0];i < boneCount;i++){
			tSrcBone=this._boneList[i];
			tParentTransform=this._templet.srcBoneMatrixArr[i];
			tSrcBone.resultTransform.scX=tParentTransform.scX *this._curOriginalData[tStartIndex++];
			tSrcBone.resultTransform.skX=tParentTransform.skX+this._curOriginalData[tStartIndex++];
			tSrcBone.resultTransform.skY=tParentTransform.skY+this._curOriginalData[tStartIndex++];
			tSrcBone.resultTransform.scY=tParentTransform.scY *this._curOriginalData[tStartIndex++];
			tSrcBone.resultTransform.x=tParentTransform.x+this._curOriginalData[tStartIndex++];
			tSrcBone.resultTransform.y=tParentTransform.y+this._curOriginalData[tStartIndex++];
			if (this._templet.tMatrixDataLen===8){
				tSrcBone.resultTransform.skewX=tParentTransform.skewX+this._curOriginalData[tStartIndex++];
				tSrcBone.resultTransform.skewY=tParentTransform.skewY+this._curOriginalData[tStartIndex++];
			}
		};
		var tSlotDic={};
		var tSlotAlphaDic={};
		var tBoneData;
		for (n+=tSectionArr[1];i < n;i++){
			tBoneData=bones[i];
			tSlotDic[tBoneData.name]=this._curOriginalData[tStartIndex++];
			tSlotAlphaDic[tBoneData.name]=this._curOriginalData[tStartIndex++];
			this._curOriginalData[tStartIndex++];
			this._curOriginalData[tStartIndex++];
			this._curOriginalData[tStartIndex++];
			this._curOriginalData[tStartIndex++];
		};
		var tBendDirectionDic={};
		var tMixDic={};
		for (n+=tSectionArr[2];i < n;i++){
			tBoneData=bones[i];
			tBendDirectionDic[tBoneData.name]=this._curOriginalData[tStartIndex++];
			tMixDic[tBoneData.name]=this._curOriginalData[tStartIndex++];
			this._curOriginalData[tStartIndex++];
			this._curOriginalData[tStartIndex++];
			this._curOriginalData[tStartIndex++];
			this._curOriginalData[tStartIndex++];
		}
		if (this._pathDic){
			var tPathConstraint;
			for (n+=tSectionArr[3];i < n;i++){
				tBoneData=bones[i];
				tPathConstraint=this._pathDic[tBoneData.name];
				if (tPathConstraint){
					var tByte=new Byte(tBoneData.extenData);
					switch (tByte.getByte()){
						case 1:
							tPathConstraint.position=this._curOriginalData[tStartIndex++];
							break ;
						case 2:
							tPathConstraint.spacing=this._curOriginalData[tStartIndex++];
							break ;
						case 3:
							tPathConstraint.rotateMix=this._curOriginalData[tStartIndex++];
							tPathConstraint.translateMix=this._curOriginalData[tStartIndex++];
							break ;
						}
				}
			}
		}
		if (this._yReverseMatrix){
			this._rootBone.update(this._yReverseMatrix);
			}else {
			this._rootBone.update(Matrix.TEMP.identity());
		}
		if (this._ikArr){
			var tIkConstraint;
			for (i=0,n=this._ikArr.length;i < n;i++){
				tIkConstraint=this._ikArr[i];
				if (tBendDirectionDic.hasOwnProperty(tIkConstraint.name)){
					tIkConstraint.bendDirection=tBendDirectionDic[tIkConstraint.name];
				}
				if (tMixDic.hasOwnProperty(tIkConstraint.name)){
					tIkConstraint.mix=tMixDic[tIkConstraint.name]
				}
				tIkConstraint.apply();
			}
		}
		if (this._pathDic){
			for (var tPathStr in this._pathDic){
				tPathConstraint=this._pathDic[tPathStr];
				tPathConstraint.apply(this._boneList,tGraphics);
			}
		}
		if (this._tfArr){
			var tTfConstraint;
			for (i=0,k=this._tfArr.length;i < k;i++){
				tTfConstraint=this._tfArr[i];
				tTfConstraint.apply();
			}
		}
		for (i=0,k=this._boneList.length;i < k;i++){
			tSrcBone=this._boneList[i];
			tDBBoneSlotArr=this._bindBoneBoneSlotDic[tSrcBone.name];
			tSrcBone.resultMatrix.copyTo(this._boneMatrixArray[i]);
			if (tDBBoneSlotArr){
				for (j=0,n=tDBBoneSlotArr.length;j < n;j++){
					tDBBoneSlot=tDBBoneSlotArr[j];
					if (tDBBoneSlot){
						tDBBoneSlot.setParentMatrix(tSrcBone.resultMatrix);
					}
				}
			}
		};
		var tDeformDic={};
		var tDeformAniArr=this._templet.deformAniArr;
		var tDeformAniData;
		var tDeformSlotData;
		var tDeformSlotDisplayData;
		if (tDeformAniArr && tDeformAniArr.length > 0){
			if (this._lastAniClipIndex !=this._aniClipIndex){
				this._lastAniClipIndex=this._aniClipIndex;
				for (i=0,n=this._boneSlotArray.length;i < n;i++){
					tDBBoneSlot=this._boneSlotArray[i];
					tDBBoneSlot.deformData=null;
				}
			};
			var tSkinDeformAni=tDeformAniArr[this._aniClipIndex];
			tDeformAniData=(tSkinDeformAni["default"]);
			this._setDeform(tDeformAniData,tDeformDic,this._boneSlotArray,curTime);
			var tSkin;
			for (tSkin in tSkinDeformAni){
				if (tSkin !="default" && tSkin !=this._skinName){
					tDeformAniData=tSkinDeformAni [tSkin];
					this._setDeform(tDeformAniData,tDeformDic,this._boneSlotArray,curTime);
				}
			}
			tDeformAniData=(tSkinDeformAni[this._skinName]);
			this._setDeform(tDeformAniData,tDeformDic,this._boneSlotArray,curTime);
		};
		var tSlotData2;
		var tSlotData3;
		var tObject;
		if (this._drawOrder){
			for (i=0,n=this._drawOrder.length;i < n;i++){
				tDBBoneSlot=this._boneSlotArray[this._drawOrder[i]];
				tSlotData2=tSlotDic[tDBBoneSlot.name];
				tSlotData3=tSlotAlphaDic[tDBBoneSlot.name];
				if (!isNaN(tSlotData3)){
					tGraphics.save();
					tGraphics.alpha(tSlotData3);
				}
				if (!isNaN(tSlotData2)&& tSlotData2 !=-2){
					if (this._templet.attachmentNames){
						tDBBoneSlot.showDisplayByName(this._templet.attachmentNames[tSlotData2]);
						}else {
						tDBBoneSlot.showDisplayByIndex(tSlotData2);
					}
				}
				if (tDeformDic[this._drawOrder[i]]){
					tObject=tDeformDic[this._drawOrder[i]];
					if (tDBBoneSlot.currDisplayData && tObject[tDBBoneSlot.currDisplayData.attachmentName]){
						tDBBoneSlot.deformData=tObject[tDBBoneSlot.currDisplayData.attachmentName];
						}else {
						tDBBoneSlot.deformData=null;
					}
					}else {
					tDBBoneSlot.deformData=null;
				}
				if (!isNaN(tSlotData3)){
					tDBBoneSlot.draw(tGraphics,this._boneMatrixArray,this._aniMode==2,tSlotData3);
					}else {
					tDBBoneSlot.draw(tGraphics,this._boneMatrixArray,this._aniMode==2);
				}
				if (!isNaN(tSlotData3)){
					tGraphics.restore();
				}
			}
			}else {
			for (i=0,n=this._boneSlotArray.length;i < n;i++){
				tDBBoneSlot=this._boneSlotArray[i];
				tSlotData2=tSlotDic[tDBBoneSlot.name];
				tSlotData3=tSlotAlphaDic[tDBBoneSlot.name];
				if (!isNaN(tSlotData3)){
					tGraphics.save();
					tGraphics.alpha(tSlotData3);
				}
				if (!isNaN(tSlotData2)&& tSlotData2 !=-2){
					if (this._templet.attachmentNames){
						tDBBoneSlot.showDisplayByName(this._templet.attachmentNames[tSlotData2]);
						}else {
						tDBBoneSlot.showDisplayByIndex(tSlotData2);
					}
				}
				if (tDeformDic[i]){
					tObject=tDeformDic[i];
					if (tDBBoneSlot.currDisplayData && tObject[tDBBoneSlot.currDisplayData.attachmentName]){
						tDBBoneSlot.deformData=tObject[tDBBoneSlot.currDisplayData.attachmentName];
						}else {
						tDBBoneSlot.deformData=null;
					}
					}else {
					tDBBoneSlot.deformData=null;
				}
				if (!isNaN(tSlotData3)){
					tDBBoneSlot.draw(tGraphics,this._boneMatrixArray,this._aniMode==2,tSlotData3);
					}else {
					tDBBoneSlot.draw(tGraphics,this._boneMatrixArray,this._aniMode==2);
				}
				if (!isNaN(tSlotData3)){
					tGraphics.restore();
				}
			}
		}
		if (this._aniMode==0){
			this._templet.setGrahicsDataWithCache(this._aniClipIndex,_clipIndex,tGraphics);
			}else if (this._aniMode==1){
			this._setGrahicsDataWithCache(this._aniClipIndex,_clipIndex,tGraphics);
		}
	}

	/**
	*设置deform数据
	*@param tDeformAniData
	*@param tDeformDic
	*@param _boneSlotArray
	*@param curTime
	*/
	__proto._setDeform=function(tDeformAniData,tDeformDic,_boneSlotArray,curTime){
		if (!tDeformAniData)return;
		var tDeformSlotData;
		var tDeformSlotDisplayData;
		var tDBBoneSlot;
		var i=0,n=0,j=0;
		if (tDeformAniData){
			for (i=0,n=tDeformAniData.deformSlotDataList.length;i < n;i++){
				tDeformSlotData=tDeformAniData.deformSlotDataList[i];
				for (j=0;j < tDeformSlotData.deformSlotDisplayList.length;j++){
					tDeformSlotDisplayData=tDeformSlotData.deformSlotDisplayList[j];
					tDBBoneSlot=_boneSlotArray[tDeformSlotDisplayData.slotIndex];
					tDeformSlotDisplayData.apply(curTime,tDBBoneSlot);
					if (!tDeformDic[tDeformSlotDisplayData.slotIndex]){
						tDeformDic[tDeformSlotDisplayData.slotIndex]={};
					}
					tDeformDic[tDeformSlotDisplayData.slotIndex][tDeformSlotDisplayData.attachment]=tDeformSlotDisplayData.deformData;
				}
			}
		}
	}

	/**
	*得到当前动画的数量
	*@return 当前动画的数量
	*/
	__proto.getAnimNum=function(){
		return this._templet.getAnimationCount();
	}

	/**
	*得到指定动画的名字
	*@param index 动画的索引
	*/
	__proto.getAniNameByIndex=function(index){
		return this._templet.getAniNameByIndex(index);
	}

	/**
	*通过名字得到插槽的引用
	*@param name 动画的名字
	*@return 插槽的引用
	*/
	__proto.getSlotByName=function(name){
		return this._boneSlotDic[name];
	}

	/**
	*通过名字显示一套皮肤
	*@param name 皮肤的名字
	*@param freshSlotIndex 是否将插槽纹理重置到初始化状态
	*/
	__proto.showSkinByName=function(name,freshSlotIndex){
		(freshSlotIndex===void 0)&& (freshSlotIndex=true);
		this.showSkinByIndex(this._templet.getSkinIndexByName(name),freshSlotIndex);
	}

	/**
	*通过索引显示一套皮肤
	*@param skinIndex 皮肤索引
	*@param freshSlotIndex 是否将插槽纹理重置到初始化状态
	*/
	__proto.showSkinByIndex=function(skinIndex,freshSlotIndex){
		(freshSlotIndex===void 0)&& (freshSlotIndex=true);
		for (var i=0;i < this._boneSlotArray.length;i++){
			(this._boneSlotArray [i]).showSlotData(null,freshSlotIndex);
		}
		if (this._templet.showSkinByIndex(this._boneSlotDic,skinIndex,freshSlotIndex)){
			var tSkinData=this._templet.skinDataArray[skinIndex];
			this._skinIndex=skinIndex;
			this._skinName=tSkinData.name;
		}
		this._clearCache();
	}

	/**
	*设置某插槽的皮肤
	*@param slotName 插槽名称
	*@param index 插糟皮肤的索引
	*/
	__proto.showSlotSkinByIndex=function(slotName,index){
		if (this._aniMode==0)return;
		var tBoneSlot=this.getSlotByName(slotName);
		if (tBoneSlot){
			tBoneSlot.showDisplayByIndex(index);
		}
		this._clearCache();
	}

	/**
	*设置某插槽的皮肤
	*@param slotName 插槽名称
	*@param name 皮肤名称
	*/
	__proto.showSlotSkinByName=function(slotName,name){
		if (this._aniMode==0)return;
		var tBoneSlot=this.getSlotByName(slotName);
		if (tBoneSlot){
			tBoneSlot.showDisplayByName(name);
		}
		this._clearCache();
	}

	/**
	*替换插槽贴图名
	*@param slotName 插槽名称
	*@param oldName 要替换的贴图名
	*@param newName 替换后的贴图名
	*/
	__proto.replaceSlotSkinName=function(slotName,oldName,newName){
		if (this._aniMode==0)return;
		var tBoneSlot=this.getSlotByName(slotName);
		if (tBoneSlot){
			tBoneSlot.replaceDisplayByName(oldName,newName);
		}
		this._clearCache();
	}

	/**
	*替换插槽的贴图索引
	*@param slotName 插槽名称
	*@param oldIndex 要替换的索引
	*@param newIndex 替换后的索引
	*/
	__proto.replaceSlotSkinByIndex=function(slotName,oldIndex,newIndex){
		if (this._aniMode==0)return;
		var tBoneSlot=this.getSlotByName(slotName);
		if (tBoneSlot){
			tBoneSlot.replaceDisplayByIndex(oldIndex,newIndex);
		}
		this._clearCache();
	}

	/**
	*设置自定义皮肤
	*@param name 插糟的名字
	*@param texture 自定义的纹理
	*/
	__proto.setSlotSkin=function(slotName,texture){
		if (this._aniMode==0)return;
		var tBoneSlot=this.getSlotByName(slotName);
		if (tBoneSlot){
			tBoneSlot.replaceSkin(texture);
		}
		this._clearCache();
	}

	/**
	*换装的时候，需要清一下缓冲区
	*/
	__proto._clearCache=function(){
		if (this._aniMode==1){
			for (var i=0,n=this._graphicsCache.length;i < n;i++){
				for (var j=0,len=this._graphicsCache[i].length;j < len;j++){
					var gp=this._graphicsCache[i][j];
					if (gp !=this.graphics){
						GraphicsAni.recycle(gp);
					}
				}
				this._graphicsCache[i].length=0;
			}
		}
	}

	/**
	*播放动画
	*
	*@param nameOrIndex 动画名字或者索引
	*@param loop 是否循环播放
	*@param force false,如果要播的动画跟上一个相同就不生效,true,强制生效
	*@param start 起始时间
	*@param end 结束时间
	*@param freshSkin 是否刷新皮肤数据
	*/
	__proto.play=function(nameOrIndex,loop,force,start,end,freshSkin){
		(force===void 0)&& (force=true);
		(start===void 0)&& (start=0);
		(end===void 0)&& (end=0);
		(freshSkin===void 0)&& (freshSkin=true);
		this._indexControl=false;
		var index=-1;
		var duration=NaN;
		if (loop){
			duration=2147483647;
			}else {
			duration=0;
		}
		if ((typeof nameOrIndex=='string')){
			for (var i=0,n=this._templet.getAnimationCount();i < n;i++){
				var animation=this._templet.getAnimation(i);
				if (animation && nameOrIndex==animation.name){
					index=i;
					break ;
				}
			}
			}else {
			index=nameOrIndex;
		}
		if (index >-1 && index < this.getAnimNum()){
			this._aniClipIndex=index;
			if (force || this._pause || this._currAniIndex !=index){
				this._currAniIndex=index;
				this._curOriginalData=new Float32Array(this._templet.getTotalkeyframesLength(index));
				this._drawOrder=null;
				this._eventIndex=0;
				this._player.play(index,this._player.playbackRate,duration,start,end);
				if (freshSkin)
					this._templet.showSkinByIndex(this._boneSlotDic,this._skinIndex);
				if (this._pause){
					this._pause=false;
					this._lastTime=Browser.now();
					this.timer.frameLoop(1,this,this._update,null,true);
				}
				this._update();
			}
		}
	}

	/**
	*停止动画
	*/
	__proto.stop=function(){
		if (!this._pause){
			this._pause=true;
			if (this._player){
				this._player.stop(true);
			}
			this.timer.clear(this,this._update);
		}
	}

	/**
	*设置动画播放速率
	*@param value 1为标准速率
	*/
	__proto.playbackRate=function(value){
		if (this._player){
			this._player.playbackRate=value;
		}
	}

	/**
	*暂停动画的播放
	*/
	__proto.paused=function(){
		if (!this._pause){
			this._pause=true;
			if (this._player){
				this._player.paused=true;
			}
			this.timer.clear(this,this._update);
		}
	}

	/**
	*恢复动画的播放
	*/
	__proto.resume=function(){
		this._indexControl=false;
		if (this._pause){
			this._pause=false;
			if (this._player){
				this._player.paused=false;
			}
			this._lastTime=Browser.now();
			this.timer.frameLoop(1,this,this._update,null,true);
		}
	}

	/**
	*@private
	*得到缓冲数据
	*@param aniIndex
	*@param frameIndex
	*@return
	*/
	__proto._getGrahicsDataWithCache=function(aniIndex,frameIndex){
		return this._graphicsCache[aniIndex][frameIndex];
	}

	/**
	*@private
	*保存缓冲grahpics
	*@param aniIndex
	*@param frameIndex
	*@param graphics
	*/
	__proto._setGrahicsDataWithCache=function(aniIndex,frameIndex,graphics){
		this._graphicsCache[aniIndex][frameIndex]=graphics;
	}

	/**
	*销毁当前动画
	*/
	__proto.destroy=function(destroyChild){
		(destroyChild===void 0)&& (destroyChild=true);
		_super.prototype.destroy.call(this,destroyChild);
		this._templet=null;
		if (this._player)this._player.offAll();
		this._player=null;
		this._curOriginalData=null;
		this._boneMatrixArray.length=0;
		this._lastTime=0;
		this.timer.clear(this,this._update);
	}

	/**
	*设置动画路径
	*/
	/**
	*得到资源的URL
	*/
	__getset(0,__proto,'url',function(){
		return this._aniPath;
		},function(path){
		this.load(path);
	});

	/**
	*@private
	*设置帧索引
	*/
	/**
	*@private
	*得到帧索引
	*/
	__getset(0,__proto,'index',function(){
		return this._index;
		},function(value){
		if (this.player){
			this._index=value;
			this._player.currentTime=this._index *1000 / this._player.cacheFrameRate;
			this._indexControl=true;
			this._update(false);
		}
	});

	/**
	*得到总帧数据
	*/
	__getset(0,__proto,'total',function(){
		if (this._templet && this._player){
			this._total=Math.floor(this._templet.getAniDuration(this._player.currentAnimationClipIndex)/ 1000 *this._player.cacheFrameRate);
			}else {
			this._total=-1;
		}
		return this._total;
	});

	/**
	*得到动画模板的引用
	*/
	__getset(0,__proto,'templet',function(){
		return this._templet;
	});

	/**
	*得到播放器的引用
	*/
	__getset(0,__proto,'player',function(){
		return this._player;
	});

	Skeleton.useSimpleMeshInCanvas=false;
	return Skeleton;
})(Sprite)


/**
*<p> <code>MovieClip</code> 用于播放经过工具处理后的 swf 动画。</p>
*/
//class laya.ani.swf.MovieClip extends laya.display.Sprite
var MovieClip=(function(_super){
	function MovieClip(parentMovieClip){
		/**@private 数据起始位置。*/
		this._start=0;
		/**@private 当前位置。*/
		this._Pos=0;
		/**@private 数据。*/
		this._data=null;
		/**@private */
		this._curIndex=0;
		/**@private */
		this._preIndex=0;
		/**@private */
		this._playIndex=0;
		/**@private */
		this._playing=false;
		/**@private */
		this._ended=true;
		/**@private 总帧数。*/
		this._count=0;
		/**@private id_data起始位置表*/
		this._ids=null;
		/**@private */
		this._loadedImage={};
		/**@private id_实例表*/
		this._idOfSprite=null;
		/**@private 父mc*/
		this._parentMovieClip=null;
		/**@private 需要更新的movieClip表*/
		this._movieClipList=null;
		/**@private */
		this._labels=null;
		/**资源根目录。*/
		this.basePath=null;
		/**@private */
		this._atlasPath=null;
		/**@private */
		this._url=null;
		/**@private */
		this._isRoot=false;
		/**@private */
		this._completeHandler=null;
		/**@private */
		this._endFrame=-1;
		/**播放间隔(单位：毫秒)。*/
		this.interval=30;
		/**是否循环播放 */
		this.loop=false;
		MovieClip.__super.call(this);
		this._ids={};
		this._idOfSprite=[];
		this._reset();
		this._playing=false;
		this._parentMovieClip=parentMovieClip;
		if (!parentMovieClip){
			this._movieClipList=[this];
			this._isRoot=true;
			this._setUpNoticeType(/*laya.display.Node.NOTICE_DISPLAY*/0x1);
			}else {
			this._isRoot=false;
			this._movieClipList=parentMovieClip._movieClipList;
			this._movieClipList.push(this);
		}
	}

	__class(MovieClip,'laya.ani.swf.MovieClip',_super);
	var __proto=MovieClip.prototype;
	/**
	*<p>销毁此对象。以及销毁引用的Texture</p>
	*@param destroyChild 是否同时销毁子节点，若值为true,则销毁子节点，否则不销毁子节点。
	*/
	__proto.destroy=function(destroyChild){
		(destroyChild===void 0)&& (destroyChild=true);
		this._clear();
		_super.prototype.destroy.call(this,destroyChild);
	}

	/**@private */
	__proto._setDisplay=function(value){
		_super.prototype._setDisplay.call(this,value);
		if (this._isRoot){
			this._$3__onDisplay(value);
		}
	}

	/**@private */
	__proto._$3__onDisplay=function(value){
		if (value)this.timer.loop(this.interval,this,this.updates,null,true);
		else this.timer.clear(this,this.updates);
	}

	/**@private 更新时间轴*/
	__proto.updates=function(){
		if (this._parentMovieClip)return;
		var i=0,len=0;
		len=this._movieClipList.length;
		for (i=0;i < len;i++){
			this._movieClipList[i]&&this._movieClipList[i]._update();
		}
	}

	/**
	*增加一个标签到index帧上，播放到此index后会派发label事件
	*@param label 标签名称
	*@param index 索引位置
	*/
	__proto.addLabel=function(label,index){
		if (!this._labels)this._labels={};
		this._labels[index]=label;
	}

	/**
	*删除某个标签
	*@param label 标签名字，如果label为空，则删除所有Label
	*/
	__proto.removeLabel=function(label){
		if (!label)this._labels=null;
		else if (!this._labels){
			for (var name in this._labels){
				if (this._labels[name]===label){
					delete this._labels[name];
					break ;
				}
			}
		}
	}

	/**
	*@private
	*动画的帧更新处理函数。
	*/
	__proto._update=function(){
		if (!this._data)return;
		if (!this._playing)return;
		this._playIndex++;
		if (this._playIndex >=this._count){
			if (!this.loop){
				this._playIndex--;
				this.stop();
				return;
			}
			this._playIndex=0;
		}
		this._parse(this._playIndex);
		if (this._labels && this._labels[this._playIndex])this.event(/*laya.events.Event.LABEL*/"label",this._labels[this._playIndex]);
		if (this._endFrame!=-1&&this._endFrame==this._playIndex){
			this._endFrame=-1;
			if (this._completeHandler !=null){
				var handler=this._completeHandler;
				this._completeHandler=null;
				handler.run();
			}
			this.stop();
		}
	}

	/**
	*停止播放动画。
	*/
	__proto.stop=function(){
		this._playing=false;
	}

	/**
	*跳到某帧并停止播放动画。
	*@param frame 要跳到的帧
	*/
	__proto.gotoAndStop=function(index){
		this.index=index;
		this.stop();
	}

	/**
	*@private
	*清理。
	*/
	__proto._clear=function(){
		this.stop();
		this._idOfSprite.length=0;
		if (!this._parentMovieClip){
			this.timer.clear(this,this.updates);
			var i=0,len=0;
			len=this._movieClipList.length;
			for (i=0;i < len;i++){
				if (this._movieClipList[i] !=this)
					this._movieClipList[i]._clear();
			}
			this._movieClipList.length=0;
		}
		if (this._atlasPath){
			Loader.clearRes(this._atlasPath);
		};
		var key;
		for (key in this._loadedImage){
			if (this._loadedImage[key]){
				Loader.clearRes(key);
				this._loadedImage[key]=false;
			}
		}
		this.removeChildren();
		this.graphics=null;
		this._parentMovieClip=null;
	}

	/**
	*播放动画。
	*@param index 帧索引。
	*/
	__proto.play=function(index,loop){
		(index===void 0)&& (index=0);
		(loop===void 0)&& (loop=true);
		this.loop=loop;
		this._playing=true;
		if (this._data)
			this._displayFrame(index);
	}

	/**@private */
	__proto._displayFrame=function(frameIndex){
		(frameIndex===void 0)&& (frameIndex=-1);
		if (frameIndex !=-1){
			if (this._curIndex > frameIndex)this._reset();
			this._parse(frameIndex);
		}
	}

	/**@private */
	__proto._reset=function(rm){
		(rm===void 0)&& (rm=true);
		if (rm && this._curIndex !=1)this.removeChildren();
		this._preIndex=this._curIndex=-1;
		this._Pos=this._start;
	}

	/**@private */
	__proto._parse=function(frameIndex){
		var curChild=this;
		var mc,sp,key=0,type=0,tPos=0,ttype=0,ifAdd=false;
		var _idOfSprite=this._idOfSprite,_data=this._data,eStr;
		if (this._ended)this._reset();
		_data.pos=this._Pos;
		this._ended=false;
		this._playIndex=frameIndex;
		if (this._curIndex > frameIndex&&frameIndex<this._preIndex){
			this._reset(true);
			_data.pos=this._Pos;
		}
		while ((this._curIndex <=frameIndex)&& (!this._ended)){
			type=_data.getUint16();
			switch (type){
				case 12:
					key=_data.getUint16();
					tPos=this._ids[_data.getUint16()];
					this._Pos=_data.pos;
					_data.pos=tPos;
					if ((ttype=_data.getUint8())==0){
						var pid=_data.getUint16();
						sp=_idOfSprite[key]
						if (!sp){
							sp=_idOfSprite[key]=new Sprite();
							var spp=new Sprite();
							spp.loadImage(this.basePath+pid+".png");
							this._loadedImage[this.basePath+pid+".png"]=true;
							sp.addChild(spp);
							spp.size(_data.getFloat32(),_data.getFloat32());
							var mat=_data._getMatrix();
							spp.transform=mat;
						}
						sp.alpha=1;
						}else if (ttype==1){
						mc=_idOfSprite[key]
						if (!mc){
							_idOfSprite[key]=mc=new MovieClip(this);
							mc.interval=this.interval;
							mc._ids=this._ids;
							mc.basePath=this.basePath;
							mc._setData(_data,tPos);
							mc._initState();
							mc.play(0);
						}
						mc.alpha=1;
					}
					_data.pos=this._Pos;
					break ;
				case 3:;
					var node=_idOfSprite[ _data.getUint16()];
					if (node){
						this.addChild(node);
						node.zOrder=_data.getUint16();
						ifAdd=true;
					}
					break ;
				case 4:
					node=_idOfSprite[ _data.getUint16()];
					node && node.removeSelf();
					break ;
				case 5:
					_idOfSprite[_data.getUint16()][MovieClip._ValueList[_data.getUint16()]]=(_data.getFloat32());
					break ;
				case 6:
					_idOfSprite[_data.getUint16()].visible=(_data.getUint8()> 0);
					break ;
				case 7:
					sp=_idOfSprite[ _data.getUint16()];
					var mt=sp.transform || Matrix.create();
					mt.setTo(_data.getFloat32(),_data.getFloat32(),_data.getFloat32(),_data.getFloat32(),_data.getFloat32(),_data.getFloat32());
					sp.transform=mt;
					break ;
				case 8:
					_idOfSprite[_data.getUint16()].setPos(_data.getFloat32(),_data.getFloat32());
					break ;
				case 9:
					_idOfSprite[_data.getUint16()].setSize(_data.getFloat32(),_data.getFloat32());
					break ;
				case 10:
					_idOfSprite[ _data.getUint16()].alpha=_data.getFloat32();
					break ;
				case 11:
					_idOfSprite[_data.getUint16()].setScale(_data.getFloat32(),_data.getFloat32());
					break ;
				case 98:
					eStr=_data.getString();
					this.event(eStr);
					if (eStr=="stop")this.stop();
					break ;
				case 99:
					this._curIndex=_data.getUint16();
					ifAdd && this.updateZOrder();
					break ;
				case 100:
					this._count=this._curIndex+1;
					this._ended=true;
					if (this._playing){
						this.event(/*laya.events.Event.FRAME*/"enterframe");
						this.event(/*laya.events.Event.END*/"end");
						this.event(/*laya.events.Event.COMPLETE*/"complete");
					}
					this._reset(false);
					break ;
				}
		}
		if (this._playing&&!this._ended)this.event(/*laya.events.Event.FRAME*/"enterframe");
		this._Pos=_data.pos;
	}

	/**@private */
	__proto._setData=function(data,start){
		this._data=data;
		this._start=start+3;
	}

	/**
	*加载资源。
	*@param url swf 资源地址。
	*@param atlas 是否使用图集资源
	*@param atlasPath 图集路径，默认使用与swf同名的图集
	*/
	__proto.load=function(url,atlas,atlasPath){
		(atlas===void 0)&& (atlas=false);
		this._url=url=URL.formatURL(url);
		if(atlas)this._atlasPath=atlasPath?atlasPath:url.split(".swf")[0]+".json";
		this.stop();
		this._clear();
		this._movieClipList=[this];
		var urls;
		urls=[ {url:url,type:/*laya.net.Loader.BUFFER*/"arraybuffer" }];
		if (this._atlasPath){
			urls.push({url:this._atlasPath,type:/*laya.net.Loader.ATLAS*/"atlas" });
		}
		Laya.loader.load(urls,Handler.create(this,this._onLoaded));
	}

	/**@private */
	__proto._onLoaded=function(){
		var data;
		data=Loader.getRes(this._url);
		if (!data){
			this.event(/*laya.events.Event.ERROR*/"error","file not find");
			return;
		}
		this.basePath=this._atlasPath?Loader.getAtlas(this._atlasPath).dir:this._url.split(".swf")[0]+"/image/";
		this._initData(data);
	}

	/**@private */
	__proto._initState=function(){
		this._reset();
		this._ended=false;
		var preState=this._playing;
		this._playing=false;
		this._curIndex=0;
		while (!this._ended)this._parse(++this._curIndex);
		this._playing=preState;
	}

	/**@private */
	__proto._initData=function(data){
		this._data=new Byte(data);
		var i=0,len=this._data.getUint16();
		for (i=0;i < len;i++)this._ids[this._data.getInt16()]=this._data.getInt32();
		this.interval=1000 / this._data.getUint16();
		this._setData(this._data,this._ids[32767]);
		this._initState();
		this.play(0);
		this.event(/*laya.events.Event.LOADED*/"loaded");
		if (!this._parentMovieClip)this.timer.loop(this.interval,this,this.updates,null,true);
	}

	/**
	*从开始索引播放到结束索引，结束之后出发complete回调
	*@param start 开始索引
	*@param end 结束索引
	*@param complete 结束回调
	*/
	__proto.playTo=function(start,end,complete){
		this._completeHandler=complete;
		this._endFrame=end;
		this.play(start,false);
	}

	/**当前播放索引。*/
	__getset(0,__proto,'index',function(){
		return this._playIndex;
		},function(value){
		this._playIndex=value;
		if (this._data)
			this._displayFrame(this._playIndex);
		if (this._labels && this._labels[value])this.event(/*laya.events.Event.LABEL*/"label",this._labels[value]);
	});

	/**
	*帧总数。
	*/
	__getset(0,__proto,'count',function(){
		return this._count;
	});

	/**
	*是否在播放中
	*/
	__getset(0,__proto,'playing',function(){
		return this._playing;
	});

	/**
	*资源地址。
	*/
	__getset(0,__proto,'url',null,function(path){
		this.load(path);
	});

	MovieClip._ValueList=["x","y","width","height","scaleX","scaleY","rotation","alpha"];
	return MovieClip;
})(Sprite)


/**
*动画模板类
*/
//class laya.ani.bone.Templet extends laya.ani.AnimationTemplet
var Templet=(function(_super){
	function Templet(){
		this._mainTexture=null;
		this._textureJson=null;
		this._graphicsCache=[];
		/**存放原始骨骼信息 */
		this.srcBoneMatrixArr=[];
		/**IK数据 */
		this.ikArr=[];
		/**transform数据 */
		this.tfArr=[];
		/**path数据 */
		this.pathArr=[];
		/**存放插槽数据的字典 */
		this.boneSlotDic={};
		/**绑定插槽数据的字典 */
		this.bindBoneBoneSlotDic={};
		/**存放插糟数据的数组 */
		this.boneSlotArray=[];
		/**皮肤数据 */
		this.skinDataArray=[];
		/**皮肤的字典数据 */
		this.skinDic={};
		/**存放纹理数据 */
		this.subTextureDic={};
		/**是否解析失败 */
		this.isParseFail=false;
		/**反转矩阵，有些骨骼动画要反转才能显示 */
		this.yReverseMatrix=null;
		/**渲染顺序动画数据 */
		this.drawOrderAniArr=[];
		/**事件动画数据 */
		this.eventAniArr=[];
		/**@private 索引对应的名称 */
		this.attachmentNames=null;
		/**顶点动画数据 */
		this.deformAniArr=[];
		this._isDestroyed=false;
		this._rate=30;
		this.isParserComplete=false;
		this.aniSectionDic={};
		this._skBufferUrl=null;
		this._textureDic={};
		this._loadList=null;
		this._path=null;
		/**@private */
		this.tMatrixDataLen=0;
		this.mRootBone=null;
		Templet.__super.call(this);
		this.skinSlotDisplayDataArr=[];
		this.mBoneArr=[];
	}

	__class(Templet,'laya.ani.bone.Templet',_super);
	var __proto=Templet.prototype;
	__proto.loadAni=function(url){
		this._skBufferUrl=url;
		Laya.loader.load(url,Handler.create(this,this.onComplete),null,/*laya.net.Loader.BUFFER*/"arraybuffer");
	}

	__proto.onComplete=function(content){
		if (this._isDestroyed){
			this.destroy();
			return;
		};
		var tSkBuffer=Loader.getRes(this._skBufferUrl);
		if (!tSkBuffer){
			this.event(/*laya.events.Event.ERROR*/"error","load failed:"+this._skBufferUrl);
			return;
		}
		this._path=this._skBufferUrl.slice(0,this._skBufferUrl.lastIndexOf("/"))+"/";
		this.parseData(null,tSkBuffer);
	}

	/**
	*解析骨骼动画数据
	*@param texture 骨骼动画用到的纹理
	*@param skeletonData 骨骼动画信息及纹理分块信息
	*@param playbackRate 缓冲的帧率数据（会根据帧率去分帧）
	*/
	__proto.parseData=function(texture,skeletonData,playbackRate){
		(playbackRate===void 0)&& (playbackRate=30);
		if(!this._path&&this.url)this._path=this.url.slice(0,this.url.lastIndexOf("/"))+"/";
		this._mainTexture=texture;
		if (this._mainTexture){
			if (Render.isWebGL && texture.bitmap){
				texture.bitmap.enableMerageInAtlas=false;
			}
		}
		this._rate=playbackRate;
		this.parse(skeletonData);
	}

	/**
	*创建动画
	*0,使用模板缓冲的数据，模板缓冲的数据，不允许修改 （内存开销小，计算开销小，不支持换装）
	*1,使用动画自己的缓冲区，每个动画都会有自己的缓冲区，相当耗费内存 （内存开销大，计算开销小，支持换装）
	*2,使用动态方式，去实时去画 （内存开销小，计算开销大，支持换装,不建议使用）
	*@param aniMode 0 动画模式，0:不支持换装,1,2支持换装
	*@return
	*/
	__proto.buildArmature=function(aniMode){
		(aniMode===void 0)&& (aniMode=0);
		return new Skeleton(this,aniMode);
	}

	/**
	*@private
	*解析动画
	*@param data 解析的二进制数据
	*@param playbackRate 帧率
	*/
	__proto.parse=function(data){
		_super.prototype.parse.call(this,data);
		this._endLoaded();
		if (this._aniVersion !=Templet.LAYA_ANIMATION_VISION){
			console.log("[Error] 版本不一致，请使用IDE版本配套的重新导出"+this._aniVersion+"->"+Templet.LAYA_ANIMATION_VISION);
			this._loaded=false;
		}
		if (this.loaded){
			if (this._mainTexture){
				this._parsePublicExtData();
				}else {
				this._parseTexturePath();
			}
			}else {
			this.event(/*laya.events.Event.ERROR*/"error",this);
			this.isParseFail=true;
		}
	}

	__proto._parseTexturePath=function(){
		if (this._isDestroyed){
			this.destroy();
			return;
		};
		var i=0;
		this._loadList=[];
		var tByte=new Byte(this.getPublicExtData());
		var tX=0,tY=0,tWidth=0,tHeight=0;
		var tFrameX=0,tFrameY=0,tFrameWidth=0,tFrameHeight=0;
		var tTempleData=0;
		var tTextureLen=tByte.getInt32();
		var tTextureName=tByte.readUTFString();
		var tTextureNameArr=tTextureName.split("\n");
		var tTexture;
		var tSrcTexturePath;
		for (i=0;i < tTextureLen;i++){
			tSrcTexturePath=this._path+tTextureNameArr[i *2];
			tTextureName=tTextureNameArr[i *2+1];
			tX=tByte.getFloat32();
			tY=tByte.getFloat32();
			tWidth=tByte.getFloat32();
			tHeight=tByte.getFloat32();
			tTempleData=tByte.getFloat32();
			tFrameX=isNaN(tTempleData)? 0 :tTempleData;
			tTempleData=tByte.getFloat32();
			tFrameY=isNaN(tTempleData)? 0 :tTempleData;
			tTempleData=tByte.getFloat32();
			tFrameWidth=isNaN(tTempleData)? tWidth :tTempleData;
			tTempleData=tByte.getFloat32();
			tFrameHeight=isNaN(tTempleData)? tHeight :tTempleData;
			if (this._loadList.indexOf(tSrcTexturePath)==-1){
				this._loadList.push(tSrcTexturePath);
			}
		}
		Laya.loader.load(this._loadList,Handler.create(this,this._textureComplete));
	}

	/**
	*纹理加载完成
	*/
	__proto._textureComplete=function(){
		var tTexture;
		var tTextureName;
		for (var i=0,n=this._loadList.length;i < n;i++){
			tTextureName=this._loadList[i];
			tTexture=this._textureDic[tTextureName]=Loader.getRes(tTextureName);
			if (Render.isWebGL && tTexture && tTexture.bitmap){
				tTexture.bitmap.enableMerageInAtlas=false;
			}
		}
		this._parsePublicExtData();
	}

	/**
	*解析自定义数据
	*/
	__proto._parsePublicExtData=function(){
		var i=0,j=0,k=0,l=0,n=0;
		for (i=0,n=this.getAnimationCount();i < n;i++){
			this._graphicsCache.push([]);
		};
		var isSpine=false;
		isSpine=this._aniClassName !="Dragon";
		var tByte=new Byte(this.getPublicExtData());
		var tX=0,tY=0,tWidth=0,tHeight=0;
		var tFrameX=0,tFrameY=0,tFrameWidth=0,tFrameHeight=0;
		var tTempleData=0;
		var tTextureLen=tByte.getInt32();
		var tTextureName=tByte.readUTFString();
		var tTextureNameArr=tTextureName.split("\n");
		var tTexture;
		var tSrcTexturePath;
		for (i=0;i < tTextureLen;i++){
			tTexture=this._mainTexture;
			tSrcTexturePath=this._path+tTextureNameArr[i *2];
			tTextureName=tTextureNameArr[i *2+1];
			if (this._mainTexture==null){
				tTexture=this._textureDic[tSrcTexturePath];
			}
			if (!tTexture){
				this.event(/*laya.events.Event.ERROR*/"error",this);
				this.isParseFail=true;
				return;
			}
			tX=tByte.getFloat32();
			tY=tByte.getFloat32();
			tWidth=tByte.getFloat32();
			tHeight=tByte.getFloat32();
			tTempleData=tByte.getFloat32();
			tFrameX=isNaN(tTempleData)? 0 :tTempleData;
			tTempleData=tByte.getFloat32();
			tFrameY=isNaN(tTempleData)? 0 :tTempleData;
			tTempleData=tByte.getFloat32();
			tFrameWidth=isNaN(tTempleData)? tWidth :tTempleData;
			tTempleData=tByte.getFloat32();
			tFrameHeight=isNaN(tTempleData)? tHeight :tTempleData;
			this.subTextureDic[tTextureName]=Texture.create(tTexture,tX,tY,tWidth,tHeight,-tFrameX,-tFrameY,tFrameWidth,tFrameHeight);
		}
		this._mainTexture=tTexture;
		var tAniCount=tByte.getUint16();
		var tSectionArr;
		for (i=0;i < tAniCount;i++){
			tSectionArr=[];
			tSectionArr.push(tByte.getUint16());
			tSectionArr.push(tByte.getUint16());
			tSectionArr.push(tByte.getUint16());
			tSectionArr.push(tByte.getUint16());
			this.aniSectionDic[i]=tSectionArr;
		};
		var tBone;
		var tParentBone;
		var tName;
		var tParentName;
		var tBoneLen=tByte.getInt16();
		var tBoneDic={};
		var tRootBone;
		for (i=0;i < tBoneLen;i++){
			tBone=new Bone();
			if (i==0){
				tRootBone=tBone;
				}else {
				tBone.root=tRootBone;
			}
			tBone.d=isSpine?-1:1;
			tName=tByte.readUTFString();
			tParentName=tByte.readUTFString();
			tBone.length=tByte.getFloat32();
			if (tByte.getByte()==1){
				tBone.inheritRotation=false;
			}
			if (tByte.getByte()==1){
				tBone.inheritScale=false;
			}
			tBone.name=tName;
			if (tParentName){
				tParentBone=tBoneDic[tParentName];
				if (tParentBone){
					tParentBone.addChild(tBone);
					}else {
					this.mRootBone=tBone;
				}
			}
			tBoneDic[tName]=tBone;
			this.mBoneArr.push(tBone);
		}
		this.tMatrixDataLen=tByte.getUint16();
		var tLen=tByte.getUint16();
		var parentIndex=0;
		var boneLength=Math.floor(tLen / this.tMatrixDataLen);
		var tResultTransform;
		var tMatrixArray=this.srcBoneMatrixArr;
		for (i=0;i < boneLength;i++){
			tResultTransform=new Transform();
			tResultTransform.scX=tByte.getFloat32();
			tResultTransform.skX=tByte.getFloat32();
			tResultTransform.skY=tByte.getFloat32();
			tResultTransform.scY=tByte.getFloat32();
			tResultTransform.x=tByte.getFloat32();
			tResultTransform.y=tByte.getFloat32();
			if (this.tMatrixDataLen===8){
				tResultTransform.skewX=tByte.getFloat32();
				tResultTransform.skewY=tByte.getFloat32();
			}
			tMatrixArray.push(tResultTransform);
			tBone=this.mBoneArr[i];
			tBone.transform=tResultTransform;
		};
		var tIkConstraintData;
		var tIkLen=tByte.getUint16();
		var tIkBoneLen=0;
		for (i=0;i < tIkLen;i++){
			tIkConstraintData=new IkConstraintData();
			tIkBoneLen=tByte.getUint16();
			for (j=0;j < tIkBoneLen;j++){
				tIkConstraintData.boneNames.push(tByte.readUTFString());
				tIkConstraintData.boneIndexs.push(tByte.getInt16());
			}
			tIkConstraintData.name=tByte.readUTFString();
			tIkConstraintData.targetBoneName=tByte.readUTFString();
			tIkConstraintData.targetBoneIndex=tByte.getInt16();
			tIkConstraintData.bendDirection=tByte.getFloat32();
			tIkConstraintData.mix=tByte.getFloat32();
			tIkConstraintData.isSpine=isSpine;
			this.ikArr.push(tIkConstraintData);
		};
		var tTfConstraintData;
		var tTfLen=tByte.getUint16();
		var tTfBoneLen=0;
		for (i=0;i < tTfLen;i++){
			tTfConstraintData=new TfConstraintData();
			tTfBoneLen=tByte.getUint16();
			for (j=0;j < tTfBoneLen;j++){
				tTfConstraintData.boneIndexs.push(tByte.getInt16());
			}
			tTfConstraintData.name=tByte.getUTFString();
			tTfConstraintData.targetIndex=tByte.getInt16();
			tTfConstraintData.rotateMix=tByte.getFloat32();
			tTfConstraintData.translateMix=tByte.getFloat32();
			tTfConstraintData.scaleMix=tByte.getFloat32();
			tTfConstraintData.shearMix=tByte.getFloat32();
			tTfConstraintData.offsetRotation=tByte.getFloat32();
			tTfConstraintData.offsetX=tByte.getFloat32();
			tTfConstraintData.offsetY=tByte.getFloat32();
			tTfConstraintData.offsetScaleX=tByte.getFloat32();
			tTfConstraintData.offsetScaleY=tByte.getFloat32();
			tTfConstraintData.offsetShearY=tByte.getFloat32();
			this.tfArr.push(tTfConstraintData);
		};
		var tPathConstraintData;
		var tPathLen=tByte.getUint16();
		var tPathBoneLen=0;
		for (i=0;i < tPathLen;i++){
			tPathConstraintData=new PathConstraintData();
			tPathConstraintData.name=tByte.readUTFString();
			tPathBoneLen=tByte.getUint16();
			for (j=0;j < tPathBoneLen;j++){
				tPathConstraintData.bones.push(tByte.getInt16());
			}
			tPathConstraintData.target=tByte.readUTFString();
			tPathConstraintData.positionMode=tByte.readUTFString();
			tPathConstraintData.spacingMode=tByte.readUTFString();
			tPathConstraintData.rotateMode=tByte.readUTFString();
			tPathConstraintData.offsetRotation=tByte.getFloat32();
			tPathConstraintData.position=tByte.getFloat32();
			tPathConstraintData.spacing=tByte.getFloat32();
			tPathConstraintData.rotateMix=tByte.getFloat32();
			tPathConstraintData.translateMix=tByte.getFloat32();
			this.pathArr.push(tPathConstraintData);
		};
		var tDeformSlotLen=0;
		var tDeformSlotDisplayLen=0;
		var tDSlotIndex=0;
		var tDAttachment;
		var tDeformTimeLen=0;
		var tDTime=NaN;
		var tDeformVecticesLen=0;
		var tDeformAniData;
		var tDeformSlotData;
		var tDeformSlotDisplayData;
		var tDeformVectices;
		var tDeformAniLen=tByte.getInt16();
		for (i=0;i < tDeformAniLen;i++){
			var tDeformSkinLen=tByte.getUint8();
			var tSkinDic={};
			this.deformAniArr.push(tSkinDic);
			for (var f=0;f < tDeformSkinLen;f++){
				tDeformAniData=new DeformAniData();
				tDeformAniData.skinName=tByte.getUTFString();
				tSkinDic[tDeformAniData.skinName]=tDeformAniData;
				tDeformSlotLen=tByte.getInt16();
				for (j=0;j < tDeformSlotLen;j++){
					tDeformSlotData=new DeformSlotData();
					tDeformAniData.deformSlotDataList.push(tDeformSlotData);
					tDeformSlotDisplayLen=tByte.getInt16();
					for (k=0;k < tDeformSlotDisplayLen;k++){
						tDeformSlotDisplayData=new DeformSlotDisplayData();
						tDeformSlotData.deformSlotDisplayList.push(tDeformSlotDisplayData);
						tDeformSlotDisplayData.slotIndex=tDSlotIndex=tByte.getInt16();
						tDeformSlotDisplayData.attachment=tDAttachment=tByte.getUTFString();
						tDeformTimeLen=tByte.getInt16();
						for (l=0;l < tDeformTimeLen;l++){
							if (tByte.getByte()==1){
								tDeformSlotDisplayData.tweenKeyList.push(true);
								}else {
								tDeformSlotDisplayData.tweenKeyList.push(false);
							}
							tDTime=tByte.getFloat32();
							tDeformSlotDisplayData.timeList.push(tDTime);
							tDeformVectices=[];
							tDeformSlotDisplayData.vectices.push(tDeformVectices);
							tDeformVecticesLen=tByte.getInt16();
							for (n=0;n < tDeformVecticesLen;n++){
								tDeformVectices.push(tByte.getFloat32());
							}
						}
					}
				}
			}
		};
		var tDrawOrderArr;
		var tDrawOrderAniLen=tByte.getInt16();
		var tDrawOrderLen=0;
		var tDrawOrderData;
		var tDoLen=0;
		for (i=0;i < tDrawOrderAniLen;i++){
			tDrawOrderLen=tByte.getInt16();
			tDrawOrderArr=[];
			for (j=0;j < tDrawOrderLen;j++){
				tDrawOrderData=new DrawOrderData();
				tDrawOrderData.time=tByte.getFloat32();
				tDoLen=tByte.getInt16();
				for (k=0;k < tDoLen;k++){
					tDrawOrderData.drawOrder.push(tByte.getInt16());
				}
				tDrawOrderArr.push(tDrawOrderData);
			}
			this.drawOrderAniArr.push(tDrawOrderArr);
		};
		var tEventArr;
		var tEventAniLen=tByte.getInt16();
		var tEventLen=0;
		var tEventData;
		for (i=0;i < tEventAniLen;i++){
			tEventLen=tByte.getInt16();
			tEventArr=[];
			for (j=0;j < tEventLen;j++){
				tEventData=new EventData();
				tEventData.name=tByte.getUTFString();
				tEventData.intValue=tByte.getInt32();
				tEventData.floatValue=tByte.getFloat32();
				tEventData.stringValue=tByte.getUTFString();
				tEventData.time=tByte.getFloat32();
				tEventArr.push(tEventData);
			}
			this.eventAniArr.push(tEventArr);
		};
		var tAttachmentLen=tByte.getInt16();
		if (tAttachmentLen > 0){
			this.attachmentNames=[];
			for (i=0;i < tAttachmentLen;i++){
				this.attachmentNames.push(tByte.getUTFString());
			}
		};
		var tBoneSlotLen=tByte.getInt16();
		var tDBBoneSlot;
		var tDBBoneSlotArr;
		for (i=0;i < tBoneSlotLen;i++){
			tDBBoneSlot=new BoneSlot();
			tDBBoneSlot.name=tByte.readUTFString();
			tDBBoneSlot.parent=tByte.readUTFString();
			tDBBoneSlot.attachmentName=tByte.readUTFString();
			tDBBoneSlot.srcDisplayIndex=tDBBoneSlot.displayIndex=tByte.getInt16();
			tDBBoneSlot.templet=this;
			this.boneSlotDic[tDBBoneSlot.name]=tDBBoneSlot;
			tDBBoneSlotArr=this.bindBoneBoneSlotDic[tDBBoneSlot.parent];
			if (tDBBoneSlotArr==null){
				this.bindBoneBoneSlotDic[tDBBoneSlot.parent]=tDBBoneSlotArr=[];
			}
			tDBBoneSlotArr.push(tDBBoneSlot);
			this.boneSlotArray.push(tDBBoneSlot);
		};
		var tNameString=tByte.readUTFString();
		var tNameArray=tNameString.split("\n");
		var tNameStartIndex=0;
		var tSkinDataLen=tByte.getUint8();
		var tSkinData,tSlotData,tDisplayData;
		var tSlotDataLen=0,tDisplayDataLen=0;
		var tUvLen=0,tWeightLen=0,tTriangleLen=0,tVerticeLen=0,tLengthLen=0;
		for (i=0;i < tSkinDataLen;i++){
			tSkinData=new SkinData();
			tSkinData.name=tNameArray[tNameStartIndex++];
			tSlotDataLen=tByte.getUint8();
			for (j=0;j < tSlotDataLen;j++){
				tSlotData=new SlotData();
				tSlotData.name=tNameArray[tNameStartIndex++];
				tDBBoneSlot=this.boneSlotDic[tSlotData.name];
				tDisplayDataLen=tByte.getUint8();
				for (k=0;k < tDisplayDataLen;k++){
					tDisplayData=new SkinSlotDisplayData();
					this.skinSlotDisplayDataArr.push(tDisplayData);
					tDisplayData.name=tNameArray[tNameStartIndex++];
					tDisplayData.attachmentName=tNameArray[tNameStartIndex++];
					tDisplayData.transform=new Transform();
					tDisplayData.transform.scX=tByte.getFloat32();
					tDisplayData.transform.skX=tByte.getFloat32();
					tDisplayData.transform.skY=tByte.getFloat32();
					tDisplayData.transform.scY=tByte.getFloat32();
					tDisplayData.transform.x=tByte.getFloat32();
					tDisplayData.transform.y=tByte.getFloat32();
					tSlotData.displayArr.push(tDisplayData);
					tDisplayData.width=tByte.getFloat32();
					tDisplayData.height=tByte.getFloat32();
					tDisplayData.type=tByte.getUint8();
					tDisplayData.verLen=tByte.getUint16();
					tBoneLen=tByte.getUint16();
					if (tBoneLen > 0){
						tDisplayData.bones=[];
						for (l=0;l < tBoneLen;l++){
							var tBoneId=tByte.getUint16();
							tDisplayData.bones.push(tBoneId);
						}
					}
					tUvLen=tByte.getUint16();
					if (tUvLen > 0){
						tDisplayData.uvs=[];
						for (l=0;l < tUvLen;l++){
							tDisplayData.uvs.push(tByte.getFloat32());
						}
					}
					tWeightLen=tByte.getUint16();
					if (tWeightLen > 0){
						tDisplayData.weights=[];
						for (l=0;l < tWeightLen;l++){
							tDisplayData.weights.push(tByte.getFloat32());
						}
					}
					tTriangleLen=tByte.getUint16();
					if (tTriangleLen > 0){
						tDisplayData.triangles=[];
						for (l=0;l < tTriangleLen;l++){
							tDisplayData.triangles.push(tByte.getUint16());
						}
					}
					tVerticeLen=tByte.getUint16();
					if (tVerticeLen > 0){
						tDisplayData.vertices=[];
						for (l=0;l < tVerticeLen;l++){
							tDisplayData.vertices.push(tByte.getFloat32());
						}
					}
					tLengthLen=tByte.getUint16();
					if (tLengthLen > 0){
						tDisplayData.lengths=[];
						for (l=0;l < tLengthLen;l++){
							tDisplayData.lengths.push(tByte.getFloat32());
						}
					}
				}
				tSkinData.slotArr.push(tSlotData);
			}
			this.skinDic[tSkinData.name]=tSkinData;
			this.skinDataArray.push(tSkinData);
		};
		var tReverse=tByte.getUint8();
		if (tReverse==1){
			this.yReverseMatrix=new Matrix(1,0,0,-1,0,0);
			if (tRootBone){
				tRootBone.setTempMatrix(this.yReverseMatrix);
			}
			}else {
			if (tRootBone){
				tRootBone.setTempMatrix(new Matrix());
			}
		}
		this.showSkinByIndex(this.boneSlotDic,0);
		this.isParserComplete=true;
		this.event(/*laya.events.Event.COMPLETE*/"complete",this);
	}

	/**
	*得到指定的纹理
	*@param name 纹理的名字
	*@return
	*/
	__proto.getTexture=function(name){
		var tTexture=this.subTextureDic[name];
		if (!tTexture){
			tTexture=this.subTextureDic[name.substr(0,name.length-1)];
		}
		if (tTexture==null){
			return this._mainTexture;
		}
		return tTexture;
	}

	/**
	*@private
	*显示指定的皮肤
	*@param boneSlotDic 插糟字典的引用
	*@param skinIndex 皮肤的索引
	*@param freshDisplayIndex 是否重置插槽纹理
	*/
	__proto.showSkinByIndex=function(boneSlotDic,skinIndex,freshDisplayIndex){
		(freshDisplayIndex===void 0)&& (freshDisplayIndex=true);
		if (skinIndex < 0 && skinIndex >=this.skinDataArray.length)return false;
		var i=0,n=0;
		var tBoneSlot;
		var tSlotData;
		var tSkinData=this.skinDataArray[skinIndex];
		if (tSkinData){
			for (i=0,n=tSkinData.slotArr.length;i < n;i++){
				tSlotData=tSkinData.slotArr[i];
				if (tSlotData){
					tBoneSlot=boneSlotDic[tSlotData.name];
					if (tBoneSlot){
						tBoneSlot.showSlotData(tSlotData,freshDisplayIndex);
						if (freshDisplayIndex&&tBoneSlot.attachmentName !="undefined" && tBoneSlot.attachmentName !="null"){
							tBoneSlot.showDisplayByName(tBoneSlot.attachmentName);
							}else {
							tBoneSlot.showDisplayByIndex(tBoneSlot.displayIndex);
						}
					}
				}
			}
			return true;
		}
		return false;
	}

	/**
	*通过皮肤名字得到皮肤索引
	*@param skinName 皮肤名称
	*@return
	*/
	__proto.getSkinIndexByName=function(skinName){
		var tSkinData;
		for (var i=0,n=this.skinDataArray.length;i < n;i++){
			tSkinData=this.skinDataArray[i];
			if (tSkinData.name==skinName){
				return i;
			}
		}
		return-1;
	}

	/**
	*@private
	*得到缓冲数据
	*@param aniIndex 动画索引
	*@param frameIndex 帧索引
	*@return
	*/
	__proto.getGrahicsDataWithCache=function(aniIndex,frameIndex){
		return this._graphicsCache[aniIndex][frameIndex];
	}

	/**
	*@private
	*保存缓冲grahpics
	*@param aniIndex 动画索引
	*@param frameIndex 帧索引
	*@param graphics 要保存的数据
	*/
	__proto.setGrahicsDataWithCache=function(aniIndex,frameIndex,graphics){
		this._graphicsCache[aniIndex][frameIndex]=graphics;
	}

	/**
	*释放纹理
	*/
	__proto.destroy=function(){
		this._isDestroyed=true;
		var tTexture;
		/*for each*/for(var $each_tTexture in this.subTextureDic){
			tTexture=this.subTextureDic[$each_tTexture];
			if(tTexture)
				tTexture.destroy();
		}
		var $each_tTexture;
		/*for each*/for($each_tTexture in this._textureDic){
			tTexture=this._textureDic[$each_tTexture];
			if(tTexture)
				tTexture.destroy();
		};
		var tSkinSlotDisplayData;
		for (var i=0,n=this.skinSlotDisplayDataArr.length;i < n;i++){
			tSkinSlotDisplayData=this.skinSlotDisplayDataArr[i];
			tSkinSlotDisplayData.destory();
		}
		this.skinSlotDisplayDataArr.length=0;
		if (this.url){
			delete Templet.TEMPLET_DICTIONARY[this.url];
		}
		laya.resource.Resource.prototype.destroy.call(this);
	}

	/**
	*通过索引得动画名称
	*@param index
	*@return
	*/
	__proto.getAniNameByIndex=function(index){
		var tAni=this.getAnimation(index);
		if (tAni)return tAni.name;
		return null;
	}

	__getset(0,__proto,'rate',function(){
		return this._rate;
		},function(v){
		this._rate=v;
	});

	Templet.LAYA_ANIMATION_VISION="LAYAANIMATION:1.6.0";
	Templet.TEMPLET_DICTIONARY=null;
	return Templet;
})(AnimationTemplet)



})(window,document,Laya);

if (typeof define === 'function' && define.amd){
	define('laya.core', ['require', "exports"], function(require, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        for (var i in Laya) {
			var o = Laya[i];
            o && o.__isclass && (exports[i] = o);
        }
    });
}

(function(window,document,Laya){
	var __un=Laya.un,__uns=Laya.uns,__static=Laya.static,__class=Laya.class,__getset=Laya.getset,__newvec=Laya.__newvec;

	var Browser=laya.utils.Browser,Color=laya.utils.Color,ColorFilterAction=laya.filters.ColorFilterAction;
	var ColorFilterActionGL=laya.filters.webgl.ColorFilterActionGL,Filter=laya.filters.Filter,FilterActionGL=laya.filters.webgl.FilterActionGL;
	var Matrix=laya.maths.Matrix,Rectangle=laya.maths.Rectangle,Render=laya.renders.Render,RenderContext=laya.renders.RenderContext;
	var RenderTarget2D=laya.webgl.resource.RenderTarget2D,RunDriver=laya.utils.RunDriver,ShaderDefines2D=laya.webgl.shader.d2.ShaderDefines2D;
	var Sprite=laya.display.Sprite,Texture=laya.resource.Texture,Value2D=laya.webgl.shader.d2.value.Value2D;
/**
*默认的FILTER,什么都不做
*@private
*/
//class laya.filters.FilterAction
var FilterAction=(function(){
	function FilterAction(){
		this.data=null;
	}

	__class(FilterAction,'laya.filters.FilterAction');
	var __proto=FilterAction.prototype;
	Laya.imps(__proto,{"laya.filters.IFilterAction":true})
	__proto.apply=function(data){
		return null;
	}

	return FilterAction;
})()


/**
*@private
*/
//class laya.filters.WebGLFilter
var WebGLFilter=(function(){
	function WebGLFilter(){}
	__class(WebGLFilter,'laya.filters.WebGLFilter');
	WebGLFilter.enable=function(){
		if (WebGLFilter.isInit)return;
		WebGLFilter.isInit=true;
		if (!Render.isWebGL)return;
		RunDriver.createFilterAction=function (type){
			var action;
			switch (type){
				case /*laya.filters.Filter.COLOR*/0x20:
					action=new ColorFilterActionGL();
					break ;
				case /*laya.filters.Filter.BLUR*/0x10:
					action=new BlurFilterActionGL();
					break ;
				case /*laya.filters.Filter.GLOW*/0x08:
					action=new GlowFilterActionGL();
					break ;
				}
			return action;
		}
	}

	WebGLFilter.isInit=false;
	WebGLFilter.__init$=function(){
		BlurFilterActionGL;
		ColorFilterActionGL;
		GlowFilterActionGL;
		Render;
		RunDriver;{
			RunDriver.createFilterAction=function (type){
				var action;
				switch (type){
					case /*laya.filters.Filter.BLUR*/0x10:
						action=new FilterAction();
						break ;
					case /*laya.filters.Filter.GLOW*/0x08:
						action=new FilterAction();
						break ;
					case /*laya.filters.Filter.COLOR*/0x20:
						action=new ColorFilterAction();
						break ;
					}
				return action;
			}
		}
	}

	return WebGLFilter;
})()


/**
*模糊滤镜
*/
//class laya.filters.BlurFilter extends laya.filters.Filter
var BlurFilter=(function(_super){
	function BlurFilter(strength){
		/**模糊滤镜的强度(值越大，越不清晰 */
		this.strength=NaN;
		this.strength_sig2_2sig2_gauss1=[];
		BlurFilter.__super.call(this);
		(strength===void 0)&& (strength=4);
		if (Render.isWebGL)WebGLFilter.enable();
		this.strength=strength;
		this._action=RunDriver.createFilterAction(0x10);
		this._action.data=this;
	}

	__class(BlurFilter,'laya.filters.BlurFilter',_super);
	var __proto=BlurFilter.prototype;
	/**
	*@private 通知微端
	*/
	__proto.callNative=function(sp){
		sp.conchModel &&sp.conchModel.blurFilter&&sp.conchModel.blurFilter(this.strength);
	}

	/**
	*@private
	*当前滤镜对应的操作器
	*/
	__getset(0,__proto,'action',function(){
		return this._action;
	});

	/**
	*@private
	*当前滤镜的类型
	*/
	__getset(0,__proto,'type',function(){
		return 0x10;
	});

	return BlurFilter;
})(Filter)


/**
*发光滤镜(也可以当成阴影滤使用）
*/
//class laya.filters.GlowFilter extends laya.filters.Filter
var GlowFilter=(function(_super){
	function GlowFilter(color,blur,offX,offY){
		/**滤镜的颜色*/
		this._color=null;
		GlowFilter.__super.call(this);
		this._elements=new Float32Array(9);
		(blur===void 0)&& (blur=4);
		(offX===void 0)&& (offX=6);
		(offY===void 0)&& (offY=6);
		if (Render.isWebGL){
			WebGLFilter.enable();
		}
		this._color=new Color(color);
		this.blur=Math.min(blur,20);
		this.offX=offX;
		this.offY=offY;
		this._action=RunDriver.createFilterAction(0x08);
		this._action.data=this;
	}

	__class(GlowFilter,'laya.filters.GlowFilter',_super);
	var __proto=GlowFilter.prototype;
	/**@private */
	__proto.getColor=function(){
		return this._color._color;
	}

	/**
	*@private 通知微端
	*/
	__proto.callNative=function(sp){
		sp.conchModel &&sp.conchModel.glowFilter&&sp.conchModel.glowFilter(this._color.strColor,this._elements[4],this._elements[5],this._elements[6]);
	}

	/**
	*@private
	*滤镜类型
	*/
	__getset(0,__proto,'type',function(){
		return 0x08;
	});

	/**@private */
	__getset(0,__proto,'action',function(){
		return this._action;
	});

	/**@private */
	/**@private */
	__getset(0,__proto,'offY',function(){
		return this._elements[6];
		},function(value){
		this._elements[6]=value;
	});

	/**@private */
	/**@private */
	__getset(0,__proto,'offX',function(){
		return this._elements[5];
		},function(value){
		this._elements[5]=value;
	});

	/**@private */
	/**@private */
	__getset(0,__proto,'blur',function(){
		return this._elements[4];
		},function(value){
		this._elements[4]=value;
	});

	return GlowFilter;
})(Filter)


/**
*@private
*/
//class laya.filters.webgl.BlurFilterActionGL extends laya.filters.webgl.FilterActionGL
var BlurFilterActionGL=(function(_super){
	function BlurFilterActionGL(){
		this.data=null;
		BlurFilterActionGL.__super.call(this);
	}

	__class(BlurFilterActionGL,'laya.filters.webgl.BlurFilterActionGL',_super);
	var __proto=BlurFilterActionGL.prototype;
	__proto.setValueMix=function(shader){
		shader.defines.add(this.data.type);
		var o=shader;
	}

	__proto.apply3d=function(scope,sprite,context,x,y){
		var b=scope.getValue("bounds");
		var shaderValue=Value2D.create(/*laya.webgl.shader.d2.ShaderDefines2D.TEXTURE2D*/0x01,0);
		shaderValue.setFilters([this.data]);
		var tMatrix=Matrix.EMPTY;
		tMatrix.identity();
		context.ctx.drawTarget(scope,0,0,b.width,b.height,Matrix.EMPTY,"src",shaderValue);
		shaderValue.setFilters(null);
	}

	__proto.setValue=function(shader){
		shader.strength=this.data.strength;
		var sigma=this.data.strength/3.0;
		var sigma2=sigma*sigma;
		this.data.strength_sig2_2sig2_gauss1[0]=this.data.strength;
		this.data.strength_sig2_2sig2_gauss1[1]=sigma2;
		this.data.strength_sig2_2sig2_gauss1[2]=2.0*sigma2;
		this.data.strength_sig2_2sig2_gauss1[3]=1.0/(2.0*Math.PI*sigma2);
		shader.strength_sig2_2sig2_gauss1=this.data.strength_sig2_2sig2_gauss1;
	}

	__getset(0,__proto,'typeMix',function(){return /*laya.filters.Filter.BLUR*/0x10;});
	return BlurFilterActionGL;
})(FilterActionGL)


/**
*@private
*/
//class laya.filters.webgl.GlowFilterActionGL extends laya.filters.webgl.FilterActionGL
var GlowFilterActionGL=(function(_super){
	function GlowFilterActionGL(){
		this.data=null;
		this._initKey=false;
		this._textureWidth=0;
		this._textureHeight=0;
		GlowFilterActionGL.__super.call(this);
	}

	__class(GlowFilterActionGL,'laya.filters.webgl.GlowFilterActionGL',_super);
	var __proto=GlowFilterActionGL.prototype;
	Laya.imps(__proto,{"laya.filters.IFilterActionGL":true})
	__proto.setValueMix=function(shader){}
	__proto.apply3d=function(scope,sprite,context,x,y){
		var b=scope.getValue("bounds");
		scope.addValue("color",this.data.getColor());
		var w=b.width,h=b.height;
		this._textureWidth=w;
		this._textureHeight=h;
		var shaderValue;
		var mat=Matrix.TEMP;
		mat.identity();
		shaderValue=Value2D.create(/*laya.webgl.shader.d2.ShaderDefines2D.TEXTURE2D*/0x01,0);
		shaderValue.setFilters([this.data]);
		context.ctx.drawTarget(scope,0,0,this._textureWidth,this._textureHeight,mat,"src",shaderValue,null);
		shaderValue=Value2D.create(/*laya.webgl.shader.d2.ShaderDefines2D.TEXTURE2D*/0x01,0);
		context.ctx.drawTarget(scope,0,0,this._textureWidth,this._textureHeight,mat,"src",shaderValue);
		return null;
	}

	__proto.setSpriteWH=function(sprite){
		this._textureWidth=sprite.width;
		this._textureHeight=sprite.height;
	}

	__proto.setValue=function(shader){
		shader.u_offsetX=this.data.offX;
		shader.u_offsetY=-this.data.offY;
		shader.u_strength=1.0;
		shader.u_blurX=this.data.blur;
		shader.u_blurY=this.data.blur;
		shader.u_textW=this._textureWidth;
		shader.u_textH=this._textureHeight;
		shader.u_color=this.data.getColor();
	}

	__getset(0,__proto,'typeMix',function(){return /*laya.filters.Filter.GLOW*/0x08;});
	GlowFilterActionGL.tmpTarget=function(scope,sprite,context,x,y){
		var b=scope.getValue("bounds");
		var out=scope.getValue("out");
		out.end();
		var tmpTarget=RenderTarget2D.create(b.width,b.height);
		tmpTarget.start();
		var color=scope.getValue("color");
		if (color){
			tmpTarget.clear(color[0],color[1],color[2],0);
		}
		scope.addValue("tmpTarget",tmpTarget);
	}

	GlowFilterActionGL.startOut=function(scope,sprite,context,x,y){
		var tmpTarget=scope.getValue("tmpTarget");
		tmpTarget.end();
		var out=scope.getValue("out");
		out.start();
		var color=scope.getValue("color");
		if (color){
			out.clear(color[0],color[1],color[2],0);
		}
	}

	GlowFilterActionGL.recycleTarget=function(scope,sprite,context,x,y){
		var src=scope.getValue("src");
		var tmpTarget=scope.getValue("tmpTarget");
		tmpTarget.recycle();
	}

	return GlowFilterActionGL;
})(FilterActionGL)


	Laya.__init([WebGLFilter]);
})(window,document,Laya);

if (typeof define === 'function' && define.amd){
	define('laya.core', ['require', "exports"], function(require, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        for (var i in Laya) {
			var o = Laya[i];
            o && o.__isclass && (exports[i] = o);
        }
    });
}

(function(window,document,Laya){
	var __un=Laya.un,__uns=Laya.uns,__static=Laya.static,__class=Laya.class,__getset=Laya.getset,__newvec=Laya.__newvec;

	var Browser=laya.utils.Browser,CSSStyle=laya.display.css.CSSStyle,ClassUtils=laya.utils.ClassUtils;
	var Event=laya.events.Event,HTMLChar=laya.utils.HTMLChar,Loader=laya.net.Loader,Node=laya.display.Node,Rectangle=laya.maths.Rectangle;
	var Render=laya.renders.Render,RenderContext=laya.renders.RenderContext,RenderSprite=laya.renders.RenderSprite;
	var Sprite=laya.display.Sprite,Stat=laya.utils.Stat,Text=laya.display.Text,Texture=laya.resource.Texture;
	var URL=laya.net.URL,Utils=laya.utils.Utils;
/**
*@private
*/
//class laya.html.utils.HTMLParse
var HTMLParse=(function(){
	function HTMLParse(){}
	__class(HTMLParse,'laya.html.utils.HTMLParse');
	HTMLParse.parse=function(ower,xmlString,url){
		xmlString=xmlString.replace(/<br>/g,"<br/>");
		xmlString="<root>"+xmlString+"</root>";
		xmlString=xmlString.replace(HTMLParse.spacePattern,HTMLParse.char255);
		var xml=Utils.parseXMLFromString(xmlString);
		HTMLParse._parseXML(ower,xml.childNodes[0].childNodes,url);
	}

	HTMLParse._parseXML=function(parent,xml,url,href){
		var i=0,n=0;
		if (xml.join || xml.item){
			for (i=0,n=xml.length;i < n;++i){
				HTMLParse._parseXML(parent,xml[i],url,href);
			}
			}else {
			var node;
			var nodeName;
			if (xml.nodeType==3){
				var txt;
				if ((parent instanceof laya.html.dom.HTMLDivElement )){
					if (xml.nodeName==null){
						xml.nodeName="#text";
					}
					nodeName=xml.nodeName.toLowerCase();
					txt=xml.textContent.replace(/^\s+|\s+$/g,'');
					if (txt.length > 0){
						node=ClassUtils.getInstance(nodeName);
						if (node){
							parent.addChild(node);
							((node).innerTEXT=txt.replace(HTMLParse.char255AndOneSpacePattern," "));
						}
					}
					}else {
					txt=xml.textContent.replace(/^\s+|\s+$/g,'');
					if (txt.length > 0){
						((parent).innerTEXT=txt.replace(HTMLParse.char255AndOneSpacePattern," "));
					}
				}
				return;
				}else {
				nodeName=xml.nodeName.toLowerCase();
				if (nodeName=="#comment")return;
				node=ClassUtils.getInstance(nodeName);
				if (node){
					node=parent.addChild(node);
					(node).URI=url;
					(node).href=href;
					var attributes=xml.attributes;
					if (attributes && attributes.length > 0){
						for (i=0,n=attributes.length;i < n;++i){
							var attribute=attributes[i];
							var attrName=attribute.nodeName;
							var value=attribute.value;
							node._setAttributes(attrName,value);
						}
					}
					HTMLParse._parseXML(node,xml.childNodes,url,(node).href);
					}else {
					HTMLParse._parseXML(parent,xml.childNodes,url,href);
				}
			}
		}
	}

	HTMLParse.char255=String.fromCharCode(255);
	HTMLParse.spacePattern=/&nbsp;|&#160;/g;
	HTMLParse.char255AndOneSpacePattern=new RegExp(String.fromCharCode(255)+"|(\\s+)","g");
	return HTMLParse;
})()


/**
*@private
*HTML的布局类
*对HTML的显示对象进行排版
*/
//class laya.html.utils.Layout
var Layout=(function(){
	function Layout(){}
	__class(Layout,'laya.html.utils.Layout');
	Layout.later=function(element){
		if (Layout._will==null){
			Layout._will=[];
			Laya.stage.frameLoop(1,null,function(){
				if (Layout._will.length < 1)
					return;
				for (var i=0;i < Layout._will.length;i++){
					laya.html.utils.Layout.layout(Layout._will[i]);
				}
				Layout._will.length=0;
			});
		}
		Layout._will.push(element);
	}

	Layout.layout=function(element){
		if (!element || !element._style)return null;
		if ((element._style._type & /*laya.display.css.CSSStyle.ADDLAYOUTED*/0x200)===0)
			return null;
		element.getStyle()._type &=~ /*laya.display.css.CSSStyle.ADDLAYOUTED*/0x200;
		var arr=Layout._multiLineLayout(element);
		if (Render.isConchApp&&element["layaoutCallNative"]){
			(element).layaoutCallNative();
		}
		return arr;
	}

	Layout._multiLineLayout=function(element){
		if (Text.RightToLeft)return Layout._multiLineLayout2(element);
		var elements=new Array;
		element._addChildsToLayout(elements);
		var i=0,n=elements.length,j=0;
		var style=element._getCSSStyle();
		var letterSpacing=style.letterSpacing;
		var leading=style.leading;
		var lineHeight=style.lineHeight;
		var widthAuto=style._widthAuto()|| !style.wordWrap;
		var width=widthAuto ? 999999 :element.width;
		var height=element.height;
		var maxWidth=0;
		var exWidth=style.italic ? style.fontSize / 3 :0;
		var align=style._getAlign();
		var valign=style._getValign();
		var endAdjust=valign!==0 || align!==0 || lineHeight !=0;
		var oneLayout;
		var x=0;
		var y=0;
		var w=0;
		var h=0;
		var tBottom=0;
		var lines=new Array;
		var curStyle;
		var curPadding;
		var curLine=lines[0]=new LayoutLine();
		var newLine=false,nextNewline=false;
		var htmlWord;
		var sprite;
		curLine.h=0;
		if (style.italic)
			width-=style.fontSize / 3;
		var tWordWidth=0;
		var tLineFirstKey=true;
		function addLine (){
			curLine.y=y;
			y+=curLine.h+leading;
			if (curLine.h==0)y+=lineHeight;
			curLine.mWidth=tWordWidth;
			tWordWidth=0;
			curLine=new LayoutLine();
			lines.push(curLine);
			curLine.h=0;
			x=0;
			tLineFirstKey=true;
			newLine=false;
		}
		for (i=0;i < n;i++){
			oneLayout=elements[i];
			if (oneLayout==null){
				if (!tLineFirstKey){
					x+=Layout.DIV_ELEMENT_PADDING;
				}
				curLine.wordStartIndex=curLine.elements.length;
				continue ;
			}
			tLineFirstKey=false;
			if ((oneLayout instanceof laya.html.dom.HTMLBrElement )){
				addLine();
				curLine.y=y;
				continue ;
				}else if (oneLayout._isChar()){
				htmlWord=oneLayout;
				if (!htmlWord.isWord){
					if (lines.length > 0 && (x+w)> width && curLine.wordStartIndex > 0){
						var tLineWord=0;
						tLineWord=curLine.elements.length-curLine.wordStartIndex+1;
						curLine.elements.length=curLine.wordStartIndex;
						i-=tLineWord;
						addLine();
						continue ;
					}
					newLine=false;
					tWordWidth+=htmlWord.width;
					}else {
					newLine=nextNewline || (htmlWord.char==='\n');
					curLine.wordStartIndex=curLine.elements.length;
				}
				w=htmlWord.width+letterSpacing;
				h=htmlWord.height;
				nextNewline=false;
				newLine=newLine || ((x+w)> width);
				newLine && addLine();
				curLine.minTextHeight=Math.min(curLine.minTextHeight,oneLayout.height);
				}else {
				curStyle=oneLayout._getCSSStyle();
				sprite=oneLayout;
				curPadding=curStyle.padding;
				curStyle._getCssFloat()===0 || (endAdjust=true);
				newLine=nextNewline || curStyle.lineElement;
				w=sprite.width *sprite._style._tf.scaleX+curPadding[1]+curPadding[3]+letterSpacing;
				h=sprite.height *sprite._style._tf.scaleY+curPadding[0]+curPadding[2];
				nextNewline=curStyle.lineElement;
				newLine=newLine || ((x+w)> width && curStyle.wordWrap);
				newLine && addLine();
			}
			curLine.elements.push(oneLayout);
			curLine.h=Math.max(curLine.h,h);
			oneLayout.x=x;
			oneLayout.y=y;
			x+=w;
			curLine.w=x-letterSpacing;
			curLine.y=y;
			maxWidth=Math.max(x+exWidth,maxWidth);
		}
		y=curLine.y+curLine.h;
		if (endAdjust){
			var tY=0;
			var tWidth=width;
			if (widthAuto && element.width > 0){
				tWidth=element.width;
			}
			for (i=0,n=lines.length;i < n;i++){
				lines[i].updatePos(0,tWidth,i,tY,align,valign,lineHeight);
				tY+=Math.max(lineHeight,lines[i].h+leading);
			}
			y=tY;
		}
		widthAuto && (element.width=maxWidth);
		(y > element.height)&& (element.height=y);
		return [maxWidth,y];
	}

	Layout._multiLineLayout2=function(element){
		var elements=new Array;
		element._addChildsToLayout(elements);
		var i=0,n=elements.length,j=0;
		var style=element._getCSSStyle();
		var letterSpacing=style.letterSpacing;
		var leading=style.leading;
		var lineHeight=style.lineHeight;
		var widthAuto=style._widthAuto()|| !style.wordWrap;
		var width=widthAuto ? 999999 :element.width;
		var height=element.height;
		var maxWidth=0;
		var exWidth=style.italic ? style.fontSize / 3 :0;
		var align=2-style._getAlign();
		var valign=style._getValign();
		var endAdjust=valign!==0 || align!==0 || lineHeight !=0;
		var oneLayout;
		var x=0;
		var y=0;
		var w=0;
		var h=0;
		var tBottom=0;
		var lines=new Array;
		var curStyle;
		var curPadding;
		var curLine=lines[0]=new LayoutLine();
		var newLine=false,nextNewline=false;
		var htmlWord;
		var sprite;
		curLine.h=0;
		if (style.italic)
			width-=style.fontSize / 3;
		var tWordWidth=0;
		var tLineFirstKey=true;
		function addLine (){
			curLine.y=y;
			y+=curLine.h+leading;
			if (curLine.h==0)y+=lineHeight;
			curLine.mWidth=tWordWidth;
			tWordWidth=0;
			curLine=new LayoutLine();
			lines.push(curLine);
			curLine.h=0;
			x=0;
			tLineFirstKey=true;
			newLine=false;
		}
		for (i=0;i < n;i++){
			oneLayout=elements[i];
			if (oneLayout==null){
				if (!tLineFirstKey){
					x+=Layout.DIV_ELEMENT_PADDING;
				}
				curLine.wordStartIndex=curLine.elements.length;
				continue ;
			}
			tLineFirstKey=false;
			if ((oneLayout instanceof laya.html.dom.HTMLBrElement )){
				addLine();
				curLine.y=y;
				continue ;
				}else if (oneLayout._isChar()){
				htmlWord=oneLayout;
				if (!htmlWord.isWord){
					if (lines.length > 0 && (x+w)> width && curLine.wordStartIndex > 0){
						var tLineWord=0;
						tLineWord=curLine.elements.length-curLine.wordStartIndex+1;
						curLine.elements.length=curLine.wordStartIndex;
						i-=tLineWord;
						addLine();
						continue ;
					}
					newLine=false;
					tWordWidth+=htmlWord.width;
					}else {
					newLine=nextNewline || (htmlWord.char==='\n');
					curLine.wordStartIndex=curLine.elements.length;
				}
				w=htmlWord.width+letterSpacing;
				h=htmlWord.height;
				nextNewline=false;
				newLine=newLine || ((x+w)> width);
				newLine && addLine();
				curLine.minTextHeight=Math.min(curLine.minTextHeight,oneLayout.height);
				}else {
				curStyle=oneLayout._getCSSStyle();
				sprite=oneLayout;
				curPadding=curStyle.padding;
				curStyle._getCssFloat()===0 || (endAdjust=true);
				newLine=nextNewline || curStyle.lineElement;
				w=sprite.width *sprite._style._tf.scaleX+curPadding[1]+curPadding[3]+letterSpacing;
				h=sprite.height *sprite._style._tf.scaleY+curPadding[0]+curPadding[2];
				nextNewline=curStyle.lineElement;
				newLine=newLine || ((x+w)> width && curStyle.wordWrap);
				newLine && addLine();
			}
			curLine.elements.push(oneLayout);
			curLine.h=Math.max(curLine.h,h);
			oneLayout.x=x;
			oneLayout.y=y;
			x+=w;
			curLine.w=x-letterSpacing;
			curLine.y=y;
			maxWidth=Math.max(x+exWidth,maxWidth);
		}
		y=curLine.y+curLine.h;
		if (endAdjust){
			var tY=0;
			var tWidth=width;
			for (i=0,n=lines.length;i < n;i++){
				lines[i].updatePos(0,tWidth,i,tY,align,valign,lineHeight);
				tY+=Math.max(lineHeight,lines[i].h+leading);
			}
			y=tY;
		}
		widthAuto && (element.width=maxWidth);
		(y > element.height)&& (element.height=y);
		for (i=0,n=lines.length;i < n;i++){
			lines[i].revertOrder(width);
		}
		return [maxWidth,y];
	}

	Layout._will=null;
	Layout.DIV_ELEMENT_PADDING=0;
	return Layout;
})()


/**
*@private
*/
//class laya.html.utils.LayoutLine
var LayoutLine=(function(){
	function LayoutLine(){
		this.x=0;
		this.y=0;
		this.w=0;
		this.h=0;
		this.wordStartIndex=0;
		this.minTextHeight=99999;
		this.mWidth=0;
		this.elements=new Array;
	}

	__class(LayoutLine,'laya.html.utils.LayoutLine');
	var __proto=LayoutLine.prototype;
	/**
	*底对齐（默认）
	*@param left
	*@param width
	*@param dy
	*@param align 水平
	*@param valign 垂直
	*@param lineHeight 行高
	*/
	__proto.updatePos=function(left,width,lineNum,dy,align,valign,lineHeight){
		var w=0;
		var one
		if (this.elements.length > 0){
			one=this.elements[this.elements.length-1];
			w=one.x+one.width-this.elements[0].x;
		};
		var dx=0,ddy=NaN;
		align===/*laya.display.css.CSSStyle.ALIGN_CENTER*/1 && (dx=(width-w)/ 2);
		align===/*laya.display.css.CSSStyle.ALIGN_RIGHT*/2 && (dx=(width-w));
		lineHeight===0 || valign !=0 || (valign=1);
		for (var i=0,n=this.elements.length;i < n;i++){
			one=this.elements[i];
			var tCSSStyle=one._getCSSStyle();
			dx!==0 && (one.x+=dx);
			switch (tCSSStyle._getValign()){
				case 0:
					one.y=dy;
					break ;
				case /*laya.display.css.CSSStyle.VALIGN_MIDDLE*/1:;
					var tMinTextHeight=0;
					if (this.minTextHeight !=99999){
						tMinTextHeight=this.minTextHeight;
					};
					var tBottomLineY=(tMinTextHeight+lineHeight)/ 2;
					tBottomLineY=Math.max(tBottomLineY,this.h);
					if ((one instanceof laya.html.dom.HTMLImageElement )){
						ddy=dy+tBottomLineY-one.height;
						}else {
						ddy=dy+tBottomLineY-one.height;
					}
					one.y=ddy;
					break ;
				case /*laya.display.css.CSSStyle.VALIGN_BOTTOM*/2:
					one.y=dy+(lineHeight-one.height);
					break ;
				}
		}
	}

	/**
	*布局反向,目前用于将ltr模式布局转为rtl模式布局
	*/
	__proto.revertOrder=function(width){
		var one
		if (this.elements.length > 0){
			var i=0,len=0;
			len=this.elements.length;
			for (i=0;i < len;i++){
				one=this.elements[i];
				one.x=width-one.x-one.width;
			}
		}
	}

	return LayoutLine;
})()


/**
*@private
*/
//class laya.html.dom.HTMLElement extends laya.display.Sprite
var HTMLElement=(function(_super){
	function HTMLElement(){
		this.URI=null;
		this._href=null;
		HTMLElement.__super.call(this);
		this._text=HTMLElement._EMPTYTEXT;
		this.setStyle(new CSSStyle(this));
		this._getCSSStyle().valign="middle";
		this.mouseEnabled=true;
	}

	__class(HTMLElement,'laya.html.dom.HTMLElement',_super);
	var __proto=HTMLElement.prototype;
	/**
	*@private
	*/
	__proto.layaoutCallNative=function(){
		var n=0;
		if (this._childs &&(n=this._childs.length)> 0){
			for (var i=0;i < n;i++){
				this._childs[i].layaoutCallNative && this._childs[i].layaoutCallNative();
			}
		};
		var word=this._getWords();
		word ? laya.html.dom.HTMLElement.fillWords(this,word,0,0,this.style.font,this.style.color,this.style.underLine):this.graphics.clear();
	}

	__proto.appendChild=function(c){
		return this.addChild(c);
	}

	/**
	*rtl模式的getWords函數
	*/
	__proto._getWords2=function(){
		var txt=this._text.text;
		if (!txt || txt.length===0)
			return null;
		var i=0,n=0;
		var realWords;
		var drawWords;
		if (!this._text.drawWords){
			realWords=txt.split(" ");
			n=realWords.length-1;
			drawWords=[];
			for (i=0;i < n;i++){
				drawWords.push(realWords[i]," ")
			}
			if(n>=0)
				drawWords.push(realWords[n]);
			this._text.drawWords=drawWords;
			}else{
			drawWords=this._text.drawWords;
		};
		var words=this._text.words;
		if (words && words.length===drawWords.length)
			return words;
		words===null && (this._text.words=words=[]);
		words.length=drawWords.length;
		var size;
		var style=this.style;
		var fontStr=style.font;
		for (i=0,n=drawWords.length;i < n;i++){
			size=Utils.measureText(drawWords[i],fontStr);
			var tHTMLChar=words[i]=new HTMLChar(drawWords[i],size.width,size.height || style.fontSize,style);
			if (tHTMLChar.char.length > 1){
				tHTMLChar.charNum=tHTMLChar.char;
			}
			if (this.href){
				var tSprite=new Sprite();
				this.addChild(tSprite);
				tHTMLChar.setSprite(tSprite);
			}
		}
		return words;
	}

	__proto._getWords=function(){
		if (!Text.CharacterCache)return this._getWords2();
		var txt=this._text.text;
		if (!txt || txt.length===0)
			return null;
		var words=this._text.words;
		if (words && words.length===txt.length)
			return words;
		words===null && (this._text.words=words=[]);
		words.length=txt.length;
		var size;
		var style=this.style;
		var fontStr=style.font;
		var startX=0;
		for (var i=0,n=txt.length;i < n;i++){
			size=Utils.measureText(txt.charAt(i),fontStr);
			var tHTMLChar=words[i]=new HTMLChar(txt.charAt(i),size.width,size.height||style.fontSize,style);
			if (this.href){
				var tSprite=new Sprite();
				this.addChild(tSprite);
				tHTMLChar.setSprite(tSprite);
			}
		}
		return words;
	}

	__proto.showLinkSprite=function(){
		var words=this._text.words;
		if (words){
			var tLinkSpriteList=[];
			var tSprite;
			var tHtmlChar;
			for (var i=0;i < words.length;i++){
				tHtmlChar=words[i];
				tSprite=new Sprite();
				tSprite.graphics.drawRect(0,0,tHtmlChar.width,tHtmlChar.height,"#ff0000");
				tSprite.width=tHtmlChar.width;
				tSprite.height=tHtmlChar.height;
				this.addChild(tSprite);
				tLinkSpriteList.push(tSprite);
			}
		}
	}

	__proto._layoutLater=function(){
		var style=this.style;
		if ((style._type & /*laya.display.css.CSSStyle.ADDLAYOUTED*/0x200))return;
		if (style.widthed(this)&& (this._childs.length>0 || this._getWords()!=null)&& style.block){
			Layout.later(this);
			style._type |=/*laya.display.css.CSSStyle.ADDLAYOUTED*/0x200;
		}
		else{
			this.parent && (this.parent)._layoutLater();
		}
	}

	__proto._setAttributes=function(name,value){
		switch (name){
			case 'style':
				this.style.cssText(value);
				return;
			case 'class':
				this.className=value;
				return;
			}
		_super.prototype._setAttributes.call(this,name,value);
	}

	__proto.updateHref=function(){
		if (this._href !=null){
			var words=this._getWords();
			if (words){
				var tHTMLChar;
				var tSprite;
				for (var i=0;i < words.length;i++){
					tHTMLChar=words[i];
					tSprite=tHTMLChar.getSprite();
					if (tSprite){
						tSprite.size(tHTMLChar.width,tHTMLChar.height);
						tSprite.on(/*laya.events.Event.CLICK*/"click",this,this.onLinkHandler);
					}
				}
			}
		}
	}

	__proto.onLinkHandler=function(e){
		switch(e.type){
			case /*laya.events.Event.CLICK*/"click":;
				var target=this;
				while (target){
					target.event(/*laya.events.Event.LINK*/"link",[this.href]);
					target=target.parent;
				}
				break ;
			}
	}

	__proto.formatURL=function(url){
		if (!this.URI)return url;
		return URL.formatURL(url,this.URI ? this.URI.path :null);
	}

	__getset(0,__proto,'href',function(){
		return this._href;
		},function(url){
		this._href=url;
		if (url !=null){
			this._getCSSStyle().underLine=1;
			this.updateHref();
		}
	});

	__getset(0,__proto,'color',null,function(value){
		this.style.color=value;
	});

	__getset(0,__proto,'onClick',null,function(value){
		var fn;
		Laya._runScript("fn=function(event){"+value+";}");
		this.on(/*laya.events.Event.CLICK*/"click",this,fn);
	});

	__getset(0,__proto,'id',null,function(value){
		HTMLDocument.document.setElementById(value,this);
	});

	__getset(0,__proto,'innerTEXT',function(){
		return this._text.text;
		},function(value){
		this.text=value;
	});

	__getset(0,__proto,'style',function(){
		return this._style;
	});

	__getset(0,__proto,'text',function(){
		return this._text.text;
		},function(value){
		if (this._text==HTMLElement._EMPTYTEXT){
			this._text={text:value,words:null};
		}
		else{
			this._text.text=value;
			this._text.words && (this._text.words.length=0);
		}
		Render.isConchApp && this.layaoutCallNative();
		this._renderType |=/*laya.renders.RenderSprite.CHILDS*/0x800;
		this.repaint();
		this.updateHref();
	});

	__getset(0,__proto,'parent',_super.prototype._$get_parent,function(value){
		if ((value instanceof laya.html.dom.HTMLElement )){
			var p=value;
			this.URI || (this.URI=p.URI);
			this.style.inherit(p.style);
		}
		Laya.superSet(Sprite,this,'parent',value);
	});

	__getset(0,__proto,'className',null,function(value){
		this.style.attrs(HTMLDocument.document.styleSheets['.'+value]);
	});

	HTMLElement.fillWords=function(ele,words,x,y,font,color,underLine){
		ele.graphics.clear();
		for (var i=0,n=words.length;i < n;i++){
			var a=words[i];
			ele.graphics.fillText(a.char,a.x+x,a.y+y,font,color,'left',underLine);
		}
	}

	HTMLElement._EMPTYTEXT={text:null,words:null};
	return HTMLElement;
})(Sprite)


/**
*@private
*/
//class laya.html.dom.HTMLBrElement extends laya.html.dom.HTMLElement
var HTMLBrElement=(function(_super){
	function HTMLBrElement(){
		HTMLBrElement.__super.call(this);
		this.style.lineElement=true;
		this.style.block=true;
	}

	__class(HTMLBrElement,'laya.html.dom.HTMLBrElement',_super);
	return HTMLBrElement;
})(HTMLElement)


/**
*DIV标签
*/
//class laya.html.dom.HTMLDivElement extends laya.html.dom.HTMLElement
var HTMLDivElement=(function(_super){
	function HTMLDivElement(){
		/**实际内容的高 */
		this.contextHeight=NaN;
		/**实际内容的宽 */
		this.contextWidth=NaN;
		HTMLDivElement.__super.call(this);
		this.style.block=true;
		this.style.lineElement=true;
		this.style.width=200;
		this.style.height=200;
		HTMLStyleElement;
	}

	__class(HTMLDivElement,'laya.html.dom.HTMLDivElement',_super);
	var __proto=HTMLDivElement.prototype;
	/**
	*追加内容，解析并对显示对象排版
	*@param text
	*/
	__proto.appendHTML=function(text){
		HTMLParse.parse(this,text,this.URI);
		this.layout();
	}

	/**
	*@private
	*@param out
	*@return
	*/
	__proto._addChildsToLayout=function(out){
		var words=this._getWords();
		if (words==null && this._childs.length==0)return false;
		words && words.forEach(function(o){
			out.push(o);
		});
		var tFirstKey=true;
		for (var i=0,len=this._childs.length;i < len;i++){
			var o=this._childs[i];
			if (tFirstKey){
				tFirstKey=false;
				}else {
				out.push(null);
			}
			o._addToLayout(out)
		}
		return true;
	}

	/**
	*@private
	*@param out
	*/
	__proto._addToLayout=function(out){
		this.layout();
	}

	/**
	*@private
	*对显示内容进行排版
	*/
	__proto.layout=function(){
		if (!this.style)return;
		this.style._type |=/*laya.display.css.CSSStyle.ADDLAYOUTED*/0x200;
		var tArray=Layout.layout(this);
		if (tArray){
			if (!this._$P.mHtmlBounds)this._set$P("mHtmlBounds",new Rectangle());
			var tRectangle=this._$P.mHtmlBounds;
			tRectangle.x=tRectangle.y=0;
			tRectangle.width=this.contextWidth=tArray[0];
			tRectangle.height=this.contextHeight=tArray[1];
			this.setBounds(tRectangle);
		}
	}

	/**
	*获取对象的高
	*/
	__getset(0,__proto,'height',function(){
		if (this._height)return this._height;
		return this.contextHeight;
	},_super.prototype._$set_height);

	/**
	*设置标签内容
	*/
	__getset(0,__proto,'innerHTML',null,function(text){
		this.destroyChildren();
		this.appendHTML(text);
	});

	/**
	*获取对象的宽
	*/
	__getset(0,__proto,'width',function(){
		if (this._width)return this._width;
		return this.contextWidth;
		},function(value){
		var changed=false;
		if (value===0){
			changed=value !=this._width;
			}else{
			changed=value !=this.width;
		}
		Laya.superSet(HTMLElement,this,'width',value);
		if(changed)
			this.layout();
	});

	return HTMLDivElement;
})(HTMLElement)


/**
*@private
*/
//class laya.html.dom.HTMLDocument extends laya.html.dom.HTMLElement
var HTMLDocument=(function(_super){
	function HTMLDocument(){
		this.all=new Array;
		this.styleSheets=CSSStyle.styleSheets;
		HTMLDocument.__super.call(this);
	}

	__class(HTMLDocument,'laya.html.dom.HTMLDocument',_super);
	var __proto=HTMLDocument.prototype;
	__proto.getElementById=function(id){
		return this.all[id];
	}

	__proto.setElementById=function(id,e){
		this.all[id]=e;
	}

	__static(HTMLDocument,
	['document',function(){return this.document=new HTMLDocument();}
	]);
	return HTMLDocument;
})(HTMLElement)


/**
*@private
*/
//class laya.html.dom.HTMLImageElement extends laya.html.dom.HTMLElement
var HTMLImageElement=(function(_super){
	function HTMLImageElement(){
		this._tex=null;
		this._url=null;
		this._renderArgs=[];
		HTMLImageElement.__super.call(this);
		this.style.block=true;
	}

	__class(HTMLImageElement,'laya.html.dom.HTMLImageElement',_super);
	var __proto=HTMLImageElement.prototype;
	__proto._addToLayout=function(out){
		!this._style.absolute && out.push(this);
	}

	__proto.render=function(context,x,y){
		if (!this._tex || !this._tex.loaded || !this._tex.loaded || this._width < 1 || this._height < 1)return;
		Stat.spriteCount++;
		this._renderArgs[0]=this._tex;
		this._renderArgs[1]=this.x;
		this._renderArgs[2]=this.y;
		this._renderArgs[3]=this.width || this._tex.width;
		this._renderArgs[4]=this.height || this._tex.height;
		context.ctx.drawTexture2(x,y,this.style.translateX,this.style.translateY,this.transform,this.style.alpha,this.style.blendMode,this._renderArgs);
	}

	/**
	*@private
	*/
	__proto.layaoutCallNative=function(){
		var n=0;
		if (this._childs &&(n=this._childs.length)> 0){
			for (var i=0;i < n;i++){
				this._childs[i].layaoutCallNative && this._childs[i].layaoutCallNative();
			}
		}
	}

	__getset(0,__proto,'src',null,function(url){
		var _$this=this;
		url=this.formatURL(url);
		if (this._url==url)return;
		this._url=url;
		var tex=this._tex=Loader.getRes(url);
		if (!tex){
			this._tex=tex=new Texture();
			tex.load(url);
			Loader.cacheRes(url,tex);
		}
		function onloaded (){
			var style=_$this._style;
			var w=style.widthed(_$this)?-1:_$this._tex.width;
			var h=style.heighted(_$this)?-1:_$this._tex.height;
			if (!style.widthed(_$this)&& _$this._width !=_$this._tex.width){
				_$this.width=_$this._tex.width;
				_$this.parent && (_$this.parent)._layoutLater();
			}
			if (!style.heighted(_$this)&& _$this._height !=_$this._tex.height){
				_$this.height=_$this._tex.height;
				_$this.parent && (_$this.parent)._layoutLater();
			}
			if (Render.isConchApp){
				_$this._renderArgs[0]=_$this._tex;
				_$this._renderArgs[1]=_$this.x;
				_$this._renderArgs[2]=_$this.y;
				_$this._renderArgs[3]=_$this.width || _$this._tex.width;
				_$this._renderArgs[4]=_$this.height || _$this._tex.height;
				_$this.graphics.drawTexture(_$this._tex,0,0,_$this._renderArgs[3],_$this._renderArgs[4]);
			}
			_$this.repaint();
			_$this.parentRepaint();
		}
		tex.loaded?onloaded():tex.on(/*laya.events.Event.LOADED*/"loaded",null,onloaded);
	});

	return HTMLImageElement;
})(HTMLElement)


/**
*@private
*/
//class laya.html.dom.HTMLLinkElement extends laya.html.dom.HTMLElement
var HTMLLinkElement=(function(_super){
	function HTMLLinkElement(){
		this.type=null;
		HTMLLinkElement.__super.call(this);
		this.visible=false;
	}

	__class(HTMLLinkElement,'laya.html.dom.HTMLLinkElement',_super);
	var __proto=HTMLLinkElement.prototype;
	__proto._onload=function(data){
		switch(this.type){
			case 'text/css':
				CSSStyle.parseCSS(data,this.URI);
				break ;
			}
	}

	__getset(0,__proto,'href',_super.prototype._$get_href,function(url){
		var _$this=this;
		url=this.formatURL(url);
		this.URI=new URL(url);
		var l=new Loader();
		l.once(/*laya.events.Event.COMPLETE*/"complete",null,function(data){
			_$this._onload(data);
		});
		l.load(url,/*laya.net.Loader.TEXT*/"text");
	});

	HTMLLinkElement._cuttingStyle=new RegExp("((@keyframes[\\s\\t]+|)(.+))[\\t\\n\\r\\\s]*{","g");
	return HTMLLinkElement;
})(HTMLElement)


/**
*@private
*/
//class laya.html.dom.HTMLStyleElement extends laya.html.dom.HTMLElement
var HTMLStyleElement=(function(_super){
	function HTMLStyleElement(){
		HTMLStyleElement.__super.call(this);
		this.visible=false;
	}

	__class(HTMLStyleElement,'laya.html.dom.HTMLStyleElement',_super);
	var __proto=HTMLStyleElement.prototype;
	/**
	*解析样式
	*/
	__getset(0,__proto,'text',_super.prototype._$get_text,function(value){
		CSSStyle.parseCSS(value,null);
	});

	return HTMLStyleElement;
})(HTMLElement)


/**
*iframe标签类，目前用于加载外并解析数据
*/
//class laya.html.dom.HTMLIframeElement extends laya.html.dom.HTMLDivElement
var HTMLIframeElement=(function(_super){
	function HTMLIframeElement(){
		HTMLIframeElement.__super.call(this);
		this._getCSSStyle().valign="middle";
	}

	__class(HTMLIframeElement,'laya.html.dom.HTMLIframeElement',_super);
	var __proto=HTMLIframeElement.prototype;
	/**
	*加载html文件，并解析数据
	*@param url
	*/
	__getset(0,__proto,'href',_super.prototype._$get_href,function(url){
		var _$this=this;
		url=this.formatURL(url);
		var l=new Loader();
		l.once(/*laya.events.Event.COMPLETE*/"complete",null,function(data){
			var pre=_$this.URI;
			_$this.URI=new URL(url);
			_$this.innerHTML=data;
			!pre || (_$this.URI=pre);
		});
		l.load(url,/*laya.net.Loader.TEXT*/"text");
	});

	return HTMLIframeElement;
})(HTMLDivElement)



})(window,document,Laya);

if (typeof define === 'function' && define.amd){
	define('laya.core', ['require', "exports"], function(require, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        for (var i in Laya) {
			var o = Laya[i];
            o && o.__isclass && (exports[i] = o);
        }
    });
}

(function(window,document,Laya){
	var __un=Laya.un,__uns=Laya.uns,__static=Laya.static,__class=Laya.class,__getset=Laya.getset,__newvec=Laya.__newvec;

	var BlendMode=laya.webgl.canvas.BlendMode,Event=laya.events.Event,HTMLCanvas=laya.resource.HTMLCanvas;
	var Handler=laya.utils.Handler,IndexBuffer2D=laya.webgl.utils.IndexBuffer2D,Loader=laya.net.Loader,MathUtil=laya.maths.MathUtil;
	var Matrix=laya.maths.Matrix,Render=laya.renders.Render,RenderContext=laya.renders.RenderContext,RenderSprite=laya.renders.RenderSprite;
	var Shader=laya.webgl.shader.Shader,Sprite=laya.display.Sprite,Stat=laya.utils.Stat,Texture=laya.resource.Texture;
	var Utils=laya.utils.Utils,Value2D=laya.webgl.shader.d2.value.Value2D,VertexBuffer2D=laya.webgl.utils.VertexBuffer2D;
	var WebGL=laya.webgl.WebGL,WebGLContext=laya.webgl.WebGLContext;
/**
*<code>EmitterBase</code> 类是粒子发射器类
*/
//class laya.particle.emitter.EmitterBase
var EmitterBase=(function(){
	function EmitterBase(){
		/**
		*积累的帧时间
		*/
		this._frameTime=0;
		/**
		*粒子发射速率
		*/
		this._emissionRate=60;
		/**
		*当前剩余发射时间
		*/
		this._emissionTime=0;
		/**
		*发射粒子最小时间间隔
		*/
		this.minEmissionTime=1 / 60;
		/**@private */
		this._particleTemplate=null;
	}

	__class(EmitterBase,'laya.particle.emitter.EmitterBase');
	var __proto=EmitterBase.prototype;
	/**
	*开始发射粒子
	*@param duration 发射持续的时间(秒)
	*/
	__proto.start=function(duration){
		(duration===void 0)&& (duration=2147483647);
		if (this._emissionRate !=0)
			this._emissionTime=duration;
	}

	/**
	*停止发射粒子
	*@param clearParticles 是否清理当前的粒子
	*/
	__proto.stop=function(){
		this._emissionTime=0;
	}

	/**
	*清理当前的活跃粒子
	*@param clearTexture 是否清理贴图数据,若清除贴图数据将无法再播放
	*/
	__proto.clear=function(){
		this._emissionTime=0;
	}

	/**
	*发射一个粒子
	*
	*/
	__proto.emit=function(){}
	/**
	*时钟前进
	*@param passedTime 前进时间
	*
	*/
	__proto.advanceTime=function(passedTime){
		(passedTime===void 0)&& (passedTime=1);
		this._emissionTime-=passedTime;
		if (this._emissionTime < 0)return;
		this._frameTime+=passedTime;
		if (this._frameTime < this.minEmissionTime)return;
		while (this._frameTime > this.minEmissionTime){
			this._frameTime-=this.minEmissionTime;
			this.emit();
		}
	}

	/**
	*设置粒子粒子模板
	*@param particleTemplate 粒子模板
	*
	*/
	__getset(0,__proto,'particleTemplate',null,function(particleTemplate){
		this._particleTemplate=particleTemplate;
	});

	/**
	*设置粒子发射速率
	*@param emissionRate 粒子发射速率 (个/秒)
	*/
	/**
	*获取粒子发射速率
	*@return 发射速率 粒子发射速率 (个/秒)
	*/
	__getset(0,__proto,'emissionRate',function(){
		return this._emissionRate;
		},function(_emissionRate){
		if (_emissionRate <=0)return;
		this._emissionRate=_emissionRate;
		(_emissionRate > 0)&& (this.minEmissionTime=1 / _emissionRate);
	});

	return EmitterBase;
})()


/**
*@private
*/
//class laya.particle.ParticleData
var ParticleData=(function(){
	function ParticleData(){
		this.position=null;
		this.velocity=null;
		this.startColor=null;
		this.endColor=null;
		this.sizeRotation=null;
		this.radius=null;
		this.radian=null;
		this.durationAddScale=NaN;
		this.time=NaN;
	}

	__class(ParticleData,'laya.particle.ParticleData');
	ParticleData.Create=function(settings,position,velocity,time){
		var particleData=new ParticleData();
		particleData.position=position;
		MathUtil.scaleVector3(velocity,settings.emitterVelocitySensitivity,ParticleData._tempVelocity);
		var horizontalVelocity=MathUtil.lerp(settings.minHorizontalVelocity,settings.maxHorizontalVelocity,Math.random());
		var horizontalAngle=Math.random()*Math.PI *2;
		ParticleData._tempVelocity[0]+=horizontalVelocity *Math.cos(horizontalAngle);
		ParticleData._tempVelocity[2]+=horizontalVelocity *Math.sin(horizontalAngle);
		ParticleData._tempVelocity[1]+=MathUtil.lerp(settings.minVerticalVelocity,settings.maxVerticalVelocity,Math.random());
		particleData.velocity=ParticleData._tempVelocity;
		particleData.startColor=ParticleData._tempStartColor;
		particleData.endColor=ParticleData._tempEndColor;
		var i=0;
		if (settings.disableColor){
			for (i=0;i < 4;i++){
				particleData.startColor[i]=1;
				particleData.endColor[i]=1;
			}
		}
		else{
			if (settings.colorComponentInter){
				for (i=0;i < 4;i++){
					particleData.startColor[i]=MathUtil.lerp(settings.minStartColor[i],settings.maxStartColor[i],Math.random());
					particleData.endColor[i]=MathUtil.lerp(settings.minEndColor[i],settings.maxEndColor[i],Math.random());
				}
				}else {
				MathUtil.lerpVector4(settings.minStartColor,settings.maxStartColor,Math.random(),particleData.startColor);
				MathUtil.lerpVector4(settings.minEndColor,settings.maxEndColor,Math.random(),particleData.endColor);
			}
		}
		particleData.sizeRotation=ParticleData._tempSizeRotation;
		var sizeRandom=Math.random();
		particleData.sizeRotation[0]=MathUtil.lerp(settings.minStartSize,settings.maxStartSize,sizeRandom);
		particleData.sizeRotation[1]=MathUtil.lerp(settings.minEndSize,settings.maxEndSize,sizeRandom);
		particleData.sizeRotation[2]=MathUtil.lerp(settings.minRotateSpeed,settings.maxRotateSpeed,Math.random());
		particleData.radius=ParticleData._tempRadius;
		var radiusRandom=Math.random();
		particleData.radius[0]=MathUtil.lerp(settings.minStartRadius,settings.maxStartRadius,radiusRandom);
		particleData.radius[1]=MathUtil.lerp(settings.minEndRadius,settings.maxEndRadius,radiusRandom);
		particleData.radian=ParticleData._tempRadian;
		particleData.radian[0]=MathUtil.lerp(settings.minHorizontalStartRadian,settings.maxHorizontalStartRadian,Math.random());
		particleData.radian[1]=MathUtil.lerp(settings.minVerticalStartRadian,settings.maxVerticalStartRadian,Math.random());
		var useEndRadian=settings.useEndRadian;
		particleData.radian[2]=useEndRadian?MathUtil.lerp(settings.minHorizontalEndRadian,settings.maxHorizontalEndRadian,Math.random()):particleData.radian[0];
		particleData.radian[3]=useEndRadian?MathUtil.lerp(settings.minVerticalEndRadian,settings.maxVerticalEndRadian,Math.random()):particleData.radian[1];
		particleData.durationAddScale=settings.ageAddScale *Math.random();
		particleData.time=time;
		return particleData;
	}

	__static(ParticleData,
	['_tempVelocity',function(){return this._tempVelocity=new Float32Array(3);},'_tempStartColor',function(){return this._tempStartColor=new Float32Array(4);},'_tempEndColor',function(){return this._tempEndColor=new Float32Array(4);},'_tempSizeRotation',function(){return this._tempSizeRotation=new Float32Array(3);},'_tempRadius',function(){return this._tempRadius=new Float32Array(2);},'_tempRadian',function(){return this._tempRadian=new Float32Array(4);}
	]);
	return ParticleData;
})()


/**
*@private
*/
//class laya.particle.ParticleEmitter
var ParticleEmitter=(function(){
	function ParticleEmitter(templet,particlesPerSecond,initialPosition){
		this._templet=null;
		this._timeBetweenParticles=NaN;
		this._previousPosition=null;
		this._timeLeftOver=0;
		this._tempVelocity=new Float32Array([0,0,0]);
		this._tempPosition=new Float32Array([0,0,0]);
		this._templet=templet;
		this._timeBetweenParticles=1.0 / particlesPerSecond;
		this._previousPosition=initialPosition;
	}

	__class(ParticleEmitter,'laya.particle.ParticleEmitter');
	var __proto=ParticleEmitter.prototype;
	__proto.update=function(elapsedTime,newPosition){
		elapsedTime=elapsedTime / 1000;
		if (elapsedTime > 0){
			MathUtil.subtractVector3(newPosition,this._previousPosition,this._tempVelocity);
			MathUtil.scaleVector3(this._tempVelocity,1 / elapsedTime,this._tempVelocity);
			var timeToSpend=this._timeLeftOver+elapsedTime;
			var currentTime=-this._timeLeftOver;
			while (timeToSpend > this._timeBetweenParticles){
				currentTime+=this._timeBetweenParticles;
				timeToSpend-=this._timeBetweenParticles;
				MathUtil.lerpVector3(this._previousPosition,newPosition,currentTime / elapsedTime,this._tempPosition);
				this._templet.addParticleArray(this._tempPosition,this._tempVelocity);
			}
			this._timeLeftOver=timeToSpend;
		}
		this._previousPosition[0]=newPosition[0];
		this._previousPosition[1]=newPosition[1];
		this._previousPosition[2]=newPosition[2];
	}

	return ParticleEmitter;
})()


/**
*<code>ParticleSettings</code> 类是粒子配置数据类
*/
//class laya.particle.ParticleSetting
var ParticleSetting=(function(){
	function ParticleSetting(){
		/**贴图*/
		this.textureName=null;
		/**贴图个数,默认为1可不设置*/
		this.textureCount=1;
		/**最大同屏粒子个数，最大饱和粒子数为maxPartices-1。注意:WebGL模式下释放粒子时间为最大声明周期，可能会出现释放延迟,实际看到的同屏粒子数小于该数值，如连续喷发出现中断，请调大该数值。*/
		this.maxPartices=100;
		/**粒子持续时间(单位:秒）*/
		this.duration=1;
		/**如果大于0，某些粒子的持续时间会小于其他粒子,并具有随机性(单位:无）*/
		this.ageAddScale=0;
		/**粒子受发射器速度的敏感度（需在自定义发射器中编码设置）*/
		this.emitterVelocitySensitivity=1;
		/**最小开始尺寸（单位：2D像素、3D坐标）*/
		this.minStartSize=100;
		/**最大开始尺寸（单位：2D像素、3D坐标）*/
		this.maxStartSize=100;
		/**最小结束尺寸（单位：2D像素、3D坐标）*/
		this.minEndSize=100;
		/**最大结束尺寸（单位：2D像素、3D坐标）*/
		this.maxEndSize=100;
		/**最小水平速度（单位：2D像素、3D坐标）*/
		this.minHorizontalVelocity=0;
		/**最大水平速度（单位：2D像素、3D坐标）*/
		this.maxHorizontalVelocity=0;
		/**最小垂直速度（单位：2D像素、3D坐标）*/
		this.minVerticalVelocity=0;
		/**最大垂直速度（单位：2D像素、3D坐标）*/
		this.maxVerticalVelocity=0;
		/**等于1时粒子从出生到消亡保持一致的速度，等于0时粒子消亡时速度为0，大于1时粒子会保持加速（单位：无）*/
		this.endVelocity=1;
		/**最小旋转速度（单位：2D弧度/秒、3D弧度/秒）*/
		this.minRotateSpeed=0;
		/**最大旋转速度（单位：2D弧度/秒、3D弧度/秒）*/
		this.maxRotateSpeed=0;
		/**最小开始半径（单位：2D像素、3D坐标）*/
		this.minStartRadius=0;
		/**最大开始半径（单位：2D像素、3D坐标）*/
		this.maxStartRadius=0;
		/**最小结束半径（单位：2D像素、3D坐标）*/
		this.minEndRadius=0;
		/**最大结束半径（单位：2D像素、3D坐标）*/
		this.maxEndRadius=0;
		/**最小水平开始弧度（单位：2D弧度、3D弧度）*/
		this.minHorizontalStartRadian=0;
		/**最大水平开始弧度（单位：2D弧度、3D弧度）*/
		this.maxHorizontalStartRadian=0;
		/**最小垂直开始弧度（单位：2D弧度、3D弧度）*/
		this.minVerticalStartRadian=0;
		/**最大垂直开始弧度（单位：2D弧度、3D弧度）*/
		this.maxVerticalStartRadian=0;
		/**是否使用结束弧度,false为结束时与起始弧度保持一致,true为根据minHorizontalEndRadian、maxHorizontalEndRadian、minVerticalEndRadian、maxVerticalEndRadian计算结束弧度。*/
		this.useEndRadian=true;
		/**最小水平结束弧度（单位：2D弧度、3D弧度）*/
		this.minHorizontalEndRadian=0;
		/**最大水平结束弧度（单位：2D弧度、3D弧度）*/
		this.maxHorizontalEndRadian=0;
		/**最小垂直结束弧度（单位：2D弧度、3D弧度）*/
		this.minVerticalEndRadian=0;
		/**最大垂直结束弧度（单位：2D弧度、3D弧度）*/
		this.maxVerticalEndRadian=0;
		/**false代表RGBA整体插值，true代表RGBA逐分量插值*/
		this.colorComponentInter=false;
		/**false代表使用参数颜色数据，true代表使用原图颜色数据*/
		this.disableColor=false;
		/**混合模式，待调整，引擎中暂无BlendState抽象*/
		this.blendState=0;
		/**发射器类型,"point","box","sphere","ring"*/
		this.emitterType="null";
		/**发射器发射速率*/
		this.emissionRate=0;
		/**球发射器半径*/
		this.sphereEmitterRadius=1;
		/**球发射器速度*/
		this.sphereEmitterVelocity=0;
		/**球发射器速度随机值*/
		this.sphereEmitterVelocityAddVariance=0;
		/**环发射器半径*/
		this.ringEmitterRadius=30;
		/**环发射器速度*/
		this.ringEmitterVelocity=0;
		/**环发射器速度随机值*/
		this.ringEmitterVelocityAddVariance=0;
		/**环发射器up向量，0代表X轴,1代表Y轴,2代表Z轴*/
		this.ringEmitterUp=2;
		this.gravity=new Float32Array([0,0,0]);
		this.minStartColor=new Float32Array([1,1,1,1]);
		this.maxStartColor=new Float32Array([1,1,1,1]);
		this.minEndColor=new Float32Array([1,1,1,1]);
		this.maxEndColor=new Float32Array([1,1,1,1]);
		this.pointEmitterPosition=new Float32Array([0,0,0]);
		this.pointEmitterPositionVariance=new Float32Array([0,0,0]);
		this.pointEmitterVelocity=new Float32Array([0,0,0]);
		this.pointEmitterVelocityAddVariance=new Float32Array([0,0,0]);
		this.boxEmitterCenterPosition=new Float32Array([0,0,0]);
		this.boxEmitterSize=new Float32Array([0,0,0]);
		this.boxEmitterVelocity=new Float32Array([0,0,0]);
		this.boxEmitterVelocityAddVariance=new Float32Array([0,0,0]);
		this.sphereEmitterCenterPosition=new Float32Array([0,0,0]);
		this.ringEmitterCenterPosition=new Float32Array([0,0,0]);
		this.positionVariance=new Float32Array([0,0,0]);
	}

	__class(ParticleSetting,'laya.particle.ParticleSetting');
	ParticleSetting.checkSetting=function(setting){
		var key;
		for (key in ParticleSetting._defaultSetting){
			if (!setting.hasOwnProperty(key)){
				setting[key]=ParticleSetting._defaultSetting[key];
			}
		}
	}

	__static(ParticleSetting,
	['_defaultSetting',function(){return this._defaultSetting=new ParticleSetting();}
	]);
	return ParticleSetting;
})()


/**
*
*<code>ParticleTemplateBase</code> 类是粒子模板基类
*
*/
//class laya.particle.ParticleTemplateBase
var ParticleTemplateBase=(function(){
	function ParticleTemplateBase(){
		/**
		*粒子配置数据
		*/
		this.settings=null;
		/**
		*粒子贴图
		*/
		this.texture=null;
	}

	__class(ParticleTemplateBase,'laya.particle.ParticleTemplateBase');
	var __proto=ParticleTemplateBase.prototype;
	/**
	*添加一个粒子
	*@param position 粒子位置
	*@param velocity 粒子速度
	*
	*/
	__proto.addParticleArray=function(position,velocity){}
	return ParticleTemplateBase;
})()


/**
*@private
*/
//class laya.particle.particleUtils.CanvasShader
var CanvasShader=(function(){
	function CanvasShader(){
		this.u_Duration=NaN;
		this.u_EndVelocity=NaN;
		this.u_Gravity=null;
		this.a_Position=null;
		this.a_Velocity=null;
		this.a_StartColor=null;
		this.a_EndColor=null;
		this.a_SizeRotation=null;
		this.a_Radius=null;
		this.a_Radian=null;
		this.a_AgeAddScale=NaN;
		this.gl_Position=null;
		this.v_Color=null;
		this.oSize=NaN;
		this._color=new Float32Array(4);
		this._position=new Float32Array(3);
	}

	__class(CanvasShader,'laya.particle.particleUtils.CanvasShader');
	var __proto=CanvasShader.prototype;
	__proto.getLen=function(position){
		return Math.sqrt(position[0] *position[0]+position[1] *position[1]+position[2] *position[2]);
	}

	__proto.ComputeParticlePosition=function(position,velocity,age,normalizedAge){
		this._position[0]=position[0];
		this._position[1]=position[1];
		this._position[2]=position[2];
		var startVelocity=this.getLen(velocity);
		var endVelocity=startVelocity *this.u_EndVelocity;
		var velocityIntegral=startVelocity *normalizedAge+(endVelocity-startVelocity)*normalizedAge *normalizedAge / 2.0;
		var lenVelocity=NaN;
		lenVelocity=this.getLen(velocity);
		var i=0,len=0;
		len=3;
		for (i=0;i < len;i++){
			this._position[i]=this._position[i]+(velocity[i] / lenVelocity)*velocityIntegral *this.u_Duration;
			this._position[i]+=this.u_Gravity[i] *age *normalizedAge;
		};
		var radius=MathUtil.lerp(this.a_Radius[0],this.a_Radius[1],normalizedAge);
		var radianHorizontal=MathUtil.lerp(this.a_Radian[0],this.a_Radian[2],normalizedAge);
		var radianVertical=MathUtil.lerp(this.a_Radian[1],this.a_Radian[3],normalizedAge);
		var r=Math.cos(radianVertical)*radius;
		this._position[1]+=Math.sin(radianVertical)*radius;
		this._position[0]+=Math.cos(radianHorizontal)*r;
		this._position[2]+=Math.sin(radianHorizontal)*r;
		return new Float32Array([this._position[0],this._position[1],0.0,1.0]);
	}

	__proto.ComputeParticleSize=function(startSize,endSize,normalizedAge){
		var size=MathUtil.lerp(startSize,endSize,normalizedAge);
		return size;
	}

	__proto.ComputeParticleRotation=function(rot,age){
		return rot *age;
	}

	__proto.ComputeParticleColor=function(startColor,endColor,normalizedAge){
		var rst=this._color;
		MathUtil.lerpVector4(startColor,endColor,normalizedAge,rst);
		rst[3]=rst[3]*normalizedAge *(1.0-normalizedAge)*(1.0-normalizedAge)*6.7;
		return rst;
	}

	__proto.clamp=function(value,min,max){
		if(value<min)return min;
		if(value>max)return max;
		return value;
	}

	__proto.getData=function(age){
		age *=1.0+this.a_AgeAddScale;
		var normalizedAge=this.clamp(age / this.u_Duration,0.0,1.0);
		this.gl_Position=this.ComputeParticlePosition(this.a_Position,this.a_Velocity,age,normalizedAge);
		var pSize=this.ComputeParticleSize(this.a_SizeRotation[0],this.a_SizeRotation[1],normalizedAge);
		var rotation=this.ComputeParticleRotation(this.a_SizeRotation[2],age);
		this.v_Color=this.ComputeParticleColor(this.a_StartColor,this.a_EndColor,normalizedAge);
		var matric=new Matrix();
		var scale=NaN;
		scale=pSize/this.oSize*2;
		matric.scale(scale,scale);
		matric.rotate(rotation);
		matric.setTranslate(this.gl_Position[0],-this.gl_Position[1]);
		var alpha=NaN;
		alpha=this.v_Color[3];
		return [this.v_Color,alpha,matric,this.v_Color[0]*alpha,this.v_Color[1]*alpha,this.v_Color[2]*alpha];
	}

	return CanvasShader;
})()


/**
*
*@private
*
*@created 2015-8-25 下午3:41:07
*/
//class laya.particle.particleUtils.CMDParticle
var CMDParticle=(function(){
	function CMDParticle(){
		/**
		*最大帧
		*/
		this.maxIndex=0;
		/**
		*帧命令数组
		*/
		this.cmds=null;
		/**
		*粒子id
		*/
		this.id=0;
	}

	__class(CMDParticle,'laya.particle.particleUtils.CMDParticle');
	var __proto=CMDParticle.prototype;
	__proto.setCmds=function(cmds){
		this.cmds=cmds;
		this.maxIndex=cmds.length-1;
	}

	return CMDParticle;
})()


//class laya.particle.particleUtils.PicTool
var PicTool=(function(){
	function PicTool(){}
	__class(PicTool,'laya.particle.particleUtils.PicTool');
	PicTool.getCanvasPic=function(img,color){
		img=img.bitmap;
		var canvas=new HTMLCanvas("2D");
		var ctx=canvas.getContext('2d');
		canvas.size(img.width,img.height);
		var red=(color >> 16 & 0xFF);
		var green=(color >> 8 & 0xFF);
		var blue=(color & 0xFF);
		if(Render.isConchApp){
			ctx.setFilter(red/255,green/255,blue/255,0);
		}
		ctx.drawImage(img.source,0,0);
		if (!Render.isConchApp){
			var imgdata=ctx.getImageData(0,0,canvas.width,canvas.height);
			var data=imgdata.data;
			for (var i=0,n=data.length;i < n;i+=4){
				if (data[i+3]==0)continue ;
				data[i] *=red/255;
				data[i+1] *=green/255;
				data[i+2] *=blue/255;
			}
			ctx.putImageData(imgdata,0,0);
		}
		return canvas;
	}

	PicTool.getRGBPic=function(img){
		var rst;
		rst=[new Texture(PicTool.getCanvasPic(img,0xFF0000)),new Texture(PicTool.getCanvasPic(img,0x00FF00)),new Texture(PicTool.getCanvasPic(img,0x0000FF))];
		return rst;
	}

	return PicTool;
})()


/**
*
*@private
*/
//class laya.particle.emitter.Emitter2D extends laya.particle.emitter.EmitterBase
var Emitter2D=(function(_super){
	function Emitter2D(_template){
		this.setting=null;
		this._posRange=null;
		this._canvasTemplate=null;
		this._emitFun=null;
		Emitter2D.__super.call(this);
		this.template=_template;
	}

	__class(Emitter2D,'laya.particle.emitter.Emitter2D',_super);
	var __proto=Emitter2D.prototype;
	__proto.emit=function(){
		_super.prototype.emit.call(this);
		if(this._emitFun!=null)
			this._emitFun();
	}

	__proto.getRandom=function(value){
		return (Math.random()*2-1)*value;
	}

	__proto.webGLEmit=function(){
		var pos=new Float32Array(3);
		pos[0]=this.getRandom(this._posRange[0]);
		pos[1]=this.getRandom(this._posRange[1]);
		pos[2]=this.getRandom(this._posRange[2]);
		var v=new Float32Array(3);
		v[0]=0;
		v[1]=0;
		v[2]=0;
		this._particleTemplate.addParticleArray(pos,v);
	}

	__proto.canvasEmit=function(){
		var pos=new Float32Array(3);
		pos[0]=this.getRandom(this._posRange[0]);
		pos[1]=this.getRandom(this._posRange[1]);
		pos[2]=this.getRandom(this._posRange[2]);
		var v=new Float32Array(3);
		v[0]=0;
		v[1]=0;
		v[2]=0;
		this._particleTemplate.addParticleArray(pos,v);
	}

	__getset(0,__proto,'template',function(){
		return this._particleTemplate;
		},function(template){
		this._particleTemplate=template;
		if (!template){
			this._emitFun=null;
			this.setting=null;
			this._posRange=null;
		};
		this.setting=template.settings;
		this._posRange=this.setting.positionVariance;
		if((this._particleTemplate instanceof laya.particle.ParticleTemplate2D )){
			this._emitFun=this.webGLEmit;
		}else
		if((this._particleTemplate instanceof laya.particle.ParticleTemplateCanvas )){
			this._canvasTemplate=template;
			this._emitFun=this.canvasEmit;
		}
	});

	return Emitter2D;
})(EmitterBase)


/**
*@private
*/
//class laya.particle.ParticleTemplateWebGL extends laya.particle.ParticleTemplateBase
var ParticleTemplateWebGL=(function(_super){
	function ParticleTemplateWebGL(parSetting){
		this._vertices=null;
		this._vertexBuffer=null;
		this._indexBuffer=null;
		this._floatCountPerVertex=29;
		//0~3为CornerTextureCoordinate,4~6为Position,7~9Velocity,10到13为StartColor,14到17为EndColor,18到20位SizeRotation，21到22位Radius,23到26位Radian，27为DurationAddScaleShaderValue,28为Time
		this._firstActiveElement=0;
		this._firstNewElement=0;
		this._firstFreeElement=0;
		this._firstRetiredElement=0;
		this._currentTime=0;
		this._drawCounter=0;
		ParticleTemplateWebGL.__super.call(this);
		this.settings=parSetting;
	}

	__class(ParticleTemplateWebGL,'laya.particle.ParticleTemplateWebGL',_super);
	var __proto=ParticleTemplateWebGL.prototype;
	__proto.initialize=function(){
		this._vertices=new Float32Array(this.settings.maxPartices *this._floatCountPerVertex *4);
		var particleOffset=0;
		for (var i=0;i < this.settings.maxPartices;i++){
			var random=Math.random();
			var cornerYSegement=this.settings.textureCount ? 1.0 / this.settings.textureCount :1.0;
			var cornerY=NaN;
			for (cornerY=0;cornerY < this.settings.textureCount;cornerY+=cornerYSegement){
				if (random < cornerY+cornerYSegement)
					break ;
			}
			particleOffset=i *this._floatCountPerVertex *4;
			this._vertices[particleOffset+this._floatCountPerVertex *0+0]=-1;
			this._vertices[particleOffset+this._floatCountPerVertex *0+1]=-1;
			this._vertices[particleOffset+this._floatCountPerVertex *0+2]=0;
			this._vertices[particleOffset+this._floatCountPerVertex *0+3]=cornerY;
			this._vertices[particleOffset+this._floatCountPerVertex *1+0]=1;
			this._vertices[particleOffset+this._floatCountPerVertex *1+1]=-1;
			this._vertices[particleOffset+this._floatCountPerVertex *1+2]=1;
			this._vertices[particleOffset+this._floatCountPerVertex *1+3]=cornerY;
			this._vertices[particleOffset+this._floatCountPerVertex *2+0]=1;
			this._vertices[particleOffset+this._floatCountPerVertex *2+1]=1;
			this._vertices[particleOffset+this._floatCountPerVertex *2+2]=1;
			this._vertices[particleOffset+this._floatCountPerVertex *2+3]=cornerY+cornerYSegement;
			this._vertices[particleOffset+this._floatCountPerVertex *3+0]=-1;
			this._vertices[particleOffset+this._floatCountPerVertex *3+1]=1;
			this._vertices[particleOffset+this._floatCountPerVertex *3+2]=0;
			this._vertices[particleOffset+this._floatCountPerVertex *3+3]=cornerY+cornerYSegement;
		}
	}

	__proto.loadContent=function(){}
	__proto.update=function(elapsedTime){
		this._currentTime+=elapsedTime / 1000;
		this.retireActiveParticles();
		this.freeRetiredParticles();
		if (this._firstActiveElement==this._firstFreeElement)
			this._currentTime=0;
		if (this._firstRetiredElement==this._firstActiveElement)
			this._drawCounter=0;
	}

	__proto.retireActiveParticles=function(){
		var epsilon=0.0001;
		var particleDuration=this.settings.duration;
		while (this._firstActiveElement !=this._firstNewElement){
			var offset=this._firstActiveElement *this._floatCountPerVertex *4;
			var index=offset+28;
			var particleAge=this._currentTime-this._vertices[index];
			particleAge *=(1.0+this._vertices[offset+27]);
			if (particleAge+epsilon < particleDuration)
				break ;
			this._vertices[index]=this._drawCounter;
			this._firstActiveElement++;
			if (this._firstActiveElement >=this.settings.maxPartices)
				this._firstActiveElement=0;
		}
	}

	__proto.freeRetiredParticles=function(){
		while (this._firstRetiredElement !=this._firstActiveElement){
			var age=this._drawCounter-this._vertices[this._firstRetiredElement *this._floatCountPerVertex *4+28];
			if (age < 3)
				break ;
			this._firstRetiredElement++;
			if (this._firstRetiredElement >=this.settings.maxPartices)
				this._firstRetiredElement=0;
		}
	}

	__proto.addNewParticlesToVertexBuffer=function(){}
	__proto.addParticleArray=function(position,velocity){
		var nextFreeParticle=this._firstFreeElement+1;
		if (nextFreeParticle >=this.settings.maxPartices)
			nextFreeParticle=0;
		if (nextFreeParticle===this._firstRetiredElement)
			return;
		var particleData=ParticleData.Create(this.settings,position,velocity,this._currentTime);
		var startIndex=this._firstFreeElement *this._floatCountPerVertex *4;
		for (var i=0;i < 4;i++){
			var j=0,offset=0;
			for (j=0,offset=4;j < 3;j++)
			this._vertices[startIndex+i *this._floatCountPerVertex+offset+j]=particleData.position[j];
			for (j=0,offset=7;j < 3;j++)
			this._vertices[startIndex+i *this._floatCountPerVertex+offset+j]=particleData.velocity[j];
			for (j=0,offset=10;j < 4;j++)
			this._vertices[startIndex+i *this._floatCountPerVertex+offset+j]=particleData.startColor[j];
			for (j=0,offset=14;j < 4;j++)
			this._vertices[startIndex+i *this._floatCountPerVertex+offset+j]=particleData.endColor[j];
			for (j=0,offset=18;j < 3;j++)
			this._vertices[startIndex+i *this._floatCountPerVertex+offset+j]=particleData.sizeRotation[j];
			for (j=0,offset=21;j < 2;j++)
			this._vertices[startIndex+i *this._floatCountPerVertex+offset+j]=particleData.radius[j];
			for (j=0,offset=23;j < 4;j++)
			this._vertices[startIndex+i *this._floatCountPerVertex+offset+j]=particleData.radian[j];
			this._vertices[startIndex+i *this._floatCountPerVertex+27]=particleData.durationAddScale;
			this._vertices[startIndex+i *this._floatCountPerVertex+28]=particleData.time;
		}
		this._firstFreeElement=nextFreeParticle;
	}

	return ParticleTemplateWebGL;
})(ParticleTemplateBase)


/**
*@private
*/
//class laya.particle.ParticleTemplateCanvas extends laya.particle.ParticleTemplateBase
var ParticleTemplateCanvas=(function(_super){
	function ParticleTemplateCanvas(particleSetting){
		/**
		*是否处于可播放状态
		*/
		this._ready=false;
		/**
		*贴图列表
		*/
		this.textureList=[];
		/**
		*粒子列表
		*/
		this.particleList=[];
		/**
		*贴图中心偏移x
		*/
		this.pX=0;
		/**
		*贴图中心偏移y
		*/
		this.pY=0;
		/**
		*当前活跃的粒子
		*/
		this.activeParticles=[];
		/**
		*粒子pool
		*/
		this.deadParticles=[];
		/**
		*粒子播放进度列表
		*/
		this.iList=[];
		/**
		*粒子系统使用的最大粒子数
		*/
		this._maxNumParticles=0;
		/**
		*纹理的宽度
		*/
		this.textureWidth=NaN;
		/**
		*宽度倒数
		*/
		this.dTextureWidth=NaN;
		/**
		*是否支持颜色变化
		*/
		this.colorChange=true;
		/**
		*采样步长
		*/
		this.step=1/60;
		this.canvasShader=new CanvasShader();
		ParticleTemplateCanvas.__super.call(this);
		this.settings=particleSetting;
		this._maxNumParticles=particleSetting.maxPartices;
		this.texture=new Texture();
		this.texture.on(/*laya.events.Event.LOADED*/"loaded",this,this._textureLoaded);
		this.texture.load(particleSetting.textureName);
	}

	__class(ParticleTemplateCanvas,'laya.particle.ParticleTemplateCanvas',_super);
	var __proto=ParticleTemplateCanvas.prototype;
	__proto._textureLoaded=function(e){
		this.setTexture(this.texture);
		this._ready=true;
	}

	__proto.clear=function(clearTexture){
		(clearTexture===void 0)&& (clearTexture=true);
		this.deadParticles.length=0;
		this.activeParticles.length=0;
		this.textureList.length=0;
	}

	/**
	*设置纹理
	*@param texture
	*
	*/
	__proto.setTexture=function(texture){
		this.texture=texture;
		this.textureWidth=texture.width;
		this.dTextureWidth=1/this.textureWidth;
		this.pX=-texture.width*0.5;
		this.pY=-texture.height*0.5;
		this.textureList=ParticleTemplateCanvas.changeTexture(texture,this.textureList);
		this.particleList.length=0;
		this.deadParticles.length=0;
		this.activeParticles.length=0;
	}

	/**
	*创建一个粒子数据
	*@return
	*
	*/
	__proto._createAParticleData=function(position,velocity){
		this.canvasShader.u_EndVelocity=this.settings.endVelocity;
		this.canvasShader.u_Gravity=this.settings.gravity;
		this.canvasShader.u_Duration=this.settings.duration;
		var particle;
		particle=ParticleData.Create(this.settings,position,velocity,0);
		this.canvasShader.a_Position=particle.position;
		this.canvasShader.a_Velocity=particle.velocity;
		this.canvasShader.a_StartColor=particle.startColor;
		this.canvasShader.a_EndColor=particle.endColor;
		this.canvasShader.a_SizeRotation=particle.sizeRotation;
		this.canvasShader.a_Radius=particle.radius;
		this.canvasShader.a_Radian=particle.radian;
		this.canvasShader.a_AgeAddScale=particle.durationAddScale;
		this.canvasShader.oSize=this.textureWidth;
		var rst=new CMDParticle();
		var i=0,len=this.settings.duration/(1+particle.durationAddScale);
		var params=[];
		var mStep=NaN;
		for(i=0;i<len;i+=this.step){
			params.push(this.canvasShader.getData(i));
		}
		rst.id=this.particleList.length;
		this.particleList.push(rst);
		rst.setCmds(params);
		return rst;
	}

	__proto.addParticleArray=function(position,velocity){
		if(!this._ready)return;
		var tParticle;
		if(this.particleList.length<this._maxNumParticles){
			tParticle=this._createAParticleData(position,velocity);
			this.iList[tParticle.id]=0;
			this.activeParticles.push(tParticle);
			}else{
			if(this.deadParticles.length>0){
				tParticle=this.deadParticles.pop();
				this.iList[tParticle.id]=0;
				this.activeParticles.push(tParticle);
			}
		}
	}

	__proto.advanceTime=function(passedTime){
		(passedTime===void 0)&& (passedTime=1);
		if(!this._ready)return;
		var particleList=this.activeParticles;
		var pool=this.deadParticles;
		var i=0,len=particleList.length;
		var tcmd;
		var tI=0;
		var iList=this.iList;
		for(i=len-1;i>-1;i--){
			tcmd=particleList[i];
			tI=iList[tcmd.id];
			if(tI>=tcmd.maxIndex){
				tI=0;
				particleList.splice(i,1);
				pool.push(tcmd);
				}else{
				tI+=1;
			}
			iList[tcmd.id]=tI;
		}
	}

	__proto.render=function(context,x,y){
		if(!this._ready)return;
		if(this.activeParticles.length<1)return;
		if (this.textureList.length < 2)return;
		if (this.settings.disableColor){
			this.noColorRender(context,x,y);
			}else{
			this.canvasRender(context,x,y);
		}
	}

	__proto.noColorRender=function(context,x,y){
		var particleList=this.activeParticles;
		var i=0,len=particleList.length;
		var tcmd;
		var tParam;
		var tAlpha=NaN;
		var px=this.pX,py=this.pY;
		var pw=-px*2,ph=-py*2;
		var tI=0;
		var textureList=this.textureList;
		var iList=this.iList;
		var preAlpha=NaN;
		context.translate(x,y);
		preAlpha=context.ctx.globalAlpha;
		for(i=0;i<len;i++){
			tcmd=particleList[i];
			tI=iList[tcmd.id];
			tParam=tcmd.cmds[tI];
			if (!tParam)continue ;
			if ((tAlpha=tParam[1])<=0.01)continue ;
			context.setAlpha(preAlpha*tAlpha);
			context.drawTextureWithTransform(this.texture,px,py,pw,ph,tParam[2],1);
		}
		context.setAlpha(preAlpha);
		context.translate(-x,-y);
	}

	__proto.canvasRender=function(context,x,y){
		var particleList=this.activeParticles;
		var i=0,len=particleList.length;
		var tcmd;
		var tParam;
		var tAlpha=NaN;
		var px=this.pX,py=this.pY;
		var pw=-px*2,ph=-py*2;
		var tI=0;
		var textureList=this.textureList;
		var iList=this.iList;
		var preAlpha=NaN;
		var preB;
		context.translate(x,y);
		preAlpha=context.ctx.globalAlpha;
		preB=context.ctx.globalCompositeOperation;
		context.blendMode("lighter");
		for(i=0;i<len;i++){
			tcmd=particleList[i];
			tI=iList[tcmd.id];
			tParam=tcmd.cmds[tI];
			if (!tParam)continue ;
			if ((tAlpha=tParam[1])<=0.01)continue ;
			context.save();
			context.transformByMatrix(tParam[2]);
			if(tParam[3]>0.01){
				context.setAlpha(preAlpha*tParam[3]);
				context.drawTexture(textureList[0],px,py,pw,ph);
			}
			if(tParam[4]>0.01){
				context.setAlpha(preAlpha*tParam[4]);
				context.drawTexture(textureList[1],px,py,pw,ph);
			}
			if(tParam[5]>0.01){
				context.setAlpha(preAlpha*tParam[5]);
				context.drawTexture(textureList[2],px,py,pw,ph);
			}
			context.restore();
		}
		context.setAlpha(preAlpha);
		context.translate(-x,-y);
		context.blendMode(preB);
	}

	ParticleTemplateCanvas.changeTexture=function(texture,rst,settings){
		if(!rst)rst=[];
		rst.length=0;
		if (settings&&settings.disableColor){
			rst.push(texture,texture,texture);
			}else{
			Utils.copyArray(rst,PicTool.getRGBPic(texture));
		}
		return rst;
	}

	return ParticleTemplateCanvas;
})(ParticleTemplateBase)


/**
*@private
*/
//class laya.particle.ParticleTemplate2D extends laya.particle.ParticleTemplateWebGL
var ParticleTemplate2D=(function(_super){
	function ParticleTemplate2D(parSetting){
		this._vertexBuffer2D=null;
		this._indexBuffer2D=null;
		this.x=0;
		this.y=0;
		this._blendFn=null;
		this._startTime=0;
		this.sv=new ParticleShaderValue();
		ParticleTemplate2D.__super.call(this,parSetting);
		var _this=this;
		Laya.loader.load(this.settings.textureName,Handler.create(null,function(texture){
			(texture.bitmap).enableMerageInAtlas=false;
			_this.texture=texture;
		}));
		this.sv.u_Duration=this.settings.duration;
		this.sv.u_Gravity=this.settings.gravity;
		this.sv.u_EndVelocity=this.settings.endVelocity;
		this._blendFn=BlendMode.fns[parSetting.blendState];
		this.initialize();
		this._vertexBuffer=this._vertexBuffer2D=VertexBuffer2D.create(-1,/*laya.webgl.WebGLContext.DYNAMIC_DRAW*/0x88E8);
		this._indexBuffer=this._indexBuffer2D=IndexBuffer2D.create(/*laya.webgl.WebGLContext.STATIC_DRAW*/0x88E4);
		this.loadContent();
	}

	__class(ParticleTemplate2D,'laya.particle.ParticleTemplate2D',_super);
	var __proto=ParticleTemplate2D.prototype;
	Laya.imps(__proto,{"laya.webgl.submit.ISubmit":true})
	__proto.getRenderType=function(){return-111}
	__proto.releaseRender=function(){}
	__proto.addParticleArray=function(position,velocity){
		position[0]+=this.x;
		position[1]+=this.y;
		_super.prototype.addParticleArray.call(this,position,velocity);
	}

	__proto.loadContent=function(){
		var indexes=new Uint16Array(this.settings.maxPartices *6);
		for (var i=0;i < this.settings.maxPartices;i++){
			indexes[i *6+0]=(i *4+0);
			indexes[i *6+1]=(i *4+1);
			indexes[i *6+2]=(i *4+2);
			indexes[i *6+3]=(i *4+0);
			indexes[i *6+4]=(i *4+2);
			indexes[i *6+5]=(i *4+3);
		}
		this._indexBuffer2D.clear();
		this._indexBuffer2D.append(indexes);
		this._indexBuffer2D.upload();
	}

	__proto.addNewParticlesToVertexBuffer=function(){
		this._vertexBuffer2D.clear();
		this._vertexBuffer2D.append(this._vertices);
		var start=0;
		if (this._firstNewElement < this._firstFreeElement){
			start=this._firstNewElement *4 *this._floatCountPerVertex *4;
			this._vertexBuffer2D.subUpload(start,start,start+(this._firstFreeElement-this._firstNewElement)*4 *this._floatCountPerVertex *4);
			}else {
			start=this._firstNewElement *4 *this._floatCountPerVertex *4;
			this._vertexBuffer2D.subUpload(start,start,start+(this.settings.maxPartices-this._firstNewElement)*4 *this._floatCountPerVertex *4);
			if (this._firstFreeElement > 0){
				this._vertexBuffer2D.setNeedUpload();
				this._vertexBuffer2D.subUpload(0,0,this._firstFreeElement *4 *this._floatCountPerVertex *4);
			}
		}
		this._firstNewElement=this._firstFreeElement;
	}

	__proto.renderSubmit=function(){
		if (this.texture&&this.texture.loaded){
			this.update(Laya.timer.delta);
			this.sv.u_CurrentTime=this._currentTime;
			if (this._firstNewElement !=this._firstFreeElement){
				this.addNewParticlesToVertexBuffer();
			}
			this.blend();
			if (this._firstActiveElement !=this._firstFreeElement){
				var gl=WebGL.mainContext;
				this._vertexBuffer2D.bind(this._indexBuffer2D);
				this.sv.u_texture=this.texture.source;
				this.sv.upload();
				if (this._firstActiveElement < this._firstFreeElement){
					WebGL.mainContext.drawElements(/*laya.webgl.WebGLContext.TRIANGLES*/0x0004,(this._firstFreeElement-this._firstActiveElement)*6,/*laya.webgl.WebGLContext.UNSIGNED_SHORT*/0x1403,this._firstActiveElement *6 *2);
				}
				else{
					WebGL.mainContext.drawElements(/*laya.webgl.WebGLContext.TRIANGLES*/0x0004,(this.settings.maxPartices-this._firstActiveElement)*6,/*laya.webgl.WebGLContext.UNSIGNED_SHORT*/0x1403,this._firstActiveElement *6 *2);
					if (this._firstFreeElement > 0)
						WebGL.mainContext.drawElements(/*laya.webgl.WebGLContext.TRIANGLES*/0x0004,this._firstFreeElement *6,/*laya.webgl.WebGLContext.UNSIGNED_SHORT*/0x1403,0);
				}
				Stat.drawCall++;
			}
			this._drawCounter++;
		}
		return 1;
	}

	__proto.blend=function(){
		if (BlendMode.activeBlendFunction!==this._blendFn){
			var gl=WebGL.mainContext;
			gl.enable(/*laya.webgl.WebGLContext.BLEND*/0x0BE2);
			this._blendFn(gl);
			BlendMode.activeBlendFunction=this._blendFn;
		}
	}

	__proto.dispose=function(){
		this._vertexBuffer2D.dispose();
		this._indexBuffer2D.dispose();
	}

	ParticleTemplate2D.activeBlendType=-1;
	return ParticleTemplate2D;
})(ParticleTemplateWebGL)


/**
*@private
*/
//class laya.particle.shader.value.ParticleShaderValue extends laya.webgl.shader.d2.value.Value2D
var ParticleShaderValue=(function(_super){
	function ParticleShaderValue(){
		this.a_CornerTextureCoordinate=[4,/*laya.webgl.WebGLContext.FLOAT*/0x1406,false,116,0];
		this.a_Position=[3,/*laya.webgl.WebGLContext.FLOAT*/0x1406,false,116,16];
		this.a_Velocity=[3,/*laya.webgl.WebGLContext.FLOAT*/0x1406,false,116,28];
		this.a_StartColor=[4,/*laya.webgl.WebGLContext.FLOAT*/0x1406,false,116,40];
		this.a_EndColor=[4,/*laya.webgl.WebGLContext.FLOAT*/0x1406,false,116,56];
		this.a_SizeRotation=[3,/*laya.webgl.WebGLContext.FLOAT*/0x1406,false,116,72];
		this.a_Radius=[2,/*laya.webgl.WebGLContext.FLOAT*/0x1406,false,116,84];
		this.a_Radian=[4,/*laya.webgl.WebGLContext.FLOAT*/0x1406,false,116,92];
		this.a_AgeAddScale=[1,/*laya.webgl.WebGLContext.FLOAT*/0x1406,false,116,108];
		this.a_Time=[1,/*laya.webgl.WebGLContext.FLOAT*/0x1406,false,116,112];
		this.u_CurrentTime=NaN;
		this.u_Duration=NaN;
		this.u_Gravity=null;
		//v3
		this.u_EndVelocity=NaN;
		this.u_texture=null;
		ParticleShaderValue.__super.call(this,0,0);
	}

	__class(ParticleShaderValue,'laya.particle.shader.value.ParticleShaderValue',_super);
	var __proto=ParticleShaderValue.prototype;
	__proto.upload=function(){
		this.refresh();
		ParticleShaderValue.pShader.upload(this);
	}

	__static(ParticleShaderValue,
	['pShader',function(){return this.pShader=new ParticleShader();}
	]);
	return ParticleShaderValue;
})(Value2D)


/**
*<code>Particle2D</code> 类是2D粒子播放类
*
*/
//class laya.particle.Particle2D extends laya.display.Sprite
var Particle2D=(function(_super){
	function Particle2D(setting){
		/**@private */
		this._matrix4=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];
		/**@private */
		this._particleTemplate=null;
		/**@private */
		this._canvasTemplate=null;
		/**@private */
		this._emitter=null;
		/**是否自动播放*/
		this.autoPlay=true;
		Particle2D.__super.call(this);
		if (setting)this.setParticleSetting(setting);
	}

	__class(Particle2D,'laya.particle.Particle2D',_super);
	var __proto=Particle2D.prototype;
	/**
	*加载粒子文件
	*@param url 粒子文件地址
	*/
	__proto.load=function(url){
		Laya.loader.load(url,Handler.create(this,this.setParticleSetting),null,/*laya.net.Loader.JSON*/"json");
	}

	/**
	*设置粒子配置数据
	*@param settings 粒子配置数据
	*/
	__proto.setParticleSetting=function(setting){
		var _$this=this;
		if (!setting)return this.stop();
		ParticleSetting.checkSetting(setting);
		if(/*__JS__ */!window.ConchParticleTemplate2D||Render.isWebGL)this.customRenderEnable=true;
		if (Render.isWebGL){
			this._particleTemplate=new ParticleTemplate2D(setting);
			this.graphics._saveToCmd(Render.context._drawParticle,[this._particleTemplate]);
		}
		else if (Render.isConchApp&&/*__JS__ */window.ConchParticleTemplate2D){
			this._particleTemplate=/*__JS__ */new ConchParticleTemplate2D();
			var _this=this;
			Laya.loader.load(setting.textureName,Handler.create(null,function(texture){
				/*__JS__ */_this._particleTemplate.texture=texture;
				_this._particleTemplate.settings=setting;
				if (Render.isConchNode){
					/*__JS__ */_this.graphics.drawParticle(_this._particleTemplate);
				}
				else{
					_this.graphics._saveToCmd(Render.context._drawParticle,[_$this._particleTemplate]);
				}
			}));
			this._emitter={start:function (){}};
			/*__JS__ */this.play=this._particleTemplate.play.bind(this._particleTemplate);
			/*__JS__ */this.stop=this._particleTemplate.stop.bind(this._particleTemplate);
			if (this.autoPlay)this.play();
			return;
		}
		else {
			this._particleTemplate=this._canvasTemplate=new ParticleTemplateCanvas(setting);
		}
		if (!this._emitter){
			this._emitter=new Emitter2D(this._particleTemplate);
			}else {
			(this._emitter).template=this._particleTemplate;
		}
		if (this.autoPlay){
			this.emitter.start();
			this.play();
		}
	}

	/**
	*播放
	*/
	__proto.play=function(){
		this.timer.frameLoop(1,this,this._loop);
	}

	/**
	*停止
	*/
	__proto.stop=function(){
		this.timer.clear(this,this._loop);
	}

	/**@private */
	__proto._loop=function(){
		this.advanceTime(1 / 60);
	}

	/**
	*时钟前进
	*@param passedTime 时钟前进时间
	*/
	__proto.advanceTime=function(passedTime){
		(passedTime===void 0)&& (passedTime=1);
		if (this._canvasTemplate){
			this._canvasTemplate.advanceTime(passedTime);
		}
		if (this._emitter){
			this._emitter.advanceTime(passedTime);
		}
	}

	__proto.customRender=function(context,x,y){
		if (Render.isWebGL){
			this._matrix4[0]=context.ctx._curMat.a;
			this._matrix4[1]=context.ctx._curMat.b;
			this._matrix4[4]=context.ctx._curMat.c;
			this._matrix4[5]=context.ctx._curMat.d;
			this._matrix4[12]=context.ctx._curMat.tx;
			this._matrix4[13]=context.ctx._curMat.ty;
			var sv=(this._particleTemplate).sv;
			sv.u_mmat=this._matrix4;
		}
		if (this._canvasTemplate){
			this._canvasTemplate.render(context,x,y);
		}
	}

	__proto.destroy=function(destroyChild){
		(destroyChild===void 0)&& (destroyChild=true);
		if ((this._particleTemplate instanceof laya.particle.ParticleTemplate2D ))
			(this._particleTemplate).dispose();
		_super.prototype.destroy.call(this,destroyChild);
	}

	/**
	*设置 粒子文件地址
	*@param path 粒子文件地址
	*/
	__getset(0,__proto,'url',null,function(url){
		this.load(url);
	});

	/**
	*获取粒子发射器
	*/
	__getset(0,__proto,'emitter',function(){
		return this._emitter;
	});

	return Particle2D;
})(Sprite)


/**
*@private
*/
//class laya.particle.shader.ParticleShader extends laya.webgl.shader.Shader
var ParticleShader=(function(_super){
	function ParticleShader(){
		ParticleShader.__super.call(this,ParticleShader.vs,ParticleShader.ps,"ParticleShader");
	}

	__class(ParticleShader,'laya.particle.shader.ParticleShader',_super);
	__static(ParticleShader,
	['vs',function(){return this.vs="attribute vec4 a_CornerTextureCoordinate;\nattribute vec3 a_Position;\nattribute vec3 a_Velocity;\nattribute vec4 a_StartColor;\nattribute vec4 a_EndColor;\nattribute vec3 a_SizeRotation;\nattribute vec2 a_Radius;\nattribute vec4 a_Radian;\nattribute float a_AgeAddScale;\nattribute float a_Time;\n\nvarying vec4 v_Color;\nvarying vec2 v_TextureCoordinate;\n\nuniform float u_CurrentTime;\nuniform float u_Duration;\nuniform float u_EndVelocity;\nuniform vec3 u_Gravity;\n\n#ifdef PARTICLE3D\n uniform mat4 u_WorldMat;\n uniform mat4 u_View;\n uniform mat4 u_Projection;\n uniform vec2 u_ViewportScale;\n#else\n uniform vec2 size;\n uniform mat4 mmat;\n uniform mat4 u_mmat;\n#endif\n\nvec4 ComputeParticlePosition(in vec3 position, in vec3 velocity,in float age,in float normalizedAge)\n{\n\n   float startVelocity = length(velocity);//起始标量速度\n   float endVelocity = startVelocity * u_EndVelocity;//结束标量速度\n\n   float velocityIntegral = startVelocity * normalizedAge +(endVelocity - startVelocity) * normalizedAge *normalizedAge/2.0;//计算当前速度的标量（单位空间），vt=v0*t+(1/2)*a*(t^2)\n   \n   vec3 addPosition = normalize(velocity) * velocityIntegral * u_Duration;//计算受自身速度影响的位置，转换标量到矢量    \n   addPosition += u_Gravity * age * normalizedAge;//计算受重力影响的位置\n   \n   float radius=mix(a_Radius.x, a_Radius.y, normalizedAge); //计算粒子受半径和角度影响（无需计算角度和半径时，可用宏定义优化屏蔽此计算）\n   float radianHorizontal =mix(a_Radian.x,a_Radian.z,normalizedAge);\n   float radianVertical =mix(a_Radian.y,a_Radian.w,normalizedAge);\n   \n   float r =cos(radianVertical)* radius;\n   addPosition.y += sin(radianVertical) * radius;\n	\n   addPosition.x += cos(radianHorizontal) *r;\n   addPosition.z += sin(radianHorizontal) *r;\n  \n   #ifdef PARTICLE3D\n   position+=addPosition;\n    return  u_Projection*u_View*u_WorldMat*(vec4(position, 1.0));\n   #else\n   addPosition.y=-addPosition.y;//2D粒子位置更新需要取负，2D粒子坐标系Y轴正向朝上\n   position+=addPosition;\n    return  vec4(position,1.0);\n   #endif\n}\n\nfloat ComputeParticleSize(in float startSize,in float endSize, in float normalizedAge)\n{    \n    float size = mix(startSize, endSize, normalizedAge);\n    \n	#ifdef PARTICLE3D\n    //Project the size into screen coordinates.\n     return size * u_Projection[1][1];\n	#else\n	 return size;\n	#endif\n}\n\nmat2 ComputeParticleRotation(in float rot,in float age)\n{    \n    float rotation =rot * age;\n    //计算2x2旋转矩阵.\n    float c = cos(rotation);\n    float s = sin(rotation);\n    return mat2(c, -s, s, c);\n}\n\nvec4 ComputeParticleColor(in vec4 startColor,in vec4 endColor,in float normalizedAge)\n{\n	vec4 color=mix(startColor,endColor,normalizedAge);\n    //硬编码设置，使粒子淡入很快，淡出很慢,6.7的缩放因子把置归一在0到1之间，可以谷歌x*(1-x)*(1-x)*6.7的制图表\n    color.a *= normalizedAge * (1.0-normalizedAge) * (1.0-normalizedAge) * 6.7;\n   \n    return color;\n}\n\nvoid main()\n{\n   float age = u_CurrentTime - a_Time;\n   age *= 1.0 + a_AgeAddScale;\n   float normalizedAge = clamp(age / u_Duration,0.0,1.0);\n   gl_Position = ComputeParticlePosition(a_Position, a_Velocity, age, normalizedAge);//计算粒子位置\n   float pSize = ComputeParticleSize(a_SizeRotation.x,a_SizeRotation.y, normalizedAge);\n   mat2 rotation = ComputeParticleRotation(a_SizeRotation.z, age);\n	\n   #ifdef PARTICLE3D\n	gl_Position.xy += (rotation*a_CornerTextureCoordinate.xy) * pSize * u_ViewportScale;\n   #else\n    mat4 mat=u_mmat*mmat;\n    gl_Position=vec4((mat*gl_Position).xy,0.0,1.0);\n	gl_Position.xy += (rotation*a_CornerTextureCoordinate.xy) * pSize*vec2(mat[0][0],mat[1][1]);\n    gl_Position=vec4((gl_Position.x/size.x-0.5)*2.0,(0.5-gl_Position.y/size.y)*2.0,0.0,1.0);\n   #endif\n   \n   v_Color = ComputeParticleColor(a_StartColor,a_EndColor, normalizedAge);\n   v_TextureCoordinate =a_CornerTextureCoordinate.zw;\n}\n\n";},'ps',function(){return this.ps="#ifdef FSHIGHPRECISION\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nvarying vec4 v_Color;\nvarying vec2 v_TextureCoordinate;\nuniform sampler2D u_texture;\n\nvoid main()\n{	\n	gl_FragColor=texture2D(u_texture,v_TextureCoordinate)*v_Color;\n	gl_FragColor.xyz *= v_Color.w;\n}";}
	]);
	return ParticleShader;
})(Shader)



})(window,document,Laya);

if (typeof define === 'function' && define.amd){
	define('laya.core', ['require', "exports"], function(require, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        for (var i in Laya) {
			var o = Laya[i];
            o && o.__isclass && (exports[i] = o);
        }
    });
}

(function(window,document,Laya){
	var __un=Laya.un,__uns=Laya.uns,__static=Laya.static,__class=Laya.class,__getset=Laya.getset,__newvec=Laya.__newvec;

	var Browser=laya.utils.Browser,HTMLCanvas=laya.resource.HTMLCanvas,Handler=laya.utils.Handler,Loader=laya.net.Loader;
	var Point=laya.maths.Point,Rectangle=laya.maths.Rectangle,Render=laya.renders.Render,RenderContext=laya.renders.RenderContext;
	var Sprite=laya.display.Sprite,Texture=laya.resource.Texture;
/**
*tiledMap是整个地图的核心
*地图以层级来划分地图（例如：地表层，植被层，建筑层）
*每层又以分块（GridSprite)来处理显示对象，只显示在视口区域的区
*每块又包括N*N个格子（tile)
*格子类型又分为动画格子跟图片格子两种
*@author ...
*/
//class laya.map.TiledMap
var TiledMap=(function(){
	var GRect,TileMapAniData,TileSet;
	function TiledMap(){
		//json数据
		this._jsonData=null;
		//存放地图中用到的所有子纹理数据
		this._tileTexSetArr=[];
		//主纹理数据，主要在释放纹理资源时使用
		this._texArray=[];
		//地图信息中的一些基本数据
		this._x=0;
		//地图的坐标
		this._y=0;
		//_height=_mapTileH *_mapH
		this._width=0;
		//地图的宽度
		this._height=0;
		//地图的高度
		this._mapW=0;
		//地图的横向格子数
		this._mapH=0;
		//地图的竖向格子数
		this._mapTileW=0;
		//tile的宽度
		this._mapTileH=0;
		//地图的显示对象
		this._mapSprite=null;
		//地图的显示对象
		this._layerArray=[];
		//这里保存所有的MapLayer对象
		this._renderLayerArray=[];
		//这里保存需要渲染的MapLayer对象
		this._gridArray=[];
		//地图块相关的
		this._showGridKey=false;
		//是否显示块边界线（用来调试用）
		this._totalGridNum=0;
		//一层中的GridSprite的总数
		this._gridW=0;
		//地图的横向块数
		this._gridH=0;
		//地图的坚向块数
		this._gridWidth=450;
		//块的默认宽度
		this._gridHeight=450;
		//块的默认高度
		this._jsonLoader=null;
		//用来加载JSON文件用的LOADER
		this._loader=null;
		//用来加载纹理数据用的LOADER
		this._tileSetArray=[];
		//用来存放还需要哪些儿纹理等待加载
		this._currTileSet=null;
		//正在加载的纹理需要的数据源
		this._completeHandler=null;
		//上次视口显示的块范围
		this._index=0;
		this._animationDic={};
		//需要创建的动画数据
		this._properties=null;
		//当前地图的自定义属性
		this._tileProperties={};
		//图块属性
		this._tileProperties2={};
		//默认的地图类型（具体要看JSON文件）
		this._orientation="orthogonal";
		//默认的tile渲染顺序（具体要看JSON文件）
		this._renderOrder="right-down";
		//调试用的颜色组合
		this._colorArray=["FF","00","33","66"];
		//缩放相关的操作
		this._scale=1;
		this._pivotScaleX=0.5;
		this._pivotScaleY=0.5;
		this._centerX=0;
		this._centerY=0;
		/**@private */
		this._viewPortX=0;
		/**@private */
		this._viewPortY=0;
		this._viewPortWidth=0;
		this._viewPortHeight=0;
		//是否开启线性取样
		this._enableLinear=true;
		//资源的相对路径
		this._resPath=null;
		this._pathArray=null;
		//把地图限制在显示区域
		this._limitRange=false;
		/**
		*快速更新模式是否不可用
		*/
		this._fastDirty=true;
		/**
		*是否自动缓存没有动画的地块
		*/
		this.autoCache=true;
		/**
		*自动缓存类型,地图较大时建议使用normal
		*/
		this.autoCacheType="normal";
		/**
		*是否合并图层,开启合并图层时，图层属性内可添加layer属性，运行时将会将相邻的layer属性相同的图层进行合并以提高性能
		*/
		this.enableMergeLayer=false;
		/**
		*是否移除被覆盖的格子,地块可添加type属性，type不为0时表示不透明，被不透明地块遮挡的地块将会被剔除以提高性能
		*/
		this.removeCoveredTile=false;
		/**
		*是否显示大格子里显示的贴图数量
		*/
		this.showGridTextureCount=false;
		/**
		*是否调整地块边缘消除缩放导致的缝隙
		*/
		this.antiCrack=true;
		/**
		*是否在加载完成之后cache所有大格子
		*/
		this.cacheAllAfterInit=false;
		this._texutreStartDic={};
		this._rect=new Rectangle();
		this._paddingRect=new Rectangle();
		this._mapRect=new GRect();
		this._mapLogicRect=new GRect();
		this._mapLastRect=new GRect();
		this._mapSprite=new Sprite();
	}

	__class(TiledMap,'laya.map.TiledMap');
	var __proto=TiledMap.prototype;
	/**
	*创建地图
	*@param mapName JSON文件名字
	*@param viewRect 视口区域
	*@param completeHandler 地图创建完成的回调函数
	*@param viewRectPadding 视口扩充区域，把视口区域上、下、左、右扩充一下，防止视口移动时的穿帮
	*@param gridSize grid大小
	*@param enableLinear 是否开启线性取样（为false时，可以解决地图黑线的问题，但画质会锐化）
	*@param limitRange 把地图限制在显示区域
	*/
	__proto.createMap=function(mapName,viewRect,completeHandler,viewRectPadding,gridSize,enableLinear,limitRange){
		(enableLinear===void 0)&& (enableLinear=true);
		(limitRange===void 0)&& (limitRange=false);
		this._enableLinear=enableLinear;
		this._limitRange=limitRange;
		this._rect.x=viewRect.x;
		this._rect.y=viewRect.y;
		this._rect.width=viewRect.width;
		this._rect.height=viewRect.height;
		this._viewPortWidth=viewRect.width / this._scale;
		this._viewPortHeight=viewRect.height / this._scale;
		this._completeHandler=completeHandler;
		if (viewRectPadding){
			this._paddingRect.copyFrom(viewRectPadding);
		}
		else {
			this._paddingRect.setTo(0,0,0,0);
		}
		if (gridSize){
			this._gridWidth=gridSize.x;
			this._gridHeight=gridSize.y;
		};
		var tIndex=mapName.lastIndexOf("/");
		if (tIndex >-1){
			this._resPath=mapName.substr(0,tIndex);
			this._pathArray=this._resPath.split("/");
		}
		else {
			this._resPath="";
			this._pathArray=[];
		}
		this._jsonLoader=new Loader();
		this._jsonLoader.once("complete",this,this.onJsonComplete);
		this._jsonLoader.load(mapName,/*laya.net.Loader.JSON*/"json",false);
	}

	/**
	*json文件读取成功后，解析里面的纹理数据，进行加载
	*@param e JSON数据
	*/
	__proto.onJsonComplete=function(e){
		var tJsonData=this._jsonData=e;
		this._properties=tJsonData.properties;
		this._orientation=tJsonData.orientation;
		this._renderOrder=tJsonData.renderorder;
		this._mapW=tJsonData.width;
		this._mapH=tJsonData.height;
		this._mapTileW=tJsonData.tilewidth;
		this._mapTileH=tJsonData.tileheight;
		this._width=this._mapTileW *this._mapW;
		this._height=this._mapTileH *this._mapH;
		if (this._orientation=="staggered"){
			this._height=(0.5+this._mapH *0.5)*this._mapTileH;
		}
		this._mapLastRect.top=this._mapLastRect.bottom=this._mapLastRect.left=this._mapLastRect.right=-1;
		var tArray=tJsonData.tilesets;
		var tileset;
		var tTileSet;
		var i=0;
		for (i=0;i < tArray.length;i++){
			tileset=tArray[i];
			tTileSet=new TileSet();
			tTileSet.init(tileset);
			if (tTileSet.properties && tTileSet.properties.ignore)continue ;
			this._tileProperties[i]=tTileSet.tileproperties;
			this.addTileProperties(tTileSet.tileproperties);
			this._tileSetArray.push(tTileSet);
			var tTiles=tileset.tiles;
			if (tTiles){
				for (var p in tTiles){
					var tAnimation=tTiles[p].animation;
					if (tAnimation){
						var tAniData=new TileMapAniData();
						this._animationDic[p]=tAniData;
						tAniData.image=tileset.image;
						for (var j=0;j < tAnimation.length;j++){
							var tAnimationItem=tAnimation[j];
							tAniData.mAniIdArray.push(tAnimationItem.tileid);
							tAniData.mDurationTimeArray.push(tAnimationItem.duration);
						}
					}
				}
			}
		}
		this._tileTexSetArr.push(null);
		if (this._tileSetArray.length > 0){
			tTileSet=this._currTileSet=this._tileSetArray.shift();
			this._loader=new Loader();
			this._loader.once("complete",this,this.onTextureComplete);
			var tPath=this.mergePath(this._resPath,tTileSet.image);
			this._loader.load(tPath,/*laya.net.Loader.IMAGE*/"image",false);
		}
	}

	/**
	*合并路径
	*@param resPath
	*@param relativePath
	*@return
	*/
	__proto.mergePath=function(resPath,relativePath){
		var tResultPath="";
		var tImageArray=relativePath.split("/");
		var tParentPathNum=0;
		var i=0;
		for (i=tImageArray.length-1;i >=0;i--){
			if (tImageArray[i]==".."){
				tParentPathNum++;
			}
		}
		if (tParentPathNum==0){
			if (this._pathArray.length > 0){
				tResultPath=resPath+"/"+relativePath;
			}
			else {
				tResultPath=relativePath;
			}
			return tResultPath;
		};
		var tSrcNum=this._pathArray.length-tParentPathNum;
		if (tSrcNum < 0){
			console.log("[error]path does not exist",this._pathArray,tImageArray,resPath,relativePath);
		}
		for (i=0;i < tSrcNum;i++){
			if (i==0){
				tResultPath+=this._pathArray[i];
			}
			else {
				tResultPath=tResultPath+"/"+this._pathArray[i];
			}
		}
		for (i=tParentPathNum;i < tImageArray.length;i++){
			tResultPath=tResultPath+"/"+tImageArray[i];
		}
		return tResultPath;
	}

	/**
	*纹理加载完成，如果所有的纹理加载，开始初始化地图
	*@param e 纹理数据
	*/
	__proto.onTextureComplete=function(e){
		var json=this._jsonData;
		var tTexture=e;
		if (Render.isWebGL && (!this._enableLinear)){
			tTexture.bitmap.minFifter=0x2600;
			tTexture.bitmap.magFifter=0x2600;
			tTexture.bitmap.enableMerageInAtlas=false;
		}
		this._texArray.push(tTexture);
		var tSubTexture=null;
		var tTileSet=this._currTileSet;
		var tTileTextureW=tTileSet.tilewidth;
		var tTileTextureH=tTileSet.tileheight;
		var tImageWidth=tTileSet.imagewidth;
		var tImageHeight=tTileSet.imageheight;
		var tFirstgid=tTileSet.firstgid;
		var tTileWNum=Math.floor((tImageWidth-tTileSet.margin-tTileTextureW)/ (tTileTextureW+tTileSet.spacing))+1;
		var tTileHNum=Math.floor((tImageHeight-tTileSet.margin-tTileTextureH)/ (tTileTextureH+tTileSet.spacing))+1;
		var tTileTexSet=null;
		this._texutreStartDic[tTileSet.image]=this._tileTexSetArr.length;
		for (var i=0;i < tTileHNum;i++){
			for (var j=0;j < tTileWNum;j++){
				tTileTexSet=new TileTexSet();
				tTileTexSet.offX=tTileSet.titleoffsetX;
				tTileTexSet.offY=tTileSet.titleoffsetY-(tTileTextureH-this._mapTileH);
				tTileTexSet.texture=Texture.createFromTexture(tTexture,tTileSet.margin+(tTileTextureW+tTileSet.spacing)*j,tTileSet.margin+(tTileTextureH+tTileSet.spacing)*i,tTileTextureW,tTileTextureH);
				if(this.antiCrack)
					this.adptTexture(tTileTexSet.texture);
				this._tileTexSetArr.push(tTileTexSet);
				tTileTexSet.gid=this._tileTexSetArr.length;
			}
		}
		if (this._tileSetArray.length > 0){
			tTileSet=this._currTileSet=this._tileSetArray.shift();
			this._loader.once("complete",this,this.onTextureComplete);
			var tPath=this.mergePath(this._resPath,tTileSet.image);
			this._loader.load(tPath,/*laya.net.Loader.IMAGE*/"image",false);
		}
		else {
			this._currTileSet=null;
			this.initMap();
		}
	}

	__proto.adptTexture=function(tex){
		if (!tex)return;
		var pX=tex.uv[0];
		var pX1=tex.uv[2];
		var pY=tex.uv[1];
		var pY1=tex.uv[7];
		var dW=1 / tex.bitmap.width;
		var dH=1 / tex.bitmap.height;
		tex.uv[0]=tex.uv[6]=pX+dW;
		tex.uv[2]=tex.uv[4]=pX1-dW;
		tex.uv[1]=tex.uv[3]=pY+dH;
		tex.uv[5]=tex.uv[7]=pY1-dH;
	}

	/**
	*初始化地图
	*/
	__proto.initMap=function(){
		var i=0,n=0;
		for (var p in this._animationDic){
			var tAniData=this._animationDic[p];
			var gStart=0;
			gStart=this._texutreStartDic[tAniData.image];
			var tTileTexSet=this.getTexture(parseInt(p)+gStart);
			if (tAniData.mAniIdArray.length > 0){
				tTileTexSet.textureArray=[];
				tTileTexSet.durationTimeArray=tAniData.mDurationTimeArray;
				tTileTexSet.isAnimation=true;
				tTileTexSet.animationTotalTime=0;
				for (i=0,n=tTileTexSet.durationTimeArray.length;i < n;i++){
					tTileTexSet.animationTotalTime+=tTileTexSet.durationTimeArray[i];
				}
				for (i=0,n=tAniData.mAniIdArray.length;i < n;i++){
					var tTexture=this.getTexture(tAniData.mAniIdArray[i]+gStart);
					tTileTexSet.textureArray.push(tTexture);
				}
			}
		}
		this._gridWidth=Math.floor(this._gridWidth / this._mapTileW)*this._mapTileW;
		this._gridHeight=Math.floor(this._gridHeight / this._mapTileH)*this._mapTileH;
		if (this._gridWidth < this._mapTileW){
			this._gridWidth=this._mapTileW;
		}
		if (this._gridHeight < this._mapTileH){
			this._gridHeight=this._mapTileH;
		}
		this._gridW=Math.ceil(this._width / this._gridWidth);
		this._gridH=Math.ceil(this._height / this._gridHeight);
		this._totalGridNum=this._gridW *this._gridH;
		for (i=0;i < this._gridH;i++){
			var tGridArray=[];
			this._gridArray.push(tGridArray);
			for (var j=0;j < this._gridW;j++){
				tGridArray.push(null);
			}
		};
		var tLayerArray=this._jsonData.layers;
		var isFirst=true;
		var tTarLayerID=1;
		var tLayerTarLayerName;
		var preLayerTarName;
		var preLayer;
		for (var tLayerLoop=0;tLayerLoop < tLayerArray.length;tLayerLoop++){
			var tLayerData=tLayerArray[tLayerLoop];
			if (tLayerData.visible==true){
				var tMapLayer=new MapLayer();
				tMapLayer.init(tLayerData,this);
				if (!this.enableMergeLayer){
					this._mapSprite.addChild(tMapLayer);
					this._renderLayerArray.push(tMapLayer);
					}else{
					tLayerTarLayerName=tMapLayer.getLayerProperties("layer");
					isFirst=isFirst || (!preLayer)|| (tLayerTarLayerName !=preLayerTarName);
					if (isFirst){
						isFirst=false;
						tMapLayer.tarLayer=tMapLayer;
						preLayer=tMapLayer;
						this._mapSprite.addChild(tMapLayer);
						this._renderLayerArray.push(tMapLayer);
						}else{
						tMapLayer.tarLayer=preLayer;
					}
					preLayerTarName=tLayerTarLayerName;
				}
				this._layerArray.push(tMapLayer);
			}
		}
		if (this.removeCoveredTile){
			this.adptTiledMapData();
		}
		if (this.cacheAllAfterInit){
			this.cacheAllGrid();
		}
		this.moveViewPort(this._rect.x,this._rect.y);
		Laya.stage.addChild(this.mapSprite());
		if (this._completeHandler !=null){
			this._completeHandler.run();
		}
	}

	//这里应该发送消息，通知上层，地图创建完成
	__proto.addTileProperties=function(tileDataDic){
		var key;
		for (key in tileDataDic){
			this._tileProperties2[key]=tileDataDic[key];
		}
	}

	__proto.getTileUserData=function(id,sign,defaultV){
		if (!this._tileProperties2 || !this._tileProperties2[id] || !(sign in this._tileProperties2[id]))return defaultV;
		return this._tileProperties2[id][sign];
	}

	__proto.adptTiledMapData=function(){
		var i=0,len=0;
		len=this._layerArray.length;
		var tLayer;
		var noNeeds={};
		var tDatas;
		for (i=len-1;i >=0;i--){
			tLayer=this._layerArray[i];
			tDatas=tLayer._mapData;
			if (!tDatas)continue ;
			this.removeCoverd(tDatas,noNeeds);
			this.collectCovers(tDatas,noNeeds,i);
		}
	}

	__proto.removeCoverd=function(datas,noNeeds){
		var i=0,len=0;
		len=datas.length;
		for (i=0;i < len;i++){
			if (noNeeds[i]){
				datas[i]=0;
			}
		}
	}

	__proto.collectCovers=function(datas,noNeeds,layer){
		var i=0,len=0;
		len=datas.length;
		var tTileData=0;
		var isCover=0;
		for (i=0;i < len;i++){
			tTileData=datas[i];
			if (tTileData > 0){
				isCover=this.getTileUserData(tTileData-1,"type",0);
				if (isCover > 0){
					noNeeds[i]=tTileData;
				}
			}
		}
	}

	/**
	*得到一块指定的地图纹理
	*@param index 纹理的索引值，默认从1开始
	*@return
	*/
	__proto.getTexture=function(index){
		if (index < this._tileTexSetArr.length){
			return this._tileTexSetArr[index];
		}
		return null;
	}

	/**
	*得到地图的自定义属性
	*@param name 属性名称
	*@return
	*/
	__proto.getMapProperties=function(name){
		if (this._properties){
			return this._properties[name];
		}
		return null;
	}

	/**
	*得到tile自定义属性
	*@param index 地图块索引
	*@param id 具体的TileSetID
	*@param name 属性名称
	*@return
	*/
	__proto.getTileProperties=function(index,id,name){
		if (this._tileProperties[index] && this._tileProperties[index][id]){
			return this._tileProperties[index][id][name];
		}
		return null;
	}

	/**
	*通过纹理索引，生成一个可控制物件
	*@param index 纹理的索引值，默认从1开始
	*@return
	*/
	__proto.getSprite=function(index,width,height){
		if (0 < this._tileTexSetArr.length){
			var tGridSprite=new GridSprite();
			tGridSprite.initData(this,true);
			tGridSprite.size(width,height);
			var tTileTexSet=this._tileTexSetArr[index];
			if (tTileTexSet !=null && tTileTexSet.texture !=null){
				if (tTileTexSet.isAnimation){
					var tAnimationSprite=new TileAniSprite();
					this._index++;
					tAnimationSprite.setTileTextureSet(this._index.toString(),tTileTexSet);
					tGridSprite.addAniSprite(tAnimationSprite);
					tGridSprite.addChild(tAnimationSprite);
				}
				else {
					tGridSprite.graphics.drawTexture(tTileTexSet.texture,0,0,width,height);
				}
				tGridSprite.drawImageNum++;
			}
			return tGridSprite;
		}
		return null;
	}

	/**
	*设置视口的缩放中心点（例如：scaleX=scaleY=0.5,就是以视口中心缩放）
	*@param scaleX
	*@param scaleY
	*/
	__proto.setViewPortPivotByScale=function(scaleX,scaleY){
		this._pivotScaleX=scaleX;
		this._pivotScaleY=scaleY;
		this._fastDirty=true;
	}

	/**
	*移动视口
	*@param moveX 视口的坐标x
	*@param moveY 视口的坐标y
	*/
	__proto.moveViewPort=function(moveX,moveY){
		this._x=-moveX;
		this._y=-moveY;
		if (this._fastDirty){
			this._rect.x=moveX;
			this._rect.y=moveY;
			this.updateViewPort();
			}else{
			var dx=NaN,dy=NaN;
			dx=moveX-this._rect.x;
			dy=moveY-this._rect.y;
			this._rect.x=moveX;
			this._rect.y=moveY;
			this.updateViewPortFast(dx,dy);
		}
	}

	/**
	*改变视口大小
	*@param moveX 视口的坐标x
	*@param moveY 视口的坐标y
	*@param width 视口的宽
	*@param height 视口的高
	*/
	__proto.changeViewPort=function(moveX,moveY,width,height){
		if (moveX==this._rect.x && moveY==this._rect.y && width==this._rect.width && height==this._rect.height)return;
		if (width==this._rect.width && height==this._rect.height){
			this.moveViewPort(moveX,moveY);
			return;
		}
		this._fastDirty=true;
		this._x=-moveX;
		this._y=-moveY;
		this._rect.x=moveX;
		this._rect.y=moveY;
		this._rect.width=width;
		this._rect.height=height;
		this._viewPortWidth=width / this._scale;
		this._viewPortHeight=height / this._scale;
		this.updateViewPort();
	}

	/**
	*在锚点的基础上计算，通过宽和高，重新计算视口
	*@param width 新视口宽
	*@param height 新视口高
	*@param rect 返回的结果
	*@return
	*/
	__proto.changeViewPortBySize=function(width,height,rect){
		if (rect==null){
			rect=new Rectangle();
		}
		this._centerX=this._rect.x+this._rect.width *this._pivotScaleX;
		this._centerY=this._rect.y+this._rect.height *this._pivotScaleY;
		rect.x=this._centerX-width *this._pivotScaleX;
		rect.y=this._centerY-height *this._pivotScaleY;
		rect.width=width;
		rect.height=height;
		this.changeViewPort(rect.x,rect.y,rect.width,rect.height);
		return rect;
	}

	/**
	*快速更新视口 ,只有在视口大小和各种缩放信息没有改变时才可以使用这个函数更新
	*@param dx 视口偏移x
	*@param dy 视口偏移y
	*/
	__proto.updateViewPortFast=function(dx,dy){
		this._centerX+=dx;
		this._centerY+=dy;
		this._viewPortX+=dx;
		this._viewPortY+=dy;
		var posChanged=false;
		var dyG=dy / this._gridHeight;
		var dxG=dx / this._gridWidth;
		this._mapLogicRect.top+=dyG;
		this._mapLogicRect.bottom+=dyG;
		this._mapLogicRect.left+=dxG;
		this._mapLogicRect.right+=dxG;
		this._mapRect.top=0|this._mapLogicRect.top;
		this._mapRect.bottom=0|this._mapLogicRect.bottom;
		this._mapRect.left=0|this._mapLogicRect.left;
		this._mapRect.right=0|this._mapLogicRect.right;
		if (this._mapRect.top !=this._mapLastRect.top || this._mapRect.bottom !=this._mapLastRect.bottom || this._mapRect.left !=this._mapLastRect.left || this._mapRect.right !=this._mapLastRect.right){
			this.clipViewPort();
			this._mapLastRect.top=this._mapRect.top;
			this._mapLastRect.bottom=this._mapRect.bottom;
			this._mapLastRect.left=this._mapRect.left;
			this._mapLastRect.right=this._mapRect.right;
			posChanged=true;
		};posChanged=posChanged|| (dx !=0 || dy !=0);
		if (!posChanged)return;
		this.updateMapLayersPos();
	}

	/**
	*刷新地图层坐标
	*/
	__proto.updateMapLayersPos=function(){
		var tMapLayer;
		var len=this._renderLayerArray.length;
		for (var i=0;i < len;i++){
			tMapLayer=this._renderLayerArray[i];
			if (tMapLayer._gridSpriteArray.length > 0){
				tMapLayer.updateAloneObject();
				tMapLayer.pos(-this._viewPortX,-this._viewPortY);
			}
		}
	}

	/**
	*刷新视口
	*/
	__proto.updateViewPort=function(){
		this._fastDirty=false;
		var dw=this._rect.width *this._pivotScaleX;
		var dh=this._rect.height *this._pivotScaleY;
		this._centerX=this._rect.x+dw;
		this._centerY=this._rect.y+dh;
		var posChanged=false;
		var preValue=this._viewPortX;
		this._viewPortX=this._centerX-dw / this._scale;
		if (preValue !=this._viewPortX){
			posChanged=true;
			}else {
			preValue=this._viewPortY;
		}
		this._viewPortY=this._centerY-dh/ this._scale;
		if (!posChanged && preValue !=this._viewPortY){
			posChanged=true;
		}
		if (this._limitRange){
			var tRight=this._viewPortX+this._viewPortWidth;
			if (tRight > this._width){
				this._viewPortX=this._width-this._viewPortWidth;
			};
			var tBottom=this._viewPortY+this._viewPortHeight;
			if (tBottom > this._height){
				this._viewPortY=this._height-this._viewPortHeight;
			}
			if (this._viewPortX < 0){
				this._viewPortX=0;
			}
			if (this._viewPortY < 0){
				this._viewPortY=0;
			}
		};
		var tPaddingRect=this._paddingRect;
		this._mapLogicRect.top=(this._viewPortY-tPaddingRect.y)/ this._gridHeight;
		this._mapLogicRect.bottom=(this._viewPortY+this._viewPortHeight+tPaddingRect.height+tPaddingRect.y)/ this._gridHeight;
		this._mapLogicRect.left=(this._viewPortX-tPaddingRect.x)/ this._gridWidth;
		this._mapLogicRect.right=(this._viewPortX+this._viewPortWidth+tPaddingRect.width+tPaddingRect.x)/ this._gridWidth;
		this._mapRect.top=0|this._mapLogicRect.top;
		this._mapRect.bottom=0|this._mapLogicRect.bottom;
		this._mapRect.left=0|this._mapLogicRect.left;
		this._mapRect.right=0|this._mapLogicRect.right;
		if (this._mapRect.top !=this._mapLastRect.top || this._mapRect.bottom !=this._mapLastRect.bottom || this._mapRect.left !=this._mapLastRect.left || this._mapRect.right !=this._mapLastRect.right){
			this.clipViewPort();
			this._mapLastRect.top=this._mapRect.top;
			this._mapLastRect.bottom=this._mapRect.bottom;
			this._mapLastRect.left=this._mapRect.left;
			this._mapLastRect.right=this._mapRect.right;
			posChanged=true;
		}
		if (!posChanged)return;
		this.updateMapLayersPos();
	}

	/**
	*GRID裁剪
	*/
	__proto.clipViewPort=function(){
		var tSpriteNum=0;
		var tSprite;
		var tIndex=0;
		var tSub=0;
		var tAdd=0;
		var i=0,j=0;
		if (this._mapRect.left > this._mapLastRect.left){
			tSub=this._mapRect.left-this._mapLastRect.left;
			if (tSub > 0){
				for (j=this._mapLastRect.left;j < this._mapLastRect.left+tSub;j++){
					for (i=this._mapLastRect.top;i <=this._mapLastRect.bottom;i++){
						this.hideGrid(j,i);
					}
				}
			}
		}
		else {
			tAdd=Math.min(this._mapLastRect.left,this._mapRect.right+1)-this._mapRect.left;
			if (tAdd > 0){
				for (j=this._mapRect.left;j < this._mapRect.left+tAdd;j++){
					for (i=this._mapRect.top;i <=this._mapRect.bottom;i++){
						this.showGrid(j,i);
					}
				}
			}
		}
		if (this._mapRect.right > this._mapLastRect.right){
			tAdd=this._mapRect.right-this._mapLastRect.right;
			if (tAdd > 0){
				for (j=Math.max(this._mapLastRect.right+1,this._mapRect.left);j <=this._mapLastRect.right+tAdd;j++){
					for (i=this._mapRect.top;i <=this._mapRect.bottom;i++){
						this.showGrid(j,i);
					}
				}
			}
		}
		else {
			tSub=this._mapLastRect.right-this._mapRect.right
			if (tSub > 0){
				for (j=this._mapRect.right+1;j <=this._mapRect.right+tSub;j++){
					for (i=this._mapLastRect.top;i <=this._mapLastRect.bottom;i++){
						this.hideGrid(j,i);
					}
				}
			}
		}
		if (this._mapRect.top > this._mapLastRect.top){
			tSub=this._mapRect.top-this._mapLastRect.top;
			if (tSub > 0){
				for (i=this._mapLastRect.top;i < this._mapLastRect.top+tSub;i++){
					for (j=this._mapLastRect.left;j <=this._mapLastRect.right;j++){
						this.hideGrid(j,i);
					}
				}
			}
		}
		else {
			tAdd=Math.min(this._mapLastRect.top,this._mapRect.bottom+1)-this._mapRect.top;
			if (tAdd > 0){
				for (i=this._mapRect.top;i < this._mapRect.top+tAdd;i++){
					for (j=this._mapRect.left;j <=this._mapRect.right;j++){
						this.showGrid(j,i);
					}
				}
			}
		}
		if (this._mapRect.bottom > this._mapLastRect.bottom){
			tAdd=this._mapRect.bottom-this._mapLastRect.bottom;
			if (tAdd > 0){
				for (i=Math.max(this._mapLastRect.bottom+1,this._mapRect.top);i <=this._mapLastRect.bottom+tAdd;i++){
					for (j=this._mapRect.left;j <=this._mapRect.right;j++){
						this.showGrid(j,i);
					}
				}
			}
		}
		else {
			tSub=this._mapLastRect.bottom-this._mapRect.bottom
			if (tSub > 0){
				for (i=this._mapRect.bottom+1;i <=this._mapRect.bottom+tSub;i++){
					for (j=this._mapLastRect.left;j <=this._mapLastRect.right;j++){
						this.hideGrid(j,i);
					}
				}
			}
		}
	}

	/**
	*显示指定的GRID
	*@param gridX
	*@param gridY
	*/
	__proto.showGrid=function(gridX,gridY){
		if (gridX < 0 || gridX >=this._gridW || gridY < 0 || gridY >=this._gridH){
			return;
		};
		var i=0,j=0;
		var tGridSprite;
		var tTempArray=this._gridArray[gridY][gridX];
		if (tTempArray==null){
			tTempArray=this.getGridArray(gridX,gridY);
		}
		else {
			for (i=0;i < tTempArray.length && i < this._layerArray.length;i++){
				var tLayerSprite=this._layerArray[i];
				if (tLayerSprite && tTempArray[i]){
					tGridSprite=tTempArray[i];
					if (tGridSprite.visible==false && tGridSprite.drawImageNum > 0){
						tGridSprite.show();
					}
				}
			}
		}
	}

	__proto.cacheAllGrid=function(){
		var i=0,j=0;
		var tempArr;
		for (i=0;i < this._gridW;i++){
			for (j=0;j < this._gridH;j++){
				tempArr=this.getGridArray(i,j);
				this.cacheGridsArray(tempArr);
			}
		}
	}

	__proto.cacheGridsArray=function(arr){
		var canvas;
		if (!TiledMap._tempContext){
			TiledMap._tempContext=new RenderContext(1,1,HTMLCanvas.create(/*laya.resource.HTMLCanvas.TYPEAUTO*/"AUTO"));
		}
		canvas=TiledMap._tempContext.canvas;
		canvas.context.asBitmap=false;
		var i=0,len=0;
		len=arr.length;
		var tGrid;
		for (i=0;i < len;i++){
			tGrid=arr[i];
			canvas.clear();
			canvas.size(1,1);
			tGrid.render(TiledMap._tempContext,0,0);
			tGrid.hide();
		}
		canvas.clear();
		canvas.size(1,1);
	}

	__proto.getGridArray=function(gridX,gridY){
		var i=0,j=0;
		var tGridSprite;
		var tTempArray=this._gridArray[gridY][gridX];
		if (tTempArray==null){
			tTempArray=this._gridArray[gridY][gridX]=[];
			var tLeft=0;
			var tRight=0;
			var tTop=0;
			var tBottom=0;
			var tGridWidth=this._gridWidth;
			var tGridHeight=this._gridHeight;
			switch (this.orientation){
				case /*CLASS CONST:laya.map.TiledMap.ORIENTATION_ISOMETRIC*/"isometric":
					tLeft=Math.floor(gridX *tGridWidth);
					tRight=Math.floor(gridX *tGridWidth+tGridWidth);
					tTop=Math.floor(gridY *tGridHeight);
					tBottom=Math.floor(gridY *tGridHeight+tGridHeight);
					var tLeft1=0,tRight1=0,tTop1=0,tBottom1=0;
					break ;
				case /*CLASS CONST:laya.map.TiledMap.ORIENTATION_STAGGERED*/"staggered":
					tLeft=Math.floor(gridX *tGridWidth / this._mapTileW);
					tRight=Math.floor((gridX *tGridWidth+tGridWidth)/ this._mapTileW);
					tTop=Math.floor(gridY *tGridHeight / (this._mapTileH / 2));
					tBottom=Math.floor((gridY *tGridHeight+tGridHeight)/ (this._mapTileH / 2));
					break ;
				case /*CLASS CONST:laya.map.TiledMap.ORIENTATION_ORTHOGONAL*/"orthogonal":
					tLeft=Math.floor(gridX *tGridWidth / this._mapTileW);
					tRight=Math.floor((gridX *tGridWidth+tGridWidth)/ this._mapTileW);
					tTop=Math.floor(gridY *tGridHeight / this._mapTileH);
					tBottom=Math.floor((gridY *tGridHeight+tGridHeight)/ this._mapTileH);
					break ;
				case /*CLASS CONST:laya.map.TiledMap.ORIENTATION_HEXAGONAL*/"hexagonal":;
					var tHeight=this._mapTileH *2 / 3;
					tLeft=Math.floor(gridX *tGridWidth / this._mapTileW);
					tRight=Math.ceil((gridX *tGridWidth+tGridWidth)/ this._mapTileW);
					tTop=Math.floor(gridY *tGridHeight / tHeight);
					tBottom=Math.ceil((gridY *tGridHeight+tGridHeight)/ tHeight);
					break ;
				};
			var tLayer=null;
			var tTGridSprite;
			var tDrawMapLayer;
			for (var z=0;z < this._layerArray.length;z++){
				tLayer=this._layerArray[z];
				if (this.enableMergeLayer){
					if (tLayer.tarLayer !=tDrawMapLayer){
						tTGridSprite=null;
						tDrawMapLayer=tLayer.tarLayer;
					}
					if (!tTGridSprite){
						tTGridSprite=tDrawMapLayer.getDrawSprite(gridX,gridY);
						tTempArray.push(tTGridSprite);
					}
					tGridSprite=tTGridSprite;
				}
				else {
					tGridSprite=tLayer.getDrawSprite(gridX,gridY);
					tTempArray.push(tGridSprite);
				};
				var tColorStr;
				if (this._showGridKey){
					tColorStr="#";
					tColorStr+=this._colorArray[Math.floor(Math.random()*this._colorArray.length)];
					tColorStr+=this._colorArray[Math.floor(Math.random()*this._colorArray.length)];
					tColorStr+=this._colorArray[Math.floor(Math.random()*this._colorArray.length)];
				}
				switch (this.orientation){
					case /*CLASS CONST:laya.map.TiledMap.ORIENTATION_ISOMETRIC*/"isometric":;
						var tHalfTileHeight=this.tileHeight / 2;
						var tHalfTileWidth=this.tileWidth / 2;
						var tHalfMapWidth=this._width / 2;
						tTop1=Math.floor(tTop / tHalfTileHeight);
						tBottom1=Math.floor(tBottom / tHalfTileHeight);
						tLeft1=this._mapW+Math.floor((tLeft-tHalfMapWidth)/ tHalfTileWidth);
						tRight1=this._mapW+Math.floor((tRight-tHalfMapWidth)/ tHalfTileWidth);
						var tMapW=this._mapW *2;
						var tMapH=this._mapH *2;
						if (tTop1 < 0){
							tTop1=0;
						}
						if (tTop1 >=tMapH){
							tTop1=tMapH-1;
						}
						if (tBottom1 < 0){
							tBottom=0;
						}
						if (tBottom1 >=tMapH){
							tBottom1=tMapH-1;
						}
						tGridSprite.zOrder=this._totalGridNum *z+gridY *this._gridW+gridX;
						for (i=tTop1;i < tBottom1;i++){
							for (j=0;j <=i;j++){
								var tIndexX=i-j;
								var tIndexY=j;
								var tIndexValue=(tIndexX-tIndexY)+this._mapW;
								if (tIndexValue > tLeft1 && tIndexValue <=tRight1){
									if (tLayer.drawTileTexture(tGridSprite,tIndexX,tIndexY)){
										tGridSprite.drawImageNum++;
									}
								}
							}
						}
						break ;
					case /*CLASS CONST:laya.map.TiledMap.ORIENTATION_STAGGERED*/"staggered":
						tGridSprite.zOrder=z *this._totalGridNum+gridY *this._gridW+gridX;
						for (i=tTop;i < tBottom;i++){
							for (j=tLeft;j < tRight;j++){
								if (tLayer.drawTileTexture(tGridSprite,j,i)){
									tGridSprite.drawImageNum++;
								}
							}
						}
						break ;
					case /*CLASS CONST:laya.map.TiledMap.ORIENTATION_ORTHOGONAL*/"orthogonal":
					case /*CLASS CONST:laya.map.TiledMap.ORIENTATION_HEXAGONAL*/"hexagonal":
					switch (this._renderOrder){
						case "right-down":
							tGridSprite.zOrder=z *this._totalGridNum+gridY *this._gridW+gridX;
							for (i=tTop;i < tBottom;i++){
								for (j=tLeft;j < tRight;j++){
									if (tLayer.drawTileTexture(tGridSprite,j,i)){
										tGridSprite.drawImageNum++;
									}
								}
							}
							break ;
						case "right-up":
							tGridSprite.zOrder=z *this._totalGridNum+(this._gridH-1-gridY)*this._gridW+gridX;
							for (i=tBottom-1;i >=tTop;i--){
								for (j=tLeft;j < tRight;j++){
									if (tLayer.drawTileTexture(tGridSprite,j,i)){
										tGridSprite.drawImageNum++;
									}
								}
							}
							break ;
						case "left-down":
							tGridSprite.zOrder=z *this._totalGridNum+gridY *this._gridW+(this._gridW-1-gridX);
							for (i=tTop;i < tBottom;i++){
								for (j=tRight-1;j >=tLeft;j--){
									if (tLayer.drawTileTexture(tGridSprite,j,i)){
										tGridSprite.drawImageNum++;
									}
								}
							}
							break ;
						case "left-up":
							tGridSprite.zOrder=z *this._totalGridNum+(this._gridH-1-gridY)*this._gridW+(this._gridW-1-gridX);
							for (i=tBottom-1;i >=tTop;i--){
								for (j=tRight-1;j >=tLeft;j--){
									if (tLayer.drawTileTexture(tGridSprite,j,i)){
										tGridSprite.drawImageNum++;
									}
								}
							}
							break ;
						}
					break ;
				}
				if (!tGridSprite.isHaveAnimation){
					tGridSprite.autoSize=true;
					if (this.autoCache)
						tGridSprite.cacheAs=this.autoCacheType;
					tGridSprite.autoSize=false;
				}
				if (!this.enableMergeLayer){
					if (tGridSprite.drawImageNum > 0){
						tLayer.addChild(tGridSprite);
						tGridSprite.visible=false;
						tGridSprite.show();
					}
					if (this._showGridKey){
						tGridSprite.graphics.drawRect(0,0,tGridWidth,tGridHeight,null,tColorStr);
					}
					}else{
					if (tTGridSprite && tTGridSprite.drawImageNum > 0&&tDrawMapLayer){
						tDrawMapLayer.addChild(tTGridSprite);
						tTGridSprite.visible=false;
						tTGridSprite.show();
					}
				}
			}
			if (this.enableMergeLayer&&this.showGridTextureCount){
				if (tTGridSprite){
					tTGridSprite.graphics.fillText(tTGridSprite.drawImageNum+"",20,20,null,"#ff0000","left");
				}
			}
		}
		return tTempArray;
	}

	/**
	*隐藏指定的GRID
	*@param gridX
	*@param gridY
	*/
	__proto.hideGrid=function(gridX,gridY){
		if (gridX < 0 || gridX >=this._gridW || gridY < 0 || gridY >=this._gridH){
			return;
		};
		var tTempArray=this._gridArray[gridY][gridX];
		if (tTempArray){
			var tGridSprite;
			for (var i=0;i < tTempArray.length;i++){
				tGridSprite=tTempArray[i];
				if (tGridSprite.drawImageNum > 0){
					if (tGridSprite !=null){
						tGridSprite.hide();
					}
				}
			}
		}
	}

	/**
	*得到对象层上的某一个物品
	*@param layerName 层的名称
	*@param objectName 所找物品的名称
	*@return
	*/
	__proto.getLayerObject=function(layerName,objectName){
		var tLayer=null;
		for (var i=0;i < this._layerArray.length;i++){
			tLayer=this._layerArray[i];
			if (tLayer.layerName==layerName){
				break ;
			}
		}
		if (tLayer){
			return tLayer.getObjectByName(objectName);
		}
		return null;
	}

	/**
	*销毁地图
	*/
	__proto.destroy=function(){
		this._orientation="orthogonal";
		this._jsonData=null;
		var i=0;
		var j=0;
		var z=0;
		this._gridArray=[];
		var tTileTexSet;
		for (i=0;i < this._tileTexSetArr.length;i++){
			tTileTexSet=this._tileTexSetArr[i];
			if (tTileTexSet){
				tTileTexSet.clearAll();
			}
		}
		this._tileTexSetArr=[];
		var tTexture;
		for (i=0;i < this._texArray.length;i++){
			tTexture=this._texArray[i];
			tTexture.destroy();
		}
		this._texArray=[];
		this._width=0;
		this._height=0;
		this._mapW=0;
		this._mapH=0;
		this._mapTileW=0;
		this._mapTileH=0;
		this._rect.setTo(0,0,0,0);
		var tLayer;
		for (i=0;i < this._layerArray.length;i++){
			tLayer=this._layerArray[i];
			tLayer.clearAll();
		}
		this._layerArray=[];
		this._renderLayerArray=[];
		if (this._mapSprite){
			this._mapSprite.destroy();
			this._mapSprite=null;
		}
		this._jsonLoader=null;
		this._loader=null;
		var tDic=this._animationDic;
		for (var p in tDic){
			delete tDic[p];
		}
		this._properties=null;
		tDic=this._tileProperties;
		for (p in tDic){
			delete tDic[p];
		}
		this._currTileSet=null;
		this._completeHandler=null;
		this._mapRect.clearAll();
		this._mapLastRect.clearAll();
		this._tileSetArray=[];
		this._gridWidth=450;
		this._gridHeight=450;
		this._gridW=0;
		this._gridH=0;
		this._x=0;
		this._y=0;
		this._index=0;
		this._enableLinear=true;
		this._resPath=null;
		this._pathArray=null;
	}

	/**
	*整个地图的显示容器
	*@return 地图的显示容器
	*/
	__proto.mapSprite=function(){
		return this._mapSprite;
	}

	/**
	*得到指定的MapLayer
	*@param layerName 要找的层名称
	*@return
	*/
	__proto.getLayerByName=function(layerName){
		var tMapLayer;
		for (var i=0;i < this._layerArray.length;i++){
			tMapLayer=this._layerArray[i];
			if (layerName==tMapLayer.layerName){
				return tMapLayer;
			}
		}
		return null;
	}

	/**
	*通过索引得MapLayer
	*@param index 要找的层索引
	*@return
	*/
	__proto.getLayerByIndex=function(index){
		if (index < this._layerArray.length){
			return this._layerArray[index];
		}
		return null;
	}

	/**
	*当前地图类型
	*/
	__getset(0,__proto,'orientation',function(){
		return this._orientation;
	});

	/**
	*@private
	*视口x坐标
	*/
	__getset(0,__proto,'viewPortX',function(){
		return-this._viewPortX;
	});

	/**
	*设置地图缩放
	*@param scale
	*/
	/**
	*得到当前地图的缩放
	*/
	__getset(0,__proto,'scale',function(){
		return this._scale;
		},function(scale){
		if (scale <=0)
			return;
		this._scale=scale;
		this._viewPortWidth=this._rect.width / scale;
		this._viewPortHeight=this._rect.height / scale;
		this._mapSprite.scale(this._scale,this._scale);
		this.updateViewPort();
	});

	/**
	*格子的宽度
	*/
	__getset(0,__proto,'tileWidth',function(){
		return this._mapTileW;
	});

	/**
	*@private
	*视口的y坐标
	*/
	__getset(0,__proto,'viewPortY',function(){
		return-this._viewPortY;
	});

	/**
	*格子的高度
	*/
	__getset(0,__proto,'tileHeight',function(){
		return this._mapTileH;
	});

	/**
	*地图的宽度
	*/
	__getset(0,__proto,'width',function(){
		return this._width;
	});

	/**
	*地图竖向的格子数
	*/
	__getset(0,__proto,'numRowsTile',function(){
		return this._mapH;
	});

	/**
	*地图横向的格子数
	*/
	__getset(0,__proto,'numColumnsTile',function(){
		return this._mapW;
	});

	/**
	*地图的高度
	*/
	__getset(0,__proto,'height',function(){
		return this._height;
	});

	/**
	*@private
	*视口的宽度
	*/
	__getset(0,__proto,'viewPortWidth',function(){
		return this._viewPortWidth;
	});

	/**
	*@private
	*视口的高度
	*/
	__getset(0,__proto,'viewPortHeight',function(){
		return this._viewPortHeight;
	});

	/**
	*地图的x坐标
	*/
	__getset(0,__proto,'x',function(){
		return this._x;
	});

	/**
	*地图的y坐标
	*/
	__getset(0,__proto,'y',function(){
		return this._y;
	});

	/**
	*块的宽度
	*/
	__getset(0,__proto,'gridWidth',function(){
		return this._gridWidth;
	});

	/**
	*块的高度
	*/
	__getset(0,__proto,'gridHeight',function(){
		return this._gridHeight;
	});

	/**
	*地图的横向块数
	*/
	__getset(0,__proto,'numColumnsGrid',function(){
		return this._gridW;
	});

	/**
	*地图的坚向块数
	*/
	__getset(0,__proto,'numRowsGrid',function(){
		return this._gridH;
	});

	/**
	*tile渲染顺序
	*/
	__getset(0,__proto,'renderOrder',function(){
		return this._renderOrder;
	});

	TiledMap.ORIENTATION_ORTHOGONAL="orthogonal";
	TiledMap.ORIENTATION_ISOMETRIC="isometric";
	TiledMap.ORIENTATION_STAGGERED="staggered";
	TiledMap.ORIENTATION_HEXAGONAL="hexagonal";
	TiledMap.RENDERORDER_RIGHTDOWN="right-down";
	TiledMap.RENDERORDER_RIGHTUP="right-up";
	TiledMap.RENDERORDER_LEFTDOWN="left-down";
	TiledMap.RENDERORDER_LEFTUP="left-up";
	TiledMap._tempContext=null;
	TiledMap.__init$=function(){
		//class GRect
		GRect=(function(){
			function GRect(){
				this.left=0;
				this.top=0;
				this.right=0;
				this.bottom=0;
			}
			__class(GRect,'');
			var __proto=GRect.prototype;
			__proto.clearAll=function(){
				this.left=this.top=this.right=this.bottom=0;
			}
			return GRect;
		})()
		//class TileMapAniData
		TileMapAniData=(function(){
			function TileMapAniData(){
				this.mAniIdArray=[];
				this.mDurationTimeArray=[];
				this.mTileTexSetArr=[];
				this.image=null;
			}
			__class(TileMapAniData,'');
			return TileMapAniData;
		})()
		//class TileSet
		TileSet=(function(){
			function TileSet(){
				this.firstgid=0;
				this.image="";
				this.imageheight=0;
				this.imagewidth=0;
				this.margin=0;
				this.name=0;
				this.properties=null;
				this.spacing=0;
				this.tileheight=0;
				this.tilewidth=0;
				this.titleoffsetX=0;
				this.titleoffsetY=0;
				this.tileproperties=null;
			}
			__class(TileSet,'');
			var __proto=TileSet.prototype;
			__proto.init=function(data){
				this.firstgid=data.firstgid;
				this.image=data.image;
				this.imageheight=data.imageheight;
				this.imagewidth=data.imagewidth;
				this.margin=data.margin;
				this.name=data.name;
				this.properties=data.properties;
				this.spacing=data.spacing;
				this.tileheight=data.tileheight;
				this.tilewidth=data.tilewidth;
				this.tileproperties=data.tileproperties;
				var tTileoffset=data.tileoffset;
				if (tTileoffset){
					this.titleoffsetX=tTileoffset.x;
					this.titleoffsetY=tTileoffset.y;
				}
			}
			return TileSet;
		})()
	}

	return TiledMap;
})()


/**
*此类是子纹理类，也包括同类动画的管理
*TiledMap会把纹理分割成无数子纹理，也可以把其中的某块子纹理替换成一个动画序列
*本类的实现就是如果发现子纹理被替换成一个动画序列，animationKey会被设为true
*即animationKey为true,就使用TileAniSprite来做显示，把动画序列根据时间画到TileAniSprite上
*@author ...
*/
//class laya.map.TileTexSet
var TileTexSet=(function(){
	function TileTexSet(){
		/**唯一标识*/
		this.gid=-1;
		/**子纹理的引用*/
		this.texture=null;
		/**纹理显示时的坐标偏移X*/
		this.offX=0;
		/**纹理显示时的坐标偏移Y*/
		this.offY=0;
		/**当前要播放动画的纹理序列*/
		this.textureArray=null;
		/**当前动画每帧的时间间隔*/
		this.durationTimeArray=null;
		/**动画播放的总时间 */
		this.animationTotalTime=0;
		/**true表示当前纹理，是一组动画，false表示当前只有一个纹理*/
		this.isAnimation=false;
		this._spriteNum=0;
		//当前动画有多少个显示对象
		this._aniDic=null;
		//通过显示对象的唯一名字，去保存显示显示对象
		this._frameIndex=0;
		//当前动画播放到第几帧
		this._time=0;
		//距离上次动画刷新，过了多少长时间
		this._interval=0;
		//每帧刷新的时间间隔
		this._preFrameTime=0;
	}

	__class(TileTexSet,'laya.map.TileTexSet');
	var __proto=TileTexSet.prototype;
	/**
	*加入一个动画显示对象到此动画中
	*@param aniName //显示对象的名字
	*@param sprite //显示对象
	*/
	__proto.addAniSprite=function(aniName,sprite){
		if (this.animationTotalTime==0){
			return;
		}
		if (this._aniDic==null){
			this._aniDic={};
		}
		if (this._spriteNum==0){
			Laya.timer.frameLoop(3,this,this.animate);
			this._preFrameTime=Browser.now();
			this._frameIndex=0;
			this._time=0;
			this._interval=0;
		}
		this._spriteNum++;
		this._aniDic[aniName]=sprite;
		if (this.textureArray && this._frameIndex < this.textureArray.length){
			var tTileTextureSet=this.textureArray[this._frameIndex];
			this.drawTexture(sprite,tTileTextureSet);
		}
	}

	/**
	*把动画画到所有注册的SPRITE上
	*/
	__proto.animate=function(){
		if (this.textureArray && this.textureArray.length > 0 && this.durationTimeArray && this.durationTimeArray.length > 0){
			var tNow=Browser.now();
			this._interval=tNow-this._preFrameTime;
			this._preFrameTime=tNow;
			if (this._interval > this.animationTotalTime){
				this._interval=this._interval % this.animationTotalTime;
			}
			this._time+=this._interval;
			var tTime=this.durationTimeArray[this._frameIndex];
			while (this._time > tTime){
				this._time-=tTime;
				this._frameIndex++;
				if (this._frameIndex >=this.durationTimeArray.length || this._frameIndex >=this.textureArray.length){
					this._frameIndex=0;
				};
				var tTileTextureSet=this.textureArray[this._frameIndex];
				var tSprite;
				for (var p in this._aniDic){
					tSprite=this._aniDic[p];
					this.drawTexture(tSprite,tTileTextureSet);
				}
				tTime=this.durationTimeArray[this._frameIndex];
			}
		}
	}

	__proto.drawTexture=function(sprite,tileTextSet){
		sprite.graphics.clear();
		sprite.graphics.drawTexture(tileTextSet.texture,tileTextSet.offX,tileTextSet.offY);
	}

	/**
	*移除不需要更新的SPRITE
	*@param _name
	*/
	__proto.removeAniSprite=function(_name){
		if (this._aniDic && this._aniDic[_name]){
			delete this._aniDic[_name];
			this._spriteNum--
			if (this._spriteNum==0){
				Laya.timer.clear(this,this.animate);
			}
		}
	}

	/**
	*显示当前动画的使用情况
	*/
	__proto.showDebugInfo=function(){
		var tInfo=null;
		if (this._spriteNum > 0){
			tInfo="TileTextureSet::gid:"+this.gid.toString()+" 动画数:"+this._spriteNum.toString();
		}
		return tInfo;
	}

	/**
	*清理
	*/
	__proto.clearAll=function(){
		this.gid=-1;
		if (this.texture){
			this.texture.destroy();
			this.texture=null;
		}
		this.offX=0;
		this.offY=0;
		this.textureArray=null;
		this.durationTimeArray=null;
		this.isAnimation=false;
		this._spriteNum=0;
		this._aniDic=null;
		this._frameIndex=0;
		this._preFrameTime=0;
		this._time=0;
		this._interval=0;
	}

	return TileTexSet;
})()


/**
*地图的每层都会分块渲染处理
*本类就是地图的块数据
*@author ...
*/
//class laya.map.GridSprite extends laya.display.Sprite
var GridSprite=(function(_super){
	function GridSprite(){
		/**相对于地图X轴的坐标*/
		this.relativeX=0;
		/**相对于地图Y轴的坐标*/
		this.relativeY=0;
		/**是否用于对象层的独立物件*/
		this.isAloneObject=false;
		/**当前GRID中是否有动画*/
		this.isHaveAnimation=false;
		/**当前GRID包含的动画*/
		this.aniSpriteArray=null;
		/**当前GRID包含多少个TILE(包含动画)*/
		this.drawImageNum=0;
		this._map=null;
		GridSprite.__super.call(this);
	}

	__class(GridSprite,'laya.map.GridSprite',_super);
	var __proto=GridSprite.prototype;
	/**
	*传入必要的参数，用于裁剪，跟确认此对象类型
	*@param map 把地图的引用传进来，参与一些裁剪计算
	*@param objectKey true:表示当前GridSprite是个活动对象，可以控制，false:地图层的组成块
	*/
	__proto.initData=function(map,objectKey){
		(objectKey===void 0)&& (objectKey=false);
		this._map=map;
		this.isAloneObject=objectKey;
	}

	/**@private */
	__proto._setDisplay=function(value){
		if (!value){
			var cc=this._$P.cacheCanvas;
			if (cc && cc.ctx){
				cc.ctx.canvas.destroy();
				cc.ctx=null;
			};
			var fc=this._$P._filterCache;
			if (fc){
				fc.destroy();
				fc.recycle();
				this._set$P('_filterCache',null);
			}
			this._$P._isHaveGlowFilter && this._set$P('_isHaveGlowFilter',false);
		}
		_super.prototype._setDisplay.call(this,value);
	}

	/**
	*把一个动画对象绑定到当前GridSprite
	*@param sprite 动画的显示对象
	*/
	__proto.addAniSprite=function(sprite){
		if (this.aniSpriteArray==null){
			this.aniSpriteArray=[];
		}
		this.aniSpriteArray.push(sprite);
	}

	/**
	*显示当前GridSprite，并把上面的动画全部显示
	*/
	__proto.show=function(){
		if (!this.visible){
			this.visible=true;
			if (!this.isAloneObject){
				var tParent;
				tParent=this.parent;
				if (tParent){
					tParent.showGridSprite(this);
				}
			}
			if (!Render.isWebGL&&this._map.autoCache){
				this.cacheAs=this._map.autoCacheType;
			}
			if (this.aniSpriteArray==null){
				return;
			};
			var tAniSprite;
			for (var i=0;i < this.aniSpriteArray.length;i++){
				tAniSprite=this.aniSpriteArray[i];
				tAniSprite.show();
			}
		}
	}

	/**
	*隐藏当前GridSprite，并把上面绑定的动画全部移除
	*/
	__proto.hide=function(){
		if (this.visible){
			this.visible=false;
			if (!this.isAloneObject){
				var tParent;
				tParent=this.parent;
				if (tParent){
					tParent.hideGridSprite(this);
				}
			}
			if (!Render.isWebGL&&this._map.autoCache){
				this.cacheAs="none";
			}
			if (this.aniSpriteArray==null){
				return;
			};
			var tAniSprite;
			for (var i=0;i < this.aniSpriteArray.length;i++){
				tAniSprite=this.aniSpriteArray[i];
				tAniSprite.hide();
			}
		}
	}

	/**
	*刷新坐标，当我们自己控制一个GridSprite移动时，需要调用此函数，手动刷新
	*/
	__proto.updatePos=function(){
		if (this.isAloneObject){
			if (this._map){
				this.x=this.relativeX;
				this.y=this.relativeY;
			}
			if (this.x < 0 || this.x > this._map.viewPortWidth || this.y < 0 || this.y > this._map.viewPortHeight){
				this.hide();
				}else {
				this.show();
			}
			}else {
			if (this._map){
				this.x=this.relativeX;
				this.y=this.relativeY;
			}
		}
	}

	/**
	*重置当前对象的所有属性
	*/
	__proto.clearAll=function(){
		if (this._map){
			this._map=null;
		}
		this.visible=false;
		var tAniSprite;
		if (this.aniSpriteArray !=null){
			for (var i=0;i < this.aniSpriteArray.length;i++){
				tAniSprite=this.aniSpriteArray[i];
				tAniSprite.clearAll();
			}
		}
		this.destroy();
		this.relativeX=0;
		this.relativeY=0;
		this.isHaveAnimation=false;
		this.aniSpriteArray=null;
		this.drawImageNum=0;
	}

	return GridSprite;
})(Sprite)


/**
*地图支持多层渲染（例如，地表层，植被层，建筑层等）
*本类就是层级类
*@author ...
*/
//class laya.map.MapLayer extends laya.display.Sprite
var MapLayer=(function(_super){
	function MapLayer(){
		this._map=null;
		this._mapData=null;
		this._tileWidthHalf=0;
		this._tileHeightHalf=0;
		this._mapWidthHalf=0;
		this._mapHeightHalf=0;
		/**
		*@private
		*/
		this._gridSpriteArray=[];
		this._objDic=null;
		//用来做字典，方便查询
		this._dataDic=null;
		//临时变量
		this._properties=null;
		/**被合到的层*/
		this.tarLayer=null;
		/**当前Layer的名称*/
		this.layerName=null;
		/**
		*当前需要更新的gridSprite列表
		*/
		this._showGridList=[];
		/**
		*活动对象列表,活动对象不管是否显示都需要更新
		*/
		this._aloneObjs=[];
		MapLayer.__super.call(this);
		this._tempMapPos=new Point();
	}

	__class(MapLayer,'laya.map.MapLayer',_super);
	var __proto=MapLayer.prototype;
	/**
	*解析LAYER数据，以及初始化一些数据
	*@param layerData 地图数据中，layer数据的引用
	*@param map 地图的引用
	*/
	__proto.init=function(layerData,map){
		this._map=map;
		this._mapData=layerData.data;
		var tHeight=layerData.height;
		var tWidth=layerData.width;
		var tTileW=map.tileWidth;
		var tTileH=map.tileHeight;
		this.layerName=layerData.name;
		this._properties=layerData.properties;
		this.alpha=layerData.opacity;
		this._tileWidthHalf=tTileW / 2;
		this._tileHeightHalf=tTileH / 2;
		this._mapWidthHalf=this._map.width / 2-this._tileWidthHalf;
		this._mapHeightHalf=this._map.height / 2;
		switch (layerData.type){
			case "tilelayer":
				break ;
			case "objectgroup":;
				var tObjectGid=0;
				var tArray=layerData.objects;
				if (tArray.length > 0){
					this._objDic={};
					this._dataDic={};
				};
				var tObjectData;
				var tObjWidth=NaN;
				var tObjHeight=NaN;
				for (var i=0;i < tArray.length;i++){
					tObjectData=tArray[i];
					this._dataDic[tObjectData.name]=tObjectData;
					if (tObjectData.visible==true){
						tObjWidth=tObjectData.width;
						tObjHeight=tObjectData.height;
						var tSprite=map.getSprite(tObjectData.gid,tObjWidth,tObjHeight);
						if (tSprite !=null){
						switch (this._map.orientation){
							case /*laya.map.TiledMap.ORIENTATION_ISOMETRIC*/"isometric":
								this.getScreenPositionByTilePos(tObjectData.x / tTileH,tObjectData.y / tTileH,Point.TEMP);
								tSprite.pivot(tObjWidth / 2,tObjHeight / 2);
								tSprite.rotation=tObjectData.rotation;
								tSprite.x=tSprite.relativeX=Point.TEMP.x+this._map.viewPortX;
								tSprite.y=tSprite.relativeY=Point.TEMP.y+this._map.viewPortY-tObjHeight / 2;
								break ;
							case /*laya.map.TiledMap.ORIENTATION_STAGGERED*/"staggered":
								tSprite.pivot(tObjWidth / 2,tObjHeight / 2);
								tSprite.rotation=tObjectData.rotation;
								tSprite.x=tSprite.relativeX=tObjectData.x+tObjWidth / 2;
								tSprite.y=tSprite.relativeY=tObjectData.y-tObjHeight / 2;
								break ;
							case /*laya.map.TiledMap.ORIENTATION_ORTHOGONAL*/"orthogonal":
								tSprite.pivot(tObjWidth / 2,tObjHeight / 2);
								tSprite.rotation=tObjectData.rotation;
								tSprite.x=tSprite.relativeX=tObjectData.x+tObjWidth / 2;
								tSprite.y=tSprite.relativeY=tObjectData.y-tObjHeight / 2;
								break ;
							case /*laya.map.TiledMap.ORIENTATION_HEXAGONAL*/"hexagonal":
								tSprite.x=tSprite.relativeX=tObjectData.x;
								tSprite.y=tSprite.relativeY=tObjectData.y;
								break ;
							}
						this.addChild(tSprite);
						this._gridSpriteArray.push(tSprite);
						if (tSprite.isAloneObject){
							this._showGridList.push(tSprite);
							this._aloneObjs.push(tSprite);
						}
						this._objDic[tObjectData.name]=tSprite;
					}
				}
			}
			break ;
		}
	}

	/**
	*通过名字获取控制对象，如果找不到返回为null
	*@param objName 所要获取对象的名字
	*@return
	*/
	__proto.getObjectByName=function(objName){
		if (this._objDic){
			return this._objDic[objName];
		}
		return null;
	}

	/**
	*通过名字获取数据，如果找不到返回为null
	*@param objName 所要获取对象的名字
	*@return
	*/
	__proto.getObjectDataByName=function(objName){
		if (this._dataDic){
			return this._dataDic[objName];
		}
		return null;
	}

	/**
	*得到地图层的自定义属性
	*@param name
	*@return
	*/
	__proto.getLayerProperties=function(name){
		if (this._properties){
			return this._properties[name];
		}
		return null;
	}

	/**
	*得到指定格子的数据
	*@param tileX 格子坐标X
	*@param tileY 格子坐标Y
	*@return
	*/
	__proto.getTileData=function(tileX,tileY){
		if (tileY >=0 && tileY < this._map.numRowsTile && tileX >=0 && tileX < this._map.numColumnsTile){
			var tIndex=tileY *this._map.numColumnsTile+tileX;
			var tMapData=this._mapData;
			if (tMapData !=null && tIndex < tMapData.length){
				return tMapData[tIndex];
			}
		}
		return 0;
	}

	/**
	*通过地图坐标得到屏幕坐标
	*@param tileX 格子坐标X
	*@param tileY 格子坐标Y
	*@param screenPos 把计算好的屏幕坐标数据，放到此对象中
	*/
	__proto.getScreenPositionByTilePos=function(tileX,tileY,screenPos){
		if (screenPos){
			switch (this._map.orientation){
				case /*laya.map.TiledMap.ORIENTATION_ISOMETRIC*/"isometric":
					screenPos.x=this._map.width / 2-(tileY-tileX)*this._tileWidthHalf;
					screenPos.y=(tileY+tileX)*this._tileHeightHalf;
					break ;
				case /*laya.map.TiledMap.ORIENTATION_STAGGERED*/"staggered":
					tileX=Math.floor(tileX);
					tileY=Math.floor(tileY);
					screenPos.x=tileX *this._map.tileWidth+(tileY & 1)*this._tileWidthHalf;
					screenPos.y=tileY *this._tileHeightHalf;
					break ;
				case /*laya.map.TiledMap.ORIENTATION_ORTHOGONAL*/"orthogonal":
					screenPos.x=tileX *this._map.tileWidth;
					screenPos.y=tileY *this._map.tileHeight;
					break ;
				case /*laya.map.TiledMap.ORIENTATION_HEXAGONAL*/"hexagonal":
					tileX=Math.floor(tileX);
					tileY=Math.floor(tileY);
					var tTileHeight=this._map.tileHeight *2 / 3;
					screenPos.x=(tileX *this._map.tileWidth+tileY % 2 *this._tileWidthHalf)% this._map.gridWidth;
					screenPos.y=(tileY *tTileHeight)% this._map.gridHeight;
					break ;
				}
			screenPos.x=(screenPos.x+this._map.viewPortX)*this._map.scale;
			screenPos.y=(screenPos.y+this._map.viewPortY)*this._map.scale;
		}
	}

	/**
	*通过屏幕坐标来获取选中格子的数据
	*@param screenX 屏幕坐标x
	*@param screenY 屏幕坐标y
	*@return
	*/
	__proto.getTileDataByScreenPos=function(screenX,screenY){
		var tData=0;
		if (this.getTilePositionByScreenPos(screenX,screenY,this._tempMapPos)){
			tData=this.getTileData(Math.floor(this._tempMapPos.x),Math.floor(this._tempMapPos.y));
		}
		return tData;
	}

	/**
	*通过屏幕坐标来获取选中格子的索引
	*@param screenX 屏幕坐标x
	*@param screenY 屏幕坐标y
	*@param result 把计算好的格子坐标，放到此对象中
	*@return
	*/
	__proto.getTilePositionByScreenPos=function(screenX,screenY,result){
		screenX=screenX/this._map.scale-this._map.viewPortX;
		screenY=screenY/this._map.scale-this._map.viewPortY;
		var tTileW=this._map.tileWidth;
		var tTileH=this._map.tileHeight;
		var tV=0;
		var tU=0;
		switch (this._map.orientation){
			case /*laya.map.TiledMap.ORIENTATION_ISOMETRIC*/"isometric":;
				var tDirX=screenX-this._map.width / 2;
				var tDirY=screenY;
				tV=-(tDirX / tTileW-tDirY / tTileH);
				tU=tDirX / tTileW+tDirY / tTileH;
				if (result){
					result.x=tU;
					result.y=tV;
				}
				return true;
				break ;
			case /*laya.map.TiledMap.ORIENTATION_STAGGERED*/"staggered":
				if (result){
					var cx=0,cy=0,rx=0,ry=0;
					cx=Math.floor(screenX / tTileW)*tTileW+tTileW / 2;
					cy=Math.floor(screenY / tTileH)*tTileH+tTileH / 2;
					rx=(screenX-cx)*tTileH / 2;
					ry=(screenY-cy)*tTileW / 2;
					if (Math.abs(rx)+Math.abs(ry)<=tTileW *tTileH / 4){
						tU=Math.floor(screenX / tTileW);
						tV=Math.floor(screenY / tTileH)*2;
						}else {
						screenX=screenX-tTileW / 2;
						tU=Math.floor(screenX / tTileW)+1;
						screenY=screenY-tTileH / 2;
						tV=Math.floor(screenY / tTileH)*2+1;
					}
					result.x=tU-(tV & 1);
					result.y=tV;
				}
				return true;
				break ;
			case /*laya.map.TiledMap.ORIENTATION_ORTHOGONAL*/"orthogonal":
				tU=screenX / tTileW;
				tV=screenY / tTileH;
				if (result){
					result.x=tU;
					result.y=tV;
				}
				return true;
				break ;
			case /*laya.map.TiledMap.ORIENTATION_HEXAGONAL*/"hexagonal":;
				var tTileHeight=tTileH *2 / 3;
				tV=screenY / tTileHeight;
				tU=(screenX-tV % 2 *this._tileWidthHalf)/ tTileW;
				if (result){
					result.x=tU;
					result.y=tV;
				}
				break ;
			}
		return false;
	}

	/**
	*得到一个GridSprite
	*@param gridX 当前Grid的X轴索引
	*@param gridY 当前Grid的Y轴索引
	*@return 一个GridSprite对象
	*/
	__proto.getDrawSprite=function(gridX,gridY){
		var tSprite=new GridSprite();
		tSprite.relativeX=gridX *this._map.gridWidth;
		tSprite.relativeY=gridY *this._map.gridHeight;
		tSprite.initData(this._map);
		tSprite.updatePos();
		this._gridSpriteArray.push(tSprite);
		return tSprite;
	}

	/**
	*将gridSprite设为显示状态
	*@param gridSprite
	*/
	__proto.showGridSprite=function(gridSprite){
		var gridList=this._showGridList;
		var i=0,len=0;
		len=gridList.length;
		var ok_i=-1;
		var tGridSprite;
		for (i=0;i < len;i++){
			tGridSprite=gridList[i];
			if (tGridSprite==gridSprite)return;
			if (!tGridSprite.isAloneObject && !tGridSprite.visible){
				ok_i=i;
			}
		}
		if (ok_i >=0){
			gridList[ok_i]=gridSprite;
			}else{
			gridList.push(gridSprite);
		}
	}

	/**
	*将gridSprite设为隐藏状态
	*@param gridSprite
	*
	*/
	__proto.hideGridSprite=function(gridSprite){
		gridSprite.visible=false;
	}

	/**
	*更新此层中块的坐标
	*手动刷新的目的是，保持层级的宽和高保持最小，加快渲染
	*/
	__proto.updateGridPos=function(){
		var tSprite;
		var tList;
		tList=this._showGridList;
		var len=0;
		len=tList.length;
		for (var i=0;i < len;i++){
			tSprite=tList[i];
			if ((tSprite._style.visible || tSprite.isAloneObject)&& tSprite.drawImageNum > 0){
				tSprite.updatePos();
			}
		}
	}

	/**
	*更新此层中的活动对象
	*/
	__proto.updateAloneObject=function(){
		var tSprite;
		var tList;
		tList=this._aloneObjs;
		var len=0;
		len=tList.length;
		for (var i=0;i < len;i++){
			tSprite=tList[i];
			if (tSprite.drawImageNum > 0){
				tSprite.updatePos();
			}
		}
	}

	/**
	*渲染时使用需要更新的列表进行渲染，减少遍历
	*@param context
	*@param x
	*@param y
	*
	*/
	__proto.render=function(context,x,y){
		var childs=this._childs;
		this._childs=this._showGridList;
		_super.prototype.render.call(this,context,x,y);
		this._childs=childs;
	}

	/**
	*@private
	*把tile画到指定的显示对象上
	*@param gridSprite 被指定显示的目标
	*@param tileX 格子的X轴坐标
	*@param tileY 格子的Y轴坐标
	*@return
	*/
	__proto.drawTileTexture=function(gridSprite,tileX,tileY){
		if (tileY >=0 && tileY < this._map.numRowsTile && tileX >=0 && tileX < this._map.numColumnsTile){
			var tIndex=tileY *this._map.numColumnsTile+tileX;
			var tMapData=this._mapData;
			if (tMapData !=null && tIndex < tMapData.length){
				if (tMapData[tIndex] !=0){
					var tTileTexSet=this._map.getTexture(tMapData[tIndex]);
					if (tTileTexSet){
						var tX=0;
						var tY=0;
						var tTexture=tTileTexSet.texture;
						switch (this._map.orientation){
							case /*laya.map.TiledMap.ORIENTATION_STAGGERED*/"staggered":
								tX=tileX *this._map.tileWidth % this._map.gridWidth+(tileY & 1)*this._tileWidthHalf;
								tY=tileY *this._tileHeightHalf % this._map.gridHeight;
								break ;
							case /*laya.map.TiledMap.ORIENTATION_ORTHOGONAL*/"orthogonal":
								tX=tileX *this._map.tileWidth % this._map.gridWidth;
								tY=tileY *this._map.tileHeight % this._map.gridHeight;
								break ;
							case /*laya.map.TiledMap.ORIENTATION_ISOMETRIC*/"isometric":
								tX=(this._mapWidthHalf+(tileX-tileY)*this._tileWidthHalf)% this._map.gridWidth;
								tY=((tileX+tileY)*this._tileHeightHalf)% this._map.gridHeight;
								break ;
							case /*laya.map.TiledMap.ORIENTATION_HEXAGONAL*/"hexagonal":;
								var tTileHeight=this._map.tileHeight *2 / 3;
								tX=(tileX *this._map.tileWidth+tileY % 2 *this._tileWidthHalf)% this._map.gridWidth;
								tY=(tileY *tTileHeight)% this._map.gridHeight;
								break ;
							}
						if (tTileTexSet.isAnimation){
							var tAnimationSprite=new TileAniSprite();
							tAnimationSprite.x=tX;
							tAnimationSprite.y=tY;
							tAnimationSprite.setTileTextureSet(tIndex.toString(),tTileTexSet);
							gridSprite.addAniSprite(tAnimationSprite);
							gridSprite.addChild(tAnimationSprite);
							gridSprite.isHaveAnimation=true;
							}else {
							gridSprite.graphics.drawTexture(tTileTexSet.texture,tX+tTileTexSet.offX,tY+tTileTexSet.offY);
						}
						return true;
					}
				}
			}
		}
		return false;
	}

	/**
	*@private
	*清理当前对象
	*/
	__proto.clearAll=function(){
		this._map=null;
		this._mapData=null;
		this._tileWidthHalf=0;
		this._tileHeightHalf=0;
		this._mapWidthHalf=0;
		this._mapHeightHalf=0;
		this.layerName=null;
		var i=0;
		if (this._objDic){
			for (var p in this._objDic){
				delete this._objDic[p];
			}
			this._objDic=null;
		}
		if (this._dataDic){
			for (p in this._dataDic){
				delete this._dataDic[p];
			}
			this._dataDic=null;
		};
		var tGridSprite;
		for (i=0;i < this._gridSpriteArray.length;i++){
			tGridSprite=this._gridSpriteArray[i];
			tGridSprite.clearAll();
		}
		this._properties=null;
		this._tempMapPos=null;
		this.tarLayer=null;
	}

	return MapLayer;
})(Sprite)


/**
*TildMap的动画显示对象（一个动画（TileTexSet），可以绑定多个动画显示对象（TileAniSprite））
*@author ...
*/
//class laya.map.TileAniSprite extends laya.display.Sprite
var TileAniSprite=(function(_super){
	function TileAniSprite(){
		this._tileTextureSet=null;
		//动画的引用
		this._aniName=null;
		TileAniSprite.__super.call(this);
	}

	__class(TileAniSprite,'laya.map.TileAniSprite',_super);
	var __proto=TileAniSprite.prototype;
	/**
	*确定当前显示对象的名称以及属于哪个动画
	*@param aniName 当前动画显示对象的名字，名字唯一
	*@param tileTextureSet 当前显示对象属于哪个动画（一个动画，可以绑定多个同类显示对象）
	*/
	__proto.setTileTextureSet=function(aniName,tileTextureSet){
		this._aniName=aniName;
		this._tileTextureSet=tileTextureSet;
		tileTextureSet.addAniSprite(this._aniName,this);
	}

	/**
	*把当前动画加入到对应的动画刷新列表中
	*/
	__proto.show=function(){
		this._tileTextureSet.addAniSprite(this._aniName,this);
	}

	/**
	*把当前动画从对应的动画刷新列表中移除
	*/
	__proto.hide=function(){
		this._tileTextureSet.removeAniSprite(this._aniName);
	}

	/**
	*清理
	*/
	__proto.clearAll=function(){
		this._tileTextureSet.removeAniSprite(this._aniName);
		this.destroy();
		this._tileTextureSet=null;
		this._aniName=null;
	}

	return TileAniSprite;
})(Sprite)


	Laya.__init([TiledMap]);
})(window,document,Laya);

if (typeof define === 'function' && define.amd){
	define('laya.core', ['require', "exports"], function(require, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        for (var i in Laya) {
			var o = Laya[i];
            o && o.__isclass && (exports[i] = o);
        }
    });
}

(function(window,document,Laya){
	var __un=Laya.un,__uns=Laya.uns,__static=Laya.static,__class=Laya.class,__getset=Laya.getset,__newvec=Laya.__newvec;

	var Animation=laya.display.Animation,Browser=laya.utils.Browser,ClassUtils=laya.utils.ClassUtils,ColorFilter=laya.filters.ColorFilter;
	var Ease=laya.utils.Ease,Event=laya.events.Event,EventDispatcher=laya.events.EventDispatcher,Font=laya.display.css.Font;
	var FrameAnimation=laya.display.FrameAnimation,Graphics=laya.display.Graphics,Handler=laya.utils.Handler;
	var Input=laya.display.Input,Loader=laya.net.Loader,Node=laya.display.Node,Point=laya.maths.Point,Rectangle=laya.maths.Rectangle;
	var Render=laya.renders.Render,Sprite=laya.display.Sprite,Text=laya.display.Text,Texture=laya.resource.Texture;
	var Tween=laya.utils.Tween,Utils=laya.utils.Utils,WeakObject=laya.utils.WeakObject;
Laya.interface('laya.ui.IItem');
Laya.interface('laya.ui.ISelect');
Laya.interface('laya.ui.IRender');
Laya.interface('laya.ui.IComponent');
Laya.interface('laya.ui.IBox','IComponent');
/**
*<code>LayoutStyle</code> 是一个布局样式类。
*/
//class laya.ui.LayoutStyle
var LayoutStyle=(function(){
	function LayoutStyle(){
		/**一个布尔值，表示是否有效。*/
		this.enable=false;
		this.top=NaN;
		this.bottom=NaN;
		this.left=NaN;
		this.right=NaN;
		this.centerX=NaN;
		this.centerY=NaN;
		this.anchorX=NaN;
		this.anchorY=NaN;
	}

	__class(LayoutStyle,'laya.ui.LayoutStyle');
	__static(LayoutStyle,
	['EMPTY',function(){return this.EMPTY=new LayoutStyle();}
	]);
	return LayoutStyle;
})()


/**
*<code>Styles</code> 定义了组件常用的样式属性。
*/
//class laya.ui.Styles
var Styles=(function(){
	function Styles(){}
	__class(Styles,'laya.ui.Styles');
	Styles.labelColor="#000000";
	Styles.buttonStateNum=3;
	Styles.scrollBarMinNum=15;
	Styles.scrollBarDelayTime=500;
	__static(Styles,
	['defaultSizeGrid',function(){return this.defaultSizeGrid=[4,4,4,4,0];},'labelPadding',function(){return this.labelPadding=[2,2,2,2];},'inputLabelPadding',function(){return this.inputLabelPadding=[1,1,1,3];},'buttonLabelColors',function(){return this.buttonLabelColors=["#32556b","#32cc6b","#ff0000","#C0C0C0"];},'comboBoxItemColors',function(){return this.comboBoxItemColors=["#5e95b6","#ffffff","#000000","#8fa4b1","#ffffff"];}
	]);
	return Styles;
})()


/**
*<code>UIUtils</code> 是文本工具集。
*/
//class laya.ui.UIUtils
var UIUtils=(function(){
	function UIUtils(){}
	__class(UIUtils,'laya.ui.UIUtils');
	UIUtils.fillArray=function(arr,str,type){
		var temp=arr.concat();
		if (str){
			var a=str.split(",");
			for (var i=0,n=Math.min(temp.length,a.length);i < n;i++){
				var value=a[i];
				temp[i]=(value=="true" ? true :(value=="false" ? false :value));
				if (type !=null)temp[i]=type(value);
			}
		}
		return temp;
	}

	UIUtils.toColor=function(color){
		return Utils.toHexColor(color);
	}

	UIUtils.gray=function(traget,isGray){
		(isGray===void 0)&& (isGray=true);
		if (isGray){
			UIUtils.addFilter(traget,UIUtils.grayFilter);
			}else {
			UIUtils.clearFilter(traget,ColorFilter);
		}
	}

	UIUtils.addFilter=function(target,filter){
		var filters=target.filters || [];
		filters.push(filter);
		target.filters=filters;
	}

	UIUtils.clearFilter=function(target,filterType){
		var filters=target.filters;
		if (filters !=null && filters.length > 0){
			for (var i=filters.length-1;i >-1;i--){
				var filter=filters[i];
				if (Laya.__typeof(filter,filterType))filters.splice(i,1);
			}
			target.filters=filters;
		}
	}

	UIUtils._getReplaceStr=function(word){
		return UIUtils.escapeSequence[word];
	}

	UIUtils.adptString=function(str){
		return str.replace(/\\(\w)/g,UIUtils._getReplaceStr);
	}

	UIUtils.getBindFun=function(value){
		var fun=UIUtils._funMap.get(value);
		if (fun==null){
			var temp="\""+value+"\"";
			temp=temp.replace(/^"\${|}"$/g,"").replace(/\${/g,"\"+").replace(/}/g,"+\"");
			var str="(function(data){if(data==null)return;with(data){try{\nreturn "+temp+"\n}catch(e){}}})";
			fun=Laya._runScript(str);
			UIUtils._funMap.set(value,fun);
		}
		return fun;
	}

	__static(UIUtils,
	['grayFilter',function(){return this.grayFilter=new ColorFilter([0.3086,0.6094,0.082,0,0,0.3086,0.6094,0.082,0,0,0.3086,0.6094,0.082,0,0,0,0,0,1,0]);},'escapeSequence',function(){return this.escapeSequence={"\\n":"\n","\\t":"\t"};},'_funMap',function(){return this._funMap=new WeakObject();}
	]);
	return UIUtils;
})()


/**全局配置*/
//class UIConfig
var UIConfig=(function(){
	function UIConfig(){}
	__class(UIConfig,'UIConfig');
	UIConfig.touchScrollEnable=true;
	UIConfig.mouseWheelEnable=true;
	UIConfig.showButtons=true;
	UIConfig.popupBgColor="#000000";
	UIConfig.popupBgAlpha=0.5;
	UIConfig.closeDialogOnSide=true;
	return UIConfig;
})()


/**
*<code>AutoBitmap</code> 类是用于表示位图图像或绘制图形的显示对象。
*<p>封装了位置，宽高及九宫格的处理，供UI组件使用。</p>
*/
//class laya.ui.AutoBitmap extends laya.display.Graphics
var AutoBitmap=(function(_super){
	function AutoBitmap(){
		/**@private 是否自动缓存命令*/
		this.autoCacheCmd=true;
		/**@private 宽度*/
		this._width=0;
		/**@private 高度*/
		this._height=0;
		/**@private 源数据*/
		this._source=null;
		/**@private 网格数据*/
		this._sizeGrid=null;
		/**@private */
		this._isChanged=false;
		/**@private */
		this._offset=null;
		AutoBitmap.__super.call(this);
	}

	__class(AutoBitmap,'laya.ui.AutoBitmap',_super);
	var __proto=AutoBitmap.prototype;
	/**@inheritDoc */
	__proto.destroy=function(){
		_super.prototype.destroy.call(this);
		this._source=null;
		this._sizeGrid=null;
		this._offset=null;
	}

	/**@private */
	__proto._setChanged=function(){
		if (!this._isChanged){
			this._isChanged=true;
			Laya.timer.callLater(this,this.changeSource);
		}
	}

	/**
	*@private
	*修改纹理资源。
	*/
	__proto.changeSource=function(){
		this._isChanged=false;
		var source=this._source;
		if (!source || !source.bitmap)return;
		var width=this.width;
		var height=this.height;
		var sizeGrid=this._sizeGrid;
		var sw=source.sourceWidth;
		var sh=source.sourceHeight;
		if (!sizeGrid || (sw===width && sh===height)){
			this.cleanByTexture(source,this._offset ? this._offset[0] :0,this._offset ? this._offset[1] :0,width,height);
			}else {
			source.$_GID || (source.$_GID=Utils.getGID());
			var key=source.$_GID+"."+width+"."+height+"."+sizeGrid.join(".");
			if (Utils.isOKCmdList(WeakObject.I.get(key))){
				this.cmds=WeakObject.I.get(key);
				return;
			}
			this.clear();
			var top=sizeGrid[0];
			var right=sizeGrid[1];
			var bottom=sizeGrid[2];
			var left=sizeGrid[3];
			var repeat=sizeGrid[4];
			var needClip=false;
			if (width==sw){
				left=right=0;
			}
			if (height==sh){
				top=bottom=0;
			}
			if (left+right > width){
				var clipWidth=width;
				needClip=true;
				width=left+right;
				this.save();
				this.clipRect(0,0,clipWidth,height);
			}
			left && top && this.drawTexture(AutoBitmap.getTexture(source,0,0,left,top),0,0,left,top);
			right && top && this.drawTexture(AutoBitmap.getTexture(source,sw-right,0,right,top),width-right,0,right,top);
			left && bottom && this.drawTexture(AutoBitmap.getTexture(source,0,sh-bottom,left,bottom),0,height-bottom,left,bottom);
			right && bottom && this.drawTexture(AutoBitmap.getTexture(source,sw-right,sh-bottom,right,bottom),width-right,height-bottom,right,bottom);
			top && this.drawBitmap(repeat,AutoBitmap.getTexture(source,left,0,sw-left-right,top),left,0,width-left-right,top);
			bottom && this.drawBitmap(repeat,AutoBitmap.getTexture(source,left,sh-bottom,sw-left-right,bottom),left,height-bottom,width-left-right,bottom);
			left && this.drawBitmap(repeat,AutoBitmap.getTexture(source,0,top,left,sh-top-bottom),0,top,left,height-top-bottom);
			right && this.drawBitmap(repeat,AutoBitmap.getTexture(source,sw-right,top,right,sh-top-bottom),width-right,top,right,height-top-bottom);
			this.drawBitmap(repeat,AutoBitmap.getTexture(source,left,top,sw-left-right,sh-top-bottom),left,top,width-left-right,height-top-bottom);
			if (needClip)this.restore();
			if (this.autoCacheCmd && !Render.isConchApp)WeakObject.I.set(key,this.cmds);
		}
		this._repaint();
	}

	__proto.drawBitmap=function(repeat,tex,x,y,width,height){
		(width===void 0)&& (width=0);
		(height===void 0)&& (height=0);
		if (width < 0.1 || height < 0.1)return;
		if (repeat && (tex.width !=width || tex.height !=height))this.fillTexture(tex,x,y,width,height);
		else this.drawTexture(tex,x,y,width,height);
	}

	__proto.clear=function(recoverCmds){
		(recoverCmds===void 0)&& (recoverCmds=true);
		_super.prototype.clear.call(this,false);
	}

	/**
	*当前实例的有效缩放网格数据。
	*<p>如果设置为null,则在应用任何缩放转换时，将正常缩放整个显示对象。</p>
	*<p>数据格式：[上边距,右边距,下边距,左边距,是否重复填充(值为0：不重复填充，1：重复填充)]。
	*<ul><li>例如：[4,4,4,4,1]</li></ul></p>
	*<p> <code>sizeGrid</code> 的值如下所示：
	*<ol>
	*<li>上边距</li>
	*<li>右边距</li>
	*<li>下边距</li>
	*<li>左边距</li>
	*<li>是否重复填充(值为0：不重复填充，1：重复填充)</li>
	*</ol></p>
	*<p>当定义 <code>sizeGrid</code> 属性时，该显示对象被分割到以 <code>sizeGrid</code> 数据中的"上边距,右边距,下边距,左边距" 组成的矩形为基础的具有九个区域的网格中，该矩形定义网格的中心区域。网格的其它八个区域如下所示：
	*<ul>
	*<li>矩形上方的区域</li>
	*<li>矩形外的右上角</li>
	*<li>矩形左侧的区域</li>
	*<li>矩形右侧的区域</li>
	*<li>矩形外的左下角</li>
	*<li>矩形下方的区域</li>
	*<li>矩形外的右下角</li>
	*<li>矩形外的左上角</li>
	*</ul>
	*同时也支持3宫格，比如0,4,0,4,1为水平3宫格，4,0,4,0,1为垂直3宫格，3宫格性能比9宫格高。
	*</p>
	*/
	__getset(0,__proto,'sizeGrid',function(){
		return this._sizeGrid;
		},function(value){
		this._sizeGrid=value;
		this._setChanged();
	});

	/**
	*表示显示对象的宽度，以像素为单位。
	*/
	__getset(0,__proto,'width',function(){
		if (this._width)return this._width;
		if (this._source)return this._source.sourceWidth;
		return 0;
		},function(value){
		if (this._width !=value){
			this._width=value;
			this._setChanged();
		}
	});

	/**
	*表示显示对象的高度，以像素为单位。
	*/
	__getset(0,__proto,'height',function(){
		if (this._height)return this._height;
		if (this._source)return this._source.sourceHeight;
		return 0;
		},function(value){
		if (this._height !=value){
			this._height=value;
			this._setChanged();
		}
	});

	/**
	*对象的纹理资源。
	*@see laya.resource.Texture
	*/
	__getset(0,__proto,'source',function(){
		return this._source;
		},function(value){
		if (value){
			this._source=value
			this._setChanged();
			}else {
			this._source=null;
			this.clear();
		}
	});

	AutoBitmap.getTexture=function(tex,x,y,width,height){
		if (width <=0)width=1;
		if (height <=0)height=1;
		tex.$_GID || (tex.$_GID=Utils.getGID())
		var key=tex.$_GID+"."+x+"."+y+"."+width+"."+height;
		var texture=WeakObject.I.get(key);
		if (!texture||!texture.source){
			texture=Texture.createFromTexture(tex,x,y,width,height);
			WeakObject.I.set(key,texture);
		}
		return texture;
	}

	return AutoBitmap;
})(Graphics)


/**
*<code>UIEvent</code> 类用来定义UI组件类的事件类型。
*/
//class laya.ui.UIEvent extends laya.events.Event
var UIEvent=(function(_super){
	function UIEvent(){
		UIEvent.__super.call(this);;
	}

	__class(UIEvent,'laya.ui.UIEvent',_super);
	UIEvent.SHOW_TIP="showtip";
	UIEvent.HIDE_TIP="hidetip";
	return UIEvent;
})(Event)


/**
*<code>Component</code> 是ui控件类的基类。
*<p>生命周期：preinitialize > createChildren > initialize > 组件构造函数</p>
*/
//class laya.ui.Component extends laya.display.Sprite
var Component=(function(_super){
	function Component(){
		this._comXml=null;
		/**@private 控件的元数据。 */
		this._dataSource=null;
		/**@private 鼠标悬停提示 */
		this._toolTip=null;
		/**@private 标签 */
		this._tag=null;
		/**@private 禁用 */
		this._disabled=false;
		/**@private 变灰*/
		this._gray=false;
		/**
		*是否启用相对布局
		*/
		this.layoutEnabled=true;
		Component.__super.call(this);
		this._layout=LayoutStyle.EMPTY;
		this.preinitialize();
		this.createChildren();
		this.initialize();
	}

	__class(Component,'laya.ui.Component',_super);
	var __proto=Component.prototype;
	Laya.imps(__proto,{"laya.ui.IComponent":true})
	/**@inheritDoc */
	__proto.destroy=function(destroyChild){
		(destroyChild===void 0)&& (destroyChild=true);
		_super.prototype.destroy.call(this,destroyChild);
		this._dataSource=this._layout=null;
		this._tag=null;
		this._toolTip=null;
	}

	/**
	*<p>预初始化。</p>
	*@internal 子类可在此函数内设置、修改属性默认值
	*/
	__proto.preinitialize=function(){}
	/**
	*<p>创建并添加控件子节点。</p>
	*@internal 子类可在此函数内创建并添加子节点。
	*/
	__proto.createChildren=function(){}
	/**
	*<p>控件初始化。</p>
	*@internal 在此子对象已被创建，可以对子对象进行修改。
	*/
	__proto.initialize=function(){}
	/**
	*<p>延迟运行指定的函数。</p>
	*<p>在控件被显示在屏幕之前调用，一般用于延迟计算数据。</p>
	*@param method 要执行的函数的名称。例如，functionName。
	*@param args 传递给 <code>method</code> 函数的可选参数列表。
	*
	*@see #runCallLater()
	*/
	__proto.callLater=function(method,args){
		Laya.timer.callLater(this,method,args);
	}

	/**
	*<p>如果有需要延迟调用的函数（通过 <code>callLater</code> 函数设置），则立即执行延迟调用函数。</p>
	*@param method 要执行的函数名称。例如，functionName。
	*@see #callLater()
	*/
	__proto.runCallLater=function(method){
		Laya.timer.runCallLater(this,method);
	}

	/**
	*<p>立即执行影响宽高度量的延迟调用函数。</p>
	*@internal <p>使用 <code>runCallLater</code> 函数，立即执行影响宽高度量的延迟运行函数(使用 <code>callLater</code> 设置延迟执行函数)。</p>
	*@see #callLater()
	*@see #runCallLater()
	*/
	__proto.commitMeasure=function(){}
	/**
	*<p>重新调整对象的大小。</p>
	*/
	__proto.changeSize=function(){
		this.event(/*laya.events.Event.RESIZE*/"resize");
	}

	/**
	*@private
	*<p>获取对象的布局样式。</p>
	*/
	__proto.getLayout=function(){
		this._layout===LayoutStyle.EMPTY && (this._layout=new LayoutStyle());
		return this._layout;
	}

	/**
	*@private
	*<p>指定对象是否可使用布局。</p>
	*<p>如果值为true,则此对象可以使用布局样式，否则不使用布局样式。</p>
	*@param value 一个 Boolean 值，指定对象是否可使用布局。
	*/
	__proto._setLayoutEnabled=function(value){
		if (this._layout && this._layout.enable !=value){
			this._layout.enable=value;
			this.on(/*laya.events.Event.ADDED*/"added",this,this.onAdded);
			this.on(/*laya.events.Event.REMOVED*/"removed",this,this.onRemoved);
			if (this.parent){
				this.onAdded();
			}
		}
	}

	/**
	*对象从显示列表移除的事件侦听处理函数。
	*/
	__proto.onRemoved=function(){
		this.parent.off(/*laya.events.Event.RESIZE*/"resize",this,this.onCompResize);
	}

	/**
	*对象被添加到显示列表的事件侦听处理函数。
	*/
	__proto.onAdded=function(){
		this.parent.on(/*laya.events.Event.RESIZE*/"resize",this,this.onCompResize);
		this.resetLayoutX();
		this.resetLayoutY();
	}

	/**
	*父容器的 <code>Event.RESIZE</code> 事件侦听处理函数。
	*/
	__proto.onCompResize=function(){
		if (this._layout && this._layout.enable){
			this.resetLayoutX();
			this.resetLayoutY();
		}
	}

	/**
	*<p>重置对象的 <code>X</code> 轴（水平方向）布局。</p>
	*/
	__proto.resetLayoutX=function(){
		var layout=this._layout;
		if (!isNaN(layout.anchorX))this.pivotX=layout.anchorX *this.width;
		if (!this.layoutEnabled)return;
		var parent=this.parent;
		if (parent){
			if (!isNaN(layout.centerX)){
				this.x=Math.round((parent.width-this.displayWidth)*0.5+layout.centerX+this.pivotX *this.scaleX);
				}else if (!isNaN(layout.left)){
				this.x=Math.round(layout.left+this.pivotX *this.scaleX);
				if (!isNaN(layout.right)){
					this.width=(parent._width-layout.left-layout.right)/ (this.scaleX || 0.01);
				}
				}else if (!isNaN(layout.right)){
				this.x=Math.round(parent.width-this.displayWidth-layout.right+this.pivotX *this.scaleX);
			}
		}
	}

	/**
	*<p>重置对象的 <code>Y</code> 轴（垂直方向）布局。</p>
	*/
	__proto.resetLayoutY=function(){
		var layout=this._layout;
		if (!isNaN(layout.anchorY))this.pivotY=layout.anchorY *this.height;
		if (!this.layoutEnabled)return;
		var parent=this.parent;
		if (parent){
			if (!isNaN(layout.centerY)){
				this.y=Math.round((parent.height-this.displayHeight)*0.5+layout.centerY+this.pivotY *this.scaleY);
				}else if (!isNaN(layout.top)){
				this.y=Math.round(layout.top+this.pivotY *this.scaleY);
				if (!isNaN(layout.bottom)){
					this.height=(parent._height-layout.top-layout.bottom)/ (this.scaleY || 0.01);
				}
				}else if (!isNaN(layout.bottom)){
				this.y=Math.round(parent.height-this.displayHeight-layout.bottom+this.pivotY *this.scaleY);
			}
		}
	}

	/**
	*对象的 <code>Event.MOUSE_OVER</code> 事件侦听处理函数。
	*/
	__proto.onMouseOver=function(e){
		Laya.stage.event(/*laya.ui.UIEvent.SHOW_TIP*/"showtip",this._toolTip);
	}

	/**
	*对象的 <code>Event.MOUSE_OUT</code> 事件侦听处理函数。
	*/
	__proto.onMouseOut=function(e){
		Laya.stage.event(/*laya.ui.UIEvent.HIDE_TIP*/"hidetip",this._toolTip);
	}

	/**
	*<p>对象的显示宽度（以像素为单位）。</p>
	*/
	__getset(0,__proto,'displayWidth',function(){
		return this.width *this.scaleX;
	});

	/**
	*<p>表示显示对象的宽度，以像素为单位。</p>
	*<p><b>注：</b>当值为0时，宽度为自适应大小。</p>
	*/
	__getset(0,__proto,'width',function(){
		if (this._width)return this._width;
		return this.measureWidth;
		},function(value){
		if (this._width !=value){
			this._width=value;
			this.conchModel && this.conchModel.size(this._width,this._height);
			this.callLater(this.changeSize);
			if (this._layout.enable && (!isNaN(this._layout.centerX)|| !isNaN(this._layout.right)|| !isNaN(this._layout.anchorX)))this.resetLayoutX();
		}
	});

	/**
	*<p>显示对象的实际显示区域宽度（以像素为单位）。</p>
	*/
	__getset(0,__proto,'measureWidth',function(){
		var max=0;
		this.commitMeasure();
		for (var i=this.numChildren-1;i >-1;i--){
			var comp=this.getChildAt(i);
			if (comp.visible){
				max=Math.max(comp.x+comp.width *comp.scaleX,max);
			}
		}
		return max;
	});

	/**
	*<p>对象的显示高度（以像素为单位）。</p>
	*/
	__getset(0,__proto,'displayHeight',function(){
		return this.height *this.scaleY;
	});

	/**
	*<p>表示显示对象的高度，以像素为单位。</p>
	*<p><b>注：</b>当值为0时，高度为自适应大小。</p>
	*/
	__getset(0,__proto,'height',function(){
		if (this._height)return this._height;
		return this.measureHeight;
		},function(value){
		if (this._height !=value){
			this._height=value;
			this.conchModel && this.conchModel.size(this._width,this._height);
			this.callLater(this.changeSize);
			if (this._layout.enable && (!isNaN(this._layout.centerY)|| !isNaN(this._layout.bottom)|| !isNaN(this._layout.anchorY)))this.resetLayoutY();
		}
	});

	/**
	*<p>数据赋值，通过对UI赋值来控制UI显示逻辑。</p>
	*<p>简单赋值会更改组件的默认属性，使用大括号可以指定组件的任意属性进行赋值。</p>
	*@example
	//默认属性赋值
	dataSource={label1:"改变了label",checkbox1:true};//(更改了label1的text属性值，更改checkbox1的selected属性)。
	//任意属性赋值
	dataSource={label2:{text:"改变了label",size:14},checkbox2:{selected:true,x:10}};
	*/
	__getset(0,__proto,'dataSource',function(){
		return this._dataSource;
		},function(value){
		this._dataSource=value;
		for (var prop in this._dataSource){
			if (this.hasOwnProperty(prop)&& !((typeof (this[prop])=='function'))){
				this[prop]=this._dataSource[prop];
			}
		}
	});

	/**@inheritDoc */
	__getset(0,__proto,'scaleY',_super.prototype._$get_scaleY,function(value){
		if (Laya.superGet(Sprite,this,'scaleY')!=value){
			Laya.superSet(Sprite,this,'scaleY',value);
			this.callLater(this.changeSize);
			this._layout.enable && this.resetLayoutY();
		}
	});

	/**
	*<p>显示对象的实际显示区域高度（以像素为单位）。</p>
	*/
	__getset(0,__proto,'measureHeight',function(){
		var max=0;
		this.commitMeasure();
		for (var i=this.numChildren-1;i >-1;i--){
			var comp=this.getChildAt(i);
			if (comp.visible){
				max=Math.max(comp.y+comp.height *comp.scaleY,max);
			}
		}
		return max;
	});

	/**@inheritDoc */
	__getset(0,__proto,'scaleX',_super.prototype._$get_scaleX,function(value){
		if (Laya.superGet(Sprite,this,'scaleX')!=value){
			Laya.superSet(Sprite,this,'scaleX',value);
			this.callLater(this.changeSize);
			this._layout.enable && this.resetLayoutX();
		}
	});

	/**
	*<p>从组件顶边到其内容区域顶边之间的垂直距离（以像素为单位）。</p>
	*/
	__getset(0,__proto,'top',function(){
		return this._layout.top;
		},function(value){
		if (value !=this._layout.top){
			this.getLayout().top=value;
			this._setLayoutEnabled(true);
		}
		this.resetLayoutY();
	});

	/**
	*<p>从组件底边到其内容区域底边之间的垂直距离（以像素为单位）。</p>
	*/
	__getset(0,__proto,'bottom',function(){
		return this._layout.bottom;
		},function(value){
		if (value !=this._layout.bottom){
			this.getLayout().bottom=value;
			this._setLayoutEnabled(true);
		}
		this.resetLayoutY();
	});

	/**
	*<p>从组件左边到其内容区域左边之间的水平距离（以像素为单位）。</p>
	*/
	__getset(0,__proto,'left',function(){
		return this._layout.left;
		},function(value){
		if (value !=this._layout.left){
			this.getLayout().left=value;
			this._setLayoutEnabled(true);
		}
		this.resetLayoutX();
	});

	/**
	*<p>从组件右边到其内容区域右边之间的水平距离（以像素为单位）。</p>
	*/
	__getset(0,__proto,'right',function(){
		return this._layout.right;
		},function(value){
		if (value !=this._layout.right){
			this.getLayout().right=value;
			this._setLayoutEnabled(true);
		}
		this.resetLayoutX();
	});

	/**
	*<p>在父容器中，此对象的水平方向中轴线与父容器的水平方向中心线的距离（以像素为单位）。</p>
	*/
	__getset(0,__proto,'centerX',function(){
		return this._layout.centerX;
		},function(value){
		if (value !=this._layout.centerX){
			this.getLayout().centerX=value;
			this._setLayoutEnabled(true);
		}
		this.resetLayoutX();
	});

	/**
	*<p>在父容器中，此对象的垂直方向中轴线与父容器的垂直方向中心线的距离（以像素为单位）。</p>
	*/
	__getset(0,__proto,'centerY',function(){
		return this._layout.centerY;
		},function(value){
		if (value !=this._layout.centerY){
			this.getLayout().centerY=value;
			this._setLayoutEnabled(true);
		}
		this.resetLayoutY();
	});

	/**X轴锚点，值为0-1*/
	__getset(0,__proto,'anchorX',function(){
		return this._layout.anchorX;
		},function(value){
		if (value !=this._layout.anchorX){
			this.getLayout().anchorX=value;
			this._setLayoutEnabled(true);
		}
		this.resetLayoutX();
	});

	/**Y轴锚点，值为0-1*/
	__getset(0,__proto,'anchorY',function(){
		return this._layout.anchorY;
		},function(value){
		if (value !=this._layout.anchorY){
			this.getLayout().anchorY=value;
			this._setLayoutEnabled(true);
		}
		this.resetLayoutY();
	});

	/**
	*<p>对象的标签。</p>
	*@internal 冗余字段，可以用来储存数据。
	*/
	__getset(0,__proto,'tag',function(){
		return this._tag;
		},function(value){
		this._tag=value;
	});

	/**
	*<p>鼠标悬停提示。</p>
	*<p>可以赋值为文本 <code>String</code> 或函数 <code>Handler</code> ，用来实现自定义样式的鼠标提示和参数携带等。</p>
	*@example
	*private var _testTips:TestTipsUI=new TestTipsUI();
	*private function testTips():void {
		//简单鼠标提示
		*btn2.toolTip="这里是鼠标提示&lt;b&gt;粗体&lt;/b&gt;&lt;br&gt;换行";
		//自定义的鼠标提示
		*btn1.toolTip=showTips1;
		//带参数的自定义鼠标提示
		*clip.toolTip=new Handler(this,showTips2,["clip"]);
		*}
	*private function showTips1():void {
		*_testTips.label.text="这里是按钮["+btn1.label+"]";
		*tip.addChild(_testTips);
		*}
	*private function showTips2(name:String):void {
		*_testTips.label.text="这里是"+name;
		*tip.addChild(_testTips);
		*}
	*/
	__getset(0,__proto,'toolTip',function(){
		return this._toolTip;
		},function(value){
		if (this._toolTip !=value){
			this._toolTip=value;
			if (value !=null){
				this.on(/*laya.events.Event.MOUSE_OVER*/"mouseover",this,this.onMouseOver);
				this.on(/*laya.events.Event.MOUSE_OUT*/"mouseout",this,this.onMouseOut);
				}else {
				this.off(/*laya.events.Event.MOUSE_OVER*/"mouseover",this,this.onMouseOver);
				this.off(/*laya.events.Event.MOUSE_OUT*/"mouseout",this,this.onMouseOut);
			}
		}
	});

	/**
	*XML 数据。
	*/
	__getset(0,__proto,'comXml',function(){
		return this._comXml;
		},function(value){
		this._comXml=value;
	});

	/**是否变灰。*/
	__getset(0,__proto,'gray',function(){
		return this._gray;
		},function(value){
		if (value!==this._gray){
			this._gray=value;
			UIUtils.gray(this,value);
		}
	});

	/**是否禁用页面，设置为true后，会变灰并且禁用鼠标。*/
	__getset(0,__proto,'disabled',function(){
		return this._disabled;
		},function(value){
		if (value!==this._disabled){
			this.gray=this._disabled=value;
			this.mouseEnabled=!value;
		}
	});

	return Component;
})(Sprite)


/**
*<code>DialogManager</code> 对话框管理容器，所有的对话框都在该容器内，并且受管理器管理。
*任意对话框打开和关闭，都会出发管理类的open和close事件
*可以通过UIConfig设置弹出框背景透明度，模式窗口点击边缘是否关闭，点击窗口是否切换层次等
*通过设置对话框的zOrder属性，可以更改弹出的层次
*/
//class laya.ui.DialogManager extends laya.display.Sprite
var DialogManager=(function(_super){
	function DialogManager(){
		/**锁屏层*/
		this.lockLayer=null;
		/**@private 全局默认弹出对话框效果，可以设置一个效果代替默认的弹出效果，如果不想有任何效果，可以赋值为null*/
		this.popupEffect=function(dialog){
			dialog.scale(1,1);
			Tween.from(dialog,{x:Laya.stage.width / 2,y:Laya.stage.height / 2,scaleX:0,scaleY:0},300,Ease.backOut,Handler.create(this,this.doOpen,[dialog]));
		}
		/**@private 全局默认关闭对话框效果，可以设置一个效果代替默认的关闭效果，如果不想有任何效果，可以赋值为null*/
		this.closeEffect=function(dialog,type){
			Tween.to(dialog,{x:Laya.stage.width / 2,y:Laya.stage.height / 2,scaleX:0,scaleY:0},300,Ease.strongOut,Handler.create(this,this.doClose,[dialog,type]));
		}
		DialogManager.__super.call(this);
		this.maskLayer=new Sprite();
		this.popupEffectHandler=new Handler(this,this.popupEffect);
		this.closeEffectHandler=new Handler(this,this.closeEffect);
		this.mouseEnabled=this.maskLayer.mouseEnabled=true;
		this.zOrder=1000;
		Laya.stage.addChild(this);
		Laya.stage.on(/*laya.events.Event.RESIZE*/"resize",this,this._onResize);
		if (UIConfig.closeDialogOnSide)this.maskLayer.on("click",this,this._closeOnSide);
		this._onResize(null);
	}

	__class(DialogManager,'laya.ui.DialogManager',_super);
	var __proto=DialogManager.prototype;
	__proto._closeOnSide=function(){
		var dialog=this.getChildAt(this.numChildren-1);
		if ((dialog instanceof laya.ui.Dialog ))dialog.close("side");
	}

	/**设置锁定界面，如果为空则什么都不显示*/
	__proto.setLockView=function(value){
		if (!this.lockLayer){
			this.lockLayer=new Box();
			this.lockLayer.mouseEnabled=true;
			this.lockLayer.size(Laya.stage.width,Laya.stage.height);
		}
		this.lockLayer.removeChildren();
		if (value){
			value.centerX=value.centerY=0;
			this.lockLayer.addChild(value);
		}
	}

	/**@private */
	__proto._onResize=function(e){
		var width=this.maskLayer.width=Laya.stage.width;
		var height=this.maskLayer.height=Laya.stage.height;
		if (this.lockLayer)this.lockLayer.size(width,height);
		this.maskLayer.graphics.clear();
		this.maskLayer.graphics.drawRect(0,0,width,height,UIConfig.popupBgColor);
		this.maskLayer.alpha=UIConfig.popupBgAlpha;
		for (var i=this.numChildren-1;i >-1;i--){
			var item=this.getChildAt(i);
			if (item.popupCenter)this._centerDialog(item);
		}
	}

	__proto._centerDialog=function(dialog){
		dialog.x=Math.round(((Laya.stage.width-dialog.width)>> 1)+dialog.pivotX);
		dialog.y=Math.round(((Laya.stage.height-dialog.height)>> 1)+dialog.pivotY);
	}

	/**
	*显示对话框(非模式窗口类型)。
	*@param dialog 需要显示的对象框 <code>Dialog</code> 实例。
	*@param closeOther 是否关闭其它对话框，若值为ture，则关闭其它的对话框。
	*@param showEffect 是否显示弹出效果
	*/
	__proto.open=function(dialog,closeOther,showEffect){
		(closeOther===void 0)&& (closeOther=false);
		(showEffect===void 0)&& (showEffect=false);
		if (closeOther)this._closeAll();
		if (dialog.popupCenter)this._centerDialog(dialog);
		this.addChild(dialog);
		if (dialog.isModal || this._$P["hasZorder"])this.timer.callLater(this,this._checkMask);
		if (showEffect && dialog.popupEffect !=null)dialog.popupEffect.runWith(dialog);
		else this.doOpen(dialog);
		this.event(/*laya.events.Event.OPEN*/"open");
	}

	/**
	*执行打开对话框。
	*@param dialog 需要关闭的对象框 <code>Dialog</code> 实例。
	*@param type 关闭的类型，默认为空
	*/
	__proto.doOpen=function(dialog){
		dialog.onOpened();
	}

	/**
	*锁定所有层，显示加载条信息，防止双击
	*/
	__proto.lock=function(value){
		if (this.lockLayer){
			if (value)this.addChild(this.lockLayer);
			else this.lockLayer.removeSelf();
		}
	}

	/**
	*关闭对话框。
	*@param dialog 需要关闭的对象框 <code>Dialog</code> 实例。
	*@param type 关闭的类型，默认为空
	*@param showEffect 是否显示弹出效果
	*/
	__proto.close=function(dialog,type,showEffect){
		(showEffect===void 0)&& (showEffect=false);
		if (showEffect && dialog.closeEffect !=null)dialog.closeEffect.runWith([dialog,type]);
		else this.doClose(dialog,type);
		this.event(/*laya.events.Event.CLOSE*/"close");
	}

	/**
	*执行关闭对话框。
	*@param dialog 需要关闭的对象框 <code>Dialog</code> 实例。
	*@param type 关闭的类型，默认为空
	*/
	__proto.doClose=function(dialog,type){
		dialog.removeSelf();
		dialog.isModal && this._checkMask();
		dialog.closeHandler && dialog.closeHandler.runWith(type);
		dialog.onClosed(type);
	}

	/**
	*关闭所有的对话框。
	*/
	__proto.closeAll=function(){
		this._closeAll();
		this.event(/*laya.events.Event.CLOSE*/"close");
	}

	/**@private */
	__proto._closeAll=function(){
		for (var i=this.numChildren-1;i >-1;i--){
			var item=this.getChildAt(i);
			if (item && item.close !=null){
				this.doClose(item);
			}
		}
	}

	/**
	*根据组获取所有对话框
	*@param group 组名称
	*@return 对话框数组
	*/
	__proto.getDialogsByGroup=function(group){
		var arr=[];
		for (var i=this.numChildren-1;i >-1;i--){
			var item=this.getChildAt(i);
			if (item && item.group===group){
				arr.push(item);
			}
		}
		return arr;
	}

	/**
	*根据组关闭所有弹出框
	*@param group 需要关闭的组名称
	*@return 需要关闭的对话框数组
	*/
	__proto.closeByGroup=function(group){
		var arr=[];
		for (var i=this.numChildren-1;i >-1;i--){
			var item=this.getChildAt(i);
			if (item && item.group===group){
				item.close();
				arr.push(item);
			}
		}
		return arr;
	}

	/**@private 发生层次改变后，重新检查遮罩层是否正确*/
	__proto._checkMask=function(){
		this.maskLayer.removeSelf();
		for (var i=this.numChildren-1;i >-1;i--){
			var dialog=this.getChildAt(i);
			if (dialog && dialog.isModal){
				this.addChildAt(this.maskLayer,i);
				return;
			}
		}
	}

	return DialogManager;
})(Sprite)


/**
*<code>Box</code> 类是一个控件容器类。
*/
//class laya.ui.Box extends laya.ui.Component
var Box=(function(_super){
	function Box(){
		Box.__super.call(this);;
	}

	__class(Box,'laya.ui.Box',_super);
	var __proto=Box.prototype;
	Laya.imps(__proto,{"laya.ui.IBox":true})
	/**@inheritDoc */
	__getset(0,__proto,'dataSource',_super.prototype._$get_dataSource,function(value){
		this._dataSource=value;
		for (var name in value){
			var comp=this.getChildByName(name);
			if (comp)comp.dataSource=value[name];
			else if (this.hasOwnProperty(name)&& !((typeof (this[name])=='function')))this[name]=value[name];
		}
	});

	return Box;
})(Component)


/**
*<code>Button</code> 组件用来表示常用的多态按钮。 <code>Button</code> 组件可显示文本标签、图标或同时显示两者。 *
*<p>可以是单态，两态和三态，默认三态(up,over,down)。</p>
*
*@example <caption>以下示例代码，创建了一个 <code>Button</code> 实例。</caption>
*package
*{
	*import laya.ui.Button;
	*import laya.utils.Handler;
	*public class Button_Example
	*{
		*public function Button_Example()
		*{
			*Laya.init(640,800);//设置游戏画布宽高。
			*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
			*Laya.loader.load("resource/ui/button.png",Handler.create(this,onLoadComplete));//加载资源。
			*}
		*private function onLoadComplete():void
		*{
			*trace("资源加载完成！");
			*var button:Button=new Button("resource/ui/button.png","label");//创建一个 Button 类的实例对象 button ,并传入它的皮肤。
			*button.x=100;//设置 button 对象的属性 x 的值，用于控制 button 对象的显示位置。
			*button.y=100;//设置 button 对象的属性 y 的值，用于控制 button 对象的显示位置。
			*button.clickHandler=new Handler(this,onClickButton,[button]);//设置 button 的点击事件处理器。
			*Laya.stage.addChild(button);//将此 button 对象添加到显示列表。
			*}
		*private function onClickButton(button:Button):void
		*{
			*trace("按钮button被点击了！");
			*}
		*}
	*}
*@example
*Laya.init(640,800);//设置游戏画布宽高、渲染模式。
*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
*Laya.loader.load("resource/ui/button.png",laya.utils.Handler.create(this,loadComplete));//加载资源
*function loadComplete()
*{
	*console.log("资源加载完成！");
	*var button=new laya.ui.Button("resource/ui/button.png","label");//创建一个 Button 类的实例对象 button ,传入它的皮肤skin和标签label。
	*button.x=100;//设置 button 对象的属性 x 的值，用于控制 button 对象的显示位置。
	*button.y=100;//设置 button 对象的属性 y 的值，用于控制 button 对象的显示位置。
	*button.clickHandler=laya.utils.Handler.create(this,onClickButton,[button],false);//设置 button 的点击事件处理函数。
	*Laya.stage.addChild(button);//将此 button 对象添加到显示列表。
	*}
*function onClickButton(button)
*{
	*console.log("按钮被点击了。",button);
	*}
*@example
*import Button=laya.ui.Button;
*import Handler=laya.utils.Handler;
*class Button_Example{
	*constructor()
	*{
		*Laya.init(640,800);
		*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
		*Laya.loader.load("resource/ui/button.png",laya.utils.Handler.create(this,this.onLoadComplete));//加载资源。
		*}
	*private onLoadComplete()
	*{
		*var button:Button=new Button("resource/ui/button.png","label");//创建一个 Button 类的实例对象 button ,并传入它的皮肤。
		*button.x=100;//设置 button 对象的属性 x 的值，用于控制 button 对象的显示位置。
		*button.y=100;//设置 button 对象的属性 y 的值，用于控制 button 对象的显示位置。
		*button.clickHandler=new Handler(this,this.onClickButton,[button]);//设置 button 的点击事件处理器。
		*Laya.stage.addChild(button);//将此 button 对象添加到显示列表。
		*}
	*private onClickButton(button:Button):void
	*{
		*console.log("按钮button被点击了！")
		*}
	*}
*/
//class laya.ui.Button extends laya.ui.Component
var Button=(function(_super){
	function Button(skin,label){
		/**
		*指定按钮按下时是否是切换按钮的显示状态。
		*
		*@example 以下示例代码，创建了一个 <code>Button</code> 实例，并设置为切换按钮。
		*@example
		*package
		*{
			*import laya.ui.Button;
			*import laya.utils.Handler;
			*public class Button_toggle
			*{
				*public function Button_toggle()
				*{
					*Laya.init(640,800);//设置游戏画布宽高、渲染模式。
					*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
					*Laya.loader.load("resource/ui/button.png",Handler.create(this,onLoadComplete));
					*}
				*private function onLoadComplete():void
				*{
					*trace("资源加载完成！");
					*var button:Button=new Button("resource/ui/button.png","label");//创建一个 Button 实例对象 button ,传入它的皮肤skin和标签label。
					*button.x=100;//设置 button 对象的属性 x 的值，用于控制 button 对象的显示位置。
					*button.y=100;//设置 button 对象的属性 y 的值，用于控制 button 对象的显示位置。
					*button.toggle=true;//设置 button 对象为切换按钮。
					*button.clickHandler=new Handler(this,onClickButton,[button]);//设置 button 的点击事件处理器。
					*Laya.stage.addChild(button);//将此 button 对象添加到显示列表。
					*}
				*private function onClickButton(button:Button):void
				*{
					*trace("button.selected = "+button.selected);
					*}
				*}
			*}
		*@example
		*Laya.init(640,800);//设置游戏画布宽高、渲染模式。
		*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
		*Laya.loader.load("resource/ui/button.png",laya.utils.Handler.create(this,loadComplete));//加载资源
		*function loadComplete()
		*{
			*console.log("资源加载完成！");
			*var button=new laya.ui.Button("resource/ui/button.png","label");//创建一个 Button 类的实例对象 button ,传入它的皮肤skin和标签label。
			*button.x=100;//设置 button 对象的属性 x 的值，用于控制 button 对象的显示位置。
			*button.y=100;//设置 button 对象的属性 y 的值，用于控制 button 对象的显示位置。
			*button.toggle=true;//设置 button 对象为切换按钮。
			*button.clickHandler=laya.utils.Handler.create(this,onClickButton,[button],false);//设置 button 的点击事件处理器。
			*Laya.stage.addChild(button);//将此 button 对象添加到显示列表。
			*}
		*function onClickButton(button)
		*{
			*console.log("button.selected = ",button.selected);
			*}
		*@example
		*Laya.init(640,800);//设置游戏画布宽高、渲染模式。
		*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
		*Laya.loader.load("button.png",null,null,null,null,null);//加载资源
		*function loadComplete(){
			*console.log("资源加载完成！");
			*var button:laya.ui.Button=new laya.ui.Button("button.png","label");//创建一个 Button 类的实例对象 button ,传入它的皮肤skin和标签label。
			*button.x=100;//设置 button 对象的属性 x 的值，用于控制 button 对象的显示位置。
			*button.y=100;//设置 button 对象的属性 y 的值，用于控制 button 对象的显示位置。
			*button.toggle=true;//设置 button 对象为切换按钮。
			*button.clickHandler=laya.utils.Handler.create(this,onClickButton,[button],false);//设置 button 的点击事件处理器。
			*Laya.stage.addChild(button);//将此 button 对象添加到显示列表。
			*}
		*function onClickButton(button){
			*console.log("button.selected = ",button.selected);
			*}
		*/
		this.toggle=false;
		/**
		*@private
		*/
		this._bitmap=null;
		/**
		*@private
		*按钮上的文本。
		*/
		this._text=null;
		/**
		*@private
		*按钮文本标签描边的颜色值。
		*/
		this._strokeColors=null;
		/**
		*@private
		*按钮的状态值。
		*/
		this._state=0;
		/**
		*@private
		*表示按钮的选中状态。
		*/
		this._selected=false;
		/**
		*@private
		*按钮的皮肤资源。
		*/
		this._skin=null;
		/**
		*@private
		*指定此显示对象是否自动计算并改变大小等属性。
		*/
		this._autoSize=true;
		/**
		*@private
		*源数据。
		*/
		this._sources=null;
		/**
		*@private
		*按钮的点击事件函数。
		*/
		this._clickHandler=null;
		/**
		*@private
		*/
		this._stateChanged=false;
		Button.__super.call(this);
		this._labelColors=Styles.buttonLabelColors;
		this._stateNum=Styles.buttonStateNum;
		(label===void 0)&& (label="");
		this.skin=skin;
		this.label=label;
	}

	__class(Button,'laya.ui.Button',_super);
	var __proto=Button.prototype;
	Laya.imps(__proto,{"laya.ui.ISelect":true})
	/**@inheritDoc */
	__proto.destroy=function(destroyChild){
		(destroyChild===void 0)&& (destroyChild=true);
		_super.prototype.destroy.call(this,destroyChild);
		this._bitmap && this._bitmap.destroy();
		this._text && this._text.destroy(destroyChild);
		this._bitmap=null;
		this._text=null;
		this._clickHandler=null;
		this._labelColors=this._sources=this._strokeColors=null;
	}

	/**@inheritDoc */
	__proto.createChildren=function(){
		this.graphics=this._bitmap=new AutoBitmap();
	}

	/**@private */
	__proto.createText=function(){
		if (!this._text){
			this._text=new Text();
			this._text.overflow=Text.HIDDEN;
			this._text.align="center";
			this._text.valign="middle";
			this._text.width=this._width;
			this._text.height=this._height;
		}
	}

	/**@inheritDoc */
	__proto.initialize=function(){
		if (this._mouseEnableState!==1){
			this.mouseEnabled=true;
			this._setBit(/*laya.display.Node.MOUSEENABLE*/0x2,true);
		}
		this._createListener(/*laya.events.Event.MOUSE_OVER*/"mouseover",this,this.onMouse,null,false,false);
		this._createListener(/*laya.events.Event.MOUSE_OUT*/"mouseout",this,this.onMouse,null,false,false);
		this._createListener(/*laya.events.Event.MOUSE_DOWN*/"mousedown",this,this.onMouse,null,false,false);
		this._createListener(/*laya.events.Event.MOUSE_UP*/"mouseup",this,this.onMouse,null,false,false);
		this._createListener(/*laya.events.Event.CLICK*/"click",this,this.onMouse,null,false,false);
	}

	/**
	*对象的 <code>Event.MOUSE_OVER、Event.MOUSE_OUT、Event.MOUSE_DOWN、Event.MOUSE_UP、Event.CLICK</code> 事件侦听处理函数。
	*@param e Event 对象。
	*/
	__proto.onMouse=function(e){
		if (this.toggle===false && this._selected)return;
		if (e.type===/*laya.events.Event.CLICK*/"click"){
			this.toggle && (this.selected=!this._selected);
			this._clickHandler && this._clickHandler.run();
			return;
		}
		!this._selected && (this.state=Button.stateMap[e.type]);
	}

	/**
	*@private
	*对象的资源切片发生改变。
	*/
	__proto.changeClips=function(){
		var img=Loader.getRes(this._skin);
		if (!img){
			console.log("lose skin",this._skin);
			return;
		};
		var width=img.sourceWidth;
		var height=img.sourceHeight / this._stateNum;
		img.$_GID || (img.$_GID=Utils.getGID());
		var key=img.$_GID+"-"+this._stateNum;
		var clips=WeakObject.I.get(key);
		if (!Utils.isOkTextureList(clips)){
			clips=null;
		}
		if (clips)this._sources=clips;
		else {
			this._sources=[];
			if (this._stateNum===1){
				this._sources.push(img);
				}else {
				for (var i=0;i < this._stateNum;i++){
					this._sources.push(Texture.createFromTexture(img,0,height *i,width,height));
				}
			}
			WeakObject.I.set(key,this._sources);
		}
		if (this._autoSize){
			this._bitmap.width=this._width || width;
			this._bitmap.height=this._height || height;
			if (this._text){
				this._text.width=this._bitmap.width;
				this._text.height=this._bitmap.height;
			}
			}else {
			this._text && (this._text.x=width);
		}
	}

	/**
	*@private
	*改变对象的状态。
	*/
	__proto.changeState=function(){
		this._stateChanged=false;
		this.runCallLater(this.changeClips);
		var index=this._state < this._stateNum ? this._state :this._stateNum-1;
		this._sources && (this._bitmap.source=this._sources[index]);
		if (this.label){
			this._text.color=this._labelColors[index];
			if (this._strokeColors)this._text.strokeColor=this._strokeColors[index];
		}
	}

	/**@private */
	__proto._setStateChanged=function(){
		if (!this._stateChanged){
			this._stateChanged=true;
			this.callLater(this.changeState);
		}
	}

	/**
	*<p>描边颜色，以字符串表示。</p>
	*默认值为 "#000000"（黑色）;
	*@see laya.display.Text.strokeColor()
	*/
	__getset(0,__proto,'labelStrokeColor',function(){
		this.createText();
		return this._text.strokeColor;
		},function(value){
		this.createText();
		this._text.strokeColor=value
	});

	/**
	*@inheritDoc
	*/
	__getset(0,__proto,'measureHeight',function(){
		this.runCallLater(this.changeClips);
		return this._text ? Math.max(this._bitmap.height,this._text.height):this._bitmap.height;
	});

	/**
	*<p>对象的皮肤资源地址。</p>
	*支持单态，两态和三态，用 <code>stateNum</code> 属性设置
	*<p>对象的皮肤地址，以字符串表示。</p>
	*@see #stateNum
	*/
	__getset(0,__proto,'skin',function(){
		return this._skin;
		},function(value){
		if (this._skin !=value){
			this._skin=value;
			this.callLater(this.changeClips);
			this._setStateChanged();
		}
	});

	/**
	*对象的状态值。
	*@see #stateMap
	*/
	__getset(0,__proto,'state',function(){
		return this._state;
		},function(value){
		if (this._state !=value){
			this._state=value;
			this._setStateChanged();
		}
	});

	/**
	*按钮文本标签 <code>Text</code> 控件。
	*/
	__getset(0,__proto,'text',function(){
		this.createText();
		return this._text;
	});

	/**
	*<p>指定对象的状态值，以数字表示。</p>
	*<p>默认值为3。此值决定皮肤资源图片的切割方式。</p>
	*<p><b>取值：</b>
	*<li>1：单态。图片不做切割，按钮的皮肤状态只有一种。</li>
	*<li>2：两态。图片将以竖直方向被等比切割为2部分，从上向下，依次为
	*弹起状态皮肤、
	*按下和经过及选中状态皮肤。</li>
	*<li>3：三态。图片将以竖直方向被等比切割为3部分，从上向下，依次为
	*弹起状态皮肤、
	*经过状态皮肤、
	*按下和选中状态皮肤</li>
	*</p>
	*/
	__getset(0,__proto,'stateNum',function(){
		return this._stateNum;
		},function(value){
		if ((typeof value=='string')){
			value=parseInt(value);
		}
		if (this._stateNum !=value){
			this._stateNum=value < 1 ? 1 :value > 3 ? 3 :value;
			this.callLater(this.changeClips);
		}
	});

	/**
	*表示按钮各个状态下的描边颜色。
	*<p><b>格式:</b> "upColor,overColor,downColor,disableColor"。</p>
	*/
	__getset(0,__proto,'strokeColors',function(){
		return this._strokeColors ? this._strokeColors.join(","):"";
		},function(value){
		this._strokeColors=UIUtils.fillArray(Styles.buttonLabelColors,value,String);
		this._setStateChanged();
	});

	/**
	*表示按钮各个状态下的文本颜色。
	*<p><b>格式:</b> "upColor,overColor,downColor,disableColor"。</p>
	*/
	__getset(0,__proto,'labelColors',function(){
		return this._labelColors.join(",");
		},function(value){
		this._labelColors=UIUtils.fillArray(Styles.buttonLabelColors,value,String);
		this._setStateChanged();
	});

	/**
	*@inheritDoc
	*/
	__getset(0,__proto,'measureWidth',function(){
		this.runCallLater(this.changeClips);
		if (this._autoSize)return this._bitmap.width;
		this.runCallLater(this.changeState);
		return this._bitmap.width+(this._text ? this._text.width :0);
	});

	/**
	*按钮的文本内容。
	*/
	__getset(0,__proto,'label',function(){
		return this._text ? this._text.text :null;
		},function(value){
		if (!this._text && !value)return;
		this.createText();
		if (this._text.text !=value){
			value && !this._text.parent && this.addChild(this._text);
			this._text.text=(value+"").replace(/\\n/g,"\n");
			this._setStateChanged();
		}
	});

	/**
	*表示按钮的选中状态。
	*<p>如果值为true，表示该对象处于选中状态。否则该对象处于未选中状态。</p>
	*/
	__getset(0,__proto,'selected',function(){
		return this._selected;
		},function(value){
		if (this._selected !=value){
			this._selected=value;
			this.state=this._selected ? 2 :0;
			this.event(/*laya.events.Event.CHANGE*/"change");
		}
	});

	/**
	*表示按钮文本标签的边距。
	*<p><b>格式：</b>"上边距,右边距,下边距,左边距"。</p>
	*/
	__getset(0,__proto,'labelPadding',function(){
		this.createText();
		return this._text.padding.join(",");
		},function(value){
		this.createText();
		this._text.padding=UIUtils.fillArray(Styles.labelPadding,value,Number);
	});

	/**
	*表示按钮文本标签的字体大小。
	*@see laya.display.Text.fontSize()
	*/
	__getset(0,__proto,'labelSize',function(){
		this.createText();
		return this._text.fontSize;
		},function(value){
		this.createText();
		this._text.fontSize=value
	});

	/**
	*<p>描边宽度（以像素为单位）。</p>
	*默认值0，表示不描边。
	*@see laya.display.Text.stroke()
	*/
	__getset(0,__proto,'labelStroke',function(){
		this.createText();
		return this._text.stroke;
		},function(value){
		this.createText();
		this._text.stroke=value
	});

	/**
	*表示按钮文本标签是否为粗体字。
	*@see laya.display.Text.bold()
	*/
	__getset(0,__proto,'labelBold',function(){
		this.createText();
		return this._text.bold;
		},function(value){
		this.createText();
		this._text.bold=value;
	});

	/**
	*表示按钮文本标签的字体名称，以字符串形式表示。
	*@see laya.display.Text.font()
	*/
	__getset(0,__proto,'labelFont',function(){
		this.createText();
		return this._text.font;
		},function(value){
		this.createText();
		this._text.font=value;
	});

	/**标签对齐模式，默认为居中对齐。*/
	__getset(0,__proto,'labelAlign',function(){
		this.createText()
		return this._text.align;
		},function(value){
		this.createText()
		this._text.align=value;
	});

	/**
	*对象的点击事件处理器函数（无默认参数）。
	*/
	__getset(0,__proto,'clickHandler',function(){
		return this._clickHandler;
		},function(value){
		this._clickHandler=value;
	});

	/**
	*<p>当前实例的位图 <code>AutoImage</code> 实例的有效缩放网格数据。</p>
	*<p>数据格式："上边距,右边距,下边距,左边距,是否重复填充(值为0：不重复填充，1：重复填充)"，以逗号分隔。
	*<ul><li>例如："4,4,4,4,1"</li></ul></p>
	*@see laya.ui.AutoBitmap.sizeGrid
	*/
	__getset(0,__proto,'sizeGrid',function(){
		if (this._bitmap.sizeGrid)return this._bitmap.sizeGrid.join(",");
		return null;
		},function(value){
		this._bitmap.sizeGrid=UIUtils.fillArray(Styles.defaultSizeGrid,value,Number);
	});

	/**@inheritDoc */
	__getset(0,__proto,'width',_super.prototype._$get_width,function(value){
		Laya.superSet(Component,this,'width',value);
		if (this._autoSize){
			this._bitmap.width=value;
			this._text && (this._text.width=value);
		}
	});

	/**@inheritDoc */
	__getset(0,__proto,'height',_super.prototype._$get_height,function(value){
		Laya.superSet(Component,this,'height',value);
		if (this._autoSize){
			this._bitmap.height=value;
			this._text && (this._text.height=value);
		}
	});

	/**@inheritDoc */
	__getset(0,__proto,'dataSource',_super.prototype._$get_dataSource,function(value){
		this._dataSource=value;
		if ((typeof value=='number')|| (typeof value=='string'))this.label=value+"";
		else Laya.superSet(Component,this,'dataSource',value);
	});

	/**图标x,y偏移，格式：100,100*/
	__getset(0,__proto,'iconOffset',function(){
		return this._bitmap._offset ? this._bitmap._offset.join(","):null;
		},function(value){
		if (value)this._bitmap._offset=UIUtils.fillArray([1,1],value,Number);
		else this._bitmap._offset=[];
	});

	__static(Button,
	['stateMap',function(){return this.stateMap={"mouseup":0,"mouseover":1,"mousedown":2,"mouseout":0};}
	]);
	return Button;
})(Component)


/**
*<p> <code>Clip</code> 类是位图切片动画。</p>
*<p> <code>Clip</code> 可将一张图片，按横向分割数量 <code>clipX</code> 、竖向分割数量 <code>clipY</code> ，
*或横向分割每个切片的宽度 <code>clipWidth</code> 、竖向分割每个切片的高度 <code>clipHeight</code> ，
*从左向右，从上到下，分割组合为一个切片动画。</p>
*Image和Clip组件是唯一支持异步加载的两个组件，比如clip.skin="abc/xxx.png"，其他UI组件均不支持异步加载。
*
*@example <caption>以下示例代码，创建了一个 <code>Clip</code> 实例。</caption>
*package
*{
	*import laya.ui.Clip;
	*public class Clip_Example
	*{
		*private var clip:Clip;
		*public function Clip_Example()
		*{
			*Laya.init(640,800);//设置游戏画布宽高。
			*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
			*onInit();
			*}
		*private function onInit():void
		*{
			*clip=new Clip("resource/ui/clip_num.png",10,1);//创建一个 Clip 类的实例对象 clip ,传入它的皮肤skin和横向分割数量、竖向分割数量。
			*clip.autoPlay=true;//设置 clip 动画自动播放。
			*clip.interval=100;//设置 clip 动画的播放时间间隔。
			*clip.x=100;//设置 clip 对象的属性 x 的值，用于控制 clip 对象的显示位置。
			*clip.y=100;//设置 clip 对象的属性 y 的值，用于控制 clip 对象的显示位置。
			*clip.on(Event.CLICK,this,onClick);//给 clip 添加点击事件函数侦听。
			*Laya.stage.addChild(clip);//将此 clip 对象添加到显示列表。
			*}
		*private function onClick():void
		*{
			*trace("clip 的点击事件侦听处理函数。clip.total="+clip.total);
			*if (clip.isPlaying==true)
			*{
				*clip.stop();//停止动画。
				*}else {
				*clip.play();//播放动画。
				*}
			*}
		*}
	*}
*@example
*Laya.init(640,800);//设置游戏画布宽高
*Laya.stage.bgColor="#efefef";//设置画布的背景颜色
*var clip;
*Laya.loader.load("resource/ui/clip_num.png",laya.utils.Handler.create(this,loadComplete));//加载资源
*function loadComplete(){
	*console.log("资源加载完成！");
	*clip=new laya.ui.Clip("resource/ui/clip_num.png",10,1);//创建一个 Clip 类的实例对象 clip ,传入它的皮肤skin和横向分割数量、竖向分割数量。
	*clip.autoPlay=true;//设置 clip 动画自动播放。
	*clip.interval=100;//设置 clip 动画的播放时间间隔。
	*clip.x=100;//设置 clip 对象的属性 x 的值，用于控制 clip 对象的显示位置。
	*clip.y=100;//设置 clip 对象的属性 y 的值，用于控制 clip 对象的显示位置。
	*clip.on(Event.CLICK,this,onClick);//给 clip 添加点击事件函数侦听。
	*Laya.stage.addChild(clip);//将此 clip 对象添加到显示列表。
	*}
*function onClick()
*{
	*console.log("clip 的点击事件侦听处理函数。");
	*if(clip.isPlaying==true)
	*{
		*clip.stop();
		*}else {
		*clip.play();
		*}
	*}
*@example
*import Clip=laya.ui.Clip;
*import Handler=laya.utils.Handler;
*class Clip_Example {
	*private clip:Clip;
	*constructor(){
		*Laya.init(640,800);//设置游戏画布宽高。
		*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
		*this.onInit();
		*}
	*private onInit():void {
		*this.clip=new Clip("resource/ui/clip_num.png",10,1);//创建一个 Clip 类的实例对象 clip ,传入它的皮肤skin和横向分割数量、竖向分割数量。
		*this.clip.autoPlay=true;//设置 clip 动画自动播放。
		*this.clip.interval=100;//设置 clip 动画的播放时间间隔。
		*this.clip.x=100;//设置 clip 对象的属性 x 的值，用于控制 clip 对象的显示位置。
		*this.clip.y=100;//设置 clip 对象的属性 y 的值，用于控制 clip 对象的显示位置。
		*this.clip.on(laya.events.Event.CLICK,this,this.onClick);//给 clip 添加点击事件函数侦听。
		*Laya.stage.addChild(this.clip);//将此 clip 对象添加到显示列表。
		*}
	*private onClick():void {
		*console.log("clip 的点击事件侦听处理函数。clip.total="+this.clip.total);
		*if (this.clip.isPlaying==true){
			*this.clip.stop();//停止动画。
			*}else {
			*this.clip.play();//播放动画。
			*}
		*}
	*}
*
*/
//class laya.ui.Clip extends laya.ui.Component
var Clip=(function(_super){
	function Clip(url,clipX,clipY){
		/**@private */
		this._sources=null;
		/**@private */
		this._bitmap=null;
		/**@private */
		this._skin=null;
		/**@private */
		this._clipX=1;
		/**@private */
		this._clipY=1;
		/**@private */
		this._clipWidth=0;
		/**@private */
		this._clipHeight=0;
		/**@private */
		this._autoPlay=false;
		/**@private */
		this._interval=50;
		/**@private */
		this._complete=null;
		/**@private */
		this._isPlaying=false;
		/**@private */
		this._index=0;
		/**@private */
		this._clipChanged=false;
		/**@private */
		this._group=null;
		/**@private */
		this._toIndex=-1;
		Clip.__super.call(this);
		(clipX===void 0)&& (clipX=1);
		(clipY===void 0)&& (clipY=1);
		this._clipX=clipX;
		this._clipY=clipY;
		this.skin=url;
	}

	__class(Clip,'laya.ui.Clip',_super);
	var __proto=Clip.prototype;
	/**@inheritDoc */
	__proto.destroy=function(destroyChild){
		(destroyChild===void 0)&& (destroyChild=true);
		_super.prototype.destroy.call(this,true);
		this._bitmap && this._bitmap.destroy();
		this._bitmap=null;
		this._sources=null;
	}

	/**
	*销毁对象并释放加载的皮肤资源。
	*/
	__proto.dispose=function(){
		this.destroy(true);
		Laya.loader.clearRes(this._skin);
	}

	/**@inheritDoc */
	__proto.createChildren=function(){
		this.graphics=this._bitmap=new AutoBitmap();
	}

	/**@private */
	__proto._onDisplay=function(e){
		if (this._isPlaying){
			if (this._displayedInStage)this.play();
			else this.stop();
			}else if (this._autoPlay){
			this.play();
		}
	}

	/**
	*@private
	*改变切片的资源、切片的大小。
	*/
	__proto.changeClip=function(){
		this._clipChanged=false;
		if (!this._skin)return;
		var img=Loader.getRes(this._skin);
		if (img){
			this.loadComplete(this._skin,img);
			}else {
			Laya.loader.load(this._skin,Handler.create(this,this.loadComplete,[this._skin]));
		}
	}

	/**
	*@private
	*加载切片图片资源完成函数。
	*@param url 资源地址。
	*@param img 纹理。
	*/
	__proto.loadComplete=function(url,img){
		if (url===this._skin && img){
			var w=this._clipWidth || Math.ceil(img.sourceWidth / this._clipX);
			var h=this._clipHeight || Math.ceil(img.sourceHeight / this._clipY);
			var key=this._skin+w+h;
			var clips=WeakObject.I.get(key);
			if (!Utils.isOkTextureList(clips)){
				clips=null;
			}
			if (clips)this._sources=clips;
			else {
				this._sources=[];
				for (var i=0;i < this._clipY;i++){
					for (var j=0;j < this._clipX;j++){
						this._sources.push(Texture.createFromTexture(img,w *j,h *i,w,h));
					}
				}
				WeakObject.I.set(key,this._sources);
			}
			this.index=this._index;
			this.event(/*laya.events.Event.LOADED*/"loaded");
			this.onCompResize();
		}
	}

	/**
	*播放动画。
	*@param from 开始索引
	*@param to 结束索引，-1为不限制
	*/
	__proto.play=function(from,to){
		(from===void 0)&& (from=0);
		(to===void 0)&& (to=-1);
		this._isPlaying=true;
		this.index=from;
		this._toIndex=to;
		this._index++;
		Laya.timer.loop(this.interval,this,this._loop);
		this.on(/*laya.events.Event.DISPLAY*/"display",this,this._onDisplay);
		this.on(/*laya.events.Event.UNDISPLAY*/"undisplay",this,this._onDisplay);
	}

	/**
	*@private
	*/
	__proto._loop=function(){
		if (this._style.visible && this._sources){
			this._index++;
			if (this._toIndex >-1 && this._index >=this._toIndex)this.stop();
			else if (this._index >=this._sources.length)this._index=0;
			this.index=this._index;
		}
	}

	/**
	*停止动画。
	*/
	__proto.stop=function(){
		this._isPlaying=false;
		Laya.timer.clear(this,this._loop);
		this.event(/*laya.events.Event.COMPLETE*/"complete");
	}

	/**@private */
	__proto._setClipChanged=function(){
		if (!this._clipChanged){
			this._clipChanged=true;
			this.callLater(this.changeClip);
		}
	}

	/**
	*表示动画播放间隔时间(以毫秒为单位)。
	*/
	__getset(0,__proto,'interval',function(){
		return this._interval;
		},function(value){
		if (this._interval !=value){
			this._interval=value;
			if (this._isPlaying)this.play();
		}
	});

	/**
	*@copy laya.ui.Image#skin
	*/
	__getset(0,__proto,'skin',function(){
		return this._skin;
		},function(value){
		if (this._skin !=value){
			this._skin=value;
			if (value){
				this._setClipChanged()
				}else {
				this._bitmap.source=null;
			}
		}
	});

	/**
	*源数据。
	*/
	__getset(0,__proto,'sources',function(){
		return this._sources;
		},function(value){
		this._sources=value;
		this.index=this._index;
		this.event(/*laya.events.Event.LOADED*/"loaded");
	});

	/**X轴（横向）切片数量。*/
	__getset(0,__proto,'clipX',function(){
		return this._clipX;
		},function(value){
		this._clipX=value || 1;
		this._setClipChanged()
	});

	/**Y轴(竖向)切片数量。*/
	__getset(0,__proto,'clipY',function(){
		return this._clipY;
		},function(value){
		this._clipY=value || 1;
		this._setClipChanged()
	});

	/**
	*切片动画的总帧数。
	*/
	__getset(0,__proto,'total',function(){
		this.runCallLater(this.changeClip);
		return this._sources ? this._sources.length :0;
	});

	/**
	*横向分割时每个切片的宽度，与 <code>clipX</code> 同时设置时优先级高于 <code>clipX</code> 。
	*/
	__getset(0,__proto,'clipWidth',function(){
		return this._clipWidth;
		},function(value){
		this._clipWidth=value;
		this._setClipChanged()
	});

	/**
	*<p>当前实例的位图 <code>AutoImage</code> 实例的有效缩放网格数据。</p>
	*<p>数据格式："上边距,右边距,下边距,左边距,是否重复填充(值为0：不重复填充，1：重复填充)"，以逗号分隔。
	*<ul><li>例如："4,4,4,4,1"</li></ul></p>
	*@see laya.ui.AutoBitmap.sizeGrid
	*/
	__getset(0,__proto,'sizeGrid',function(){
		if (this._bitmap.sizeGrid)return this._bitmap.sizeGrid.join(",");
		return null;
		},function(value){
		this._bitmap.sizeGrid=UIUtils.fillArray(Styles.defaultSizeGrid,value,Number);
	});

	/**
	*资源分组。
	*/
	__getset(0,__proto,'group',function(){
		return this._group;
		},function(value){
		if (value && this._skin)Loader.setGroup(this._skin,value);
		this._group=value;
	});

	/**
	*竖向分割时每个切片的高度，与 <code>clipY</code> 同时设置时优先级高于 <code>clipY</code> 。
	*/
	__getset(0,__proto,'clipHeight',function(){
		return this._clipHeight;
		},function(value){
		this._clipHeight=value;
		this._setClipChanged()
	});

	/**@inheritDoc */
	__getset(0,__proto,'width',_super.prototype._$get_width,function(value){
		Laya.superSet(Component,this,'width',value);
		this._bitmap.width=value;
	});

	/**@inheritDoc */
	__getset(0,__proto,'height',_super.prototype._$get_height,function(value){
		Laya.superSet(Component,this,'height',value);
		this._bitmap.height=value;
	});

	/**@inheritDoc */
	__getset(0,__proto,'measureWidth',function(){
		this.runCallLater(this.changeClip);
		return this._bitmap.width;
	});

	/**@inheritDoc */
	__getset(0,__proto,'measureHeight',function(){
		this.runCallLater(this.changeClip);
		return this._bitmap.height;
	});

	/**
	*当前帧索引。
	*/
	__getset(0,__proto,'index',function(){
		return this._index;
		},function(value){
		this._index=value;
		this._bitmap && this._sources && (this._bitmap.source=this._sources[value]);
		this.event(/*laya.events.Event.CHANGE*/"change");
	});

	/**
	*表示是否自动播放动画，若自动播放值为true,否则值为false;
	*<p>可控制切片动画的播放、停止。</p>
	*/
	__getset(0,__proto,'autoPlay',function(){
		return this._autoPlay;
		},function(value){
		if (this._autoPlay !=value){
			this._autoPlay=value;
			value ? this.play():this.stop();
		}
	});

	/**
	*表示动画的当前播放状态。
	*如果动画正在播放中，则为true，否则为flash。
	*/
	__getset(0,__proto,'isPlaying',function(){
		return this._isPlaying;
		},function(value){
		this._isPlaying=value;
	});

	/**@inheritDoc */
	__getset(0,__proto,'dataSource',_super.prototype._$get_dataSource,function(value){
		this._dataSource=value;
		if (((typeof value=='number')&& Math.floor(value)==value)|| (typeof value=='string'))this.index=parseInt(value);
		else Laya.superSet(Component,this,'dataSource',value);
	});

	/**
	*<code>AutoBitmap</code> 位图实例。
	*/
	__getset(0,__proto,'bitmap',function(){
		return this._bitmap;
	});

	return Clip;
})(Component)


/**
*<code>ColorPicker</code> 组件将显示包含多个颜色样本的列表，用户可以从中选择颜色。
*
*@example <caption>以下示例代码，创建了一个 <code>ColorPicker</code> 实例。</caption>
*package
*{
	*import laya.ui.ColorPicker;
	*import laya.utils.Handler;
	*public class ColorPicker_Example
	*{
		*public function ColorPicker_Example()
		*{
			*Laya.init(640,800);//设置游戏画布宽高。
			*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
			*Laya.loader.load("resource/ui/color.png",Handler.create(this,onLoadComplete));//加载资源。
			*}
		*private function onLoadComplete():void
		*{
			*trace("资源加载完成！");
			*var colorPicket:ColorPicker=new ColorPicker();//创建一个 ColorPicker 类的实例对象 colorPicket 。
			*colorPicket.skin="resource/ui/color.png";//设置 colorPicket 的皮肤。
			*colorPicket.x=100;//设置 colorPicket 对象的属性 x 的值，用于控制 colorPicket 对象的显示位置。
			*colorPicket.y=100;//设置 colorPicket 对象的属性 y 的值，用于控制 colorPicket 对象的显示位置。
			*colorPicket.changeHandler=new Handler(this,onChangeColor,[colorPicket]);//设置 colorPicket 的颜色改变回调函数。
			*Laya.stage.addChild(colorPicket);//将此 colorPicket 对象添加到显示列表。
			*}
		*private function onChangeColor(colorPicket:ColorPicker):void
		*{
			*trace("当前选择的颜色： "+colorPicket.selectedColor);
			*}
		*}
	*}
*@example
*Laya.init(640,800);//设置游戏画布宽高
*Laya.stage.bgColor="#efefef";//设置画布的背景颜色
*Laya.loader.load("resource/ui/color.png",laya.utils.Handler.create(this,loadComplete));//加载资源
*function loadComplete()
*{
	*console.log("资源加载完成！");
	*var colorPicket=new laya.ui.ColorPicker();//创建一个 ColorPicker 类的实例对象 colorPicket 。
	*colorPicket.skin="resource/ui/color.png";//设置 colorPicket 的皮肤。
	*colorPicket.x=100;//设置 colorPicket 对象的属性 x 的值，用于控制 colorPicket 对象的显示位置。
	*colorPicket.y=100;//设置 colorPicket 对象的属性 y 的值，用于控制 colorPicket 对象的显示位置。
	*colorPicket.changeHandler=laya.utils.Handler.create(this,onChangeColor,[colorPicket],false);//设置 colorPicket 的颜色改变回调函数。
	*Laya.stage.addChild(colorPicket);//将此 colorPicket 对象添加到显示列表。
	*}
*function onChangeColor(colorPicket)
*{
	*console.log("当前选择的颜色： "+colorPicket.selectedColor);
	*}
*@example
*import ColorPicker=laya.ui.ColorPicker;
*import Handler=laya.utils.Handler;
*class ColorPicker_Example {
	*constructor(){
		*Laya.init(640,800);//设置游戏画布宽高。
		*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
		*Laya.loader.load("resource/ui/color.png",Handler.create(this,this.onLoadComplete));//加载资源。
		*}
	*private onLoadComplete():void {
		*console.log("资源加载完成！");
		*var colorPicket:ColorPicker=new ColorPicker();//创建一个 ColorPicker 类的实例对象 colorPicket 。
		*colorPicket.skin="resource/ui/color.png";//设置 colorPicket 的皮肤。
		*colorPicket.x=100;//设置 colorPicket 对象的属性 x 的值，用于控制 colorPicket 对象的显示位置。
		*colorPicket.y=100;//设置 colorPicket 对象的属性 y 的值，用于控制 colorPicket 对象的显示位置。
		*colorPicket.changeHandler=new Handler(this,this.onChangeColor,[colorPicket]);//设置 colorPicket 的颜色改变回调函数。
		*Laya.stage.addChild(colorPicket);//将此 colorPicket 对象添加到显示列表。
		*}
	*private onChangeColor(colorPicket:ColorPicker):void {
		*console.log("当前选择的颜色： "+colorPicket.selectedColor);
		*}
	*}
*/
//class laya.ui.ColorPicker extends laya.ui.Component
var ColorPicker=(function(_super){
	function ColorPicker(){
		/**
		*当颜色发生改变时执行的函数处理器。
		*默认返回参数color：颜色值字符串。
		*/
		this.changeHandler=null;
		/**
		*@private
		*指定每个正方形的颜色小格子的宽高（以像素为单位）。
		*/
		this._gridSize=11;
		/**
		*@private
		*表示颜色样本列表面板的背景颜色值。
		*/
		this._bgColor="#ffffff";
		/**
		*@private
		*表示颜色样本列表面板的边框颜色值。
		*/
		this._borderColor="#000000";
		/**
		*@private
		*表示颜色样本列表面板选择或输入的颜色值。
		*/
		this._inputColor="#000000";
		/**
		*@private
		*表示颜色输入框的背景颜色值。
		*/
		this._inputBgColor="#efefef";
		/**
		*@private
		*表示颜色样本列表面板。
		*/
		this._colorPanel=null;
		/**
		*@private
		*表示颜色网格。
		*/
		this._colorTiles=null;
		/**
		*@private
		*表示颜色块显示对象。
		*/
		this._colorBlock=null;
		/**
		*@private
		*表示颜色输入框控件 <code>Input</code> 。
		*/
		this._colorInput=null;
		/**
		*@private
		*表示点击后显示颜色样本列表面板的按钮控件 <code>Button</code> 。
		*/
		this._colorButton=null;
		/**
		*@private
		*表示颜色值列表。
		*/
		this._colors=[];
		/**
		*@private
		*表示选择的颜色值。
		*/
		this._selectedColor="#000000";
		/**@private */
		this._panelChanged=false;
		ColorPicker.__super.call(this);
	}

	__class(ColorPicker,'laya.ui.ColorPicker',_super);
	var __proto=ColorPicker.prototype;
	/**@inheritDoc */
	__proto.destroy=function(destroyChild){
		(destroyChild===void 0)&& (destroyChild=true);
		_super.prototype.destroy.call(this,destroyChild);
		this._colorPanel && this._colorPanel.destroy(destroyChild);
		this._colorButton && this._colorButton.destroy(destroyChild);
		this._colorPanel=null;
		this._colorTiles=null;
		this._colorBlock=null;
		this._colorInput=null;
		this._colorButton=null;
		this._colors=null;
		this.changeHandler=null;
	}

	/**@inheritDoc */
	__proto.createChildren=function(){
		this.addChild(this._colorButton=new Button());
		this._colorPanel=new Box();
		this._colorPanel.size(230,166);
		this._colorPanel.addChild(this._colorTiles=new Sprite());
		this._colorPanel.addChild(this._colorBlock=new Sprite());
		this._colorPanel.addChild(this._colorInput=new Input());
	}

	/**@inheritDoc */
	__proto.initialize=function(){
		this._colorButton.on(/*laya.events.Event.CLICK*/"click",this,this.onColorButtonClick);
		this._colorBlock.pos(5,5);
		this._colorInput.pos(60,5);
		this._colorInput.size(60,20);
		this._colorInput.on(/*laya.events.Event.CHANGE*/"change",this,this.onColorInputChange);
		this._colorInput.on(/*laya.events.Event.KEY_DOWN*/"keydown",this,this.onColorFieldKeyDown);
		this._colorTiles.pos(5,30);
		this._colorTiles.on(/*laya.events.Event.MOUSE_MOVE*/"mousemove",this,this.onColorTilesMouseMove);
		this._colorTiles.on(/*laya.events.Event.CLICK*/"click",this,this.onColorTilesClick);
		this._colorTiles.size(20 *this._gridSize,12 *this._gridSize);
		this._colorPanel.on(/*laya.events.Event.MOUSE_DOWN*/"mousedown",this,this.onPanelMouseDown);
		this.bgColor=this._bgColor;
	}

	__proto.onPanelMouseDown=function(e){
		e.stopPropagation();
	}

	/**
	*改变颜色样本列表面板。
	*/
	__proto.changePanel=function(){
		this._panelChanged=false;
		var g=this._colorPanel.graphics;
		g.clear();
		g.drawRect(0,0,230,166,this._bgColor,this._borderColor);
		this.drawBlock(this._selectedColor);
		this._colorInput.borderColor=this._borderColor;
		this._colorInput.bgColor=this._inputBgColor;
		this._colorInput.color=this._inputColor;
		g=this._colorTiles.graphics;
		g.clear();
		var mainColors=[0x000000,0x333333,0x666666,0x999999,0xCCCCCC,0xFFFFFF,0xFF0000,0x00FF00,0x0000FF,0xFFFF00,0x00FFFF,0xFF00FF];
		for (var i=0;i < 12;i++){
			for (var j=0;j < 20;j++){
				var color=0;
				if (j===0)color=mainColors[i];
				else if (j===1)color=0x000000;
				else color=(((i *3+j / 6)% 3 << 0)+((i / 6)<< 0)*3)*0x33 << 16 | j % 6 *0x33 << 8 | (i << 0)% 6 *0x33;
				var strColor=UIUtils.toColor(color);
				this._colors.push(strColor);
				var x=j *this._gridSize;
				var y=i *this._gridSize;
				g.drawRect(x,y,this._gridSize,this._gridSize,strColor,"#000000");
			}
		}
	}

	/**
	*颜色样本列表面板的显示按钮的 <code>Event.MOUSE_DOWN</code> 事件侦听处理函数。
	*/
	__proto.onColorButtonClick=function(e){
		if (this._colorPanel.parent)this.close();
		else this.open();
	}

	/**
	*打开颜色样本列表面板。
	*/
	__proto.open=function(){
		var p=this.localToGlobal(new Point());
		var px=p.x+this._colorPanel.width <=Laya.stage.width ? p.x :Laya.stage.width-this._colorPanel.width;
		var py=p.y+this._colorButton.height;
		py=py+this._colorPanel.height <=Laya.stage.height ? py :p.y-this._colorPanel.height;
		this._colorPanel.pos(px,py);
		this._colorPanel.zOrder=1001;
		Laya._currentStage.addChild(this._colorPanel);
		Laya.stage.on(/*laya.events.Event.MOUSE_DOWN*/"mousedown",this,this.removeColorBox);
	}

	/**
	*关闭颜色样本列表面板。
	*/
	__proto.close=function(){
		Laya.stage.off(/*laya.events.Event.MOUSE_DOWN*/"mousedown",this,this.removeColorBox);
		this._colorPanel.removeSelf();
	}

	/**
	*舞台的 <code>Event.MOUSE_DOWN</code> 事件侦听处理函数。
	*/
	__proto.removeColorBox=function(e){
		this.close();
	}

	/**
	*小格子色块的 <code>Event.KEY_DOWN</code> 事件侦听处理函数。
	*/
	__proto.onColorFieldKeyDown=function(e){
		if (e.keyCode==13){
			if (this._colorInput.text)this.selectedColor=this._colorInput.text;
			else this.selectedColor=null;
			this.close();
			e.stopPropagation();
		}
	}

	/**
	*颜色值输入框 <code>Event.CHANGE</code> 事件侦听处理函数。
	*/
	__proto.onColorInputChange=function(e){
		if (this._colorInput.text)this.drawBlock(this._colorInput.text);
		else this.drawBlock("#FFFFFF");
	}

	/**
	*小格子色块的 <code>Event.CLICK</code> 事件侦听处理函数。
	*/
	__proto.onColorTilesClick=function(e){
		this.selectedColor=this.getColorByMouse();
		this.close();
	}

	/**
	*@private
	*小格子色块的 <code>Event.MOUSE_MOVE</code> 事件侦听处理函数。
	*/
	__proto.onColorTilesMouseMove=function(e){
		this._colorInput.focus=false;
		var color=this.getColorByMouse();
		this._colorInput.text=color;
		this.drawBlock(color);
	}

	/**
	*通过鼠标位置取对应的颜色块的颜色值。
	*/
	__proto.getColorByMouse=function(){
		var point=this._colorTiles.getMousePoint();
		var x=Math.floor(point.x / this._gridSize);
		var y=Math.floor(point.y / this._gridSize);
		return this._colors[y *20+x];
	}

	/**
	*绘制颜色块。
	*@param color 需要绘制的颜色块的颜色值。
	*/
	__proto.drawBlock=function(color){
		var g=this._colorBlock.graphics;
		g.clear();
		var showColor=color ? color :"#ffffff";
		g.drawRect(0,0,50,20,showColor,this._borderColor);
		color || g.drawLine(0,0,50,20,"#ff0000");
	}

	/**
	*改变颜色。
	*/
	__proto.changeColor=function(){
		var g=this.graphics;
		g.clear();
		var showColor=this._selectedColor || "#000000";
		g.drawRect(0,0,this._colorButton.width,this._colorButton.height,showColor);
	}

	/**@private */
	__proto._setPanelChanged=function(){
		if (!this._panelChanged){
			this._panelChanged=true;
			this.callLater(this.changePanel);
		}
	}

	/**
	*表示颜色输入框的背景颜色值。
	*/
	__getset(0,__proto,'inputBgColor',function(){
		return this._inputBgColor;
		},function(value){
		this._inputBgColor=value;
		this._setPanelChanged();
	});

	/**
	*表示选择的颜色值。
	*/
	__getset(0,__proto,'selectedColor',function(){
		return this._selectedColor;
		},function(value){
		if (this._selectedColor !=value){
			this._selectedColor=this._colorInput.text=value;
			this.drawBlock(value);
			this.changeColor();
			this.changeHandler && this.changeHandler.runWith(this._selectedColor);
			this.event(/*laya.events.Event.CHANGE*/"change",Event.EMPTY.setTo(/*laya.events.Event.CHANGE*/"change",this,this));
		}
	});

	/**
	*@copy laya.ui.Button#skin
	*/
	__getset(0,__proto,'skin',function(){
		return this._colorButton.skin;
		},function(value){
		this._colorButton.skin=value;
		this.changeColor();
	});

	/**
	*表示颜色样本列表面板的背景颜色值。
	*/
	__getset(0,__proto,'bgColor',function(){
		return this._bgColor;
		},function(value){
		this._bgColor=value;
		this._setPanelChanged();
	});

	/**
	*表示颜色样本列表面板的边框颜色值。
	*/
	__getset(0,__proto,'borderColor',function(){
		return this._borderColor;
		},function(value){
		this._borderColor=value;
		this._setPanelChanged();
	});

	/**
	*表示颜色样本列表面板选择或输入的颜色值。
	*/
	__getset(0,__proto,'inputColor',function(){
		return this._inputColor;
		},function(value){
		this._inputColor=value;
		this._setPanelChanged();
	});

	return ColorPicker;
})(Component)


/**
*<code>ComboBox</code> 组件包含一个下拉列表，用户可以从该列表中选择单个值。
*
*@example <caption>以下示例代码，创建了一个 <code>ComboBox</code> 实例。</caption>
*package
*{
	*import laya.ui.ComboBox;
	*import laya.utils.Handler;
	*public class ComboBox_Example
	*{
		*public function ComboBox_Example()
		*{
			*Laya.init(640,800);//设置游戏画布宽高。
			*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
			*Laya.loader.load("resource/ui/button.png",Handler.create(this,onLoadComplete));//加载资源。
			*}
		*private function onLoadComplete():void
		*{
			*trace("资源加载完成！");
			*var comboBox:ComboBox=new ComboBox("resource/ui/button.png","item0,item1,item2,item3,item4,item5");//创建一个 ComboBox 类的实例对象 comboBox ,传入它的皮肤和标签集。
			*comboBox.x=100;//设置 comboBox 对象的属性 x 的值，用于控制 comboBox 对象的显示位置。
			*comboBox.y=100;//设置 comboBox 对象的属性 x 的值，用于控制 comboBox 对象的显示位置。
			*comboBox.selectHandler=new Handler(this,onSelect);//设置 comboBox 选择项改变时执行的处理器。
			*Laya.stage.addChild(comboBox);//将此 comboBox 对象添加到显示列表。
			*}
		*private function onSelect(index:int):void
		*{
			*trace("当前选中的项对象索引： ",index);
			*}
		*}
	*}
*@example
*Laya.init(640,800);//设置游戏画布宽高。
*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
*Laya.loader.load("resource/ui/button.png",laya.utils.Handler.create(this,loadComplete));//加载资源
*function loadComplete(){
	*console.log("资源加载完成！");
	*var comboBox=new laya.ui.ComboBox("resource/ui/button.png","item0,item1,item2,item3,item4,item5");//创建一个 ComboBox 类的实例对象 comboBox ,传入它的皮肤和标签集。
	*comboBox.x=100;//设置 comboBox 对象的属性 x 的值，用于控制 comboBox 对象的显示位置。
	*comboBox.y=100;//设置 comboBox 对象的属性 x 的值，用于控制 comboBox 对象的显示位置。
	*comboBox.selectHandler=new laya.utils.Handler(this,onSelect);//设置 comboBox 选择项改变时执行的处理器。
	*Laya.stage.addChild(comboBox);//将此 comboBox 对象添加到显示列表。
	*}
*function onSelect(index)
*{
	*console.log("当前选中的项对象索引： ",index);
	*}
*@example
*import ComboBox=laya.ui.ComboBox;
*import Handler=laya.utils.Handler;
*class ComboBox_Example {
	*constructor(){
		*Laya.init(640,800);//设置游戏画布宽高。
		*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
		*Laya.loader.load("resource/ui/button.png",Handler.create(this,this.onLoadComplete));//加载资源。
		*}
	*private onLoadComplete():void {
		*console.log("资源加载完成！");
		*var comboBox:ComboBox=new ComboBox("resource/ui/button.png","item0,item1,item2,item3,item4,item5");//创建一个 ComboBox 类的实例对象 comboBox ,传入它的皮肤和标签集。
		*comboBox.x=100;//设置 comboBox 对象的属性 x 的值，用于控制 comboBox 对象的显示位置。
		*comboBox.y=100;//设置 comboBox 对象的属性 x 的值，用于控制 comboBox 对象的显示位置。
		*comboBox.selectHandler=new Handler(this,this.onSelect);//设置 comboBox 选择项改变时执行的处理器。
		*Laya.stage.addChild(comboBox);//将此 comboBox 对象添加到显示列表。
		*}
	*private onSelect(index:number):void {
		*console.log("当前选中的项对象索引： ",index);
		*}
	*}
*
*/
//class laya.ui.ComboBox extends laya.ui.Component
var ComboBox=(function(_super){
	function ComboBox(skin,labels){
		/**@private */
		this._visibleNum=6;
		/**
		*@private
		*/
		this._button=null;
		/**
		*@private
		*/
		this._list=null;
		/**
		*@private
		*/
		this._isOpen=false;
		/**
		*@private
		*/
		this._itemSize=12;
		/**
		*@private
		*/
		this._labels=[];
		/**
		*@private
		*/
		this._selectedIndex=-1;
		/**
		*@private
		*/
		this._selectHandler=null;
		/**
		*@private
		*/
		this._itemHeight=NaN;
		/**
		*@private
		*/
		this._listHeight=NaN;
		/**
		*@private
		*/
		this._listChanged=false;
		/**
		*@private
		*/
		this._itemChanged=false;
		/**
		*@private
		*/
		this._scrollBarSkin=null;
		/**
		*@private
		*/
		this._isCustomList=false;
		/**
		*渲染项，用来显示下拉列表展示对象
		*/
		this.itemRender=null;
		ComboBox.__super.call(this);
		this._itemColors=Styles.comboBoxItemColors;
		this.skin=skin;
		this.labels=labels;
	}

	__class(ComboBox,'laya.ui.ComboBox',_super);
	var __proto=ComboBox.prototype;
	/**@inheritDoc */
	__proto.destroy=function(destroyChild){
		(destroyChild===void 0)&& (destroyChild=true);
		_super.prototype.destroy.call(this,destroyChild);
		this._button && this._button.destroy(destroyChild);
		this._list && this._list.destroy(destroyChild);
		this._button=null;
		this._list=null;
		this._itemColors=null;
		this._labels=null;
		this._selectHandler=null;
	}

	/**@inheritDoc */
	__proto.createChildren=function(){
		this.addChild(this._button=new Button());
		this._button.text.align="left";
		this._button.labelPadding="0,0,0,5";
		this._button.on(/*laya.events.Event.MOUSE_DOWN*/"mousedown",this,this.onButtonMouseDown);
	}

	__proto._createList=function(){
		this._list=new List();
		if (this._scrollBarSkin)this._list.vScrollBarSkin=this._scrollBarSkin;
		this._setListEvent(this._list);
	}

	__proto._setListEvent=function(list){
		this._list.selectEnable=true;
		this._list.on(/*laya.events.Event.MOUSE_DOWN*/"mousedown",this,this.onListDown);
		this._list.mouseHandler=Handler.create(this,this.onlistItemMouse,null,false);
		if (this._list.scrollBar)this._list.scrollBar.on(/*laya.events.Event.MOUSE_DOWN*/"mousedown",this,this.onScrollBarDown);
	}

	/**
	*@private
	*/
	__proto.onListDown=function(e){
		e.stopPropagation();
	}

	__proto.onScrollBarDown=function(e){
		e.stopPropagation();
	}

	__proto.onButtonMouseDown=function(e){
		this.callLater(this.switchTo,[!this._isOpen]);
	}

	/**
	*@private
	*/
	__proto.changeList=function(){
		this._listChanged=false;
		var labelWidth=this.width-2;
		var labelColor=this._itemColors[2];
		this._itemHeight=this._itemSize+6;
		this._list.itemRender=this.itemRender || {type:"Box",child:[{type:"Label",props:{name:"label",x:1,padding:"3,3,3,3",width:labelWidth,height:this._itemHeight,fontSize:this._itemSize,color:labelColor}}]};
		this._list.repeatY=this._visibleNum;
		this._list.refresh();
	}

	/**
	*@private
	*下拉列表的鼠标事件响应函数。
	*/
	__proto.onlistItemMouse=function(e,index){
		var type=e.type;
		if (type===/*laya.events.Event.MOUSE_OVER*/"mouseover" || type===/*laya.events.Event.MOUSE_OUT*/"mouseout"){
			if (this._isCustomList)return;
			var box=this._list.getCell(index);
			if (!box)return;
			var label=box.getChildByName("label");
			if (label){
				if (type===/*laya.events.Event.ROLL_OVER*/"mouseover"){
					label.bgColor=this._itemColors[0];
					label.color=this._itemColors[1];
					}else {
					label.bgColor=null;
					label.color=this._itemColors[2];
				}
			}
			}else if (type===/*laya.events.Event.CLICK*/"click"){
			this.selectedIndex=index;
			this.isOpen=false;
		}
	}

	/**
	*@private
	*/
	__proto.switchTo=function(value){
		this.isOpen=value;
	}

	/**
	*更改下拉列表的打开状态。
	*/
	__proto.changeOpen=function(){
		this.isOpen=!this._isOpen;
	}

	/**
	*更改下拉列表。
	*/
	__proto.changeItem=function(){
		this._itemChanged=false;
		this._listHeight=this._labels.length > 0 ? Math.min(this._visibleNum,this._labels.length)*this._itemHeight :this._itemHeight;
		if (!this._isCustomList){
			var g=this._list.graphics;
			g.clear();
			g.drawRect(0,0,this.width-1,this._listHeight,this._itemColors[4],this._itemColors[3]);
		};
		var a=this._list.array || [];
		a.length=0;
		for (var i=0,n=this._labels.length;i < n;i++){
			a.push({label:this._labels[i]});
		}
		this._list.height=this._listHeight;
		this._list.array=a;
	}

	__proto.changeSelected=function(){
		this._button.label=this.selectedLabel;
	}

	__proto._onStageMouseWheel=function(e){
		if(!this._list||this._list.contains(e.target))return;
		this.removeList(null);
	}

	/**
	*关闭下拉列表。
	*/
	__proto.removeList=function(e){
		Laya.stage.off(/*laya.events.Event.MOUSE_DOWN*/"mousedown",this,this.removeList);
		Laya.stage.off(/*laya.events.Event.MOUSE_WHEEL*/"mousewheel",this,this._onStageMouseWheel);
		this.isOpen=false;
	}

	/**
	*表示选择的下拉列表项的索引。
	*/
	__getset(0,__proto,'selectedIndex',function(){
		return this._selectedIndex;
		},function(value){
		if (this._selectedIndex !=value){
			this._selectedIndex=value;
			if (this._labels.length > 0)this.changeSelected();
			else this.callLater(this.changeSelected);
			this.event(/*laya.events.Event.CHANGE*/"change",[Event.EMPTY.setTo(/*laya.events.Event.CHANGE*/"change",this,this)]);
			this._selectHandler && this._selectHandler.runWith(this._selectedIndex);
		}
	});

	/**@inheritDoc */
	__getset(0,__proto,'measureHeight',function(){
		return this._button.height;
	});

	/**
	*@copy laya.ui.Button#skin
	*/
	__getset(0,__proto,'skin',function(){
		return this._button.skin;
		},function(value){
		if (this._button.skin !=value){
			this._button.skin=value;
			this._listChanged=true;
		}
	});

	/**@inheritDoc */
	__getset(0,__proto,'measureWidth',function(){
		return this._button.width;
	});

	/**@inheritDoc */
	__getset(0,__proto,'width',_super.prototype._$get_width,function(value){
		Laya.superSet(Component,this,'width',value);
		this._button.width=this._width;
		this._itemChanged=true;
		this._listChanged=true;
	});

	/**
	*表示选择的下拉列表项的的标签。
	*/
	__getset(0,__proto,'selectedLabel',function(){
		return this._selectedIndex >-1 && this._selectedIndex < this._labels.length ? this._labels[this._selectedIndex] :null;
		},function(value){
		this.selectedIndex=this._labels.indexOf(value);
	});

	/**
	*标签集合字符串。
	*/
	__getset(0,__proto,'labels',function(){
		return this._labels.join(",");
		},function(value){
		if (this._labels.length > 0)this.selectedIndex=-1;
		if (value)this._labels=value.split(",");
		else this._labels.length=0;
		this._itemChanged=true;
	});

	/**@inheritDoc */
	__getset(0,__proto,'height',_super.prototype._$get_height,function(value){
		Laya.superSet(Component,this,'height',value);
		this._button.height=this._height;
	});

	/**
	*改变下拉列表的选择项时执行的处理器(默认返回参数index:int)。
	*/
	__getset(0,__proto,'selectHandler',function(){
		return this._selectHandler;
		},function(value){
		this._selectHandler=value;
	});

	/**
	*获取或设置没有滚动条的下拉列表中可显示的最大行数。
	*/
	__getset(0,__proto,'visibleNum',function(){
		return this._visibleNum;
		},function(value){
		this._visibleNum=value;
		this._listChanged=true;
	});

	/**
	*表示按钮文本标签是否为粗体字。
	*@see laya.display.Text#bold
	*/
	__getset(0,__proto,'labelBold',function(){
		return this._button.text.bold;
		},function(value){
		this._button.text.bold=value
	});

	/**
	*下拉列表项颜色。
	*<p><b>格式：</b>"悬停或被选中时背景颜色,悬停或被选中时标签颜色,标签颜色,边框颜色,背景颜色"</p>
	*/
	__getset(0,__proto,'itemColors',function(){
		return String(this._itemColors)
		},function(value){
		this._itemColors=UIUtils.fillArray(this._itemColors,value,String);
		this._listChanged=true;
	});

	/**
	*下拉列表项标签的字体大小。
	*/
	__getset(0,__proto,'itemSize',function(){
		return this._itemSize;
		},function(value){
		this._itemSize=value;
		this._listChanged=true;
	});

	/**
	*获取对 <code>ComboBox</code> 组件所包含的 <code>VScrollBar</code> 滚动条组件的引用。
	*/
	__getset(0,__proto,'scrollBar',function(){
		return this.list.scrollBar;
	});

	/**
	*表示下拉列表的打开状态。
	*/
	__getset(0,__proto,'isOpen',function(){
		return this._isOpen;
		},function(value){
		if (this._isOpen !=value){
			this._isOpen=value;
			this._button.selected=this._isOpen;
			if (this._isOpen){
				this._list || this._createList();
				this._listChanged && !this._isCustomList && this.changeList();
				this._itemChanged && this.changeItem();
				var p=this.localToGlobal(Point.TEMP.setTo(0,0));
				var py=p.y+this._button.height;
				py=py+this._listHeight <=Laya.stage.height ? py :p.y-this._listHeight;
				this._list.pos(p.x,py);
				this._list.zOrder=1001;
				Laya._currentStage.addChild(this._list);
				Laya.stage.once(/*laya.events.Event.MOUSE_DOWN*/"mousedown",this,this.removeList);
				Laya.stage.on(/*laya.events.Event.MOUSE_WHEEL*/"mousewheel",this,this._onStageMouseWheel);
				this._list.selectedIndex=this._selectedIndex;
				}else {
				this._list && this._list.removeSelf();
			}
		}
	});

	/**
	*滚动条皮肤。
	*/
	__getset(0,__proto,'scrollBarSkin',function(){
		return this._scrollBarSkin;
		},function(value){
		this._scrollBarSkin=value;
	});

	/**
	*<p>当前实例的位图 <code>AutoImage</code> 实例的有效缩放网格数据。</p>
	*<p>数据格式："上边距,右边距,下边距,左边距,是否重复填充(值为0：不重复填充，1：重复填充)"，以逗号分隔。
	*<ul><li>例如："4,4,4,4,1"</li></ul></p>
	*@see laya.ui.AutoBitmap.sizeGrid
	*/
	__getset(0,__proto,'sizeGrid',function(){
		return this._button.sizeGrid;
		},function(value){
		this._button.sizeGrid=value;
	});

	/**
	*获取对 <code>ComboBox</code> 组件所包含的 <code>Button</code> 组件的引用。
	*/
	__getset(0,__proto,'button',function(){
		return this._button;
	});

	/**
	*获取对 <code>ComboBox</code> 组件所包含的 <code>List</code> 列表组件的引用。
	*/
	__getset(0,__proto,'list',function(){
		this._list || this._createList();
		return this._list;
		},function(value){
		if (value){
			value.removeSelf();
			this._isCustomList=true;
			this._list=value;
			this._setListEvent(value);
			this._itemHeight=value.getCell(0).height+value.spaceY;
		}
	});

	/**@inheritDoc */
	__getset(0,__proto,'dataSource',_super.prototype._$get_dataSource,function(value){
		this._dataSource=value;
		if (((typeof value=='number')&& Math.floor(value)==value)|| (typeof value=='string'))this.selectedIndex=parseInt(value);
		else if ((value instanceof Array))this.labels=(value).join(",");
		else Laya.superSet(Component,this,'dataSource',value);
	});

	/**
	*获取或设置对 <code>ComboBox</code> 组件所包含的 <code>Button</code> 组件的文本标签颜色。
	*<p><b>格式：</b>upColor,overColor,downColor,disableColor</p>
	*/
	__getset(0,__proto,'labelColors',function(){
		return this._button.labelColors;
		},function(value){
		if (this._button.labelColors !=value){
			this._button.labelColors=value;
		}
	});

	/**
	*获取或设置对 <code>ComboBox</code> 组件所包含的 <code>Button</code> 组件的文本边距。
	*<p><b>格式：</b>上边距,右边距,下边距,左边距</p>
	*/
	__getset(0,__proto,'labelPadding',function(){
		return this._button.text.padding.join(",");
		},function(value){
		this._button.text.padding=UIUtils.fillArray(Styles.labelPadding,value,Number);
	});

	/**
	*获取或设置对 <code>ComboBox</code> 组件所包含的 <code>Button</code> 组件的标签字体大小。
	*/
	__getset(0,__proto,'labelSize',function(){
		return this._button.text.fontSize;
		},function(value){
		this._button.text.fontSize=value
	});

	/**
	*表示按钮文本标签的字体名称，以字符串形式表示。
	*@see laya.display.Text#font
	*/
	__getset(0,__proto,'labelFont',function(){
		return this._button.text.font;
		},function(value){
		this._button.text.font=value
	});

	/**
	*表示按钮的状态值。
	*@see laya.ui.Button#stateNum
	*/
	__getset(0,__proto,'stateNum',function(){
		return this._button.stateNum;
		},function(value){
		this._button.stateNum=value
	});

	return ComboBox;
})(Component)


/**
*<code>ScrollBar</code> 组件是一个滚动条组件。
*<p>当数据太多以至于显示区域无法容纳时，最终用户可以使用 <code>ScrollBar</code> 组件控制所显示的数据部分。</p>
*<p> 滚动条由四部分组成：两个箭头按钮、一个轨道和一个滑块。 </p> *
*
*@see laya.ui.VScrollBar
*@see laya.ui.HScrollBar
*/
//class laya.ui.ScrollBar extends laya.ui.Component
var ScrollBar=(function(_super){
	function ScrollBar(skin){
		/**滚动衰减系数*/
		this.rollRatio=0.95;
		/**滚动变化时回调，回传value参数。*/
		this.changeHandler=null;
		/**是否缩放滑动条，默认值为true。 */
		this.scaleBar=true;
		/**一个布尔值，指定是否自动隐藏滚动条(无需滚动时)，默认值为false。*/
		this.autoHide=false;
		/**橡皮筋效果极限距离，0为没有橡皮筋效果。*/
		this.elasticDistance=0;
		/**橡皮筋回弹时间，单位为毫秒。*/
		this.elasticBackTime=500;
		/**上按钮 */
		this.upButton=null;
		/**下按钮 */
		this.downButton=null;
		/**滑条 */
		this.slider=null;
		/**@private */
		this._scrollSize=1;
		/**@private */
		this._skin=null;
		/**@private */
		this._thumbPercent=1;
		/**@private */
		this._target=null;
		/**@private */
		this._lastPoint=null;
		/**@private */
		this._lastOffset=0;
		/**@private */
		this._checkElastic=false;
		/**@private */
		this._isElastic=false;
		/**@private */
		this._value=NaN;
		/**@private */
		this._hide=false;
		/**@private */
		this._clickOnly=true;
		/**@private */
		this._offsets=null;
		ScrollBar.__super.call(this);
		this._showButtons=UIConfig.showButtons;
		this._touchScrollEnable=UIConfig.touchScrollEnable;
		this._mouseWheelEnable=UIConfig.mouseWheelEnable;
		this.skin=skin;
		this.max=1;
	}

	__class(ScrollBar,'laya.ui.ScrollBar',_super);
	var __proto=ScrollBar.prototype;
	/**@inheritDoc */
	__proto.destroy=function(destroyChild){
		(destroyChild===void 0)&& (destroyChild=true);
		this.stopScroll();
		this.target=null;
		_super.prototype.destroy.call(this,destroyChild);
		this.upButton && this.upButton.destroy(destroyChild);
		this.downButton && this.downButton.destroy(destroyChild);
		this.slider && this.slider.destroy(destroyChild);
		this.upButton=this.downButton=null;
		this.slider=null;
		this.changeHandler=null;
		this._offsets=null;
	}

	/**@inheritDoc */
	__proto.createChildren=function(){
		this.addChild(this.slider=new Slider());
		this.addChild(this.upButton=new Button());
		this.addChild(this.downButton=new Button());
	}

	/**@inheritDoc */
	__proto.initialize=function(){
		this.slider.showLabel=false;
		this.slider.on(/*laya.events.Event.CHANGE*/"change",this,this.onSliderChange);
		this.slider.setSlider(0,0,0);
		this.upButton.on(/*laya.events.Event.MOUSE_DOWN*/"mousedown",this,this.onButtonMouseDown);
		this.downButton.on(/*laya.events.Event.MOUSE_DOWN*/"mousedown",this,this.onButtonMouseDown);
	}

	/**
	*@private
	*滑块位置发生改变的处理函数。
	*/
	__proto.onSliderChange=function(){
		if(this._value !=this.slider.value)this.value=this.slider.value;
	}

	/**
	*@private
	*向上和向下按钮的 <code>Event.MOUSE_DOWN</code> 事件侦听处理函数。
	*/
	__proto.onButtonMouseDown=function(e){
		var isUp=e.currentTarget===this.upButton;
		this.slide(isUp);
		Laya.timer.once(Styles.scrollBarDelayTime,this,this.startLoop,[isUp]);
		Laya.stage.once(/*laya.events.Event.MOUSE_UP*/"mouseup",this,this.onStageMouseUp);
	}

	/**@private */
	__proto.startLoop=function(isUp){
		Laya.timer.frameLoop(1,this,this.slide,[isUp]);
	}

	/**@private */
	__proto.slide=function(isUp){
		if (isUp)this.value-=this._scrollSize;
		else this.value+=this._scrollSize;
	}

	/**
	*@private
	*舞台的 <code>Event.MOUSE_DOWN</code> 事件侦听处理函数。
	*/
	__proto.onStageMouseUp=function(e){
		Laya.timer.clear(this,this.startLoop);
		Laya.timer.clear(this,this.slide);
	}

	/**
	*@private
	*更改对象的皮肤及位置。
	*/
	__proto.changeScrollBar=function(){
		this.upButton.visible=this._showButtons;
		this.downButton.visible=this._showButtons;
		if (this._showButtons){
			this.upButton.skin=this._skin.replace(".png","$up.png");
			this.downButton.skin=this._skin.replace(".png","$down.png");
		}
		if (this.slider.isVertical)this.slider.y=this._showButtons ? this.upButton.height :0;
		else this.slider.x=this._showButtons ? this.upButton.width :0;
		this.resetPositions();
		this.repaint();
	}

	/**@inheritDoc */
	__proto.changeSize=function(){
		_super.prototype.changeSize.call(this);
		this.repaint();
		this.resetPositions();
		this.event(/*laya.events.Event.CHANGE*/"change");
		this.changeHandler && this.changeHandler.runWith(this.value);
	}

	/**@private */
	__proto.resetPositions=function(){
		if (this.slider.isVertical)this.slider.height=this.height-(this._showButtons ? (this.upButton.height+this.downButton.height):0);
		else this.slider.width=this.width-(this._showButtons ? (this.upButton.width+this.downButton.width):0);
		this.resetButtonPosition();
	}

	/**@private */
	__proto.resetButtonPosition=function(){
		if (this.slider.isVertical)this.downButton.y=this.slider.y+this.slider.height;
		else this.downButton.x=this.slider.x+this.slider.width;
	}

	/**
	*设置滚动条信息。
	*@param min 滚动条最小位置值。
	*@param max 滚动条最大位置值。
	*@param value 滚动条当前位置值。
	*/
	__proto.setScroll=function(min,max,value){
		this.runCallLater(this.changeSize);
		this.slider.setSlider(min,max,value);
		this.slider.bar.visible=max > 0;
		if (!this._hide && this.autoHide)this.visible=false;
	}

	/**@private */
	__proto.onTargetMouseWheel=function(e){
		this.value-=e.delta *this._scrollSize;
		this.target=this._target;
	}

	/**@private */
	__proto.onTargetMouseDown=function(e){
		this._clickOnly=true;
		this._lastOffset=0;
		this._checkElastic=false;
		this._lastPoint || (this._lastPoint=new Point());
		this._lastPoint.setTo(Laya.stage.mouseX,Laya.stage.mouseY);
		Laya.timer.clear(this,this.tweenMove);
		Tween.clearTween(this);
		Laya.stage.once(/*laya.events.Event.MOUSE_UP*/"mouseup",this,this.onStageMouseUp2);
		Laya.stage.once(/*laya.events.Event.MOUSE_OUT*/"mouseout",this,this.onStageMouseUp2);
		Laya.timer.frameLoop(1,this,this.loop);
	}

	/**@private */
	__proto.loop=function(){
		var mouseY=Laya.stage.mouseY;
		var mouseX=Laya.stage.mouseX;
		this._lastOffset=this.isVertical ? (mouseY-this._lastPoint.y):(mouseX-this._lastPoint.x);
		if (this._clickOnly){
			if (Math.abs(this._lastOffset *(this.isVertical ? Laya.stage._canvasTransform.getScaleY():Laya.stage._canvasTransform.getScaleX()))> 1){
				this._clickOnly=false;
				this._offsets || (this._offsets=[]);
				this._offsets.length=0;
				this._target.mouseEnabled=false;
				if (!this.hide && this.autoHide){
					this.alpha=1;
					this.visible=true;
				}
				this.event(/*laya.events.Event.START*/"start");
			}else return;
		}
		this._offsets.push(this._lastOffset);
		this._lastPoint.x=mouseX;
		this._lastPoint.y=mouseY;
		if (this._lastOffset===0)return;
		if (!this._checkElastic){
			if (this.elasticDistance > 0){
				if (!this._checkElastic && this._lastOffset !=0){
					if ((this._lastOffset > 0 && this._value <=this.min)|| (this._lastOffset < 0 && this._value >=this.max)){
						this._isElastic=true;
						this._checkElastic=true;
						}else {
						this._isElastic=false;
					}
				}
				}else {
				this._checkElastic=true;
			}
		}
		if (this._isElastic){
			if (this._value <=this.min){
				this.value-=this._lastOffset *Math.max(0,(1-((this.min-this._value)/ this.elasticDistance)));
				}else if (this._value >=this.max){
				this.value-=this._lastOffset *Math.max(0,(1-((this._value-this.max)/ this.elasticDistance)));
			}
			}else {
			this.value-=this._lastOffset;
		}
	}

	/**@private */
	__proto.onStageMouseUp2=function(e){
		Laya.stage.off(/*laya.events.Event.MOUSE_UP*/"mouseup",this,this.onStageMouseUp2);
		Laya.stage.off(/*laya.events.Event.MOUSE_OUT*/"mouseout",this,this.onStageMouseUp2);
		Laya.timer.clear(this,this.loop);
		if (this._clickOnly){
			if(this._value>=this.min&&this._value<=this.max)
				return;
		}
		this._target.mouseEnabled=true;
		if (this._isElastic){
			if (this._value < this.min){
				Tween.to(this,{value:this.min},this.elasticBackTime,Ease.sineOut,Handler.create(this,this.elasticOver));
				}else if (this._value > this.max){
				Tween.to(this,{value:this.max},this.elasticBackTime,Ease.sineOut,Handler.create(this,this.elasticOver));
			}
			}else {
			if (!this._offsets)return;
			if (this._offsets.length < 1){
				this._offsets[0]=this.isVertical ? Laya.stage.mouseY-this._lastPoint.y :Laya.stage.mouseX-this._lastPoint.x;
			};
			var offset=0;
			var n=Math.min(this._offsets.length,3);
			for (var i=0;i < n;i++){
				offset+=this._offsets[this._offsets.length-1-i];
			}
			this._lastOffset=offset / n;
			offset=Math.abs(this._lastOffset);
			if (offset < 2){
				this.event(/*laya.events.Event.END*/"end");
				return;
			}
			if (offset > 60)this._lastOffset=this._lastOffset > 0 ? 60 :-60;
			var dis=Math.round(Math.abs(this.elasticDistance *(this._lastOffset / 240)));
			Laya.timer.frameLoop(1,this,this.tweenMove,[dis]);
		}
	}

	/**@private */
	__proto.elasticOver=function(){
		this._isElastic=false;
		if (!this.hide && this.autoHide){
			Tween.to(this,{alpha:0},500);
		}
		this.event(/*laya.events.Event.END*/"end");
	}

	/**@private */
	__proto.tweenMove=function(maxDistance){
		this._lastOffset *=this.rollRatio;
		var tarSpeed=NaN;
		if (maxDistance > 0){
			if (this._lastOffset > 0 && this.value <=this.min){
				this._isElastic=true;
				tarSpeed=-(this.min-maxDistance-this.value)*0.5;
				if (this._lastOffset > tarSpeed)this._lastOffset=tarSpeed;
				}else if (this._lastOffset < 0 && this.value >=this.max){
				this._isElastic=true;
				tarSpeed=-(this.max+maxDistance-this.value)*0.5;
				if (this._lastOffset < tarSpeed)this._lastOffset=tarSpeed;
			}
		}
		this.value-=this._lastOffset;
		if (Math.abs(this._lastOffset)< 1){
			Laya.timer.clear(this,this.tweenMove);
			if (this._isElastic){
				if (this._value < this.min){
					Tween.to(this,{value:this.min},this.elasticBackTime,Ease.sineOut,Handler.create(this,this.elasticOver));
					}else if (this._value > this.max){
					Tween.to(this,{value:this.max},this.elasticBackTime,Ease.sineOut,Handler.create(this,this.elasticOver));
					}else {
					this.elasticOver();
				}
				return;
			}
			this.event(/*laya.events.Event.END*/"end");
			if (!this.hide && this.autoHide){
				Tween.to(this,{alpha:0},500);
			}
		}
	}

	/**
	*停止滑动。
	*/
	__proto.stopScroll=function(){
		this.onStageMouseUp2(null);
		Laya.timer.clear(this,this.tweenMove);
		Tween.clearTween(this);
	}

	/**@inheritDoc */
	__getset(0,__proto,'measureHeight',function(){
		if (this.slider.isVertical)return 100;
		return this.slider.height;
	});

	/**
	*@copy laya.ui.Image#skin
	*/
	__getset(0,__proto,'skin',function(){
		return this._skin;
		},function(value){
		if (this._skin !=value){
			this._skin=value;
			this.slider.skin=this._skin;
			this.callLater(this.changeScrollBar);
		}
	});

	/**
	*获取或设置表示最高滚动位置的数字。
	*/
	__getset(0,__proto,'max',function(){
		return this.slider.max;
		},function(value){
		this.slider.max=value;
	});

	/**一个布尔值，指定是否显示向上、向下按钮，默认值为true。*/
	__getset(0,__proto,'showButtons',function(){
		return this._showButtons;
		},function(value){
		this._showButtons=value;
		this.callLater(this.changeScrollBar);
	});

	/**@inheritDoc */
	__getset(0,__proto,'measureWidth',function(){
		if (this.slider.isVertical)return this.slider.width;
		return 100;
	});

	/**
	*获取或设置表示最低滚动位置的数字。
	*/
	__getset(0,__proto,'min',function(){
		return this.slider.min;
		},function(value){
		this.slider.min=value;
	});

	/**
	*获取或设置表示当前滚动位置的数字。
	*/
	__getset(0,__proto,'value',function(){
		return this._value;
		},function(v){
		if (v!==this._value){
			this._value=v;
			if (!this._isElastic){
				if (this.slider._value !=v){
					this.slider._value=v;
					this.slider.changeValue();
				}
				this._value=this.slider._value;
			}
			this.event(/*laya.events.Event.CHANGE*/"change");
			this.changeHandler && this.changeHandler.runWith(this._value);
		}
	});

	/**
	*一个布尔值，指示滚动条是否为垂直滚动。如果值为true，则为垂直滚动，否则为水平滚动。
	*<p>默认值为：true。</p>
	*/
	__getset(0,__proto,'isVertical',function(){
		return this.slider.isVertical;
		},function(value){
		this.slider.isVertical=value;
	});

	/**
	*<p>当前实例的 <code>Slider</code> 实例的有效缩放网格数据。</p>
	*<p>数据格式："上边距,右边距,下边距,左边距,是否重复填充(值为0：不重复填充，1：重复填充)"，以逗号分隔。
	*<ul><li>例如："4,4,4,4,1"</li></ul></p>
	*@see laya.ui.AutoBitmap.sizeGrid
	*/
	__getset(0,__proto,'sizeGrid',function(){
		return this.slider.sizeGrid;
		},function(value){
		this.slider.sizeGrid=value;
	});

	/**获取或设置一个值，该值表示按下滚动条轨道时页面滚动的增量。 */
	__getset(0,__proto,'scrollSize',function(){
		return this._scrollSize;
		},function(value){
		this._scrollSize=value;
	});

	/**@inheritDoc */
	__getset(0,__proto,'dataSource',_super.prototype._$get_dataSource,function(value){
		this._dataSource=value;
		if ((typeof value=='number')|| (typeof value=='string'))this.value=Number(value);
		else Laya.superSet(Component,this,'dataSource',value);
	});

	/**获取或设置一个值，该值表示滑条长度比例，值为：（0-1）。 */
	__getset(0,__proto,'thumbPercent',function(){
		return this._thumbPercent;
		},function(value){
		this.runCallLater(this.changeScrollBar);
		this.runCallLater(this.changeSize);
		value=value >=1 ? 0.99 :value;
		this._thumbPercent=value;
		if (this.scaleBar){
			if (this.slider.isVertical)this.slider.bar.height=Math.max(this.slider.height *value,Styles.scrollBarMinNum);
			else this.slider.bar.width=Math.max(this.slider.width *value,Styles.scrollBarMinNum);
		}
	});

	/**
	*设置滚动对象。
	*@see laya.ui.TouchScroll#target
	*/
	__getset(0,__proto,'target',function(){
		return this._target;
		},function(value){
		if (this._target){
			this._target.off(/*laya.events.Event.MOUSE_WHEEL*/"mousewheel",this,this.onTargetMouseWheel);
			this._target.off(/*laya.events.Event.MOUSE_DOWN*/"mousedown",this,this.onTargetMouseDown);
		}
		this._target=value;
		if (value){
			this._mouseWheelEnable && this._target.on(/*laya.events.Event.MOUSE_WHEEL*/"mousewheel",this,this.onTargetMouseWheel);
			this._touchScrollEnable && this._target.on(/*laya.events.Event.MOUSE_DOWN*/"mousedown",this,this.onTargetMouseDown);
		}
	});

	/**是否隐藏滚动条，不显示滚动条，但是可以正常滚动，默认为false。*/
	__getset(0,__proto,'hide',function(){
		return this._hide;
		},function(value){
		this._hide=value;
		this.visible=!value;
	});

	/**一个布尔值，指定是否开启触摸，默认值为true。*/
	__getset(0,__proto,'touchScrollEnable',function(){
		return this._touchScrollEnable;
		},function(value){
		this._touchScrollEnable=value;
		this.target=this._target;
	});

	/**一个布尔值，指定是否滑轮滚动，默认值为true。*/
	__getset(0,__proto,'mouseWheelEnable',function(){
		return this._mouseWheelEnable;
		},function(value){
		this._mouseWheelEnable=value;
	});

	/**
	*滚动的刻度值，滑动数值为tick的整数倍。默认值为1。
	*/
	__getset(0,__proto,'tick',function(){
		return this.slider.tick;
		},function(value){
		this.slider.tick=value;
	});

	return ScrollBar;
})(Component)


/**
*使用 <code>Slider</code> 控件，用户可以通过在滑块轨道的终点之间移动滑块来选择值。
*<p>滑块的当前值由滑块端点（对应于滑块的最小值和最大值）之间滑块的相对位置确定。</p>
*<p>滑块允许最小值和最大值之间特定间隔内的值。滑块还可以使用数据提示显示其当前值。</p>
*
*@see laya.ui.HSlider
*@see laya.ui.VSlider
*/
//class laya.ui.Slider extends laya.ui.Component
var Slider=(function(_super){
	function Slider(skin){
		/**
		*数据变化处理器。
		*<p>默认回调参数为滑块位置属性 <code>value</code>属性值：Number 。</p>
		*/
		this.changeHandler=null;
		/**
		*一个布尔值，指示是否为垂直滚动。如果值为true，则为垂直方向，否则为水平方向。
		*<p>默认值为：true。</p>
		*@default true
		*/
		this.isVertical=true;
		/**
		*一个布尔值，指示是否显示标签。
		*@default true
		*/
		this.showLabel=true;
		/**@private */
		this._allowClickBack=false;
		/**@private */
		this._max=100;
		/**@private */
		this._min=0;
		/**@private */
		this._tick=1;
		/**@private */
		this._value=0;
		/**@private */
		this._skin=null;
		/**@private */
		this._bg=null;
		/**@private */
		this._progress=null;
		/**@private */
		this._bar=null;
		/**@private */
		this._tx=NaN;
		/**@private */
		this._ty=NaN;
		/**@private */
		this._maxMove=NaN;
		/**@private */
		this._globalSacle=null;
		Slider.__super.call(this);
		this.skin=skin;
	}

	__class(Slider,'laya.ui.Slider',_super);
	var __proto=Slider.prototype;
	/**
	*@inheritDoc
	*/
	__proto.destroy=function(destroyChild){
		(destroyChild===void 0)&& (destroyChild=true);
		_super.prototype.destroy.call(this,destroyChild);
		this._bg && this._bg.destroy(destroyChild);
		this._bar && this._bar.destroy(destroyChild);
		this._progress && this._progress.destroy(destroyChild);
		this._bg=null;
		this._bar=null;
		this._progress=null;
		this.changeHandler=null;
	}

	/**@inheritDoc */
	__proto.createChildren=function(){
		this.addChild(this._bg=new Image());
		this.addChild(this._bar=new Button());
	}

	/**@inheritDoc */
	__proto.initialize=function(){
		this._bar.on(/*laya.events.Event.MOUSE_DOWN*/"mousedown",this,this.onBarMouseDown);
		this._bg.sizeGrid=this._bar.sizeGrid="4,4,4,4,0";
		if (this._progress)this._progress.sizeGrid=this._bar.sizeGrid;
		this.allowClickBack=true;
	}

	/**
	*@private
	*滑块的的 <code>Event.MOUSE_DOWN</code> 事件侦听处理函数。
	*/
	__proto.onBarMouseDown=function(e){
		this._globalSacle || (this._globalSacle=new Point());
		this._globalSacle.setTo(this.globalScaleX || 0.01,this.globalScaleY || 0.01);
		this._maxMove=this.isVertical ? (this.height-this._bar.height):(this.width-this._bar.width);
		this._tx=Laya.stage.mouseX;
		this._ty=Laya.stage.mouseY;
		Laya.stage.on(/*laya.events.Event.MOUSE_MOVE*/"mousemove",this,this.mouseMove);
		Laya.stage.once(/*laya.events.Event.MOUSE_UP*/"mouseup",this,this.mouseUp);
		Laya.stage.once(/*laya.events.Event.MOUSE_OUT*/"mouseout",this,this.mouseUp);
		this.showValueText();
	}

	/**
	*@private
	*显示标签。
	*/
	__proto.showValueText=function(){
		if (this.showLabel){
			var label=laya.ui.Slider.label;
			this.addChild(label);
			label.textField.changeText(this._value+"");
			if (this.isVertical){
				label.x=this._bar.x+20;
				label.y=(this._bar.height-label.height)*0.5+this._bar.y;
				}else {
				label.y=this._bar.y-20;
				label.x=(this._bar.width-label.width)*0.5+this._bar.x;
			}
		}
	}

	/**
	*@private
	*隐藏标签。
	*/
	__proto.hideValueText=function(){
		laya.ui.Slider.label && laya.ui.Slider.label.removeSelf();
	}

	/**
	*@private
	*/
	__proto.mouseUp=function(e){
		Laya.stage.off(/*laya.events.Event.MOUSE_MOVE*/"mousemove",this,this.mouseMove);
		Laya.stage.off(/*laya.events.Event.MOUSE_UP*/"mouseup",this,this.mouseUp);
		Laya.stage.off(/*laya.events.Event.MOUSE_OUT*/"mouseout",this,this.mouseUp);
		this.sendChangeEvent(/*laya.events.Event.CHANGED*/"changed");
		this.hideValueText();
	}

	/**
	*@private
	*/
	__proto.mouseMove=function(e){
		var oldValue=this._value;
		if (this.isVertical){
			this._bar.y+=(Laya.stage.mouseY-this._ty)/ this._globalSacle.y;
			if (this._bar.y > this._maxMove)this._bar.y=this._maxMove;
			else if (this._bar.y < 0)this._bar.y=0;
			this._value=this._bar.y / this._maxMove *(this._max-this._min)+this._min;
			if(this._progress)this._progress.height=this._bar.y+0.5*this._bar.height;
			}else {
			this._bar.x+=(Laya.stage.mouseX-this._tx)/ this._globalSacle.x;
			if (this._bar.x > this._maxMove)this._bar.x=this._maxMove;
			else if (this._bar.x < 0)this._bar.x=0;
			this._value=this._bar.x / this._maxMove *(this._max-this._min)+this._min;
			if(this._progress)this._progress.width=this._bar.x+0.5*this._bar.width;
		}
		this._tx=Laya.stage.mouseX;
		this._ty=Laya.stage.mouseY;
		var pow=Math.pow(10,(this._tick+"").length-1);
		this._value=Math.round(Math.round(this._value / this._tick)*this._tick *pow)/ pow;
		if (this._value !=oldValue){
			this.sendChangeEvent();
		}
		this.showValueText();
	}

	/**
	*@private
	*/
	__proto.sendChangeEvent=function(type){
		(type===void 0)&& (type=/*laya.events.Event.CHANGE*/"change");
		this.event(type);
		this.changeHandler && this.changeHandler.runWith(this._value);
	}

	/**
	*@private
	*设置滑块的位置信息。
	*/
	__proto.setBarPoint=function(){
		if (this.isVertical)this._bar.x=Math.round((this._bg.width-this._bar.width)*0.5);
		else this._bar.y=Math.round((this._bg.height-this._bar.height)*0.5);
	}

	/**@inheritDoc */
	__proto.changeSize=function(){
		_super.prototype.changeSize.call(this);
		if (this.isVertical)this._bg.height=this.height;
		else this._bg.width=this.width;
		this.setBarPoint();
		this.changeValue();
	}

	/**
	*设置滑动条的信息。
	*@param min 滑块的最小值。
	*@param max 滑块的最小值。
	*@param value 滑块的当前值。
	*/
	__proto.setSlider=function(min,max,value){
		this._value=-1;
		this._min=min;
		this._max=max > min ? max :min;
		this.value=value < min ? min :value > max ? max :value;
	}

	/**
	*@private
	*改变滑块的位置值。
	*/
	__proto.changeValue=function(){
		var pow=Math.pow(10,(this._tick+"").length-1);
		this._value=Math.round(Math.round(this._value / this._tick)*this._tick *pow)/ pow;
		this._value=this._value > this._max ? this._max :this._value < this._min ? this._min :this._value;
		var num=this._max-this._min;
		if (num===0)num=1;
		if (this.isVertical){
			this._bar.y=(this._value-this._min)/ num *(this.height-this._bar.height);
			if(this._progress)this._progress.height=this._bar.y+0.5*this._bar.height;
		}
		else{
			this._bar.x=(this._value-this._min)/ num *(this.width-this._bar.width);
			if(this._progress)this._progress.width=this._bar.x+0.5*this._bar.width;
		}
	}

	/**
	*@private
	*滑动条的 <code>Event.MOUSE_DOWN</code> 事件侦听处理函数。
	*/
	__proto.onBgMouseDown=function(e){
		var point=this._bg.getMousePoint();
		if (this.isVertical)this.value=point.y / (this.height-this._bar.height)*(this._max-this._min)+this._min;
		else this.value=point.x / (this.width-this._bar.width)*(this._max-this._min)+this._min;
	}

	/**@inheritDoc */
	__getset(0,__proto,'measureHeight',function(){
		return Math.max(this._bg.height,this._bar.height);
	});

	/**
	*@copy laya.ui.Image#skin
	*/
	__getset(0,__proto,'skin',function(){
		return this._skin;
		},function(value){
		if (this._skin !=value){
			this._skin=value;
			this._bg.skin=this._skin;
			this._bar.skin=this._skin.replace(".png","$bar.png");
			var progressSkin=this._skin.replace(".png","$progress.png");
			if (Loader.getRes(progressSkin)){
				if (!this._progress){
					this.addChild(this._progress=new Image());
					this._progress.sizeGrid=this._bar.sizeGrid;
					this.setChildIndex(this._progress,1);
				}
				this._progress.skin=progressSkin;
			}
			this.setBarPoint();
			this.callLater(this.changeValue);
		}
	});

	/**
	*一个布尔值，指定是否允许通过点击滑动条改变 <code>Slider</code> 的 <code>value</code> 属性值。
	*/
	__getset(0,__proto,'allowClickBack',function(){
		return this._allowClickBack;
		},function(value){
		if (this._allowClickBack !=value){
			this._allowClickBack=value;
			if (value)this._bg.on(/*laya.events.Event.MOUSE_DOWN*/"mousedown",this,this.onBgMouseDown);
			else this._bg.off(/*laya.events.Event.MOUSE_DOWN*/"mousedown",this,this.onBgMouseDown);
		}
	});

	/**
	*获取或设置表示最高位置的数字。 默认值为100。
	*/
	__getset(0,__proto,'max',function(){
		return this._max;
		},function(value){
		if (this._max !=value){
			this._max=value;
			this.callLater(this.changeValue);
		}
	});

	/**@inheritDoc */
	__getset(0,__proto,'measureWidth',function(){
		return Math.max(this._bg.width,this._bar.width);
	});

	/**
	*滑动的刻度值，滑动数值为tick的整数倍。默认值为1。
	*/
	__getset(0,__proto,'tick',function(){
		return this._tick;
		},function(value){
		if (this._tick !=value){
			this._tick=value;
			this.callLater(this.changeValue);
		}
	});

	/**
	*<p>当前实例的背景图（ <code>Image</code> ）和滑块按钮（ <code>Button</code> ）实例的有效缩放网格数据。</p>
	*<p>数据格式："上边距,右边距,下边距,左边距,是否重复填充(值为0：不重复填充，1：重复填充)"，以逗号分隔。
	*<ul><li>例如："4,4,4,4,1"</li></ul></p>
	*@see laya.ui.AutoBitmap.sizeGrid
	*/
	__getset(0,__proto,'sizeGrid',function(){
		return this._bg.sizeGrid;
		},function(value){
		this._bg.sizeGrid=value;
		this._bar.sizeGrid=value;
		if (this._progress)this._progress.sizeGrid=this._bar.sizeGrid;
	});

	/**
	*获取或设置表示最低位置的数字。 默认值为0。
	*/
	__getset(0,__proto,'min',function(){
		return this._min;
		},function(value){
		if (this._min !=value){
			this._min=value;
			this.callLater(this.changeValue);
		}
	});

	/**
	*获取或设置表示当前滑块位置的数字。
	*/
	__getset(0,__proto,'value',function(){
		return this._value;
		},function(num){
		if (this._value !=num){
			var oldValue=this._value;
			this._value=num;
			this.changeValue();
			if (this._value !=oldValue){
				this.sendChangeEvent();
			}
		}
	});

	/**@inheritDoc */
	__getset(0,__proto,'dataSource',_super.prototype._$get_dataSource,function(value){
		this._dataSource=value;
		if ((typeof value=='number')|| (typeof value=='string'))this.value=Number(value);
		else Laya.superSet(Component,this,'dataSource',value);
	});

	/**
	*表示滑块按钮的引用。
	*/
	__getset(0,__proto,'bar',function(){
		return this._bar;
	});

	__static(Slider,
	['label',function(){return this.label=new Label();}
	]);
	return Slider;
})(Component)


/**
*<code>Image</code> 类是用于表示位图图像或绘制图形的显示对象。
*Image和Clip组件是唯一支持异步加载的两个组件，比如img.skin="abc/xxx.png"，其他UI组件均不支持异步加载。
*
*@example <caption>以下示例代码，创建了一个新的 <code>Image</code> 实例，设置了它的皮肤、位置信息，并添加到舞台上。</caption>
*package
*{
	*import laya.ui.Image;
	*public class Image_Example
	*{
		*public function Image_Example()
		*{
			*Laya.init(640,800);//设置游戏画布宽高。
			*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
			*onInit();
			*}
		*private function onInit():void
		*{
			*var bg:Image=new Image("resource/ui/bg.png");//创建一个 Image 类的实例对象 bg ,并传入它的皮肤。
			*bg.x=100;//设置 bg 对象的属性 x 的值，用于控制 bg 对象的显示位置。
			*bg.y=100;//设置 bg 对象的属性 y 的值，用于控制 bg 对象的显示位置。
			*bg.sizeGrid="40,10,5,10";//设置 bg 对象的网格信息。
			*bg.width=150;//设置 bg 对象的宽度。
			*bg.height=250;//设置 bg 对象的高度。
			*Laya.stage.addChild(bg);//将此 bg 对象添加到显示列表。
			*var image:Image=new Image("resource/ui/image.png");//创建一个 Image 类的实例对象 image ,并传入它的皮肤。
			*image.x=100;//设置 image 对象的属性 x 的值，用于控制 image 对象的显示位置。
			*image.y=100;//设置 image 对象的属性 y 的值，用于控制 image 对象的显示位置。
			*Laya.stage.addChild(image);//将此 image 对象添加到显示列表。
			*}
		*}
	*}
*@example
*Laya.init(640,800);//设置游戏画布宽高
*Laya.stage.bgColor="#efefef";//设置画布的背景颜色
*onInit();
*function onInit(){
	*var bg=new laya.ui.Image("resource/ui/bg.png");//创建一个 Image 类的实例对象 bg ,并传入它的皮肤。
	*bg.x=100;//设置 bg 对象的属性 x 的值，用于控制 bg 对象的显示位置。
	*bg.y=100;//设置 bg 对象的属性 y 的值，用于控制 bg 对象的显示位置。
	*bg.sizeGrid="40,10,5,10";//设置 bg 对象的网格信息。
	*bg.width=150;//设置 bg 对象的宽度。
	*bg.height=250;//设置 bg 对象的高度。
	*Laya.stage.addChild(bg);//将此 bg 对象添加到显示列表。
	*var image=new laya.ui.Image("resource/ui/image.png");//创建一个 Image 类的实例对象 image ,并传入它的皮肤。
	*image.x=100;//设置 image 对象的属性 x 的值，用于控制 image 对象的显示位置。
	*image.y=100;//设置 image 对象的属性 y 的值，用于控制 image 对象的显示位置。
	*Laya.stage.addChild(image);//将此 image 对象添加到显示列表。
	*}
*@example
*class Image_Example {
	*constructor(){
		*Laya.init(640,800);//设置游戏画布宽高。
		*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
		*this.onInit();
		*}
	*private onInit():void {
		*var bg:laya.ui.Image=new laya.ui.Image("resource/ui/bg.png");//创建一个 Image 类的实例对象 bg ,并传入它的皮肤。
		*bg.x=100;//设置 bg 对象的属性 x 的值，用于控制 bg 对象的显示位置。
		*bg.y=100;//设置 bg 对象的属性 y 的值，用于控制 bg 对象的显示位置。
		*bg.sizeGrid="40,10,5,10";//设置 bg 对象的网格信息。
		*bg.width=150;//设置 bg 对象的宽度。
		*bg.height=250;//设置 bg 对象的高度。
		*Laya.stage.addChild(bg);//将此 bg 对象添加到显示列表。
		*var image:laya.ui.Image=new laya.ui.Image("resource/ui/image.png");//创建一个 Image 类的实例对象 image ,并传入它的皮肤。
		*image.x=100;//设置 image 对象的属性 x 的值，用于控制 image 对象的显示位置。
		*image.y=100;//设置 image 对象的属性 y 的值，用于控制 image 对象的显示位置。
		*Laya.stage.addChild(image);//将此 image 对象添加到显示列表。
		*}
	*}
*@see laya.ui.AutoBitmap
*/
//class laya.ui.Image extends laya.ui.Component
var Image=(function(_super){
	function Image(skin){
		/**@private */
		this._bitmap=null;
		/**@private */
		this._skin=null;
		/**@private */
		this._group=null;
		Image.__super.call(this);
		this.skin=skin;
	}

	__class(Image,'laya.ui.Image',_super);
	var __proto=Image.prototype;
	/**@inheritDoc */
	__proto.destroy=function(destroyChild){
		(destroyChild===void 0)&& (destroyChild=true);
		_super.prototype.destroy.call(this,true);
		this._bitmap && this._bitmap.destroy();
		this._bitmap=null;
	}

	/**
	*销毁对象并释放加载的皮肤资源。
	*/
	__proto.dispose=function(){
		this.destroy(true);
		Laya.loader.clearRes(this._skin);
	}

	/**@inheritDoc */
	__proto.createChildren=function(){
		this.graphics=this._bitmap=new AutoBitmap();
		this._bitmap.autoCacheCmd=false;
	}

	/**
	*@private
	*设置皮肤资源。
	*/
	__proto.setSource=function(url,img){
		if (url===this._skin && img){
			this.source=img
			this.onCompResize();
		}
	}

	/**
	*@copy laya.ui.AutoBitmap#source
	*/
	__getset(0,__proto,'source',function(){
		return this._bitmap.source;
		},function(value){
		if (!this._bitmap)return;
		this._bitmap.source=value;
		this.event(/*laya.events.Event.LOADED*/"loaded");
		this.repaint();
	});

	/**@inheritDoc */
	__getset(0,__proto,'dataSource',_super.prototype._$get_dataSource,function(value){
		this._dataSource=value;
		if ((typeof value=='string'))this.skin=value;
		else Laya.superSet(Component,this,'dataSource',value);
	});

	/**@inheritDoc */
	__getset(0,__proto,'measureHeight',function(){
		return this._bitmap.height;
	});

	/**
	*<p>对象的皮肤地址，以字符串表示。</p>
	*<p>如果资源未加载，则先加载资源，加载完成后应用于此对象。</p>
	*<b>注意：</b>资源加载完成后，会自动缓存至资源库中。
	*/
	__getset(0,__proto,'skin',function(){
		return this._skin;
		},function(value){
		if (this._skin !=value){
			this._skin=value;
			if (value){
				var source=Loader.getRes(value);
				if (source){
					this.source=source;
					this.onCompResize();
				}else Laya.loader.load(this._skin,Handler.create(this,this.setSource,[this._skin]),null,/*laya.net.Loader.IMAGE*/"image",1,true,this._group);
				}else {
				this.source=null;
			}
		}
	});

	/**
	*资源分组。
	*/
	__getset(0,__proto,'group',function(){
		return this._group;
		},function(value){
		if (value && this._skin)Loader.setGroup(this._skin,value);
		this._group=value;
	});

	/**
	*<p>当前实例的位图 <code>AutoImage</code> 实例的有效缩放网格数据。</p>
	*<p>数据格式："上边距,右边距,下边距,左边距,是否重复填充(值为0：不重复填充，1：重复填充)"，以逗号分隔。
	*<ul><li>例如："4,4,4,4,1"。</li></ul></p>
	*@see laya.ui.AutoBitmap#sizeGrid
	*/
	__getset(0,__proto,'sizeGrid',function(){
		if (this._bitmap.sizeGrid)return this._bitmap.sizeGrid.join(",");
		return null;
		},function(value){
		this._bitmap.sizeGrid=UIUtils.fillArray(Styles.defaultSizeGrid,value,Number);
	});

	/**@inheritDoc */
	__getset(0,__proto,'measureWidth',function(){
		return this._bitmap.width;
	});

	/**@inheritDoc */
	__getset(0,__proto,'width',_super.prototype._$get_width,function(value){
		Laya.superSet(Component,this,'width',value);
		this._bitmap.width=value==0 ? 0.0000001 :value;
	});

	/**@inheritDoc */
	__getset(0,__proto,'height',_super.prototype._$get_height,function(value){
		Laya.superSet(Component,this,'height',value);
		this._bitmap.height=value==0 ? 0.0000001 :value;
	});

	return Image;
})(Component)


/**
*<p> <code>Label</code> 类用于创建显示对象以显示文本。</p>
*
*@example <caption>以下示例代码，创建了一个 <code>Label</code> 实例。</caption>
*package
*{
	*import laya.ui.Label;
	*public class Label_Example
	*{
		*public function Label_Example()
		*{
			*Laya.init(640,800);//设置游戏画布宽高、渲染模式。
			*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
			*onInit();
			*}
		*private function onInit():void
		*{
			*var label:Label=new Label();//创建一个 Label 类的实例对象 label 。
			*label.font="Arial";//设置 label 的字体。
			*label.bold=true;//设置 label 显示为粗体。
			*label.leading=4;//设置 label 的行间距。
			*label.wordWrap=true;//设置 label 自动换行。
			*label.padding="10,10,10,10";//设置 label 的边距。
			*label.color="#ff00ff";//设置 label 的颜色。
			*label.text="Hello everyone,我是一个可爱的文本！";//设置 label 的文本内容。
			*label.x=100;//设置 label 对象的属性 x 的值，用于控制 label 对象的显示位置。
			*label.y=100;//设置 label 对象的属性 y 的值，用于控制 label 对象的显示位置。
			*label.width=300;//设置 label 的宽度。
			*label.height=200;//设置 label 的高度。
			*Laya.stage.addChild(label);//将 label 添加到显示列表。
			*var passwordLabel:Label=new Label("请原谅我，我不想被人看到我心里话。");//创建一个 Label 类的实例对象 passwordLabel 。
			*passwordLabel.asPassword=true;//设置 passwordLabel 的显示反式为密码显示。
			*passwordLabel.x=100;//设置 passwordLabel 对象的属性 x 的值，用于控制 passwordLabel 对象的显示位置。
			*passwordLabel.y=350;//设置 passwordLabel 对象的属性 y 的值，用于控制 passwordLabel 对象的显示位置。
			*passwordLabel.width=300;//设置 passwordLabel 的宽度。
			*passwordLabel.color="#000000";//设置 passwordLabel 的文本颜色。
			*passwordLabel.bgColor="#ccffff";//设置 passwordLabel 的背景颜色。
			*passwordLabel.fontSize=20;//设置 passwordLabel 的文本字体大小。
			*Laya.stage.addChild(passwordLabel);//将 passwordLabel 添加到显示列表。
			*}
		*}
	*}
*@example
*Laya.init(640,800);//设置游戏画布宽高
*Laya.stage.bgColor="#efefef";//设置画布的背景颜色
*onInit();
*function onInit(){
	*var label=new laya.ui.Label();//创建一个 Label 类的实例对象 label 。
	*label.font="Arial";//设置 label 的字体。
	*label.bold=true;//设置 label 显示为粗体。
	*label.leading=4;//设置 label 的行间距。
	*label.wordWrap=true;//设置 label 自动换行。
	*label.padding="10,10,10,10";//设置 label 的边距。
	*label.color="#ff00ff";//设置 label 的颜色。
	*label.text="Hello everyone,我是一个可爱的文本！";//设置 label 的文本内容。
	*label.x=100;//设置 label 对象的属性 x 的值，用于控制 label 对象的显示位置。
	*label.y=100;//设置 label 对象的属性 y 的值，用于控制 label 对象的显示位置。
	*label.width=300;//设置 label 的宽度。
	*label.height=200;//设置 label 的高度。
	*Laya.stage.addChild(label);//将 label 添加到显示列表。
	*var passwordLabel=new laya.ui.Label("请原谅我，我不想被人看到我心里话。");//创建一个 Label 类的实例对象 passwordLabel 。
	*passwordLabel.asPassword=true;//设置 passwordLabel 的显示反式为密码显示。
	*passwordLabel.x=100;//设置 passwordLabel 对象的属性 x 的值，用于控制 passwordLabel 对象的显示位置。
	*passwordLabel.y=350;//设置 passwordLabel 对象的属性 y 的值，用于控制 passwordLabel 对象的显示位置。
	*passwordLabel.width=300;//设置 passwordLabel 的宽度。
	*passwordLabel.color="#000000";//设置 passwordLabel 的文本颜色。
	*passwordLabel.bgColor="#ccffff";//设置 passwordLabel 的背景颜色。
	*passwordLabel.fontSize=20;//设置 passwordLabel 的文本字体大小。
	*Laya.stage.addChild(passwordLabel);//将 passwordLabel 添加到显示列表。
	*}
*@example
*import Label=laya.ui.Label;
*class Label_Example {
	*constructor(){
		*Laya.init(640,800);//设置游戏画布宽高。
		*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
		*this.onInit();
		*}
	*private onInit():void {
		*var label:Label=new Label();//创建一个 Label 类的实例对象 label 。
		*label.font="Arial";//设置 label 的字体。
		*label.bold=true;//设置 label 显示为粗体。
		*label.leading=4;//设置 label 的行间距。
		*label.wordWrap=true;//设置 label 自动换行。
		*label.padding="10,10,10,10";//设置 label 的边距。
		*label.color="#ff00ff";//设置 label 的颜色。
		*label.text="Hello everyone,我是一个可爱的文本！";//设置 label 的文本内容。
		*label.x=100;//设置 label 对象的属性 x 的值，用于控制 label 对象的显示位置。
		*label.y=100;//设置 label 对象的属性 y 的值，用于控制 label 对象的显示位置。
		*label.width=300;//设置 label 的宽度。
		*label.height=200;//设置 label 的高度。
		*Laya.stage.addChild(label);//将 label 添加到显示列表。
		*var passwordLabel:Label=new Label("请原谅我，我不想被人看到我心里话。");//创建一个 Label 类的实例对象 passwordLabel 。
		*passwordLabel.asPassword=true;//设置 passwordLabel 的显示反式为密码显示。
		*passwordLabel.x=100;//设置 passwordLabel 对象的属性 x 的值，用于控制 passwordLabel 对象的显示位置。
		*passwordLabel.y=350;//设置 passwordLabel 对象的属性 y 的值，用于控制 passwordLabel 对象的显示位置。
		*passwordLabel.width=300;//设置 passwordLabel 的宽度。
		*passwordLabel.color="#000000";//设置 passwordLabel 的文本颜色。
		*passwordLabel.bgColor="#ccffff";//设置 passwordLabel 的背景颜色。
		*passwordLabel.fontSize=20;//设置 passwordLabel 的文本字体大小。
		*Laya.stage.addChild(passwordLabel);//将 passwordLabel 添加到显示列表。
		*}
	*}
*@see laya.display.Text
*/
//class laya.ui.Label extends laya.ui.Component
var Label=(function(_super){
	function Label(text){
		/**
		*@private
		*文本 <code>Text</code> 实例。
		*/
		this._tf=null;
		Label.__super.call(this);
		(text===void 0)&& (text="");
		Font.defaultColor=Styles.labelColor;
		this.text=text;
	}

	__class(Label,'laya.ui.Label',_super);
	var __proto=Label.prototype;
	/**@inheritDoc */
	__proto.destroy=function(destroyChild){
		(destroyChild===void 0)&& (destroyChild=true);
		_super.prototype.destroy.call(this,destroyChild);
		this._tf=null;
	}

	/**@inheritDoc */
	__proto.createChildren=function(){
		this.addChild(this._tf=new Text());
	}

	/**@copy laya.display.Text#changeText()
	**/
	__proto.changeText=function(text){
		this._tf.changeText(text);
	}

	/**
	*<p>边距信息</p>
	*<p>"上边距，右边距，下边距 , 左边距（边距以像素为单位）"</p>
	*@see laya.display.Text.padding
	*/
	__getset(0,__proto,'padding',function(){
		return this._tf.padding.join(",");
		},function(value){
		this._tf.padding=UIUtils.fillArray(Styles.labelPadding,value,Number);
	});

	/**
	*@copy laya.display.Text#bold
	*/
	__getset(0,__proto,'bold',function(){
		return this._tf.bold;
		},function(value){
		this._tf.bold=value;
	});

	/**
	*@copy laya.display.Text#align
	*/
	__getset(0,__proto,'align',function(){
		return this._tf.align;
		},function(value){
		this._tf.align=value;
	});

	/**
	*当前文本内容字符串。
	*@see laya.display.Text.text
	*/
	__getset(0,__proto,'text',function(){
		return this._tf.text;
		},function(value){
		if (this._tf.text !=value){
			if(value)
				value=UIUtils.adptString(value+"");
			this._tf.text=value;
			this.event(/*laya.events.Event.CHANGE*/"change");
			if (!this._width || !this._height)this.onCompResize();
		}
	});

	/**
	*@copy laya.display.Text#italic
	*/
	__getset(0,__proto,'italic',function(){
		return this._tf.italic;
		},function(value){
		this._tf.italic=value;
	});

	/**
	*@copy laya.display.Text#wordWrap
	*/
	/**
	*@copy laya.display.Text#wordWrap
	*/
	__getset(0,__proto,'wordWrap',function(){
		return this._tf.wordWrap;
		},function(value){
		this._tf.wordWrap=value;
	});

	/**
	*@copy laya.display.Text#font
	*/
	__getset(0,__proto,'font',function(){
		return this._tf.font;
		},function(value){
		this._tf.font=value;
	});

	/**@inheritDoc */
	__getset(0,__proto,'dataSource',_super.prototype._$get_dataSource,function(value){
		this._dataSource=value;
		if ((typeof value=='number')|| (typeof value=='string'))this.text=value+"";
		else Laya.superSet(Component,this,'dataSource',value);
	});

	/**
	*@copy laya.display.Text#color
	*/
	__getset(0,__proto,'color',function(){
		return this._tf.color;
		},function(value){
		this._tf.color=value;
	});

	/**
	*@copy laya.display.Text#valign
	*/
	__getset(0,__proto,'valign',function(){
		return this._tf.valign;
		},function(value){
		this._tf.valign=value;
	});

	/**
	*@copy laya.display.Text#leading
	*/
	__getset(0,__proto,'leading',function(){
		return this._tf.leading;
		},function(value){
		this._tf.leading=value;
	});

	/**
	*@copy laya.display.Text#fontSize
	*/
	__getset(0,__proto,'fontSize',function(){
		return this._tf.fontSize;
		},function(value){
		this._tf.fontSize=value;
	});

	/**
	*@copy laya.display.Text#bgColor
	*/
	__getset(0,__proto,'bgColor',function(){
		return this._tf.bgColor
		},function(value){
		this._tf.bgColor=value;
	});

	/**
	*@copy laya.display.Text#borderColor
	*/
	__getset(0,__proto,'borderColor',function(){
		return this._tf.borderColor
		},function(value){
		this._tf.borderColor=value;
	});

	/**
	*@copy laya.display.Text#stroke
	*/
	__getset(0,__proto,'stroke',function(){
		return this._tf.stroke;
		},function(value){
		this._tf.stroke=value;
	});

	/**
	*@copy laya.display.Text#strokeColor
	*/
	__getset(0,__proto,'strokeColor',function(){
		return this._tf.strokeColor;
		},function(value){
		this._tf.strokeColor=value;
	});

	/**
	*文本控件实体 <code>Text</code> 实例。
	*/
	__getset(0,__proto,'textField',function(){
		return this._tf;
	});

	/**
	*@inheritDoc
	*/
	__getset(0,__proto,'measureWidth',function(){
		return this._tf.width;
	});

	/**
	*@inheritDoc
	*/
	__getset(0,__proto,'measureHeight',function(){
		return this._tf.height;
	});

	/**
	*@inheritDoc
	*/
	/**
	*@inheritDoc
	*/
	__getset(0,__proto,'width',function(){
		if (this._width || this._tf.text)return Laya.superGet(Component,this,'width');
		return 0;
		},function(value){
		Laya.superSet(Component,this,'width',value);
		this._tf.width=value;
	});

	/**
	*@inheritDoc
	*/
	/**
	*@inheritDoc
	*/
	__getset(0,__proto,'height',function(){
		if (this._height || this._tf.text)return Laya.superGet(Component,this,'height');
		return 0;
		},function(value){
		Laya.superSet(Component,this,'height',value);
		this._tf.height=value;
	});

	/**
	*@copy laya.display.Text#overflow
	*/
	/**
	*@copy laya.display.Text#overflow
	*/
	__getset(0,__proto,'overflow',function(){
		return this._tf.overflow;
		},function(value){
		this._tf.overflow=value;
	});

	/**
	*@copy laya.display.Text#underline
	*/
	/**
	*@copy laya.display.Text#underline
	*/
	__getset(0,__proto,'underline',function(){
		return this._tf.underline;
		},function(value){
		this._tf.underline=value;
	});

	/**
	*@copy laya.display.Text#underlineColor
	*/
	/**
	*@copy laya.display.Text#underlineColor
	*/
	__getset(0,__proto,'underlineColor',function(){
		return this._tf.underlineColor;
		},function(value){
		this._tf.underlineColor=value;
	});

	return Label;
})(Component)


/**
*<code>ProgressBar</code> 组件显示内容的加载进度。
*@example <caption>以下示例代码，创建了一个新的 <code>ProgressBar</code> 实例，设置了它的皮肤、位置、宽高、网格等信息，并添加到舞台上。</caption>
*package
*{
	*import laya.ui.ProgressBar;
	*import laya.utils.Handler;
	*public class ProgressBar_Example
	*{
		*private var progressBar:ProgressBar;
		*public function ProgressBar_Example()
		*{
			*Laya.init(640,800);//设置游戏画布宽高。
			*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
			*Laya.loader.load(["resource/ui/progress.png","resource/ui/progress$bar.png"],Handler.create(this,onLoadComplete));//加载资源。
			*}
		*private function onLoadComplete():void
		*{
			*progressBar=new ProgressBar("resource/ui/progress.png");//创建一个 ProgressBar 类的实例对象 progressBar 。
			*progressBar.x=100;//设置 progressBar 对象的属性 x 的值，用于控制 progressBar 对象的显示位置。
			*progressBar.y=100;//设置 progressBar 对象的属性 y 的值，用于控制 progressBar 对象的显示位置。
			*progressBar.value=0.3;//设置 progressBar 的进度值。
			*progressBar.width=200;//设置 progressBar 的宽度。
			*progressBar.height=50;//设置 progressBar 的高度。
			*progressBar.sizeGrid="5,10,5,10";//设置 progressBar 的网格信息。
			*progressBar.changeHandler=new Handler(this,onChange);//设置 progressBar 的value值改变时执行的处理器。
			*Laya.stage.addChild(progressBar);//将 progressBar 添加到显示列表。
			*Laya.timer.once(3000,this,changeValue);//设定 3000ms（毫秒）后，执行函数changeValue。
			*}
		*private function changeValue():void
		*{
			*trace("改变进度条的进度值。");
			*progressBar.value=0.6;
			*}
		*private function onChange(value:Number):void
		*{
			*trace("进度发生改变： value=" ,value);
			*}
		*}
	*}
*@example
*Laya.init(640,800);//设置游戏画布宽高
*Laya.stage.bgColor="#efefef";//设置画布的背景颜色
*var res=["resource/ui/progress.png","resource/ui/progress$bar.png"];
*Laya.loader.load(res,laya.utils.Handler.create(this,onLoadComplete));//加载资源。
*function onLoadComplete()
*{
	*progressBar=new laya.ui.ProgressBar("resource/ui/progress.png");//创建一个 ProgressBar 类的实例对象 progressBar 。
	*progressBar.x=100;//设置 progressBar 对象的属性 x 的值，用于控制 progressBar 对象的显示位置。
	*progressBar.y=100;//设置 progressBar 对象的属性 y 的值，用于控制 progressBar 对象的显示位置。
	*progressBar.value=0.3;//设置 progressBar 的进度值。
	*progressBar.width=200;//设置 progressBar 的宽度。
	*progressBar.height=50;//设置 progressBar 的高度。
	*progressBar.sizeGrid="10,5,10,5";//设置 progressBar 的网格信息。
	*progressBar.changeHandler=new laya.utils.Handler(this,onChange);//设置 progressBar 的value值改变时执行的处理器。
	*Laya.stage.addChild(progressBar);//将 progressBar 添加到显示列表。
	*Laya.timer.once(3000,this,changeValue);//设定 3000ms（毫秒）后，执行函数changeValue。
	*}
*function changeValue()
*{
	*console.log("改变进度条的进度值。");
	*progressBar.value=0.6;
	*}
*function onChange(value)
*{
	*console.log("进度发生改变： value=" ,value);
	*}
*@example
*import ProgressBar=laya.ui.ProgressBar;
*import Handler=laya.utils.Handler;
*class ProgressBar_Example {
	*private progressBar:ProgressBar;
	*public ProgressBar_Example(){
		*Laya.init(640,800);//设置游戏画布宽高。
		*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
		*Laya.loader.load(["resource/ui/progress.png","resource/ui/progress$bar.png"],Handler.create(this,this.onLoadComplete));//加载资源。
		*}
	*private onLoadComplete():void {
		*this.progressBar=new ProgressBar("resource/ui/progress.png");//创建一个 ProgressBar 类的实例对象 progressBar 。
		*this.progressBar.x=100;//设置 progressBar 对象的属性 x 的值，用于控制 progressBar 对象的显示位置。
		*this.progressBar.y=100;//设置 progressBar 对象的属性 y 的值，用于控制 progressBar 对象的显示位置。
		*this.progressBar.value=0.3;//设置 progressBar 的进度值。
		*this.progressBar.width=200;//设置 progressBar 的宽度。
		*this.progressBar.height=50;//设置 progressBar 的高度。
		*this.progressBar.sizeGrid="5,10,5,10";//设置 progressBar 的网格信息。
		*this.progressBar.changeHandler=new Handler(this,this.onChange);//设置 progressBar 的value值改变时执行的处理器。
		*Laya.stage.addChild(this.progressBar);//将 progressBar 添加到显示列表。
		*Laya.timer.once(3000,this,this.changeValue);//设定 3000ms（毫秒）后，执行函数changeValue。
		*}
	*private changeValue():void {
		*console.log("改变进度条的进度值。");
		*this.progressBar.value=0.6;
		*}
	*private onChange(value:number):void {
		*console.log("进度发生改变： value=",value);
		*}
	*}
*/
//class laya.ui.ProgressBar extends laya.ui.Component
var ProgressBar=(function(_super){
	function ProgressBar(skin){
		/**
		*当 <code>ProgressBar</code> 实例的 <code>value</code> 属性发生变化时的函数处理器。
		*<p>默认返回参数<code>value</code> 属性（进度值）。</p>
		*/
		this.changeHandler=null;
		/**@private */
		this._bg=null;
		/**@private */
		this._bar=null;
		/**@private */
		this._skin=null;
		/**@private */
		this._value=0.5;
		ProgressBar.__super.call(this);
		this.skin=skin;
	}

	__class(ProgressBar,'laya.ui.ProgressBar',_super);
	var __proto=ProgressBar.prototype;
	/**@inheritDoc */
	__proto.destroy=function(destroyChild){
		(destroyChild===void 0)&& (destroyChild=true);
		_super.prototype.destroy.call(this,destroyChild);
		this._bg && this._bg.destroy(destroyChild);
		this._bar && this._bar.destroy(destroyChild);
		this._bg=this._bar=null;
		this.changeHandler=null;
	}

	/**@inheritDoc */
	__proto.createChildren=function(){
		this.addChild(this._bg=new Image());
		this.addChild(this._bar=new Image());
		this._bar._bitmap.autoCacheCmd=false;
	}

	/**
	*@private
	*更改进度值的显示。
	*/
	__proto.changeValue=function(){
		if (this.sizeGrid){
			var grid=this.sizeGrid.split(",");
			var left=Number(grid[3]);
			var right=Number(grid[1]);
			var max=this.width-left-right;
			var sw=max *this._value;
			this._bar.width=left+right+sw;
			this._bar.visible=this._bar.width > left+right;
			}else {
			this._bar.width=this.width *this._value;
		}
	}

	/**@inheritDoc */
	__getset(0,__proto,'measureHeight',function(){
		return this._bg.height;
	});

	/**
	*@copy laya.ui.Image#skin
	*/
	__getset(0,__proto,'skin',function(){
		return this._skin;
		},function(value){
		if (this._skin !=value){
			this._skin=value;
			this._bg.skin=this._skin;
			this._bar.skin=this._skin.replace(".png","$bar.png");
			this.callLater(this.changeValue);
		}
	});

	/**@inheritDoc */
	__getset(0,__proto,'measureWidth',function(){
		return this._bg.width;
	});

	/**@inheritDoc */
	__getset(0,__proto,'height',_super.prototype._$get_height,function(value){
		Laya.superSet(Component,this,'height',value);
		this._bg.height=this._height;
		this._bar.height=this._height;
	});

	/**
	*获取进度条对象。
	*/
	__getset(0,__proto,'bar',function(){
		return this._bar;
	});

	/**
	*当前的进度量。
	*<p><b>取值：</b>介于0和1之间。</p>
	*/
	__getset(0,__proto,'value',function(){
		return this._value;
		},function(num){
		if (this._value !=num){
			num=num > 1 ? 1 :num < 0 ? 0 :num;
			this._value=num;
			this.callLater(this.changeValue);
			this.event(/*laya.events.Event.CHANGE*/"change");
			this.changeHandler && this.changeHandler.runWith(num);
		}
	});

	/**
	*获取背景条对象。
	*/
	__getset(0,__proto,'bg',function(){
		return this._bg;
	});

	/**
	*<p>当前 <code>ProgressBar</code> 实例的进度条背景位图（ <code>Image</code> 实例）的有效缩放网格数据。</p>
	*<p>数据格式："上边距,右边距,下边距,左边距,是否重复填充(值为0：不重复填充，1：重复填充)"，以逗号分隔。
	*<ul><li>例如："4,4,4,4,1"</li></ul></p>
	*@see laya.ui.AutoBitmap.sizeGrid
	*/
	__getset(0,__proto,'sizeGrid',function(){
		return this._bg.sizeGrid;
		},function(value){
		this._bg.sizeGrid=this._bar.sizeGrid=value;
	});

	/**@inheritDoc */
	__getset(0,__proto,'width',_super.prototype._$get_width,function(value){
		Laya.superSet(Component,this,'width',value);
		this._bg.width=this._width;
		this.callLater(this.changeValue);
	});

	/**@inheritDoc */
	__getset(0,__proto,'dataSource',_super.prototype._$get_dataSource,function(value){
		this._dataSource=value;
		if ((typeof value=='number')|| (typeof value=='string'))this.value=Number(value);
		else Laya.superSet(Component,this,'dataSource',value);
	});

	return ProgressBar;
})(Component)


/**鼠标提示管理类*/
//class laya.ui.TipManager extends laya.ui.Component
var TipManager=(function(_super){
	function TipManager(){
		this._tipBox=null;
		this._tipText=null;
		this._defaultTipHandler=null;
		TipManager.__super.call(this);
		this._tipBox=new Component();
		this._tipBox.addChild(this._tipText=new Text());
		this._tipText.x=this._tipText.y=5;
		this._tipText.color=TipManager.tipTextColor;
		this._defaultTipHandler=this._showDefaultTip;
		Laya.stage.on(/*laya.ui.UIEvent.SHOW_TIP*/"showtip",this,this._onStageShowTip);
		Laya.stage.on(/*laya.ui.UIEvent.HIDE_TIP*/"hidetip",this,this._onStageHideTip);
		this.zOrder=1100
	}

	__class(TipManager,'laya.ui.TipManager',_super);
	var __proto=TipManager.prototype;
	/**
	*@private
	*/
	__proto._onStageHideTip=function(e){
		Laya.timer.clear(this,this._showTip);
		this.closeAll();
		this.removeSelf();
	}

	/**
	*@private
	*/
	__proto._onStageShowTip=function(data){
		Laya.timer.once(TipManager.tipDelay,this,this._showTip,[data],true);
	}

	/**
	*@private
	*/
	__proto._showTip=function(tip){
		if ((typeof tip=='string')){
			var text=String(tip);
			if (Boolean(text)){
				this._defaultTipHandler(text);
			}
			}else if ((tip instanceof laya.utils.Handler )){
			(tip).run();
			}else if ((typeof tip=='function')){
			(tip).apply();
		}
		if (true){
			Laya.stage.on(/*laya.events.Event.MOUSE_MOVE*/"mousemove",this,this._onStageMouseMove);
			Laya.stage.on(/*laya.events.Event.MOUSE_DOWN*/"mousedown",this,this._onStageMouseDown);
		}
		this._onStageMouseMove(null);
	}

	/**
	*@private
	*/
	__proto._onStageMouseDown=function(e){
		this.closeAll();
	}

	/**
	*@private
	*/
	__proto._onStageMouseMove=function(e){
		this._showToStage(this,TipManager.offsetX,TipManager.offsetY);
	}

	/**
	*@private
	*/
	__proto._showToStage=function(dis,offX,offY){
		(offX===void 0)&& (offX=0);
		(offY===void 0)&& (offY=0);
		var rec=dis.getBounds();
		dis.x=Laya.stage.mouseX+offX;
		dis.y=Laya.stage.mouseY+offY;
		if (dis.x+rec.width > Laya.stage.width){
			dis.x-=rec.width+offX;
		}
		if (dis.y+rec.height > Laya.stage.height){
			dis.y-=rec.height+offY;
		}
	}

	/**关闭所有鼠标提示*/
	__proto.closeAll=function(){
		Laya.timer.clear(this,this._showTip);
		Laya.stage.off(/*laya.events.Event.MOUSE_MOVE*/"mousemove",this,this._onStageMouseMove);
		Laya.stage.off(/*laya.events.Event.MOUSE_DOWN*/"mousedown",this,this._onStageMouseDown);
		this.removeChildren();
	}

	/**
	*显示显示对象类型的tip
	*/
	__proto.showDislayTip=function(tip){
		this.addChild(tip);
		this._showToStage(this);
		Laya._currentStage.addChild(this);
	}

	/**
	*@private
	*/
	__proto._showDefaultTip=function(text){
		this._tipText.text=text;
		var g=this._tipBox.graphics;
		g.clear();
		g.drawRect(0,0,this._tipText.width+10,this._tipText.height+10,TipManager.tipBackColor);
		this.addChild(this._tipBox);
		this._showToStage(this);
		Laya._currentStage.addChild(this);
	}

	/**默认鼠标提示函数*/
	__getset(0,__proto,'defaultTipHandler',function(){
		return this._defaultTipHandler;
		},function(value){
		this._defaultTipHandler=value;
	});

	TipManager.offsetX=10;
	TipManager.offsetY=15;
	TipManager.tipTextColor="#ffffff";
	TipManager.tipBackColor="#111111";
	TipManager.tipDelay=200;
	return TipManager;
})(Component)


/**
*<code>View</code> 是一个视图类。
*@internal <p><code>View</code></p>
*/
//class laya.ui.View extends laya.ui.Box
var View=(function(_super){
	var DataWatcher;
	function View(){
		/**@private */
		this._idMap=null;
		/**@private */
		this._aniList=null;
		/**@private */
		this._watchMap={};
		View.__super.call(this);
	}

	__class(View,'laya.ui.View',_super);
	var __proto=View.prototype;
	/**
	*@private
	*通过视图数据创建视图。
	*@param uiView 视图数据信息。
	*/
	__proto.createView=function(uiView){
		if (uiView.animations && !this._idMap)this._idMap={};
		View.createComp(uiView,this,this);
		if (uiView.animations){
			var anilist=[];
			var animations=uiView.animations;
			var i=0,len=animations.length;
			var tAni;
			var tAniO;
			for (i=0;i < len;i++){
				tAni=new FrameAnimation();
				tAniO=animations[i];
				tAni._setUp(this._idMap,tAniO);
				this[tAniO.name]=tAni;
				tAni._setControlNode(this);
				switch (tAniO.action){
					case 1:
						tAni.play(0,false);
						break ;
					case 2:
						tAni.play(0,true);
						break ;
					}
				anilist.push(tAni);
			}
			this._aniList=anilist;
		}
		if (this._width > 0 && uiView.props.hitTestPrior==null && !this.mouseThrough)this.hitTestPrior=true;
	}

	__proto.onEvent=function(type,event){}
	/**
	*@private
	*装载UI视图。用于加载模式。
	*@param path UI资源地址。
	*/
	__proto.loadUI=function(path){
		var uiView=View.uiMap[path];
		uiView && this.createView(uiView);
	}

	/**
	*<p>销毁此对象。</p>
	*@param destroyChild 是否同时销毁子节点，若值为true,则销毁子节点，否则不销毁子节点。
	*/
	__proto.destroy=function(destroyChild){
		(destroyChild===void 0)&& (destroyChild=true);
		if (this._aniList)this._aniList.length=0;
		this._idMap=null;
		this._aniList=null;
		this._watchMap=null;
		laya.ui.Component.prototype.destroy.call(this,destroyChild);
	}

	/**@private */
	__proto.changeData=function(key){
		var arr=this._watchMap[key];
		if (!arr)return;
		console.log("change",key);
		for (var i=0,n=arr.length;i < n;i++){
			var watcher=arr[i];
			watcher.exe(this);
		}
	}

	View._regs=function(){
		for (var key in View.uiClassMap){
			ClassUtils.regClass(key,View.uiClassMap[key]);
		}
	}

	View.createComp=function(uiView,comp,view,dataMap){
		comp=comp || View.getCompInstance(uiView);
		if (!comp){
			console.warn("can not create:"+uiView.type);
			return null;
		};
		var child=uiView.child;
		if (child){
			var isList=(comp instanceof laya.ui.List );
			for (var i=0,n=child.length;i < n;i++){
				var node=child[i];
				if (comp.hasOwnProperty("itemRender")&& (node.props.name=="render" || node.props.renderType==="render")){
					(comp).itemRender=node;
					}else if (node.type=="Graphic"){
					ClassUtils.addGraphicsToSprite(node,comp);
					}else if (ClassUtils.isDrawType(node.type)){
					ClassUtils.addGraphicToSprite(node,comp,true);
					}else {
					if (isList){
						var arr=[];
						var tChild=View.createComp(node,null,view,arr);
						if (arr.length)tChild["_$bindData"]=arr;
						}else {
						tChild=View.createComp(node,null,view,dataMap);
					}
					if (node.type=="Script"){
						if ("owner" in tChild){
							tChild["owner"]=comp;
							}else if ("target" in tChild){
							tChild["target"]=comp;
						}
						}else if (node.props.renderType=="mask" || node.props.name=="mask"){
						comp.mask=tChild;
						}else {(
						tChild instanceof laya.display.Sprite )&& comp.addChild(tChild);
					}
				}
			}
		};
		var props=uiView.props;
		for (var prop in props){
			var value=props[prop];
			if (View.eventDic[prop]){
				if (value&&view){
					(comp).on(prop,view,view.onEvent,[value]);
				}
			}else
			View.setCompValue(comp,prop,value,view,dataMap);
		}
		if (Laya.__typeof(comp,'laya.ui.IItem'))(comp).initItems();
		if (uiView.compId && view && view._idMap){
			view._idMap[uiView.compId]=comp;
		}
		return comp;
	}

	View.setCompValue=function(comp,prop,value,view,dataMap){
		if ((typeof value=='string')&& value.indexOf("${")>-1){
			View._sheet || (View._sheet=ClassUtils.getClass("laya.data.Table"));
			if (!View._sheet){
				console.warn("Can not find class Sheet");
				return;
			}
			if (dataMap){
				dataMap.push(comp,prop,value);
				}else if (view){
				if (value.indexOf("].")==-1){
					value=value.replace(".","[0].");
				};
				var watcher=new DataWatcher(comp,prop,value);
				watcher.exe(view);
				var one,temp;
				var str=value.replace(/\[.*?\]\./g,".");
				while ((one=View._parseWatchData.exec(str))!=null){
					var key1=one[1];
					while ((temp=View._parseKeyWord.exec(key1))!=null){
						var key2=temp[0];
						var arr=(view._watchMap[key2] || (view._watchMap[key2]=[]));
						arr.push(watcher);
						View._sheet.I.notifer.on(key2,view,view.changeData,[key2]);
					}
					arr=(view._watchMap[key1] || (view._watchMap[key1]=[]));
					arr.push(watcher);
					View._sheet.I.notifer.on(key1,view,view.changeData,[key1]);
				}
			}
			return;
		}
		if (prop==="var" && view){
			view[value]=comp;
			}else if (prop=="onClick"){
			var fun=Laya._runScript("(function(){"+value+"})");
			comp.on(/*laya.events.Event.CLICK*/"click",view,fun);
			}else {
			comp[prop]=(value==="true" ? true :(value==="false" ? false :value));
		}
	}

	View.getCompInstance=function(json){
		var runtime=json.props ? json.props.runtime :null;
		var compClass;
		compClass=runtime ? (View.viewClassMap[runtime] || View.uiClassMap[runtime]|| Laya["__classmap"][runtime]):View.uiClassMap[json.type];
		if (json.props && json.props.hasOwnProperty("renderType")&& json.props["renderType"]=="instance")return compClass["instance"];
		return compClass ? new compClass():null;
	}

	View.regComponent=function(key,compClass){
		View.uiClassMap[key]=compClass;
		ClassUtils.regClass(key,compClass);
	}

	View.regViewRuntime=function(key,compClass){
		View.viewClassMap[key]=compClass;
	}

	View.uiMap={};
	View.viewClassMap={};
	View._sheet=null;
	__static(View,
	['uiClassMap',function(){return this.uiClassMap={"ViewStack":ViewStack,"LinkButton":Button,"TextArea":TextArea,"ColorPicker":ColorPicker,"Box":Box,"Button":Button,"CheckBox":CheckBox,"Clip":Clip,"ComboBox":ComboBox,"Component":Component,"HScrollBar":HScrollBar,"HSlider":HSlider,"Image":Image,"Label":Label,"List":List,"Panel":Panel,"ProgressBar":ProgressBar,"Radio":Radio,"RadioGroup":RadioGroup,"ScrollBar":ScrollBar,"Slider":Slider,"Tab":Tab,"TextInput":TextInput,"View":View,"VScrollBar":VScrollBar,"VSlider":VSlider,"Tree":Tree,"HBox":HBox,"VBox":VBox,"Sprite":Sprite,"Animation":Animation,"Text":Text,"FontClip":FontClip};},'eventDic',function(){return this.eventDic={"mousedown":true,"mouseup":true,"mousemove":true,"mouseover":true,"mouseout":true,"click":true,"doubleclick":true,"rightmousedown":true,"rightmouseup":true,"rightclick":true };},'_parseWatchData',function(){return this._parseWatchData=/\${(.*?)}/g;},'_parseKeyWord',function(){return this._parseKeyWord=/[a-zA-Z_][a-zA-Z0-9_]*(?:(?:\.[a-zA-Z_][a-zA-Z0-9_]*)+)/g;}
	]);
	View.__init$=function(){
		View._regs()
		//class DataWatcher
		DataWatcher=(function(){
			function DataWatcher(comp,prop,value){
				this.comp=null;
				this.prop=null;
				this.value=null;
				this.comp=comp;
				this.prop=prop;
				this.value=value;
			}
			__class(DataWatcher,'');
			var __proto=DataWatcher.prototype;
			__proto.exe=function(view){
				var fun=UIUtils.getBindFun(this.value);
				this.comp[this.prop]=fun.call(this,view);
			}
			return DataWatcher;
		})()
	}

	return View;
})(Box)


/**
*<code>CheckBox</code> 组件显示一个小方框，该方框内可以有选中标记。
*<code>CheckBox</code> 组件还可以显示可选的文本标签，默认该标签位于 CheckBox 右侧。
*<p><code>CheckBox</code> 使用 <code>dataSource</code>赋值时的的默认属性是：<code>selected</code>。</p>
*
*@example <caption>以下示例代码，创建了一个 <code>CheckBox</code> 实例。</caption>
*package
*{
	*import laya.ui.CheckBox;
	*import laya.utils.Handler;
	*public class CheckBox_Example
	*{
		*public function CheckBox_Example()
		*{
			*Laya.init(640,800);//设置游戏画布宽高。
			*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
			*Laya.loader.load("resource/ui/check.png",Handler.create(this,onLoadComplete));//加载资源。
			*}
		*private function onLoadComplete():void
		*{
			*trace("资源加载完成！");
			*var checkBox:CheckBox=new CheckBox("resource/ui/check.png","这个是一个CheckBox组件。");//创建一个 CheckBox 类的实例对象 checkBox ,传入它的皮肤skin和标签label。
			*checkBox.x=100;//设置 checkBox 对象的属性 x 的值，用于控制 checkBox 对象的显示位置。
			*checkBox.y=100;//设置 checkBox 对象的属性 y 的值，用于控制 checkBox 对象的显示位置。
			*checkBox.clickHandler=new Handler(this,onClick,[checkBox]);//设置 checkBox 的点击事件处理器。
			*Laya.stage.addChild(checkBox);//将此 checkBox 对象添加到显示列表。
			*}
		*private function onClick(checkBox:CheckBox):void
		*{
			*trace("输出选中状态: checkBox.selected = "+checkBox.selected);
			*}
		*}
	*}
*@example
*Laya.init(640,800);//设置游戏画布宽高
*Laya.stage.bgColor="#efefef";//设置画布的背景颜色
*Laya.loader.load("resource/ui/check.png",laya.utils.Handler.create(this,loadComplete));//加载资源
*function loadComplete()
*{
	*console.log("资源加载完成！");
	*var checkBox:laya.ui.CheckBox=new laya.ui.CheckBox("resource/ui/check.png","这个是一个CheckBox组件。");//创建一个 CheckBox 类的类的实例对象 checkBox ,传入它的皮肤skin和标签label。
	*checkBox.x=100;//设置 checkBox 对象的属性 x 的值，用于控制 checkBox 对象的显示位置。
	*checkBox.y=100;//设置 checkBox 对象的属性 y 的值，用于控制 checkBox 对象的显示位置。
	*checkBox.clickHandler=new laya.utils.Handler(this,this.onClick,[checkBox],false);//设置 checkBox 的点击事件处理器。
	*Laya.stage.addChild(checkBox);//将此 checkBox 对象添加到显示列表。
	*}
*function onClick(checkBox)
*{
	*console.log("checkBox.selected = ",checkBox.selected);
	*}
*@example
*import CheckBox=laya.ui.CheckBox;
*import Handler=laya.utils.Handler;
*class CheckBox_Example{
	*constructor()
	*{
		*Laya.init(640,800);
		*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
		*Laya.loader.load("resource/ui/check.png",Handler.create(this,this.onLoadComplete));//加载资源。
		*}
	*private onLoadComplete()
	*{
		*var checkBox:CheckBox=new CheckBox("resource/ui/check.png","这个是一个CheckBox组件。");//创建一个 CheckBox 类的实例对象 checkBox ,传入它的皮肤skin和标签label。
		*checkBox.x=100;//设置 checkBox 对象的属性 x 的值，用于控制 checkBox 对象的显示位置。
		*checkBox.y=100;//设置 checkBox 对象的属性 y 的值，用于控制 checkBox 对象的显示位置。
		*checkBox.clickHandler=new Handler(this,this.onClick,[checkBox]);//设置 checkBox 的点击事件处理器。
		*Laya.stage.addChild(checkBox);//将此 checkBox 对象添加到显示列表。
		*}
	*private onClick(checkBox:CheckBox):void
	*{
		*console.log("输出选中状态: checkBox.selected = "+checkBox.selected);
		*}
	*}
*/
//class laya.ui.CheckBox extends laya.ui.Button
var CheckBox=(function(_super){
	/**
	*创建一个新的 <code>CheckBox</code> 组件实例。
	*@param skin 皮肤资源地址。
	*@param label 文本标签的内容。
	*/
	function CheckBox(skin,label){
		(label===void 0)&& (label="");
		CheckBox.__super.call(this,skin,label);
	}

	__class(CheckBox,'laya.ui.CheckBox',_super);
	var __proto=CheckBox.prototype;
	/**@inheritDoc */
	__proto.preinitialize=function(){
		laya.ui.Component.prototype.preinitialize.call(this);
		this.toggle=true;
		this._autoSize=false;
	}

	/**@inheritDoc */
	__proto.initialize=function(){
		_super.prototype.initialize.call(this);
		this.createText();
		this._text.align="left";
		this._text.valign="top";
		this._text.width=0;
	}

	/**@inheritDoc */
	__getset(0,__proto,'dataSource',_super.prototype._$get_dataSource,function(value){
		this._dataSource=value;
		if ((typeof value=='boolean'))this.selected=value;
		else if ((typeof value=='string'))this.selected=value==="true";
		else Laya.superSet(Button,this,'dataSource',value);
	});

	return CheckBox;
})(Button)


/**
*<code>LayoutBox</code> 是一个布局容器类。
*/
//class laya.ui.LayoutBox extends laya.ui.Box
var LayoutBox=(function(_super){
	function LayoutBox(){
		/**@private */
		this._space=0;
		/**@private */
		this._align="none";
		/**@private */
		this._itemChanged=false;
		LayoutBox.__super.call(this);
	}

	__class(LayoutBox,'laya.ui.LayoutBox',_super);
	var __proto=LayoutBox.prototype;
	/**@inheritDoc */
	__proto.addChild=function(child){
		child.on(/*laya.events.Event.RESIZE*/"resize",this,this.onResize);
		this._setItemChanged();
		return laya.display.Node.prototype.addChild.call(this,child);
	}

	__proto.onResize=function(e){
		this._setItemChanged();
	}

	/**@inheritDoc */
	__proto.addChildAt=function(child,index){
		child.on(/*laya.events.Event.RESIZE*/"resize",this,this.onResize);
		this._setItemChanged();
		return laya.display.Node.prototype.addChildAt.call(this,child,index);
	}

	/**@inheritDoc */
	__proto.removeChild=function(child){
		child.off(/*laya.events.Event.RESIZE*/"resize",this,this.onResize);
		this._setItemChanged();
		return laya.display.Node.prototype.removeChild.call(this,child);
	}

	/**@inheritDoc */
	__proto.removeChildAt=function(index){
		this.getChildAt(index).off(/*laya.events.Event.RESIZE*/"resize",this,this.onResize);
		this._setItemChanged();
		return laya.display.Node.prototype.removeChildAt.call(this,index);
	}

	/**刷新。*/
	__proto.refresh=function(){
		this._setItemChanged();
	}

	/**
	*改变子对象的布局。
	*/
	__proto.changeItems=function(){
		this._itemChanged=false;
	}

	/**
	*排序项目列表。可通过重写改变默认排序规则。
	*@param items 项目列表。
	*/
	__proto.sortItem=function(items){
		if (items)items.sort(function(a,b){return a.y-b.y;});
	}

	__proto._setItemChanged=function(){
		if (!this._itemChanged){
			this._itemChanged=true;
			this.callLater(this.changeItems);
		}
	}

	/**子对象的间隔。*/
	__getset(0,__proto,'space',function(){
		return this._space;
		},function(value){
		this._space=value;
		this._setItemChanged();
	});

	/**子对象对齐方式。*/
	__getset(0,__proto,'align',function(){
		return this._align;
		},function(value){
		this._align=value;
		this._setItemChanged();
	});

	return LayoutBox;
})(Box)


/**
*字体切片，简化版的位图字体，只需设置一个切片图片和文字内容即可使用，效果同位图字体
*使用方式：设置位图字体皮肤skin，设置皮肤对应的字体内容sheet（如果多行，可以使用空格换行），示例：
*fontClip.skin="font1.png";//设置皮肤
*fontClip.sheet="abc123 456";//设置皮肤对应的内容，空格换行。此皮肤为2行5列（显示时skin会被等分为2行5列），第一行对应的文字为"abc123"，第二行为"456"
*fontClip.value="a1326";//显示"a1326"文字
*/
//class laya.ui.FontClip extends laya.ui.Clip
var FontClip=(function(_super){
	function FontClip(skin,sheet){
		/**数值*/
		this._valueArr=null;
		/**文字内容数组**/
		this._indexMap=null;
		/**位图字体内容**/
		this._sheet=null;
		/**@private */
		this._direction="horizontal";
		/**X方向间隙*/
		this._spaceX=0;
		/**Y方向间隙*/
		this._spaceY=0;
		/**@private 水平对齐方式*/
		this._align="left";
		/**@private 显示文字宽*/
		this._wordsW=0;
		/**@private 显示文字高*/
		this._wordsH=0;
		FontClip.__super.call(this);
		if (skin)this.skin=skin;
		if (sheet)this.sheet=sheet;
	}

	__class(FontClip,'laya.ui.FontClip',_super);
	var __proto=FontClip.prototype;
	__proto.createChildren=function(){
		this._bitmap=new AutoBitmap();
		this.on(/*laya.events.Event.LOADED*/"loaded",this,this._onClipLoaded);
	}

	/**
	*资源加载完毕
	*/
	__proto._onClipLoaded=function(){
		this.callLater(this.changeValue);
	}

	/**渲染数值*/
	__proto.changeValue=function(){
		if (!this._sources)return;
		if (!this._valueArr)return;
		this.graphics.clear(true);
		var texture;
		texture=this._sources[0];
		if (!texture)return;
		var isHorizontal=(this._direction==="horizontal");
		if (isHorizontal){
			this._wordsW=this._valueArr.length *(texture.sourceWidth+this.spaceX);
			this._wordsH=texture.sourceHeight;
			}else{
			this._wordsW=texture.sourceWidth;
			this._wordsH=(texture.sourceHeight+this.spaceY)*this._valueArr.length;
		};
		var dX=0;
		if (this._width){
			switch(this._align){
				case "center":
					dX=0.5 *(this._width-this._wordsW);
					break ;
				case "right":
					dX=this._width-this._wordsW;
					break ;
				default :
					dX=0;
				}
		}
		for (var i=0,sz=this._valueArr.length;i < sz;i++){
			var index=this._indexMap[this._valueArr.charAt(i)];
			if (!this.sources[index])continue ;
			texture=this.sources[index];
			if (isHorizontal)this.graphics.drawTexture(texture,dX+i *(texture.sourceWidth+this.spaceX),0,texture.sourceWidth,texture.sourceHeight);
			else this.graphics.drawTexture(texture,0+dX,i *(texture.sourceHeight+this.spaceY),texture.sourceWidth,texture.sourceHeight);
		}
		if (!this._width){
			this.resetLayoutX();
			this.callLater(this.changeSize);
		}
		if (!this._height){
			this.resetLayoutY();
			this.callLater(this.changeSize);
		}
	}

	__proto.destroy=function(destroyChild){
		(destroyChild===void 0)&& (destroyChild=true);
		this._valueArr=null;
		this._indexMap=null;
		this.graphics.clear(true);
		this.removeSelf();
		this.off(/*laya.events.Event.LOADED*/"loaded",this,this._onClipLoaded);
		_super.prototype.destroy.call(this,destroyChild);
	}

	/**
	*设置位图字体内容，空格代表换行。比如"abc123 456"，代表第一行对应的文字为"abc123"，第二行为"456"
	*/
	__getset(0,__proto,'sheet',function(){
		return this._sheet;
		},function(value){
		value+="";
		this._sheet=value;
		var arr=value.split(" ");
		this._clipX=String(arr[0]).length;
		this.clipY=arr.length;
		this._indexMap={};
		for (var i=0;i < this._clipY;i++){
			var line=arr[i].split("");
			for (var j=0,n=line.length;j < n;j++){
				this._indexMap[line[j]]=i *this._clipX+j;
			}
		}
	});

	__getset(0,__proto,'height',_super.prototype._$get_height,function(value){
		Laya.superSet(Clip,this,'height',value);
		this.callLater(this.changeValue);
	});

	/**
	*布局方向。
	*<p>默认值为"horizontal"。</p>
	*<p><b>取值：</b>
	*<li>"horizontal"：表示水平布局。</li>
	*<li>"vertical"：表示垂直布局。</li>
	*</p>
	*/
	__getset(0,__proto,'direction',function(){
		return this._direction;
		},function(value){
		this._direction=value;
		this.callLater(this.changeValue);
	});

	/**
	*设置位图字体的显示内容
	*/
	__getset(0,__proto,'value',function(){
		if (!this._valueArr)return "";
		return this._valueArr;
		},function(value){
		value+="";
		this._valueArr=value;
		this.callLater(this.changeValue);
	});

	__getset(0,__proto,'width',_super.prototype._$get_width,function(value){
		Laya.superSet(Clip,this,'width',value);
		this.callLater(this.changeValue);
	});

	/**X方向文字间隙*/
	__getset(0,__proto,'spaceX',function(){
		return this._spaceX;
		},function(value){
		this._spaceX=value;
		if (this._direction==="horizontal")this.callLater(this.changeValue);
	});

	/**Y方向文字间隙*/
	__getset(0,__proto,'spaceY',function(){
		return this._spaceY;
		},function(value){
		this._spaceY=value;
		if (!(this._direction==="horizontal"))this.callLater(this.changeValue);
	});

	/**水平对齐方式*/
	__getset(0,__proto,'align',function(){
		return this._align;
		},function(v){
		this._align=v;
		this.callLater(this.changeValue);
	});

	__getset(0,__proto,'measureWidth',function(){
		return this._wordsW;
	});

	__getset(0,__proto,'measureHeight',function(){
		return this._wordsH;
	});

	return FontClip;
})(Clip)


/**
*<code>List</code> 控件可显示项目列表。默认为垂直方向列表。可通过UI编辑器自定义列表。
*
*@example <caption>以下示例代码，创建了一个 <code>List</code> 实例。</caption>
*package
*{
	*import laya.ui.List;
	*import laya.utils.Handler;
	*public class List_Example
	*{
		*public function List_Example()
		*{
			*Laya.init(640,800,"false");//设置游戏画布宽高、渲染模式。
			*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
			*Laya.loader.load(["resource/ui/vscroll.png","resource/ui/vscroll$bar.png","resource/ui/vscroll$down.png","resource/ui/vscroll$up.png"],Handler.create(this,onLoadComplete));
			*}
		*private function onLoadComplete():void
		*{
			*var arr:Array=[];//创建一个数组，用于存贮列表的数据信息。
			*for (var i:int=0;i &lt;20;i++)
			*{
				*arr.push({label:"item"+i});
				*}
			*var list:List=new List();//创建一个 List 类的实例对象 list 。
			*list.itemRender=Item;//设置 list 的单元格渲染器。
			*list.repeatX=1;//设置 list 的水平方向单元格数量。
			*list.repeatY=10;//设置 list 的垂直方向单元格数量。
			*list.vScrollBarSkin="resource/ui/vscroll.png";//设置 list 的垂直方向滚动条皮肤。
			*list.array=arr;//设置 list 的列表数据源。
			*list.pos(100,100);//设置 list 的位置。
			*list.selectEnable=true;//设置 list 可选。
			*list.selectHandler=new Handler(this,onSelect);//设置 list 改变选择项执行的处理器。
			*Laya.stage.addChild(list);//将 list 添加到显示列表。
			*}
		*private function onSelect(index:int):void
		*{
			*trace("当前选择的项目索引： index= ",index);
			*}
		*}
	*}
*import laya.ui.Box;
*import laya.ui.Label;
*class Item extends Box
*{
	*public function Item()
	*{
		*graphics.drawRect(0,0,100,20,null,"#ff0000");
		*var label:Label=new Label();
		*label.text="100000";
		*label.name="label";//设置 label 的name属性值。
		*label.size(100,20);
		*addChild(label);
		*}
	*}
*@example
*(function (_super){
	*function Item(){
		*Item.__super.call(this);//初始化父类
		*this.graphics.drawRect(0,0,100,20,"#ff0000");
		*var label=new laya.ui.Label();//创建一个 Label 类的实例对象 label 。
		*label.text="100000";//设置 label 的文本内容。
		*label.name="label";//设置 label 的name属性值。
		*label.size(100,20);//设置 label 的宽度、高度。
		*this.addChild(label);//将 label 添加到显示列表。
		*};
	*Laya.class(Item,"mypackage.listExample.Item",_super);//注册类 Item 。
	*})(laya.ui.Box);
*Laya.init(640,800);//设置游戏画布宽高、渲染模式。
*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
*var res=["resource/ui/vscroll.png","resource/ui/vscroll$bar.png","resource/ui/vscroll$down.png","resource/ui/vscroll$up.png"];
*Laya.loader.load(res,new laya.utils.Handler(this,onLoadComplete));//加载资源。
*function onLoadComplete(){
	*var arr=[];//创建一个数组，用于存贮列表的数据信息。
	*for (var i=0;i &lt;20;i++){
		*arr.push({label:"item"+i});
		*}
	*var list=new laya.ui.List();//创建一个 List 类的实例对象 list 。
	*list.itemRender=mypackage.listExample.Item;//设置 list 的单元格渲染器。
	*list.repeatX=1;//设置 list 的水平方向单元格数量。
	*list.repeatY=10;//设置 list 的垂直方向单元格数量。
	*list.vScrollBarSkin="resource/ui/vscroll.png";//设置 list 的垂直方向滚动条皮肤。
	*list.array=arr;//设置 list 的列表数据源。
	*list.pos(100,100);//设置 list 的位置。
	*list.selectEnable=true;//设置 list 可选。
	*list.selectHandler=new laya.utils.Handler(this,onSelect);//设置 list 改变选择项执行的处理器。
	*Laya.stage.addChild(list);//将 list 添加到显示列表。
	*}
*function onSelect(index)
*{
	*console.log("当前选择的项目索引： index= ",index);
	*}
*
*@example
*import List=laya.ui.List;
*import Handler=laya.utils.Handler;
*public class List_Example {
	*public List_Example(){
		*Laya.init(640,800);//设置游戏画布宽高。
		*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
		*Laya.loader.load(["resource/ui/vscroll.png","resource/ui/vscroll$bar.png","resource/ui/vscroll$down.png","resource/ui/vscroll$up.png"],Handler.create(this,this.onLoadComplete));
		*}
	*private onLoadComplete():void {
		*var arr=[];//创建一个数组，用于存贮列表的数据信息。
		*for (var i:number=0;i &lt;20;i++)
		*{
			*arr.push({label:"item"+i });
			*}
		*var list:List=new List();//创建一个 List 类的实例对象 list 。
		*list.itemRender=Item;//设置 list 的单元格渲染器。
		*list.repeatX=1;//设置 list 的水平方向单元格数量。
		*list.repeatY=10;//设置 list 的垂直方向单元格数量。
		*list.vScrollBarSkin="resource/ui/vscroll.png";//设置 list 的垂直方向滚动条皮肤。
		*list.array=arr;//设置 list 的列表数据源。
		*list.pos(100,100);//设置 list 的位置。
		*list.selectEnable=true;//设置 list 可选。
		*list.selectHandler=new Handler(this,this.onSelect);//设置 list 改变选择项执行的处理器。
		*Laya.stage.addChild(list);//将 list 添加到显示列表。
		*}
	*private onSelect(index:number):void {
		*console.log("当前选择的项目索引： index= ",index);
		*}
	*}
*import Box=laya.ui.Box;
*import Label=laya.ui.Label;
*class Item extends Box {
	*constructor(){
		*this.graphics.drawRect(0,0,100,20,null,"#ff0000");
		*var label:Label=new Label();
		*label.text="100000";
		*label.name="label";//设置 label 的name属性值。
		*label.size(100,20);
		*this.addChild(label);
		*}
	*}
*/
//class laya.ui.List extends laya.ui.Box
var List=(function(_super){
	function List(){
		/**改变 <code>List</code> 的选择项时执行的处理器，(默认返回参数： 项索引（index:int）)。*/
		this.selectHandler=null;
		/**单元格渲染处理器(默认返回参数cell:Box,index:int)。*/
		this.renderHandler=null;
		/**单元格鼠标事件处理器(默认返回参数e:Event,index:int)。*/
		this.mouseHandler=null;
		/**指定是否可以选择，若值为true则可以选择，否则不可以选择。 @default false*/
		this.selectEnable=false;
		/**最大分页数。*/
		this.totalPage=0;
		/**@private */
		this._content=null;
		/**@private */
		this._scrollBar=null;
		/**@private */
		this._itemRender=null;
		/**@private */
		this._repeatX=0;
		/**@private */
		this._repeatY=0;
		/**@private */
		this._repeatX2=0;
		/**@private */
		this._repeatY2=0;
		/**@private */
		this._spaceX=0;
		/**@private */
		this._spaceY=0;
		/**@private */
		this._array=null;
		/**@private */
		this._startIndex=0;
		/**@private */
		this._selectedIndex=-1;
		/**@private */
		this._page=0;
		/**@private */
		this._isVertical=true;
		/**@private */
		this._cellSize=20;
		/**@private */
		this._cellOffset=0;
		/**@private */
		this._isMoved=false;
		/**是否缓存内容，如果数据源较少，并且list内无动画，设置此属性为true能大大提高性能 */
		this.cacheContent=false;
		/**@private */
		this._createdLine=0;
		/**@private */
		this._cellChanged=false;
		List.__super.call(this);
		this._cells=[];
		this._offset=new Point();
	}

	__class(List,'laya.ui.List',_super);
	var __proto=List.prototype;
	Laya.imps(__proto,{"laya.ui.IRender":true,"laya.ui.IItem":true})
	/**@inheritDoc */
	__proto.destroy=function(destroyChild){
		(destroyChild===void 0)&& (destroyChild=true);
		this._content && this._content.destroy(destroyChild);
		this._scrollBar && this._scrollBar.destroy(destroyChild);
		laya.ui.Component.prototype.destroy.call(this,destroyChild);
		this._content=null;
		this._scrollBar=null;
		this._itemRender=null;
		this._cells=null;
		this._array=null;
		this.selectHandler=this.renderHandler=this.mouseHandler=null;
	}

	/**@inheritDoc */
	__proto.createChildren=function(){
		this.addChild(this._content=new Box());
	}

	__proto.onScrollStart=function(){
		this._$P.cacheAs || (this._$P.cacheAs=Laya.superGet(Box,this,'cacheAs'));
		Laya.superSet(Box,this,'cacheAs',"none");
		this._scrollBar.once(/*laya.events.Event.END*/"end",this,this.onScrollEnd);
	}

	__proto.onScrollEnd=function(){
		Laya.superSet(Box,this,'cacheAs',this._$P.cacheAs);
	}

	__proto._removePreScrollBar=function(){
		var preNode=this.removeChildByName("scrollBar");
		if (preNode)preNode.destroy(true);
	}

	/**
	*@private
	*更改单元格的信息。
	*@internal 在此销毁、创建单元格，并设置单元格的位置等属性。相当于此列表内容发送改变时调用此函数。
	*/
	__proto.changeCells=function(){
		this._cellChanged=false;
		if (this._itemRender){
			this.scrollBar=this.getChildByName("scrollBar");
			var cell=this._getOneCell();
			var cellWidth=(cell.width+this._spaceX)|| 1;
			var cellHeight=(cell.height+this._spaceY)|| 1;
			if (this._width > 0)this._repeatX2=this._isVertical ? Math.round(this._width / cellWidth):Math.ceil(this._width / cellWidth);
			if (this._height > 0)this._repeatY2=this._isVertical ? Math.ceil(this._height / cellHeight):Math.round(this._height / cellHeight);
			var listWidth=this._width ? this._width :(cellWidth *this.repeatX-this._spaceX);
			var listHeight=this._height ? this._height :(cellHeight *this.repeatY-this._spaceY);
			this._cellSize=this._isVertical ? cellHeight :cellWidth;
			this._cellOffset=this._isVertical ? (cellHeight *Math.max(this._repeatY2,this._repeatY)-listHeight-this._spaceY):(cellWidth *Math.max(this._repeatX2,this._repeatX)-listWidth-this._spaceX);
			if (this._isVertical && this._scrollBar)this._scrollBar.height=listHeight;
			else if (!this._isVertical && this._scrollBar)this._scrollBar.width=listWidth;
			this.setContentSize(listWidth,listHeight);
			var numX=this._isVertical ? this.repeatX :this.repeatY;
			var numY=(this._isVertical ? this.repeatY :this.repeatX)+(this._scrollBar ? 1 :0);
			this._createItems(0,numX,numY);
			this._createdLine=numY;
			if (this._array){
				this.array=this._array;
				this.runCallLater(this.renderItems);
			}
		}
	}

	__proto._getOneCell=function(){
		if (this._cells.length===0){
			var item=this.createItem();
			this._offset.setTo(item.x,item.y);
			if (this.cacheContent)return item;
			this._cells.push(item);
		}
		return this._cells[0];
	}

	__proto._createItems=function(startY,numX,numY){
		var box=this._content;
		var cell=this._getOneCell();
		var cellWidth=cell.width+this._spaceX;
		var cellHeight=cell.height+this._spaceY;
		if (this.cacheContent){
			var cacheBox=new Box();
			cacheBox.cacheAsBitmap=true;
			cacheBox.pos((this._isVertical ? 0 :startY)*cellWidth,(this._isVertical ? startY :0)*cellHeight);
			this._content.addChild(cacheBox);
			this._content.optimizeScrollRect=true;
			box=cacheBox;
			}else {
			var arr=[];
			for (var i=this._cells.length-1;i >-1;i--){
				var item=this._cells[i];
				item.removeSelf();
				arr.push(item);
			}
			this._cells.length=0;
		}
		for (var k=startY;k < numY;k++){
			for (var l=0;l < numX;l++){
				if (arr && arr.length){
					cell=arr.pop();
					}else {
					cell=this.createItem();
				}
				cell.x=(this._isVertical ? l :k)*cellWidth-box.x;
				cell.y=(this._isVertical ? k :l)*cellHeight-box.y;
				cell.name="item"+(k *numX+l);
				box.addChild(cell);
				this.addCell(cell);
			}
		}
	}

	__proto.createItem=function(){
		var arr=[];
		if ((typeof this._itemRender=='function')){
			var box=new this._itemRender();
			}else {
			box=View.createComp(this._itemRender,null,null,arr)
		}
		if (arr.length==0 && box._watchMap){
			var watchMap=box._watchMap;
			for (var name in watchMap){
				var a=watchMap[name];
				for (var i=0;i < a.length;i++){
					var watcher=a[i];
					arr.push(watcher.comp,watcher.prop,watcher.value)
				}
			}
		}
		if (arr.length)box["_$bindData"]=arr;
		return box;
	}

	/**
	*@private
	*添加单元格。
	*@param cell 需要添加的单元格对象。
	*/
	__proto.addCell=function(cell){
		cell.on(/*laya.events.Event.CLICK*/"click",this,this.onCellMouse);
		cell.on(/*laya.events.Event.RIGHT_CLICK*/"rightclick",this,this.onCellMouse);
		cell.on(/*laya.events.Event.MOUSE_OVER*/"mouseover",this,this.onCellMouse);
		cell.on(/*laya.events.Event.MOUSE_OUT*/"mouseout",this,this.onCellMouse);
		cell.on(/*laya.events.Event.MOUSE_DOWN*/"mousedown",this,this.onCellMouse);
		cell.on(/*laya.events.Event.MOUSE_UP*/"mouseup",this,this.onCellMouse);
		this._cells.push(cell);
	}

	/**
	*初始化单元格信息。
	*/
	__proto.initItems=function(){
		if (!this._itemRender && this.getChildByName("item0")!=null){
			this.repeatX=1;
			var count=0;
			count=0;
			for (var i=0;i < 10000;i++){
				var cell=this.getChildByName("item"+i);
				if (cell){
					this.addCell(cell);
					count++;
					continue ;
				}
				break ;
			}
			this.repeatY=count;
		}
	}

	/**
	*设置可视区域大小。
	*<p>以（0，0，width参数，height参数）组成的矩形区域为可视区域。</p>
	*@param width 可视区域宽度。
	*@param height 可视区域高度。
	*/
	__proto.setContentSize=function(width,height){
		this._content.width=width;
		this._content.height=height;
		if (this._scrollBar || this._offset.x !=0 || this._offset.y !=0){
			this._content.scrollRect || (this._content.scrollRect=new Rectangle());
			this._content.scrollRect.setTo(-this._offset.x,-this._offset.y,width,height);
			this._content.scrollRect=this._content.scrollRect;
		}
		this.event(/*laya.events.Event.RESIZE*/"resize");
	}

	/**
	*@private
	*单元格的鼠标事件侦听处理函数。
	*/
	__proto.onCellMouse=function(e){
		if (e.type===/*laya.events.Event.MOUSE_DOWN*/"mousedown")this._isMoved=false;
		var cell=e.currentTarget;
		var index=this._startIndex+this._cells.indexOf(cell);
		if (index < 0)return;
		if (e.type===/*laya.events.Event.CLICK*/"click" || e.type===/*laya.events.Event.RIGHT_CLICK*/"rightclick"){
			if (this.selectEnable && !this._isMoved)this.selectedIndex=index;
			else this.changeCellState(cell,true,0);
			}else if ((e.type===/*laya.events.Event.MOUSE_OVER*/"mouseover" || e.type===/*laya.events.Event.MOUSE_OUT*/"mouseout")&& this._selectedIndex!==index){
			this.changeCellState(cell,e.type===/*laya.events.Event.MOUSE_OVER*/"mouseover",0);
		}
		this.mouseHandler && this.mouseHandler.runWith([e,index]);
	}

	/**
	*@private
	*改变单元格的可视状态。
	*@param cell 单元格对象。
	*@param visable 是否显示。
	*@param index 单元格的属性 <code>index</code> 值。
	*/
	__proto.changeCellState=function(cell,visable,index){
		var selectBox=cell.getChildByName("selectBox");
		if (selectBox){
			this.selectEnable=true;
			selectBox.visible=visable;
			selectBox.index=index;
		}
	}

	/**@inheritDoc */
	__proto.changeSize=function(){
		laya.ui.Component.prototype.changeSize.call(this);
		this.setContentSize(this.width,this.height);
		if (this._scrollBar)this.callLater(this.onScrollBarChange);
	}

	/**
	*@private
	*滚动条的 <code>Event.CHANGE</code> 事件侦听处理函数。
	*/
	__proto.onScrollBarChange=function(e){
		this.runCallLater(this.changeCells);
		var scrollValue=this._scrollBar.value;
		var lineX=(this._isVertical ? this.repeatX :this.repeatY);
		var lineY=(this._isVertical ? this.repeatY :this.repeatX);
		var scrollLine=Math.floor(scrollValue / this._cellSize);
		if (!this.cacheContent){
			var index=scrollLine *lineX;
			var num=0;
			if (index > this._startIndex){
				num=index-this._startIndex;
				var down=true;
				var toIndex=this._startIndex+lineX *(lineY+1);
				this._isMoved=true;
				}else if (index < this._startIndex){
				num=this._startIndex-index;
				down=false;
				toIndex=this._startIndex-1;
				this._isMoved=true;
			}
			for (var i=0;i < num;i++){
				if (down){
					var cell=this._cells.shift();
					this._cells[this._cells.length]=cell;
					var cellIndex=toIndex+i;
					}else {
					cell=this._cells.pop();
					this._cells.unshift(cell);
					cellIndex=toIndex-i;
				};
				var pos=Math.floor(cellIndex / lineX)*this._cellSize;
				this._isVertical ? cell.y=pos :cell.x=pos;
				this.renderItem(cell,cellIndex);
			}
			this._startIndex=index;
			this.changeSelectStatus();
			}else {
			num=(lineY+1);
			if (this._createdLine-scrollLine < num){
				this._createItems(this._createdLine,lineX,this._createdLine+num);
				this.renderItems(this._createdLine *lineX,0);
				this._createdLine+=num;
			}
		};
		var r=this._content.scrollRect;
		if (this._isVertical){
			r.y=scrollValue-this._offset.y;
			r.x=-this._offset.x;
			}else {
			r.y=-this._offset.y;
			r.x=scrollValue-this._offset.x;
		}
		this._content.scrollRect=r;
	}

	__proto.posCell=function(cell,cellIndex){
		if (!this._scrollBar)return;
		var lineX=(this._isVertical ? this.repeatX :this.repeatY);
		var lineY=(this._isVertical ? this.repeatY :this.repeatX);
		var pos=Math.floor(cellIndex / lineX)*this._cellSize;
		this._isVertical ? cell.y=pos :cell.x=pos;
	}

	/**
	*@private
	*改变单元格的选择状态。
	*/
	__proto.changeSelectStatus=function(){
		for (var i=0,n=this._cells.length;i < n;i++){
			this.changeCellState(this._cells[i],this._selectedIndex===this._startIndex+i,1);
		}
	}

	/**
	*@private
	*渲染单元格列表。
	*/
	__proto.renderItems=function(from,to){
		(from===void 0)&& (from=0);
		(to===void 0)&& (to=0);
		for (var i=from,n=to || this._cells.length;i < n;i++){
			this.renderItem(this._cells[i],this._startIndex+i);
		}
		this.changeSelectStatus();
	}

	/**
	*渲染一个单元格。
	*@param cell 需要渲染的单元格对象。
	*@param index 单元格索引。
	*/
	__proto.renderItem=function(cell,index){
		if (this._array && index >=0 && index < this._array.length){
			cell.visible=true;
			if (cell._$bindData){
				cell._dataSource=this._array[index];
				this._bindData(cell,this._array[index]);
			}else cell.dataSource=this._array[index];
			if (!this.cacheContent){
				this.posCell(cell,index);
			}
			if (this.hasListener(/*laya.events.Event.RENDER*/"render"))this.event(/*laya.events.Event.RENDER*/"render",[cell,index]);
			if (this.renderHandler)this.renderHandler.runWith([cell,index]);
			}else {
			cell.visible=false;
			cell.dataSource=null;
		}
	}

	__proto._bindData=function(cell,data){
		var arr=cell._$bindData;
		for (var i=0,n=arr.length;i < n;i++){
			var ele=arr[i++];
			var prop=arr[i++];
			var value=arr[i];
			var fun=UIUtils.getBindFun(value);
			ele[prop]=fun.call(this,data);
		}
	}

	/**
	*刷新列表数据源。
	*/
	__proto.refresh=function(){
		this.array=this._array;
	}

	/**
	*获取单元格数据源。
	*@param index 单元格索引。
	*/
	__proto.getItem=function(index){
		if (index >-1 && index < this._array.length){
			return this._array[index];
		}
		return null;
	}

	/**
	*修改单元格数据源。
	*@param index 单元格索引。
	*@param source 单元格数据源。
	*/
	__proto.changeItem=function(index,source){
		if (index >-1 && index < this._array.length){
			this._array[index]=source;
			if (index >=this._startIndex && index < this._startIndex+this._cells.length){
				this.renderItem(this.getCell(index),index);
			}
		}
	}

	/**
	*设置单元格数据源。
	*@param index 单元格索引。
	*@param source 单元格数据源。
	*/
	__proto.setItem=function(index,source){
		this.changeItem(index,source);
	}

	/**
	*添加单元格数据源。
	*@param souce 数据源。
	*/
	__proto.addItem=function(souce){
		this._array.push(souce);
		this.array=this._array;
	}

	/**
	*添加单元格数据源到对应的数据索引处。
	*@param souce 单元格数据源。
	*@param index 索引。
	*/
	__proto.addItemAt=function(souce,index){
		this._array.splice(index,0,souce);
		this.array=this._array;
	}

	/**
	*通过数据源索引删除单元格数据源。
	*@param index 需要删除的数据源索引值。
	*/
	__proto.deleteItem=function(index){
		this._array.splice(index,1);
		this.array=this._array;
	}

	/**
	*通过可视单元格索引，获取单元格。
	*@param index 可视单元格索引。
	*@return 单元格对象。
	*/
	__proto.getCell=function(index){
		this.runCallLater(this.changeCells);
		if (index >-1 && this._cells){
			return this._cells[(index-this._startIndex)% this._cells.length];
		}
		return null;
	}

	/**
	*<p>滚动列表，以设定的数据索引对应的单元格为当前可视列表的第一项。</p>
	*@param index 单元格在数据列表中的索引。
	*/
	__proto.scrollTo=function(index){
		if (this._scrollBar){
			var numX=this._isVertical ? this.repeatX :this.repeatY;
			this._scrollBar.value=Math.floor(index / numX)*this._cellSize;
			}else {
			this.startIndex=index;
		}
	}

	/**
	*<p>缓动滚动列表，以设定的数据索引对应的单元格为当前可视列表的第一项。</p>
	*@param index 单元格在数据列表中的索引。
	*@param time 缓动时间。
	*@param complete 缓动结束回掉
	*/
	__proto.tweenTo=function(index,time,complete){
		(time===void 0)&& (time=200);
		if (this._scrollBar){
			var numX=this._isVertical ? this.repeatX :this.repeatY;
			Tween.to(this._scrollBar,{value:Math.floor(index / numX)*this._cellSize},time,null,complete,0,true);
			}else {
			this.startIndex=index;
			if (complete)complete.run();
		}
	}

	/**@private */
	__proto._setCellChanged=function(){
		if (!this._cellChanged){
			this._cellChanged=true;
			this.callLater(this.changeCells);
		}
	}

	__proto.commitMeasure=function(){
		this.runCallLater(this.changeCells);
	}

	/**@inheritDoc */
	__getset(0,__proto,'cacheAs',_super.prototype._$get_cacheAs,function(value){
		Laya.superSet(Box,this,'cacheAs',value);
		if (this._scrollBar){
			this._$P.cacheAs=null;
			if (value!=="none")this._scrollBar.on(/*laya.events.Event.START*/"start",this,this.onScrollStart);
			else this._scrollBar.off(/*laya.events.Event.START*/"start",this,this.onScrollStart);
		}
	});

	/**
	*获取对 <code>List</code> 组件所包含的内容容器 <code>Box</code> 组件的引用。
	*/
	__getset(0,__proto,'content',function(){
		return this._content;
	});

	/**@inheritDoc */
	__getset(0,__proto,'height',_super.prototype._$get_height,function(value){
		if (value !=this._height){
			Laya.superSet(Box,this,'height',value);
			this._setCellChanged();
		}
	});

	/**
	*单元格渲染器。
	*<p><b>取值：</b>
	*<ol>
	*<li>单元格类对象。</li>
	*<li> UI 的 JSON 描述。</li>
	*</ol></p>
	*/
	__getset(0,__proto,'itemRender',function(){
		return this._itemRender;
		},function(value){
		if (this._itemRender !=value){
			this._itemRender=value;
			for (var i=this._cells.length-1;i >-1;i--){
				this._cells[i].destroy();
			}
			this._cells.length=0;
			this._setCellChanged();
		}
	});

	/**
	*垂直方向滚动条皮肤。
	*/
	__getset(0,__proto,'vScrollBarSkin',function(){
		return this._scrollBar ? this._scrollBar.skin :null;
		},function(value){
		this._removePreScrollBar();
		var scrollBar=new VScrollBar();
		scrollBar.name="scrollBar";
		scrollBar.right=0;
		if (value && value !=" ")
			scrollBar.skin=value;
		this.scrollBar=scrollBar;
		this.addChild(scrollBar);
		this._setCellChanged();
	});

	/**
	*列表的当前页码。
	*/
	__getset(0,__proto,'page',function(){
		return this._page;
		},function(value){
		this._page=value
		if (this._array){
			this._page=value > 0 ? value :0;
			this._page=this._page < this.totalPage ? this._page :this.totalPage-1;
			this.startIndex=this._page *this.repeatX *this.repeatY;
		}
	});

	/**
	*水平方向滚动条皮肤。
	*/
	__getset(0,__proto,'hScrollBarSkin',function(){
		return this._scrollBar ? this._scrollBar.skin :null;
		},function(value){
		this._removePreScrollBar();
		var scrollBar=new HScrollBar();
		scrollBar.name="scrollBar";
		scrollBar.bottom=0;
		if (value && value !=" ")
			scrollBar.skin=value;
		this.scrollBar=scrollBar;
		this.addChild(scrollBar);
		this._setCellChanged();
	});

	/**
	*水平方向显示的单元格数量。
	*/
	__getset(0,__proto,'repeatX',function(){
		return this._repeatX > 0 ? this._repeatX :this._repeatX2 > 0 ? this._repeatX2 :1;
		},function(value){
		this._repeatX=value;
		this._setCellChanged();
	});

	/**
	*获取对 <code>List</code> 组件所包含的滚动条 <code>ScrollBar</code> 组件的引用。
	*/
	__getset(0,__proto,'scrollBar',function(){
		return this._scrollBar;
		},function(value){
		if (this._scrollBar !=value){
			this._scrollBar=value;
			if (value){
				this._isVertical=this._scrollBar.isVertical;
				this.addChild(this._scrollBar);
				this._scrollBar.on(/*laya.events.Event.CHANGE*/"change",this,this.onScrollBarChange);
			}
		}
	});

	/**@inheritDoc */
	__getset(0,__proto,'width',_super.prototype._$get_width,function(value){
		if (value !=this._width){
			Laya.superSet(Box,this,'width',value);
			this._setCellChanged();
		}
	});

	/**
	*垂直方向显示的单元格数量。
	*/
	__getset(0,__proto,'repeatY',function(){
		return this._repeatY > 0 ? this._repeatY :this._repeatY2 > 0 ? this._repeatY2 :1;
		},function(value){
		this._repeatY=value;
		this._setCellChanged();
	});

	/**
	*水平方向显示的单元格之间的间距（以像素为单位）。
	*/
	__getset(0,__proto,'spaceX',function(){
		return this._spaceX;
		},function(value){
		this._spaceX=value;
		this._setCellChanged();
	});

	/**
	*垂直方向显示的单元格之间的间距（以像素为单位）。
	*/
	__getset(0,__proto,'spaceY',function(){
		return this._spaceY;
		},function(value){
		this._spaceY=value;
		this._setCellChanged();
	});

	/**
	*表示当前选择的项索引。selectedIndex值更改会引起list重新渲染
	*/
	__getset(0,__proto,'selectedIndex',function(){
		return this._selectedIndex;
		},function(value){
		if (this._selectedIndex !=value){
			this._selectedIndex=value;
			this.changeSelectStatus();
			this.event(/*laya.events.Event.CHANGE*/"change");
			this.selectHandler && this.selectHandler.runWith(value);
			this.startIndex=this._startIndex;
		}
	});

	/**
	*当前选中的单元格数据源。
	*/
	__getset(0,__proto,'selectedItem',function(){
		return this._selectedIndex !=-1 ? this._array[this._selectedIndex] :null;
		},function(value){
		this.selectedIndex=this._array.indexOf(value);
	});

	/**
	*列表的数据总个数。
	*/
	__getset(0,__proto,'length',function(){
		return this._array ? this._array.length :0;
	});

	/**
	*获取或设置当前选择的单元格对象。
	*/
	__getset(0,__proto,'selection',function(){
		return this.getCell(this._selectedIndex);
		},function(value){
		this.selectedIndex=this._startIndex+this._cells.indexOf(value);
	});

	/**
	*当前显示的单元格列表的开始索引。
	*/
	__getset(0,__proto,'startIndex',function(){
		return this._startIndex;
		},function(value){
		this._startIndex=value > 0 ? value :0;
		this.callLater(this.renderItems);
	});

	/**
	*列表数据源。
	*/
	__getset(0,__proto,'array',function(){
		return this._array;
		},function(value){
		this.runCallLater(this.changeCells);
		this._array=value || [];
		var length=this._array.length;
		this.totalPage=Math.ceil(length / (this.repeatX *this.repeatY));
		this._selectedIndex=this._selectedIndex < length ? this._selectedIndex :length-1;
		this.startIndex=this._startIndex;
		if (this._scrollBar){
			this._scrollBar.stopScroll();
			var numX=this._isVertical ? this.repeatX :this.repeatY;
			var numY=this._isVertical ? this.repeatY :this.repeatX;
			var lineCount=Math.ceil(length / numX);
			var total=this._cellOffset > 0 ? this.totalPage+1 :this.totalPage;
			if (total > 1){
				this._scrollBar.scrollSize=this._cellSize;
				this._scrollBar.thumbPercent=numY / lineCount;
				this._scrollBar.setScroll(0,(lineCount-numY)*this._cellSize+this._cellOffset,this._scrollBar.value);
				this._scrollBar.target=this._content;
				}else {
				this._scrollBar.setScroll(0,0,0);
				this._scrollBar.target=this._content;
			}
		}
	});

	/**@inheritDoc */
	__getset(0,__proto,'dataSource',_super.prototype._$get_dataSource,function(value){
		this._dataSource=value;
		if (((typeof value=='number')&& Math.floor(value)==value)|| (typeof value=='string'))this.selectedIndex=parseInt(value);
		else if ((value instanceof Array))this.array=value
		else Laya.superSet(Box,this,'dataSource',value);
	});

	/**
	*单元格集合。
	*/
	__getset(0,__proto,'cells',function(){
		this.runCallLater(this.changeCells);
		return this._cells;
	});

	return List;
})(Box)


/**
*使用 <code>HScrollBar</code> （水平 <code>ScrollBar</code> ）控件，可以在因数据太多而不能在显示区域完全显示时控制显示的数据部分。
*@example <caption>以下示例代码，创建了一个 <code>HScrollBar</code> 实例。</caption>
*package
*{
	*import laya.ui.HScrollBar;
	*import laya.utils.Handler;
	*public class HScrollBar_Example
	*{
		*private var hScrollBar:HScrollBar;
		*public function HScrollBar_Example()
		*{
			*Laya.init(640,800);//设置游戏画布宽高。
			*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
			*Laya.loader.load(["resource/ui/hscroll.png","resource/ui/hscroll$bar.png","resource/ui/hscroll$down.png","resource/ui/hscroll$up.png"],Handler.create(this,onLoadComplete));//加载资源。
			*}
		*private function onLoadComplete():void
		*{
			*hScrollBar=new HScrollBar();//创建一个 HScrollBar 类的实例对象 hScrollBar 。
			*hScrollBar.skin="resource/ui/hscroll.png";//设置 hScrollBar 的皮肤。
			*hScrollBar.x=100;//设置 hScrollBar 对象的属性 x 的值，用于控制 hScrollBar 对象的显示位置。
			*hScrollBar.y=100;//设置 hScrollBar 对象的属性 y 的值，用于控制 hScrollBar 对象的显示位置。
			*hScrollBar.changeHandler=new Handler(this,onChange);//设置 hScrollBar 的滚动变化处理器。
			*Laya.stage.addChild(hScrollBar);//将此 hScrollBar 对象添加到显示列表。
			*}
		*private function onChange(value:Number):void
		*{
			*trace("滚动条的位置： value="+value);
			*}
		*}
	*}
*@example
*Laya.init(640,800);//设置游戏画布宽高
*Laya.stage.bgColor="#efefef";//设置画布的背景颜色
*var hScrollBar;
*var res=["resource/ui/hscroll.png","resource/ui/hscroll$bar.png","resource/ui/hscroll$down.png","resource/ui/hscroll$up.png"];
*Laya.loader.load(res,laya.utils.Handler.create(this,onLoadComplete));//加载资源。
*function onLoadComplete(){
	*console.log("资源加载完成！");
	*hScrollBar=new laya.ui.HScrollBar();//创建一个 HScrollBar 类的实例对象 hScrollBar 。
	*hScrollBar.skin="resource/ui/hscroll.png";//设置 hScrollBar 的皮肤。
	*hScrollBar.x=100;//设置 hScrollBar 对象的属性 x 的值，用于控制 hScrollBar 对象的显示位置。
	*hScrollBar.y=100;//设置 hScrollBar 对象的属性 y 的值，用于控制 hScrollBar 对象的显示位置。
	*hScrollBar.changeHandler=new laya.utils.Handler(this,onChange);//设置 hScrollBar 的滚动变化处理器。
	*Laya.stage.addChild(hScrollBar);//将此 hScrollBar 对象添加到显示列表。
	*}
*function onChange(value)
*{
	*console.log("滚动条的位置： value="+value);
	*}
*@example
*import HScrollBar=laya.ui.HScrollBar;
*import Handler=laya.utils.Handler;
*class HScrollBar_Example {
	*private hScrollBar:HScrollBar;
	*constructor(){
		*Laya.init(640,800);//设置游戏画布宽高。
		*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
		*Laya.loader.load(["resource/ui/hscroll.png","resource/ui/hscroll$bar.png","resource/ui/hscroll$down.png","resource/ui/hscroll$up.png"],Handler.create(this,this.onLoadComplete));//加载资源。
		*}
	*private onLoadComplete():void {
		*this.hScrollBar=new HScrollBar();//创建一个 HScrollBar 类的实例对象 hScrollBar 。
		*this.hScrollBar.skin="resource/ui/hscroll.png";//设置 hScrollBar 的皮肤。
		*this.hScrollBar.x=100;//设置 hScrollBar 对象的属性 x 的值，用于控制 hScrollBar 对象的显示位置。
		*this.hScrollBar.y=100;//设置 hScrollBar 对象的属性 y 的值，用于控制 hScrollBar 对象的显示位置。
		*this.hScrollBar.changeHandler=new Handler(this,this.onChange);//设置 hScrollBar 的滚动变化处理器。
		*Laya.stage.addChild(this.hScrollBar);//将此 hScrollBar 对象添加到显示列表。
		*}
	*private onChange(value:number):void {
		*console.log("滚动条的位置： value="+value);
		*}
	*}
*/
//class laya.ui.HScrollBar extends laya.ui.ScrollBar
var HScrollBar=(function(_super){
	function HScrollBar(){
		HScrollBar.__super.call(this);;
	}

	__class(HScrollBar,'laya.ui.HScrollBar',_super);
	var __proto=HScrollBar.prototype;
	/**@inheritDoc */
	__proto.initialize=function(){
		_super.prototype.initialize.call(this);
		this.slider.isVertical=false;
	}

	return HScrollBar;
})(ScrollBar)


/**
*<code>Panel</code> 是一个面板容器类。
*/
//class laya.ui.Panel extends laya.ui.Box
var Panel=(function(_super){
	function Panel(){
		/**@private */
		this._content=null;
		/**@private */
		this._vScrollBar=null;
		/**@private */
		this._hScrollBar=null;
		/**@private */
		this._scrollChanged=false;
		Panel.__super.call(this);
		this.width=this.height=100;
	}

	__class(Panel,'laya.ui.Panel',_super);
	var __proto=Panel.prototype;
	/**@inheritDoc */
	__proto.destroy=function(destroyChild){
		(destroyChild===void 0)&& (destroyChild=true);
		laya.ui.Component.prototype.destroy.call(this,destroyChild);
		this._content && this._content.destroy(destroyChild);
		this._vScrollBar && this._vScrollBar.destroy(destroyChild);
		this._hScrollBar && this._hScrollBar.destroy(destroyChild);
		this._vScrollBar=null;
		this._hScrollBar=null;
		this._content=null;
	}

	/**@inheritDoc */
	__proto.destroyChildren=function(){
		this._content.destroyChildren();
	}

	/**@inheritDoc */
	__proto.createChildren=function(){
		laya.display.Node.prototype.addChild.call(this,this._content=new Box());
	}

	/**@inheritDoc */
	__proto.addChild=function(child){
		child.on(/*laya.events.Event.RESIZE*/"resize",this,this.onResize);
		this._setScrollChanged();
		return this._content.addChild(child);
	}

	/**
	*@private
	*子对象的 <code>Event.RESIZE</code> 事件侦听处理函数。
	*/
	__proto.onResize=function(){
		this._setScrollChanged();
	}

	/**@inheritDoc */
	__proto.addChildAt=function(child,index){
		child.on(/*laya.events.Event.RESIZE*/"resize",this,this.onResize);
		this._setScrollChanged();
		return this._content.addChildAt(child,index);
	}

	/**@inheritDoc */
	__proto.removeChild=function(child){
		child.off(/*laya.events.Event.RESIZE*/"resize",this,this.onResize);
		this._setScrollChanged();
		return this._content.removeChild(child);
	}

	/**@inheritDoc */
	__proto.removeChildAt=function(index){
		this.getChildAt(index).off(/*laya.events.Event.RESIZE*/"resize",this,this.onResize);
		this._setScrollChanged();
		return this._content.removeChildAt(index);
	}

	/**@inheritDoc */
	__proto.removeChildren=function(beginIndex,endIndex){
		(beginIndex===void 0)&& (beginIndex=0);
		(endIndex===void 0)&& (endIndex=0x7fffffff);
		for (var i=this._content.numChildren-1;i >-1;i--){
			this._content.removeChildAt(i);
		}
		this._setScrollChanged();
		return this;
	}

	/**@inheritDoc */
	__proto.getChildAt=function(index){
		return this._content.getChildAt(index);
	}

	/**@inheritDoc */
	__proto.getChildByName=function(name){
		return this._content.getChildByName(name);
	}

	/**@inheritDoc */
	__proto.getChildIndex=function(child){
		return this._content.getChildIndex(child);
	}

	/**@private */
	__proto.changeScroll=function(){
		this._scrollChanged=false;
		var contentW=this.contentWidth || 1;
		var contentH=this.contentHeight || 1;
		var vscroll=this._vScrollBar;
		var hscroll=this._hScrollBar;
		var vShow=vscroll && contentH > this._height;
		var hShow=hscroll && contentW > this._width;
		var showWidth=vShow ? this._width-vscroll.width :this._width;
		var showHeight=hShow ? this._height-hscroll.height :this._height;
		if (vscroll){
			vscroll.x=this._width-vscroll.width;
			vscroll.y=0;
			vscroll.height=this._height-(hShow ? hscroll.height :0);
			vscroll.scrollSize=Math.max(this._height *0.033,1);
			vscroll.thumbPercent=showHeight / contentH;
			vscroll.setScroll(0,contentH-showHeight,vscroll.value);
		}
		if (hscroll){
			hscroll.x=0;
			hscroll.y=this._height-hscroll.height;
			hscroll.width=this._width-(vShow ? vscroll.width :0);
			hscroll.scrollSize=Math.max(this._width *0.033,1);
			hscroll.thumbPercent=showWidth / contentW;
			hscroll.setScroll(0,contentW-showWidth,hscroll.value);
		}
	}

	/**@inheritDoc */
	__proto.changeSize=function(){
		laya.ui.Component.prototype.changeSize.call(this);
		this.setContentSize(this._width,this._height);
	}

	/**
	*@private
	*设置内容的宽度、高度（以像素为单位）。
	*@param width 宽度。
	*@param height 高度。
	*/
	__proto.setContentSize=function(width,height){
		var content=this._content;
		content.width=width;
		content.height=height;
		content.scrollRect || (content.scrollRect=new Rectangle());
		content.scrollRect.setTo(0,0,width,height);
		content.scrollRect=content.scrollRect;
	}

	/**
	*@private
	*滚动条的<code><code>Event.MOUSE_DOWN</code>事件侦听处理函数。</code>事件侦听处理函数。
	*@param scrollBar 滚动条对象。
	*@param e Event 对象。
	*/
	__proto.onScrollBarChange=function(scrollBar){
		var rect=this._content.scrollRect;
		if (rect){
			var start=Math.round(scrollBar.value);
			scrollBar.isVertical ? rect.y=start :rect.x=start;
			this._content.scrollRect=rect;
		}
	}

	/**
	*<p>滚动内容容器至设定的垂直、水平方向滚动条位置。</p>
	*@param x 水平方向滚动条属性value值。滚动条位置数字。
	*@param y 垂直方向滚动条属性value值。滚动条位置数字。
	*/
	__proto.scrollTo=function(x,y){
		(x===void 0)&& (x=0);
		(y===void 0)&& (y=0);
		if (this.vScrollBar)this.vScrollBar.value=y;
		if (this.hScrollBar)this.hScrollBar.value=x;
	}

	/**
	*刷新滚动内容。
	*/
	__proto.refresh=function(){
		this.changeScroll();
	}

	__proto.onScrollStart=function(){
		this._$P.cacheAs || (this._$P.cacheAs=Laya.superGet(Box,this,'cacheAs'));
		Laya.superSet(Box,this,'cacheAs',"none");
		this._hScrollBar && this._hScrollBar.once(/*laya.events.Event.END*/"end",this,this.onScrollEnd);
		this._vScrollBar && this._vScrollBar.once(/*laya.events.Event.END*/"end",this,this.onScrollEnd);
	}

	__proto.onScrollEnd=function(){
		Laya.superSet(Box,this,'cacheAs',this._$P.cacheAs);
	}

	/**@private */
	__proto._setScrollChanged=function(){
		if (!this._scrollChanged){
			this._scrollChanged=true;
			this.callLater(this.changeScroll);
		}
	}

	/**@inheritDoc */
	__getset(0,__proto,'numChildren',function(){
		return this._content.numChildren;
	});

	/**
	*水平方向滚动条皮肤。
	*/
	__getset(0,__proto,'hScrollBarSkin',function(){
		return this._hScrollBar ? this._hScrollBar.skin :null;
		},function(value){
		if (this._hScrollBar==null){
			laya.display.Node.prototype.addChild.call(this,this._hScrollBar=new HScrollBar());
			this._hScrollBar.on(/*laya.events.Event.CHANGE*/"change",this,this.onScrollBarChange,[this._hScrollBar]);
			this._hScrollBar.target=this._content;
			this._setScrollChanged();
		}
		this._hScrollBar.skin=value;
	});

	/**
	*@private
	*获取内容宽度（以像素为单位）。
	*/
	__getset(0,__proto,'contentWidth',function(){
		var max=0;
		for (var i=this._content.numChildren-1;i >-1;i--){
			var comp=this._content.getChildAt(i);
			max=Math.max(comp.x+comp.width *comp.scaleX,max);
		}
		return max;
	});

	/**
	*@private
	*获取内容高度（以像素为单位）。
	*/
	__getset(0,__proto,'contentHeight',function(){
		var max=0;
		for (var i=this._content.numChildren-1;i >-1;i--){
			var comp=this._content.getChildAt(i);
			max=Math.max(comp.y+comp.height *comp.scaleY,max);
		}
		return max;
	});

	/**
	*@inheritDoc
	*/
	__getset(0,__proto,'width',_super.prototype._$get_width,function(value){
		Laya.superSet(Box,this,'width',value);
		this._setScrollChanged();
	});

	/**
	*水平方向滚动条对象。
	*/
	__getset(0,__proto,'hScrollBar',function(){
		return this._hScrollBar;
	});

	/**
	*获取内容容器对象。
	*/
	__getset(0,__proto,'content',function(){
		return this._content;
	});

	/**@inheritDoc */
	__getset(0,__proto,'height',_super.prototype._$get_height,function(value){
		Laya.superSet(Box,this,'height',value);
		this._setScrollChanged();
	});

	/**
	*垂直方向滚动条皮肤。
	*/
	__getset(0,__proto,'vScrollBarSkin',function(){
		return this._vScrollBar ? this._vScrollBar.skin :null;
		},function(value){
		if (this._vScrollBar==null){
			laya.display.Node.prototype.addChild.call(this,this._vScrollBar=new VScrollBar());
			this._vScrollBar.on(/*laya.events.Event.CHANGE*/"change",this,this.onScrollBarChange,[this._vScrollBar]);
			this._vScrollBar.target=this._content;
			this._setScrollChanged();
		}
		this._vScrollBar.skin=value;
	});

	/**
	*垂直方向滚动条对象。
	*/
	__getset(0,__proto,'vScrollBar',function(){
		return this._vScrollBar;
	});

	/**@inheritDoc */
	__getset(0,__proto,'cacheAs',_super.prototype._$get_cacheAs,function(value){
		Laya.superSet(Box,this,'cacheAs',value);
		this._$P.cacheAs=null;
		if (value!=="none"){
			this._hScrollBar && this._hScrollBar.on(/*laya.events.Event.START*/"start",this,this.onScrollStart);
			this._vScrollBar && this._vScrollBar.on(/*laya.events.Event.START*/"start",this,this.onScrollStart);
			}else {
			this._hScrollBar && this._hScrollBar.off(/*laya.events.Event.START*/"start",this,this.onScrollStart);
			this._vScrollBar && this._vScrollBar.off(/*laya.events.Event.START*/"start",this,this.onScrollStart);
		}
	});

	return Panel;
})(Box)


/**
*使用 <code>HSlider</code> 控件，用户可以通过在滑块轨道的终点之间移动滑块来选择值。
*<p> <code>HSlider</code> 控件采用水平方向。滑块轨道从左向右扩展，而标签位于轨道的顶部或底部。</p>
*
*@example <caption>以下示例代码，创建了一个 <code>HSlider</code> 实例。</caption>
*package
*{
	*import laya.ui.HSlider;
	*import laya.utils.Handler;
	*public class HSlider_Example
	*{
		*private var hSlider:HSlider;
		*public function HSlider_Example()
		*{
			*Laya.init(640,800);//设置游戏画布宽高。
			*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
			*Laya.loader.load(["resource/ui/hslider.png","resource/ui/hslider$bar.png"],Handler.create(this,onLoadComplete));//加载资源。
			*}
		*private function onLoadComplete():void
		*{
			*hSlider=new HSlider();//创建一个 HSlider 类的实例对象 hSlider 。
			*hSlider.skin="resource/ui/hslider.png";//设置 hSlider 的皮肤。
			*hSlider.min=0;//设置 hSlider 最低位置值。
			*hSlider.max=10;//设置 hSlider 最高位置值。
			*hSlider.value=2;//设置 hSlider 当前位置值。
			*hSlider.tick=1;//设置 hSlider 刻度值。
			*hSlider.x=100;//设置 hSlider 对象的属性 x 的值，用于控制 hSlider 对象的显示位置。
			*hSlider.y=100;//设置 hSlider 对象的属性 y 的值，用于控制 hSlider 对象的显示位置。
			*hSlider.changeHandler=new Handler(this,onChange);//设置 hSlider 位置变化处理器。
			*Laya.stage.addChild(hSlider);//把 hSlider 添加到显示列表。
			*}
		*private function onChange(value:Number):void
		*{
			*trace("滑块的位置： value="+value);
			*}
		*}
	*}
*@example
*Laya.init(640,800,"canvas");//设置游戏画布宽高、渲染模式
*Laya.stage.bgColor="#efefef";//设置画布的背景颜色
*var hSlider;
*var res=["resource/ui/hslider.png","resource/ui/hslider$bar.png"];
*Laya.loader.load(res,laya.utils.Handler.create(this,onLoadComplete));
*function onLoadComplete(){
	*console.log("资源加载完成！");
	*hSlider=new laya.ui.HSlider();//创建一个 HSlider 类的实例对象 hSlider 。
	*hSlider.skin="resource/ui/hslider.png";//设置 hSlider 的皮肤。
	*hSlider.min=0;//设置 hSlider 最低位置值。
	*hSlider.max=10;//设置 hSlider 最高位置值。
	*hSlider.value=2;//设置 hSlider 当前位置值。
	*hSlider.tick=1;//设置 hSlider 刻度值。
	*hSlider.x=100;//设置 hSlider 对象的属性 x 的值，用于控制 hSlider 对象的显示位置。
	*hSlider.y=100;//设置 hSlider 对象的属性 y 的值，用于控制 hSlider 对象的显示位置。
	*hSlider.changeHandler=new laya.utils.Handler(this,onChange);//设置 hSlider 位置变化处理器。
	*Laya.stage.addChild(hSlider);//把 hSlider 添加到显示列表。
	*}
*function onChange(value)
*{
	*console.log("滑块的位置： value="+value);
	*}
*@example
*import Handler=laya.utils.Handler;
*import HSlider=laya.ui.HSlider;
*class HSlider_Example {
	*private hSlider:HSlider;
	*constructor(){
		*Laya.init(640,800);//设置游戏画布宽高。
		*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
		*Laya.loader.load(["resource/ui/hslider.png","resource/ui/hslider$bar.png"],Handler.create(this,this.onLoadComplete));//加载资源。
		*}
	*private onLoadComplete():void {
		*this.hSlider=new HSlider();//创建一个 HSlider 类的实例对象 hSlider 。
		*this.hSlider.skin="resource/ui/hslider.png";//设置 hSlider 的皮肤。
		*this.hSlider.min=0;//设置 hSlider 最低位置值。
		*this.hSlider.max=10;//设置 hSlider 最高位置值。
		*this.hSlider.value=2;//设置 hSlider 当前位置值。
		*this.hSlider.tick=1;//设置 hSlider 刻度值。
		*this.hSlider.x=100;//设置 hSlider 对象的属性 x 的值，用于控制 hSlider 对象的显示位置。
		*this.hSlider.y=100;//设置 hSlider 对象的属性 y 的值，用于控制 hSlider 对象的显示位置。
		*this.hSlider.changeHandler=new Handler(this,this.onChange);//设置 hSlider 位置变化处理器。
		*Laya.stage.addChild(this.hSlider);//把 hSlider 添加到显示列表。
		*}
	*private onChange(value:number):void {
		*console.log("滑块的位置： value="+value);
		*}
	*}
*
*@see laya.ui.Slider
*/
//class laya.ui.HSlider extends laya.ui.Slider
var HSlider=(function(_super){
	/**
	*创建一个 <code>HSlider</code> 类实例。
	*@param skin 皮肤。
	*/
	function HSlider(skin){
		HSlider.__super.call(this,skin);
		this.isVertical=false;
	}

	__class(HSlider,'laya.ui.HSlider',_super);
	return HSlider;
})(Slider)


/**
*<code>Group</code> 是一个可以自动布局的项集合控件。
*<p> <code>Group</code> 的默认项对象为 <code>Button</code> 类实例。
*<code>Group</code> 是 <code>Tab</code> 和 <code>RadioGroup</code> 的基类。</p>
*/
//class laya.ui.UIGroup extends laya.ui.Box
var UIGroup=(function(_super){
	function UIGroup(labels,skin){
		/**
		*改变 <code>Group</code> 的选择项时执行的处理器，(默认返回参数： 项索引（index:int）)。
		*/
		this.selectHandler=null;
		/**@private */
		this._items=null;
		/**@private */
		this._selectedIndex=-1;
		/**@private */
		this._skin=null;
		/**@private */
		this._direction="horizontal";
		/**@private */
		this._space=0;
		/**@private */
		this._labels=null;
		/**@private */
		this._labelColors=null;
		/**@private */
		this._labelFont=null;
		/**@private */
		this._labelStrokeColor=null;
		/**@private */
		this._strokeColors=null;
		/**@private */
		this._labelStroke=NaN;
		/**@private */
		this._labelSize=0;
		/**@private */
		this._labelBold=false;
		/**@private */
		this._labelPadding=null;
		/**@private */
		this._labelAlign=null;
		/**@private */
		this._stateNum=0;
		/**@private */
		this._labelChanged=false;
		UIGroup.__super.call(this);
		this.skin=skin;
		this.labels=labels;
	}

	__class(UIGroup,'laya.ui.UIGroup',_super);
	var __proto=UIGroup.prototype;
	Laya.imps(__proto,{"laya.ui.IItem":true})
	/**@inheritDoc */
	__proto.preinitialize=function(){
		this.mouseEnabled=true;
	}

	/**@inheritDoc */
	__proto.destroy=function(destroyChild){
		(destroyChild===void 0)&& (destroyChild=true);
		laya.ui.Component.prototype.destroy.call(this,destroyChild);
		this._items && (this._items.length=0);
		this._items=null;
		this.selectHandler=null;
	}

	/**
	*添加一个项对象，返回此项对象的索引id。
	*
	*@param item 需要添加的项对象。
	*@param autoLayOut 是否自动布局，如果为true，会根据 <code>direction</code> 和 <code>space</code> 属性计算item的位置。
	*@return
	*/
	__proto.addItem=function(item,autoLayOut){
		(autoLayOut===void 0)&& (autoLayOut=true);
		var display=item;
		var index=this._items.length;
		display.name="item"+index;
		this.addChild(display);
		this.initItems();
		if (autoLayOut && index > 0){
			var preItem=this._items [index-1];
			if (this._direction=="horizontal"){
				display.x=preItem.x+preItem.width+this._space;
				}else {
				display.y=preItem.y+preItem.height+this._space;
			}
			}else {
			if (autoLayOut){
				display.x=0;
				display.y=0;
			}
		}
		return index;
	}

	/**
	*删除一个项对象。
	*@param item 需要删除的项对象。
	*@param autoLayOut 是否自动布局，如果为true，会根据 <code>direction</code> 和 <code>space</code> 属性计算item的位置。
	*/
	__proto.delItem=function(item,autoLayOut){
		(autoLayOut===void 0)&& (autoLayOut=true);
		var index=this._items.indexOf(item);
		if (index !=-1){
			var display=item;
			this.removeChild(display);
			for (var i=index+1,n=this._items.length;i < n;i++){
				var child=this._items [i];
				child.name="item"+(i-1);
				if (autoLayOut){
					if (this._direction=="horizontal"){
						child.x-=display.width+this._space;
						}else {
						child.y-=display.height+this._space;
					}
				}
			}
			this.initItems();
			if (this._selectedIndex >-1){
				var newIndex=0;
				newIndex=this._selectedIndex < this._items.length ? this._selectedIndex :(this._selectedIndex-1);
				this._selectedIndex=-1;
				this.selectedIndex=newIndex;
			}
		}
	}

	/**
	*初始化项对象们。
	*/
	__proto.initItems=function(){
		this._items || (this._items=[]);
		this._items.length=0;
		for (var i=0;i < 10000;i++){
			var item=this.getChildByName("item"+i);
			if (item==null)break ;
			this._items.push(item);
			item.selected=(i===this._selectedIndex);
			item.clickHandler=Handler.create(this,this.itemClick,[i],false);
		}
	}

	/**
	*@private
	*项对象的点击事件侦听处理函数。
	*@param index 项索引。
	*/
	__proto.itemClick=function(index){
		this.selectedIndex=index;
	}

	/**
	*@private
	*通过对象的索引设置项对象的 <code>selected</code> 属性值。
	*@param index 需要设置的项对象的索引。
	*@param selected 表示项对象的选中状态。
	*/
	__proto.setSelect=function(index,selected){
		if (this._items && index >-1 && index < this._items.length)this._items[index].selected=selected;
	}

	/**
	*@private
	*创建一个项显示对象。
	*@param skin 项对象的皮肤。
	*@param label 项对象标签。
	*/
	__proto.createItem=function(skin,label){
		return null;
	}

	/**
	*@private
	*更改项对象的属性值。
	*/
	__proto.changeLabels=function(){
		this._labelChanged=false;
		if (this._items){
			var left=0
			for (var i=0,n=this._items.length;i < n;i++){
				var btn=this._items [i];
				this._skin && (btn.skin=this._skin);
				this._labelColors && (btn.labelColors=this._labelColors);
				this._labelSize && (btn.labelSize=this._labelSize);
				this._labelStroke && (btn.labelStroke=this._labelStroke);
				this._labelStrokeColor && (btn.labelStrokeColor=this._labelStrokeColor);
				this._strokeColors && (btn.strokeColors=this._strokeColors);
				this._labelBold && (btn.labelBold=this._labelBold);
				this._labelPadding && (btn.labelPadding=this._labelPadding);
				this._labelAlign && (btn.labelAlign=this._labelAlign);
				this._stateNum && (btn.stateNum=this._stateNum);
				this._labelFont && (btn.labelFont=this._labelFont);
				if (this._direction==="horizontal"){
					btn.y=0;
					btn.x=left;
					left+=btn.width+this._space;
					}else {
					btn.x=0;
					btn.y=left;
					left+=btn.height+this._space;
				}
			}
		}
		this.changeSize();
	}

	/**@inheritDoc */
	__proto.commitMeasure=function(){
		this.runCallLater(this.changeLabels);
	}

	/**@private */
	__proto._setLabelChanged=function(){
		if (!this._labelChanged){
			this._labelChanged=true;
			this.callLater(this.changeLabels);
		}
	}

	/**
	*<p>描边颜色，以字符串表示。</p>
	*默认值为 "#000000"（黑色）;
	*@see laya.display.Text.strokeColor()
	*/
	__getset(0,__proto,'labelStrokeColor',function(){
		return this._labelStrokeColor;
		},function(value){
		if (this._labelStrokeColor !=value){
			this._labelStrokeColor=value;
			this._setLabelChanged();
		}
	});

	/**
	*@copy laya.ui.Image#skin
	*/
	__getset(0,__proto,'skin',function(){
		return this._skin;
		},function(value){
		if (this._skin !=value){
			this._skin=value;
			this._setLabelChanged();
		}
	});

	/**
	*表示当前选择的项索引。默认值为-1。
	*/
	__getset(0,__proto,'selectedIndex',function(){
		return this._selectedIndex;
		},function(value){
		if (this._selectedIndex !=value){
			this.setSelect(this._selectedIndex,false);
			this._selectedIndex=value;
			this.setSelect(value,true);
			this.event(/*laya.events.Event.CHANGE*/"change");
			this.selectHandler && this.selectHandler.runWith(this._selectedIndex);
		}
	});

	/**
	*标签集合字符串。以逗号做分割，如"item0,item1,item2,item3,item4,item5"。
	*/
	__getset(0,__proto,'labels',function(){
		return this._labels;
		},function(value){
		if (this._labels !=value){
			this._labels=value;
			this.removeChildren();
			this._setLabelChanged();
			if (this._labels){
				var a=this._labels.split(",");
				for (var i=0,n=a.length;i < n;i++){
					var item=this.createItem(this._skin,a[i]);
					item.name="item"+i;
					this.addChild(item);
				}
			}
			this.initItems();
		}
	});

	/**
	*<p>表示各个状态下的描边颜色。</p>
	*@see laya.display.Text.strokeColor()
	*/
	__getset(0,__proto,'strokeColors',function(){
		return this._strokeColors;
		},function(value){
		if (this._strokeColors !=value){
			this._strokeColors=value;
			this._setLabelChanged();
		}
	});

	/**
	*@copy laya.ui.Button#labelColors()
	*/
	__getset(0,__proto,'labelColors',function(){
		return this._labelColors;
		},function(value){
		if (this._labelColors !=value){
			this._labelColors=value;
			this._setLabelChanged();
		}
	});

	/**
	*<p>描边宽度（以像素为单位）。</p>
	*默认值0，表示不描边。
	*@see laya.display.Text.stroke()
	*/
	__getset(0,__proto,'labelStroke',function(){
		return this._labelStroke;
		},function(value){
		if (this._labelStroke !=value){
			this._labelStroke=value;
			this._setLabelChanged();
		}
	});

	/**
	*表示按钮文本标签的字体大小。
	*/
	__getset(0,__proto,'labelSize',function(){
		return this._labelSize;
		},function(value){
		if (this._labelSize !=value){
			this._labelSize=value;
			this._setLabelChanged();
		}
	});

	/**
	*表示按钮的状态值，以数字表示，默认为3态。
	*@see laya.ui.Button#stateNum
	*/
	__getset(0,__proto,'stateNum',function(){
		return this._stateNum;
		},function(value){
		if (this._stateNum !=value){
			this._stateNum=value;
			this._setLabelChanged();
		}
	});

	/**
	*表示按钮文本标签是否为粗体字。
	*/
	__getset(0,__proto,'labelBold',function(){
		return this._labelBold;
		},function(value){
		if (this._labelBold !=value){
			this._labelBold=value;
			this._setLabelChanged();
		}
	});

	/**
	*表示按钮文本标签的字体名称，以字符串形式表示。
	*@see laya.display.Text.font()
	*/
	__getset(0,__proto,'labelFont',function(){
		return this._labelFont;
		},function(value){
		if (this._labelFont !=value){
			this._labelFont=value;
			this._setLabelChanged();
		}
	});

	/**
	*表示按钮文本标签的边距。
	*<p><b>格式：</b>"上边距,右边距,下边距,左边距"。</p>
	*/
	__getset(0,__proto,'labelPadding',function(){
		return this._labelPadding;
		},function(value){
		if (this._labelPadding !=value){
			this._labelPadding=value;
			this._setLabelChanged();
		}
	});

	/**
	*布局方向。
	*<p>默认值为"horizontal"。</p>
	*<p><b>取值：</b>
	*<li>"horizontal"：表示水平布局。</li>
	*<li>"vertical"：表示垂直布局。</li>
	*</p>
	*/
	__getset(0,__proto,'direction',function(){
		return this._direction;
		},function(value){
		this._direction=value;
		this._setLabelChanged();
	});

	/**
	*项对象们之间的间隔（以像素为单位）。
	*/
	__getset(0,__proto,'space',function(){
		return this._space;
		},function(value){
		this._space=value;
		this._setLabelChanged();
	});

	/**
	*项对象们的存放数组。
	*/
	__getset(0,__proto,'items',function(){
		return this._items;
	});

	/**
	*获取或设置当前选择的项对象。
	*/
	__getset(0,__proto,'selection',function(){
		return this._selectedIndex >-1 && this._selectedIndex < this._items.length ? this._items[this._selectedIndex] :null;
		},function(value){
		this.selectedIndex=this._items.indexOf(value);
	});

	/**@inheritDoc */
	__getset(0,__proto,'dataSource',_super.prototype._$get_dataSource,function(value){
		this._dataSource=value;
		if (((typeof value=='number')&& Math.floor(value)==value)|| (typeof value=='string'))this.selectedIndex=parseInt(value);
		else if ((value instanceof Array))this.labels=(value).join(",");
		else Laya.superSet(Box,this,'dataSource',value);
	});

	return UIGroup;
})(Box)


/**
*<code>Radio</code> 控件使用户可在一组互相排斥的选择中做出一种选择。
*用户一次只能选择 <code>Radio</code> 组中的一个成员。选择未选中的组成员将取消选择该组中当前所选的 <code>Radio</code> 控件。
*@see laya.ui.RadioGroup
*/
//class laya.ui.Radio extends laya.ui.Button
var Radio=(function(_super){
	function Radio(skin,label){
		/**@private */
		this._value=null;
		(label===void 0)&& (label="");
		Radio.__super.call(this,skin,label);
	}

	__class(Radio,'laya.ui.Radio',_super);
	var __proto=Radio.prototype;
	/**@inheritDoc */
	__proto.destroy=function(destroyChild){
		(destroyChild===void 0)&& (destroyChild=true);
		_super.prototype.destroy.call(this,destroyChild);
		this._value=null;
	}

	/**@inheritDoc */
	__proto.preinitialize=function(){
		laya.ui.Component.prototype.preinitialize.call(this);
		this.toggle=false;
		this._autoSize=false;
	}

	/**@inheritDoc */
	__proto.initialize=function(){
		_super.prototype.initialize.call(this);
		this.createText();
		this._text.align="left";
		this._text.valign="top";
		this._text.width=0;
		this.on(/*laya.events.Event.CLICK*/"click",this,this.onClick);
	}

	/**
	*@private
	*对象的<code>Event.CLICK</code>事件侦听处理函数。
	*/
	__proto.onClick=function(e){
		this.selected=true;
	}

	/**
	*获取或设置 <code>Radio</code> 关联的可选用户定义值。
	*/
	__getset(0,__proto,'value',function(){
		return this._value !=null ? this._value :this.label;
		},function(obj){
		this._value=obj;
	});

	return Radio;
})(Button)


/**
*<code>Tree</code> 控件使用户可以查看排列为可扩展树的层次结构数据。
*
*@example
*package
*{
	*import laya.ui.Tree;
	*import laya.utils.Browser;
	*import laya.utils.Handler;
	*public class Tree_Example
	*{
		*public function Tree_Example()
		*{
			*Laya.init(640,800);
			*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
			*Laya.loader.load(["resource/ui/vscroll.png","resource/ui/vscroll$bar.png","resource/ui/vscroll$down.png","resource/ui/vscroll$up.png","resource/ui/clip_selectBox.png","resource/ui/clip_tree_folder.png","resource/ui/clip_tree_arrow.png"],Handler.create(this,onLoadComplete));
			*}
		*private function onLoadComplete():void
		*{
			*var xmlString:String;//创建一个xml字符串，用于存储树结构数据。
			*xmlString="&lt;root&gt;&lt;item label='box1'&gt;&lt;abc label='child1'/&gt;&lt;abc label='child2'/&gt;&lt;abc label='child3'/&gt;&lt;abc label='child4'/&gt;&lt;abc label='child5'/&gt;&lt;/item&gt;&lt;item label='box2'&gt;&lt;abc label='child1'/&gt;&lt;abc label='child2'/&gt;&lt;abc label='child3'/&gt;&lt;abc label='child4'/&gt;&lt;/item&gt;&lt;/root&gt;";
			*var domParser:*=new Browser.window.DOMParser();//创建一个DOMParser实例domParser。
			*var xml:*=domParser.parseFromString(xmlString,"text/xml");//解析xml字符。
			*var tree:Tree=new Tree();//创建一个 Tree 类的实例对象 tree 。
			*tree.scrollBarSkin="resource/ui/vscroll.png";//设置 tree 的皮肤。
			*tree.itemRender=Item;//设置 tree 的项渲染器。
			*tree.xml=xml;//设置 tree 的树结构数据。
			*tree.x=100;//设置 tree 对象的属性 x 的值，用于控制 tree 对象的显示位置。
			*tree.y=100;//设置 tree 对象的属性 y 的值，用于控制 tree 对象的显示位置。
			*tree.width=200;//设置 tree 的宽度。
			*tree.height=100;//设置 tree 的高度。
			*Laya.stage.addChild(tree);//将 tree 添加到显示列表。
			*}
		*}
	*}
*import laya.ui.Box;
*import laya.ui.Clip;
*import laya.ui.Label;
*class Item extends Box
*{
	*public function Item()
	*{
		*this.name="render";
		*this.right=0;
		*this.left=0;
		*var selectBox:Clip=new Clip("resource/ui/clip_selectBox.png",1,2);
		*selectBox.name="selectBox";
		*selectBox.height=24;
		*selectBox.x=13;
		*selectBox.y=0;
		*selectBox.left=12;
		*addChild(selectBox);
		*var folder:Clip=new Clip("resource/ui/clip_tree_folder.png",1,3);
		*folder.name="folder";
		*folder.x=14;
		*folder.y=4;
		*addChild(folder);
		*var label:Label=new Label("treeItem");
		*label.name="label";
		*label.color="#ffff00";
		*label.width=150;
		*label.height=22;
		*label.x=33;
		*label.y=1;
		*label.left=33;
		*label.right=0;
		*addChild(label);
		*var arrow:Clip=new Clip("resource/ui/clip_tree_arrow.png",1,2);
		*arrow.name="arrow";
		*arrow.x=0;
		*arrow.y=5;
		*addChild(arrow);
		*}
	*}
*@example
*Laya.init(640,800);//设置游戏画布宽高、渲染模式
*Laya.stage.bgColor="#efefef";//设置画布的背景颜色
*var res=["resource/ui/vscroll.png","resource/ui/vscroll$bar.png","resource/ui/vscroll$down.png","resource/ui/vscroll$up.png","resource/ui/clip_selectBox.png","resource/ui/clip_tree_folder.png","resource/ui/clip_tree_arrow.png"];
*Laya.loader.load(res,new laya.utils.Handler(this,onLoadComplete));
*function onLoadComplete(){
	*var xmlString;//创建一个xml字符串，用于存储树结构数据。
	*xmlString="&lt;root&gt;&lt;item label='box1'&gt;&lt;abc label='child1'/&gt;&lt;abc label='child2'/&gt;&lt;abc label='child3'/&gt;&lt;abc label='child4'/&gt;&lt;abc label='child5'/&gt;&lt;/item&gt;&lt;item label='box2'&gt;&lt;abc label='child1'/&gt;&lt;abc label='child2'/&gt;&lt;abc label='child3'/&gt;&lt;abc label='child4'/&gt;&lt;/item&gt;&lt;/root&gt;";
	*var domParser=new laya.utils.Browser.window.DOMParser();//创建一个DOMParser实例domParser。
	*var xml=domParser.parseFromString(xmlString,"text/xml");//解析xml字符。
	*var tree=new laya.ui.Tree();//创建一个 Tree 类的实例对象 tree 。
	*tree.scrollBarSkin="resource/ui/vscroll.png";//设置 tree 的皮肤。
	*tree.itemRender=mypackage.treeExample.Item;//设置 tree 的项渲染器。
	*tree.xml=xml;//设置 tree 的树结构数据。
	*tree.x=100;//设置 tree 对象的属性 x 的值，用于控制 tree 对象的显示位置。
	*tree.y=100;//设置 tree 对象的属性 y 的值，用于控制 tree 对象的显示位置。
	*tree.width=200;//设置 tree 的宽度。
	*tree.height=100;//设置 tree 的高度。
	*Laya.stage.addChild(tree);//将 tree 添加到显示列表。
	*}
*(function (_super){
	*function Item(){
		*Item.__super.call(this);//初始化父类。
		*this.right=0;
		*this.left=0;
		*var selectBox=new laya.ui.Clip("resource/ui/clip_selectBox.png",1,2);
		*selectBox.name="selectBox";//设置 selectBox 的name 为“selectBox”时，将被识别为树结构的项的背景。2帧：悬停时背景、选中时背景。
		*selectBox.height=24;
		*selectBox.x=13;
		*selectBox.y=0;
		*selectBox.left=12;
		*this.addChild(selectBox);//需要使用this.访问父类的属性或方法。
		*var folder=new laya.ui.Clip("resource/ui/clip_tree_folder.png",1,3);
		*folder.name="folder";//设置 folder 的name 为“folder”时，将被识别为树结构的文件夹开启状态图表。2帧：折叠状态、打开状态。
		*folder.x=14;
		*folder.y=4;
		*this.addChild(folder);
		*var label=new laya.ui.Label("treeItem");
		*label.name="label";//设置 label 的name 为“label”时，此值将用于树结构数据赋值。
		*label.color="#ffff00";
		*label.width=150;
		*label.height=22;
		*label.x=33;
		*label.y=1;
		*label.left=33;
		*label.right=0;
		*this.addChild(label);
		*var arrow=new laya.ui.Clip("resource/ui/clip_tree_arrow.png",1,2);
		*arrow.name="arrow";//设置 arrow 的name 为“arrow”时，将被识别为树结构的文件夹开启状态图表。2帧：折叠状态、打开状态。
		*arrow.x=0;
		*arrow.y=5;
		*this.addChild(arrow);
		*};
	*Laya.class(Item,"mypackage.treeExample.Item",_super);//注册类 Item 。
	*})(laya.ui.Box);
*@example
*import Tree=laya.ui.Tree;
*import Browser=laya.utils.Browser;
*import Handler=laya.utils.Handler;
*class Tree_Example {
	*constructor(){
		*Laya.init(640,800);
		*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
		*Laya.loader.load(["resource/ui/vscroll.png","resource/ui/vscroll$bar.png","resource/ui/vscroll$down.png","resource/ui/vscroll$up.png","resource/ui/vscroll$up.png","resource/ui/clip_selectBox.png","resource/ui/clip_tree_folder * . * png","resource/ui/clip_tree_arrow.png"],Handler.create(this,this.onLoadComplete));
		*}
	*private onLoadComplete():void {
		*var xmlString:String;//创建一个xml字符串，用于存储树结构数据。
		*xmlString="&lt;root&gt;&lt;item label='box1'&gt;&lt;abc label='child1'/&gt;&lt;abc label='child2'/&gt;&lt;abc label='child3'/&gt;&lt;abc label='child4'/&gt;&lt;abc label='child5'/&gt;&lt;/item&gt;&lt;item label='box2'&gt;&lt;abc  * label='child1'/&gt;&lt;abc label='child2'/&gt;&lt;abc label='child3'/&gt;&lt;abc label='child4'/&gt;&lt;/item&gt;&lt;/root&gt;";
		*var domParser:any=new Browser.window.DOMParser();//创建一个DOMParser实例domParser。
		*var xml:any=domParser.parseFromString(xmlString,"text/xml");//解析xml字符。
		*var tree:Tree=new Tree();//创建一个 Tree 类的实例对象 tree 。
		*tree.scrollBarSkin="resource/ui/vscroll.png";//设置 tree 的皮肤。
		*tree.itemRender=Item;//设置 tree 的项渲染器。
		*tree.xml=xml;//设置 tree 的树结构数据。
		*tree.x=100;//设置 tree 对象的属性 x 的值，用于控制 tree 对象的显示位置。
		*tree.y=100;//设置 tree 对象的属性 y 的值，用于控制 tree 对象的显示位置。
		*tree.width=200;//设置 tree 的宽度。
		*tree.height=100;//设置 tree 的高度。
		*Laya.stage.addChild(tree);//将 tree 添加到显示列表。
		*}
	*}
*import Box=laya.ui.Box;
*import Clip=laya.ui.Clip;
*import Label=laya.ui.Label;
*class Item extends Box {
	*constructor(){
		*super();
		*this.name="render";
		*this.right=0;
		*this.left=0;
		*var selectBox:Clip=new Clip("resource/ui/clip_selectBox.png",1,2);
		*selectBox.name="selectBox";
		*selectBox.height=24;
		*selectBox.x=13;
		*selectBox.y=0;
		*selectBox.left=12;
		*this.addChild(selectBox);
		*var folder:Clip=new Clip("resource/ui/clip_tree_folder.png",1,3);
		*folder.name="folder";
		*folder.x=14;
		*folder.y=4;
		*this.addChild(folder);
		*var label:Label=new Label("treeItem");
		*label.name="label";
		*label.color="#ffff00";
		*label.width=150;
		*label.height=22;
		*label.x=33;
		*label.y=1;
		*label.left=33;
		*label.right=0;
		*this.addChild(label);
		*var arrow:Clip=new Clip("resource/ui/clip_tree_arrow.png",1,2);
		*arrow.name="arrow";
		*arrow.x=0;
		*arrow.y=5;
		*this.addChild(arrow);
		*}
	*}
*/
//class laya.ui.Tree extends laya.ui.Box
var Tree=(function(_super){
	function Tree(){
		/**@private */
		this._list=null;
		/**@private */
		this._source=null;
		/**@private */
		this._renderHandler=null;
		/**@private */
		this._spaceLeft=10;
		/**@private */
		this._spaceBottom=0;
		/**@private */
		this._keepStatus=true;
		Tree.__super.call(this);
		this.width=this.height=200;
	}

	__class(Tree,'laya.ui.Tree',_super);
	var __proto=Tree.prototype;
	Laya.imps(__proto,{"laya.ui.IRender":true})
	/**@inheritDoc */
	__proto.destroy=function(destroyChild){
		(destroyChild===void 0)&& (destroyChild=true);
		laya.ui.Component.prototype.destroy.call(this,destroyChild);
		this._list && this._list.destroy(destroyChild);
		this._list=null;
		this._source=null;
		this._renderHandler=null;
	}

	/**@inheritDoc */
	__proto.createChildren=function(){
		this.addChild(this._list=new List());
		this._list.renderHandler=Handler.create(this,this.renderItem,null,false);
		this._list.repeatX=1;
		this._list.on(/*laya.events.Event.CHANGE*/"change",this,this.onListChange);
	}

	/**
	*@private
	*此对象包含的<code>List</code>实例的<code>Event.CHANGE</code>事件侦听处理函数。
	*/
	__proto.onListChange=function(e){
		this.event(/*laya.events.Event.CHANGE*/"change");
	}

	/**
	*@private
	*获取数据源集合。
	*/
	__proto.getArray=function(){
		var arr=[];
		var item;
		/*for each*/for(var $each_item in this._source){
			item=this._source[$each_item];
			if (this.getParentOpenStatus(item)){
				item.x=this._spaceLeft *this.getDepth(item);
				arr.push(item);
			}
		}
		return arr;
	}

	/**
	*@private
	*获取项对象的深度。
	*/
	__proto.getDepth=function(item,num){
		(num===void 0)&& (num=0);
		if (item.nodeParent==null)return num;
		else return this.getDepth(item.nodeParent,num+1);
	}

	/**
	*@private
	*获取项对象的上一级的打开状态。
	*/
	__proto.getParentOpenStatus=function(item){
		var parent=item.nodeParent;
		if (parent==null){
			return true;
			}else {
			if (parent.isOpen){
				if (parent.nodeParent !=null)return this.getParentOpenStatus(parent);
				else return true;
				}else {
				return false;
			}
		}
	}

	/**
	*@private
	*渲染一个项对象。
	*@param cell 一个项对象。
	*@param index 项的索引。
	*/
	__proto.renderItem=function(cell,index){
		var item=cell.dataSource;
		if (item){
			cell.left=item.x;
			var arrow=cell.getChildByName("arrow");
			if (arrow){
				if (item.hasChild){
					arrow.visible=true;
					arrow.index=item.isOpen ? 1 :0;
					arrow.tag=index;
					arrow.off(/*laya.events.Event.CLICK*/"click",this,this.onArrowClick);
					arrow.on(/*laya.events.Event.CLICK*/"click",this,this.onArrowClick);
					}else {
					arrow.visible=false;
				}
			};
			var folder=cell.getChildByName("folder");
			if (folder){
				if (folder.clipY==2){
					folder.index=item.isDirectory ? 0 :1;
					}else {
					folder.index=item.isDirectory ? item.isOpen ? 1 :0 :2;
				}
			}
			this._renderHandler && this._renderHandler.runWith([cell,index]);
		}
	}

	/**
	*@private
	*/
	__proto.onArrowClick=function(e){
		var arrow=e.currentTarget;
		var index=arrow.tag;
		this._list.array[index].isOpen=!this._list.array[index].isOpen;
		this.event(/*laya.events.Event.OPEN*/"open");
		this._list.array=this.getArray();
	}

	/**
	*设置指定项索引的项对象的打开状态。
	*@param index 项索引。
	*@param isOpen 是否处于打开状态。
	*/
	__proto.setItemState=function(index,isOpen){
		if (!this._list.array[index])return;
		this._list.array[index].isOpen=isOpen;
		this._list.array=this.getArray();
	}

	/**
	*刷新项列表。
	*/
	__proto.fresh=function(){
		this._list.array=this.getArray();
		this.repaint();
	}

	/**
	*@private
	*解析并处理XML类型的数据源。
	*/
	__proto.parseXml=function(xml,source,nodeParent,isRoot){
		var obj;
		var list=xml.childNodes;
		var childCount=list.length;
		if (!isRoot){
			obj={};
			var list2=xml.attributes;
			var attrs;
			/*for each*/for(var $each_attrs in list2){
				attrs=list2[$each_attrs];
				var prop=attrs.nodeName;
				var value=attrs.nodeValue;
				obj[prop]=value=="true" ? true :value=="false" ? false :value;
			}
			obj.nodeParent=nodeParent;
			if (childCount > 0)obj.isDirectory=true;
			obj.hasChild=childCount > 0;
			source.push(obj);
		}
		for (var i=0;i < childCount;i++){
			var node=list[i];
			this.parseXml(node,source,obj,false);
		}
	}

	/**
	*@private
	*处理数据项的打开状态。
	*/
	__proto.parseOpenStatus=function(oldSource,newSource){
		for (var i=0,n=newSource.length;i < n;i++){
			var newItem=newSource[i];
			if (newItem.isDirectory){
				for (var j=0,m=oldSource.length;j < m;j++){
					var oldItem=oldSource[j];
					if (oldItem.isDirectory && this.isSameParent(oldItem,newItem)&& newItem.label==oldItem.label){
						newItem.isOpen=oldItem.isOpen;
						break ;
					}
				}
			}
		}
	}

	/**
	*@private
	*判断两个项对象在树结构中的父节点是否相同。
	*@param item1 项对象。
	*@param item2 项对象。
	*@return 如果父节点相同值为true，否则值为false。
	*/
	__proto.isSameParent=function(item1,item2){
		if (item1.nodeParent==null && item2.nodeParent==null)return true;
		else if (item1.nodeParent==null || item2.nodeParent==null)return false
		else {
			if (item1.nodeParent.label==item2.nodeParent.label)return this.isSameParent(item1.nodeParent,item2.nodeParent);
			else return false;
		}
	}

	/**
	*更新项列表，显示指定键名的数据项。
	*@param key 键名。
	*/
	__proto.filter=function(key){
		if (Boolean(key)){
			var result=[];
			this.getFilterSource(this._source,result,key);
			this._list.array=result;
			}else {
			this._list.array=this.getArray();
		}
	}

	/**
	*@private
	*获取数据源中指定键名的值。
	*/
	__proto.getFilterSource=function(array,result,key){
		key=key.toLocaleLowerCase();
		var item;
		/*for each*/for(var $each_item in array){
			item=array[$each_item];
			if (!item.isDirectory && String(item.label).toLowerCase().indexOf(key)>-1){
				item.x=0;
				result.push(item);
			}
			if (item.child && item.child.length > 0){
				this.getFilterSource(item.child,result,key);
			}
		}
	}

	/**
	*每一项之间的间隔距离（以像素为单位）。
	*/
	__getset(0,__proto,'spaceBottom',function(){
		return this._list.spaceY;
		},function(value){
		this._list.spaceY=value;
	});

	/**
	*数据源发生变化后，是否保持之前打开状态，默认为true。
	*<p><b>取值：</b>
	*<li>true：保持之前打开状态。</li>
	*<li>false：不保持之前打开状态。</li>
	*</p>
	*/
	__getset(0,__proto,'keepStatus',function(){
		return this._keepStatus;
		},function(value){
		this._keepStatus=value;
	});

	/**
	*此对象包含的<code>List</code>实例的单元格渲染器。
	*<p><b>取值：</b>
	*<ol>
	*<li>单元格类对象。</li>
	*<li> UI 的 JSON 描述。</li>
	*</ol></p>
	*/
	__getset(0,__proto,'itemRender',function(){
		return this._list.itemRender;
		},function(value){
		this._list.itemRender=value;
	});

	/**
	*列表数据源，只包含当前可视节点数据。
	*/
	__getset(0,__proto,'array',function(){
		return this._list.array;
		},function(value){
		if (this._keepStatus && this._list.array && value){
			this.parseOpenStatus(this._list.array,value);
		}
		this._source=value;
		this._list.array=this.getArray();
	});

	/**
	*单元格鼠标事件处理器。
	*<p>默认返回参数（e:Event,index:int）。</p>
	*/
	__getset(0,__proto,'mouseHandler',function(){
		return this._list.mouseHandler;
		},function(value){
		this._list.mouseHandler=value;
	});

	/**@inheritDoc */
	__getset(0,__proto,'dataSource',_super.prototype._$get_dataSource,function(value){
		this._dataSource=value;
		Laya.superSet(Box,this,'dataSource',value);
	});

	/**
	*数据源，全部节点数据。
	*/
	__getset(0,__proto,'source',function(){
		return this._source;
	});

	/**滚动条*/
	__getset(0,__proto,'scrollBar',function(){
		return this._list.scrollBar;
	});

	/**
	*此对象包含的<code>List</code>实例对象。
	*/
	__getset(0,__proto,'list',function(){
		return this._list;
	});

	/**
	*滚动条皮肤。
	*/
	__getset(0,__proto,'scrollBarSkin',function(){
		return this._list.vScrollBarSkin;
		},function(value){
		this._list.vScrollBarSkin=value;
	});

	/**
	*<code>Tree</code> 实例的渲染处理器。
	*/
	__getset(0,__proto,'renderHandler',function(){
		return this._renderHandler;
		},function(value){
		this._renderHandler=value;
	});

	/**
	*表示当前选择的项索引。
	*/
	__getset(0,__proto,'selectedIndex',function(){
		return this._list.selectedIndex;
		},function(value){
		this._list.selectedIndex=value;
	});

	/**
	*左侧缩进距离（以像素为单位）。
	*/
	__getset(0,__proto,'spaceLeft',function(){
		return this._spaceLeft;
		},function(value){
		this._spaceLeft=value;
	});

	/**
	*当前选中的项对象的数据源。
	*/
	__getset(0,__proto,'selectedItem',function(){
		return this._list.selectedItem;
		},function(value){
		this._list.selectedItem=value;
	});

	/**
	*@inheritDoc
	*/
	__getset(0,__proto,'width',_super.prototype._$get_width,function(value){
		Laya.superSet(Box,this,'width',value);
		this._list.width=value;
	});

	/**@inheritDoc */
	__getset(0,__proto,'height',_super.prototype._$get_height,function(value){
		Laya.superSet(Box,this,'height',value);
		this._list.height=value;
	});

	/**
	*xml结构的数据源。
	*/
	__getset(0,__proto,'xml',null,function(value){
		var arr=[];
		this.parseXml(value.childNodes[0],arr,null,true);
		this.array=arr;
	});

	/**
	*表示选择的树节点项的<code>path</code>属性值。
	*/
	__getset(0,__proto,'selectedPath',function(){
		if (this._list.selectedItem){
			return this._list.selectedItem.path;
		}
		return null;
	});

	return Tree;
})(Box)


/**
*<code>ViewStack</code> 类用于视图堆栈类，用于视图的显示等设置处理。
*/
//class laya.ui.ViewStack extends laya.ui.Box
var ViewStack=(function(_super){
	function ViewStack(){
		/**@private */
		this._items=null;
		/**@private */
		this._selectedIndex=0;
		ViewStack.__super.call(this);
		this._setIndexHandler=Handler.create(this,this.setIndex,null,false);
	}

	__class(ViewStack,'laya.ui.ViewStack',_super);
	var __proto=ViewStack.prototype;
	Laya.imps(__proto,{"laya.ui.IItem":true})
	/**
	*批量设置视图对象。
	*@param views 视图对象数组。
	*/
	__proto.setItems=function(views){
		this.removeChildren();
		var index=0;
		for (var i=0,n=views.length;i < n;i++){
			var item=views[i];
			if (item){
				item.name="item"+index;
				this.addChild(item);
				index++;
			}
		}
		this.initItems();
	}

	/**
	*添加视图。
	*@internal 添加视图对象，并设置此视图对象的<code>name</code> 属性。
	*@param view 需要添加的视图对象。
	*/
	__proto.addItem=function(view){
		view.name="item"+this._items.length;
		this.addChild(view);
		this.initItems();
	}

	/**
	*初始化视图对象集合。
	*/
	__proto.initItems=function(){
		this._items=[];
		for (var i=0;i < 10000;i++){
			var item=this.getChildByName("item"+i);
			if (item==null){
				break ;
			}
			this._items.push(item);
			item.visible=(i==this._selectedIndex);
		}
	}

	/**
	*@private
	*通过对象的索引设置项对象的 <code>selected</code> 属性值。
	*@param index 需要设置的对象的索引。
	*@param selected 表示对象的选中状态。
	*/
	__proto.setSelect=function(index,selected){
		if (this._items && index >-1 && index < this._items.length){
			this._items[index].visible=selected;
		}
	}

	/**
	*@private
	*设置属性<code>selectedIndex</code>的值。
	*@param index 选中项索引值。
	*/
	__proto.setIndex=function(index){
		this.selectedIndex=index;
	}

	/**@inheritDoc */
	__getset(0,__proto,'dataSource',_super.prototype._$get_dataSource,function(value){
		this._dataSource=value;
		if (((typeof value=='number')&& Math.floor(value)==value)|| (typeof value=='string')){
			this.selectedIndex=parseInt(value);
			}else {
			for (var prop in this._dataSource){
				if (this.hasOwnProperty(prop)){
					this[prop]=this._dataSource[prop];
				}
			}
		}
	});

	/**
	*表示当前视图索引。
	*/
	__getset(0,__proto,'selectedIndex',function(){
		return this._selectedIndex;
		},function(value){
		if (this._selectedIndex !=value){
			this.setSelect(this._selectedIndex,false);
			this._selectedIndex=value;
			this.setSelect(this._selectedIndex,true);
		}
	});

	/**
	*获取或设置当前选择的项对象。
	*/
	__getset(0,__proto,'selection',function(){
		return this._selectedIndex >-1 && this._selectedIndex < this._items.length ? this._items[this._selectedIndex] :null;
		},function(value){
		this.selectedIndex=this._items.indexOf(value);
	});

	/**
	*视图集合数组。
	*/
	__getset(0,__proto,'items',function(){
		return this._items;
	});

	/**
	*索引设置处理器。
	*<p>默认回调参数：index:int</p>
	*/
	__getset(0,__proto,'setIndexHandler',function(){
		return this._setIndexHandler;
		},function(value){
		this._setIndexHandler=value;
	});

	return ViewStack;
})(Box)


/**
*
*使用 <code>VScrollBar</code> （垂直 <code>ScrollBar</code> ）控件，可以在因数据太多而不能在显示区域完全显示时控制显示的数据部分。
*
*@example <caption>以下示例代码，创建了一个 <code>VScrollBar</code> 实例。</caption>
*package
*{
	*import laya.ui.vScrollBar;
	*import laya.ui.VScrollBar;
	*import laya.utils.Handler;
	*public class VScrollBar_Example
	*{
		*private var vScrollBar:VScrollBar;
		*public function VScrollBar_Example()
		*{
			*Laya.init(640,800);//设置游戏画布宽高、渲染模式。
			*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
			*Laya.loader.load(["resource/ui/vscroll.png","resource/ui/vscroll$bar.png","resource/ui/vscroll$down.png","resource/ui/vscroll$up.png"],Handler.create(this,onLoadComplete));
			*}
		*private function onLoadComplete():void
		*{
			*vScrollBar=new VScrollBar();//创建一个 vScrollBar 类的实例对象 hScrollBar 。
			*vScrollBar.skin="resource/ui/vscroll.png";//设置 vScrollBar 的皮肤。
			*vScrollBar.x=100;//设置 vScrollBar 对象的属性 x 的值，用于控制 vScrollBar 对象的显示位置。
			*vScrollBar.y=100;//设置 vScrollBar 对象的属性 y 的值，用于控制 vScrollBar 对象的显示位置。
			*vScrollBar.changeHandler=new Handler(this,onChange);//设置 vScrollBar 的滚动变化处理器。
			*Laya.stage.addChild(vScrollBar);//将此 vScrollBar 对象添加到显示列表。
			*}
		*private function onChange(value:Number):void
		*{
			*trace("滚动条的位置： value="+value);
			*}
		*}
	*}
*@example
*Laya.init(640,800);//设置游戏画布宽高
*Laya.stage.bgColor="#efefef";//设置画布的背景颜色
*var vScrollBar;
*var res=["resource/ui/vscroll.png","resource/ui/vscroll$bar.png","resource/ui/vscroll$down.png","resource/ui/vscroll$up.png"];
*Laya.loader.load(res,laya.utils.Handler.create(this,onLoadComplete));//加载资源。
*function onLoadComplete(){
	*vScrollBar=new laya.ui.VScrollBar();//创建一个 vScrollBar 类的实例对象 hScrollBar 。
	*vScrollBar.skin="resource/ui/vscroll.png";//设置 vScrollBar 的皮肤。
	*vScrollBar.x=100;//设置 vScrollBar 对象的属性 x 的值，用于控制 vScrollBar 对象的显示位置。
	*vScrollBar.y=100;//设置 vScrollBar 对象的属性 y 的值，用于控制 vScrollBar 对象的显示位置。
	*vScrollBar.changeHandler=new laya.utils.Handler(this,onChange);//设置 vScrollBar 的滚动变化处理器。
	*Laya.stage.addChild(vScrollBar);//将此 vScrollBar 对象添加到显示列表。
	*}
*function onChange(value){
	*console.log("滚动条的位置： value="+value);
	*}
*@example
*import VScrollBar=laya.ui.VScrollBar;
*import Handler=laya.utils.Handler;
*class VScrollBar_Example {
	*private vScrollBar:VScrollBar;
	*constructor(){
		*Laya.init(640,800);//设置游戏画布宽高、渲染模式。
		*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
		*Laya.loader.load(["resource/ui/vscroll.png","resource/ui/vscroll$bar.png","resource/ui/vscroll$down.png","resource/ui/vscroll$up.png"],Handler.create(this,this.onLoadComplete));
		*}
	*private onLoadComplete():void {
		*this.vScrollBar=new VScrollBar();//创建一个 vScrollBar 类的实例对象 hScrollBar 。
		*this.vScrollBar.skin="resource/ui/vscroll.png";//设置 vScrollBar 的皮肤。
		*this.vScrollBar.x=100;//设置 vScrollBar 对象的属性 x 的值，用于控制 vScrollBar 对象的显示位置。
		*this.vScrollBar.y=100;//设置 vScrollBar 对象的属性 y 的值，用于控制 vScrollBar 对象的显示位置。
		*this.vScrollBar.changeHandler=new Handler(this,this.onChange);//设置 vScrollBar 的滚动变化处理器。
		*Laya.stage.addChild(this.vScrollBar);//将此 vScrollBar 对象添加到显示列表。
		*}
	*private onChange(value:number):void {
		*console.log("滚动条的位置： value="+value);
		*}
	*}
*/
//class laya.ui.VScrollBar extends laya.ui.ScrollBar
var VScrollBar=(function(_super){
	function VScrollBar(){
		VScrollBar.__super.call(this);;
	}

	__class(VScrollBar,'laya.ui.VScrollBar',_super);
	return VScrollBar;
})(ScrollBar)


/**
*<code>TextInput</code> 类用于创建显示对象以显示和输入文本。
*
*@example <caption>以下示例代码，创建了一个 <code>TextInput</code> 实例。</caption>
*package
*{
	*import laya.display.Stage;
	*import laya.ui.TextInput;
	*import laya.utils.Handler;
	*public class TextInput_Example
	*{
		*public function TextInput_Example()
		*{
			*Laya.init(640,800);//设置游戏画布宽高、渲染模式。
			*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
			*Laya.loader.load(["resource/ui/input.png"],Handler.create(this,onLoadComplete));//加载资源。
			*}
		*private function onLoadComplete():void
		*{
			*var textInput:TextInput=new TextInput("这是一个TextInput实例。");//创建一个 TextInput 类的实例对象 textInput 。
			*textInput.skin="resource/ui/input.png";//设置 textInput 的皮肤。
			*textInput.sizeGrid="4,4,4,4";//设置 textInput 的网格信息。
			*textInput.color="#008fff";//设置 textInput 的文本颜色。
			*textInput.font="Arial";//设置 textInput 的文本字体。
			*textInput.bold=true;//设置 textInput 的文本显示为粗体。
			*textInput.fontSize=30;//设置 textInput 的字体大小。
			*textInput.wordWrap=true;//设置 textInput 的文本自动换行。
			*textInput.x=100;//设置 textInput 对象的属性 x 的值，用于控制 textInput 对象的显示位置。
			*textInput.y=100;//设置 textInput 对象的属性 y 的值，用于控制 textInput 对象的显示位置。
			*textInput.width=300;//设置 textInput 的宽度。
			*textInput.height=200;//设置 textInput 的高度。
			*Laya.stage.addChild(textInput);//将 textInput 添加到显示列表。
			*}
		*}
	*}
*@example
*Laya.init(640,800);//设置游戏画布宽高
*Laya.stage.bgColor="#efefef";//设置画布的背景颜色
*Laya.loader.load(["resource/ui/input.png"],laya.utils.Handler.create(this,onLoadComplete));//加载资源。
*function onLoadComplete(){
	*var textInput=new laya.ui.TextInput("这是一个TextInput实例。");//创建一个 TextInput 类的实例对象 textInput 。
	*textInput.skin="resource/ui/input.png";//设置 textInput 的皮肤。
	*textInput.sizeGrid="4,4,4,4";//设置 textInput 的网格信息。
	*textInput.color="#008fff";//设置 textInput 的文本颜色。
	*textInput.font="Arial";//设置 textInput 的文本字体。
	*textInput.bold=true;//设置 textInput 的文本显示为粗体。
	*textInput.fontSize=30;//设置 textInput 的字体大小。
	*textInput.wordWrap=true;//设置 textInput 的文本自动换行。
	*textInput.x=100;//设置 textInput 对象的属性 x 的值，用于控制 textInput 对象的显示位置。
	*textInput.y=100;//设置 textInput 对象的属性 y 的值，用于控制 textInput 对象的显示位置。
	*textInput.width=300;//设置 textInput 的宽度。
	*textInput.height=200;//设置 textInput 的高度。
	*Laya.stage.addChild(textInput);//将 textInput 添加到显示列表。
	*}
*@example
*import Stage=laya.display.Stage;
*import TextInput=laya.ui.TextInput;
*import Handler=laya.utils.Handler;
*class TextInput_Example {
	*constructor(){
		*Laya.init(640,800);//设置游戏画布宽高、渲染模式。
		*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
		*Laya.loader.load(["resource/ui/input.png"],Handler.create(this,this.onLoadComplete));//加载资源。
		*}
	*private onLoadComplete():void {
		*var textInput:TextInput=new TextInput("这是一个TextInput实例。");//创建一个 TextInput 类的实例对象 textInput 。
		*textInput.skin="resource/ui/input.png";//设置 textInput 的皮肤。
		*textInput.sizeGrid="4,4,4,4";//设置 textInput 的网格信息。
		*textInput.color="#008fff";//设置 textInput 的文本颜色。
		*textInput.font="Arial";//设置 textInput 的文本字体。
		*textInput.bold=true;//设置 textInput 的文本显示为粗体。
		*textInput.fontSize=30;//设置 textInput 的字体大小。
		*textInput.wordWrap=true;//设置 textInput 的文本自动换行。
		*textInput.x=100;//设置 textInput 对象的属性 x 的值，用于控制 textInput 对象的显示位置。
		*textInput.y=100;//设置 textInput 对象的属性 y 的值，用于控制 textInput 对象的显示位置。
		*textInput.width=300;//设置 textInput 的宽度。
		*textInput.height=200;//设置 textInput 的高度。
		*Laya.stage.addChild(textInput);//将 textInput 添加到显示列表。
		*}
	*}
*/
//class laya.ui.TextInput extends laya.ui.Label
var TextInput=(function(_super){
	function TextInput(text){
		/**@private */
		this._bg=null;
		/**@private */
		this._skin=null;
		TextInput.__super.call(this);
		(text===void 0)&& (text="");
		this.text=text;
		this.skin=this.skin;
	}

	__class(TextInput,'laya.ui.TextInput',_super);
	var __proto=TextInput.prototype;
	/**@inheritDoc */
	__proto.preinitialize=function(){
		this.mouseEnabled=true;
	}

	/**@inheritDoc */
	__proto.destroy=function(destroyChild){
		(destroyChild===void 0)&& (destroyChild=true);
		_super.prototype.destroy.call(this,destroyChild);
		this._bg && this._bg.destroy();
		this._bg=null;
	}

	/**@inheritDoc */
	__proto.createChildren=function(){
		this.addChild(this._tf=new Input());
		this._tf.padding=Styles.inputLabelPadding;
		this._tf.on(/*laya.events.Event.INPUT*/"input",this,this._onInput);
		this._tf.on(/*laya.events.Event.ENTER*/"enter",this,this._onEnter);
		this._tf.on(/*laya.events.Event.BLUR*/"blur",this,this._onBlur);
		this._tf.on(/*laya.events.Event.FOCUS*/"focus",this,this._onFocus);
	}

	/**
	*@private
	*/
	__proto._onFocus=function(){
		this.event(/*laya.events.Event.FOCUS*/"focus",this);
	}

	/**
	*@private
	*/
	__proto._onBlur=function(){
		this.event(/*laya.events.Event.BLUR*/"blur",this);
	}

	/**
	*@private
	*/
	__proto._onInput=function(){
		this.event(/*laya.events.Event.INPUT*/"input",this);
	}

	/**
	*@private
	*/
	__proto._onEnter=function(){
		this.event(/*laya.events.Event.ENTER*/"enter",this);
	}

	/**@inheritDoc */
	__proto.initialize=function(){
		this.width=128;
		this.height=22;
	}

	/**选中输入框内的文本。*/
	__proto.select=function(){
		(this._tf).select();
	}

	__proto.setSelection=function(startIndex,endIndex){
		(this._tf).setSelection(startIndex,endIndex);
	}

	/**
	*当前文本内容字符串。
	*@see laya.display.Text.text
	*/
	__getset(0,__proto,'text',_super.prototype._$get_text,function(value){
		if (this._tf.text !=value){
			value=value+"";
			this._tf.text=value;
			this.event(/*laya.events.Event.CHANGE*/"change");
		}
	});

	/**
	*表示此对象包含的文本背景 <code>AutoBitmap</code> 组件实例。
	*/
	__getset(0,__proto,'bg',function(){
		return this._bg;
		},function(value){
		this.graphics=this._bg=value;
	});

	/**
	*设置原生input输入框的y坐标偏移。
	*/
	__getset(0,__proto,'inputElementYAdjuster',function(){
		return (this._tf).inputElementYAdjuster;
		},function(value){
		(this._tf).inputElementYAdjuster=value;
	});

	/**
	*<p>指示当前是否是文本域。</p>
	*值为true表示当前是文本域，否则不是文本域。
	*/
	__getset(0,__proto,'multiline',function(){
		return (this._tf).multiline;
		},function(value){
		(this._tf).multiline=value;
	});

	/**
	*@copy laya.ui.Image#skin
	*/
	__getset(0,__proto,'skin',function(){
		return this._skin;
		},function(value){
		if (this._skin !=value){
			this._skin=value;
			this._bg || (this.graphics=this._bg=new AutoBitmap());
			this._bg.source=Loader.getRes(this._skin);
			this._width && (this._bg.width=this._width);
			this._height && (this._bg.height=this._height);
		}
	});

	/**
	*<p>当前实例的背景图（ <code>AutoBitmap</code> ）实例的有效缩放网格数据。</p>
	*<p>数据格式："上边距,右边距,下边距,左边距,是否重复填充(值为0：不重复填充，1：重复填充)"，以逗号分隔。
	*<ul><li>例如："4,4,4,4,1"</li></ul></p>
	*@see laya.ui.AutoBitmap.sizeGrid
	*/
	__getset(0,__proto,'sizeGrid',function(){
		return this._bg && this._bg.sizeGrid ? this._bg.sizeGrid.join(","):null;
		},function(value){
		this._bg || (this.graphics=this._bg=new AutoBitmap());
		this._bg.sizeGrid=UIUtils.fillArray(Styles.defaultSizeGrid,value,Number);
	});

	/**
	*设置原生input输入框的x坐标偏移。
	*/
	__getset(0,__proto,'inputElementXAdjuster',function(){
		return (this._tf).inputElementXAdjuster;
		},function(value){
		(this._tf).inputElementXAdjuster=value;
	});

	/**@inheritDoc */
	__getset(0,__proto,'width',_super.prototype._$get_width,function(value){
		Laya.superSet(Label,this,'width',value);
		this._bg && (this._bg.width=value);
	});

	/**@inheritDoc */
	__getset(0,__proto,'height',_super.prototype._$get_height,function(value){
		Laya.superSet(Label,this,'height',value);
		this._bg && (this._bg.height=value);
	});

	/**
	*设置可编辑状态。
	*/
	__getset(0,__proto,'editable',function(){
		return (this._tf).editable;
		},function(value){
		(this._tf).editable=value;
	});

	/**限制输入的字符。*/
	__getset(0,__proto,'restrict',function(){
		return (this._tf).restrict;
		},function(pattern){
		(this._tf).restrict=pattern;
	});

	/**
	*@copy laya.display.Input#prompt
	*/
	__getset(0,__proto,'prompt',function(){
		return (this._tf).prompt;
		},function(value){
		(this._tf).prompt=value;
	});

	/**
	*@copy laya.display.Input#promptColor
	*/
	__getset(0,__proto,'promptColor',function(){
		return (this._tf).promptColor;
		},function(value){
		(this._tf).promptColor=value;
	});

	/**
	*@copy laya.display.Input#maxChars
	*/
	__getset(0,__proto,'maxChars',function(){
		return (this._tf).maxChars;
		},function(value){
		(this._tf).maxChars=value;
	});

	/**
	*@copy laya.display.Input#focus
	*/
	__getset(0,__proto,'focus',function(){
		return (this._tf).focus;
		},function(value){
		(this._tf).focus=value;
	});

	/**
	*@copy laya.display.Input#type
	*/
	__getset(0,__proto,'type',function(){
		return (this._tf).type;
		},function(value){
		(this._tf).type=value;
	});

	/**
	*@copy laya.display.Input#asPassword
	*/
	__getset(0,__proto,'asPassword',function(){
		return (this._tf).asPassword;
		},function(value){
		(this._tf).asPassword=value;
	});

	return TextInput;
})(Label)


/**
*使用 <code>VSlider</code> 控件，用户可以通过在滑块轨道的终点之间移动滑块来选择值。
*<p> <code>VSlider</code> 控件采用垂直方向。滑块轨道从下往上扩展，而标签位于轨道的左右两侧。</p>
*
*@example <caption>以下示例代码，创建了一个 <code>VSlider</code> 实例。</caption>
*package
*{
	*import laya.ui.HSlider;
	*import laya.ui.VSlider;
	*import laya.utils.Handler;
	*public class VSlider_Example
	*{
		*private var vSlider:VSlider;
		*public function VSlider_Example()
		*{
			*Laya.init(640,800);//设置游戏画布宽高。
			*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
			*Laya.loader.load(["resource/ui/vslider.png","resource/ui/vslider$bar.png"],Handler.create(this,onLoadComplete));//加载资源。
			*}
		*private function onLoadComplete():void
		*{
			*vSlider=new VSlider();//创建一个 VSlider 类的实例对象 vSlider 。
			*vSlider.skin="resource/ui/vslider.png";//设置 vSlider 的皮肤。
			*vSlider.min=0;//设置 vSlider 最低位置值。
			*vSlider.max=10;//设置 vSlider 最高位置值。
			*vSlider.value=2;//设置 vSlider 当前位置值。
			*vSlider.tick=1;//设置 vSlider 刻度值。
			*vSlider.x=100;//设置 vSlider 对象的属性 x 的值，用于控制 vSlider 对象的显示位置。
			*vSlider.y=100;//设置 vSlider 对象的属性 y 的值，用于控制 vSlider 对象的显示位置。
			*vSlider.changeHandler=new Handler(this,onChange);//设置 vSlider 位置变化处理器。
			*Laya.stage.addChild(vSlider);//把 vSlider 添加到显示列表。
			*}
		*private function onChange(value:Number):void
		*{
			*trace("滑块的位置： value="+value);
			*}
		*}
	*}
*@example
*Laya.init(640,800);//设置游戏画布宽高
*Laya.stage.bgColor="#efefef";//设置画布的背景颜色
*var vSlider;
*Laya.loader.load(["resource/ui/vslider.png","resource/ui/vslider$bar.png"],laya.utils.Handler.create(this,onLoadComplete));//加载资源。
*function onLoadComplete(){
	*vSlider=new laya.ui.VSlider();//创建一个 VSlider 类的实例对象 vSlider 。
	*vSlider.skin="resource/ui/vslider.png";//设置 vSlider 的皮肤。
	*vSlider.min=0;//设置 vSlider 最低位置值。
	*vSlider.max=10;//设置 vSlider 最高位置值。
	*vSlider.value=2;//设置 vSlider 当前位置值。
	*vSlider.tick=1;//设置 vSlider 刻度值。
	*vSlider.x=100;//设置 vSlider 对象的属性 x 的值，用于控制 vSlider 对象的显示位置。
	*vSlider.y=100;//设置 vSlider 对象的属性 y 的值，用于控制 vSlider 对象的显示位置。
	*vSlider.changeHandler=new laya.utils.Handler(this,onChange);//设置 vSlider 位置变化处理器。
	*Laya.stage.addChild(vSlider);//把 vSlider 添加到显示列表。
	*}
*function onChange(value){
	*console.log("滑块的位置： value="+value);
	*}
*@example
*import HSlider=laya.ui.HSlider;
*import VSlider=laya.ui.VSlider;
*import Handler=laya.utils.Handler;
*class VSlider_Example {
	*private vSlider:VSlider;
	*constructor(){
		*Laya.init(640,800);//设置游戏画布宽高。
		*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
		*Laya.loader.load(["resource/ui/vslider.png","resource/ui/vslider$bar.png"],Handler.create(this,this.onLoadComplete));//加载资源。
		*}
	*private onLoadComplete():void {
		*this.vSlider=new VSlider();//创建一个 VSlider 类的实例对象 vSlider 。
		*this.vSlider.skin="resource/ui/vslider.png";//设置 vSlider 的皮肤。
		*this.vSlider.min=0;//设置 vSlider 最低位置值。
		*this.vSlider.max=10;//设置 vSlider 最高位置值。
		*this.vSlider.value=2;//设置 vSlider 当前位置值。
		*this.vSlider.tick=1;//设置 vSlider 刻度值。
		*this.vSlider.x=100;//设置 vSlider 对象的属性 x 的值，用于控制 vSlider 对象的显示位置。
		*this.vSlider.y=100;//设置 vSlider 对象的属性 y 的值，用于控制 vSlider 对象的显示位置。
		*this.vSlider.changeHandler=new Handler(this,this.onChange);//设置 vSlider 位置变化处理器。
		*Laya.stage.addChild(this.vSlider);//把 vSlider 添加到显示列表。
		*}
	*private onChange(value:number):void {
		*console.log("滑块的位置： value="+value);
		*}
	*}
*@see laya.ui.Slider
*/
//class laya.ui.VSlider extends laya.ui.Slider
var VSlider=(function(_super){
	function VSlider(){
		VSlider.__super.call(this);;
	}

	__class(VSlider,'laya.ui.VSlider',_super);
	return VSlider;
})(Slider)


/**
*<code>Dialog</code> 组件是一个弹出对话框，实现对话框弹出，拖动，模式窗口功能。
*可以通过UIConfig设置弹出框背景透明度，模式窗口点击边缘是否关闭等
*通过设置zOrder属性，可以更改弹出的层次
*通过设置popupEffect和closeEffect可以设置弹出效果和关闭效果，如果不想有任何弹出关闭效果，可以设置前述属性为空
*
*@example <caption>以下示例代码，创建了一个 <code>Dialog</code> 实例。</caption>
*package
*{
	*import laya.ui.Dialog;
	*import laya.utils.Handler;
	*public class Dialog_Example
	*{
		*private var dialog:Dialog_Instance;
		*public function Dialog_Example()
		*{
			*Laya.init(640,800);//设置游戏画布宽高、渲染模式。
			*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
			*Laya.loader.load("resource/ui/btn_close.png",Handler.create(this,onLoadComplete));//加载资源。
			*}
		*private function onLoadComplete():void
		*{
			*dialog=new Dialog_Instance();//创建一个 Dialog_Instance 类的实例对象 dialog。
			*dialog.dragArea="0,0,150,50";//设置 dialog 的拖拽区域。
			*dialog.show();//显示 dialog。
			*dialog.closeHandler=new Handler(this,onClose);//设置 dialog 的关闭函数处理器。
			*}
		*private function onClose(name:String):void
		*{
			*if (name==Dialog.CLOSE)
			*{
				*trace("通过点击 name 为"+name+"的组件，关闭了dialog。");
				*}
			*}
		*}
	*}
*import laya.ui.Button;
*import laya.ui.Dialog;
*import laya.ui.Image;
*class Dialog_Instance extends Dialog
*{
	*function Dialog_Instance():void
	*{
		*var bg:Image=new Image("resource/ui/bg.png");
		*bg.sizeGrid="40,10,5,10";
		*bg.width=150;
		*bg.height=250;
		*addChild(bg);
		*var image:Image=new Image("resource/ui/image.png");
		*addChild(image);
		*var button:Button=new Button("resource/ui/btn_close.png");
		*button.name=Dialog.CLOSE;//设置button的name属性值。
		*button.x=0;
		*button.y=0;
		*addChild(button);
		*}
	*}
*@example
*Laya.init(640,800);//设置游戏画布宽高、渲染模式
*Laya.stage.bgColor="#efefef";//设置画布的背景颜色
*var dialog;
*Laya.loader.load("resource/ui/btn_close.png",laya.utils.Handler.create(this,loadComplete));//加载资源
*(function (_super){//新建一个类Dialog_Instance继承自laya.ui.Dialog。
	*function Dialog_Instance(){
		*Dialog_Instance.__super.call(this);//初始化父类
		*var bg=new laya.ui.Image("resource/ui/bg.png");//新建一个 Image 类的实例 bg 。
		*bg.sizeGrid="10,40,10,5";//设置 bg 的网格信息。
		*bg.width=150;//设置 bg 的宽度。
		*bg.height=250;//设置 bg 的高度。
		*this.addChild(bg);//将 bg 添加到显示列表。
		*var image=new laya.ui.Image("resource/ui/image.png");//新建一个 Image 类的实例 image 。
		*this.addChild(image);//将 image 添加到显示列表。
		*var button=new laya.ui.Button("resource/ui/btn_close.png");//新建一个 Button 类的实例 bg 。
		*button.name=laya.ui.Dialog.CLOSE;//设置 button 的 name 属性值。
		*button.x=0;//设置 button 对象的属性 x 的值，用于控制 button 对象的显示位置。
		*button.y=0;//设置 button 对象的属性 y 的值，用于控制 button 对象的显示位置。
		*this.addChild(button);//将 button 添加到显示列表。
		*};
	*Laya.class(Dialog_Instance,"mypackage.dialogExample.Dialog_Instance",_super);//注册类Dialog_Instance。
	*})(laya.ui.Dialog);
*function loadComplete(){
	*console.log("资源加载完成！");
	*dialog=new mypackage.dialogExample.Dialog_Instance();//创建一个 Dialog_Instance 类的实例对象 dialog。
	*dialog.dragArea="0,0,150,50";//设置 dialog 的拖拽区域。
	*dialog.show();//显示 dialog。
	*dialog.closeHandler=new laya.utils.Handler(this,onClose);//设置 dialog 的关闭函数处理器。
	*}
*function onClose(name){
	*if (name==laya.ui.Dialog.CLOSE){
		*console.log("通过点击 name 为"+name+"的组件，关闭了dialog。");
		*}
	*}
*@example
*import Dialog=laya.ui.Dialog;
*import Handler=laya.utils.Handler;
*class Dialog_Example {
	*private dialog:Dialog_Instance;
	*constructor(){
		*Laya.init(640,800);//设置游戏画布宽高。
		*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
		*Laya.loader.load("resource/ui/btn_close.png",Handler.create(this,this.onLoadComplete));//加载资源。
		*}
	*private onLoadComplete():void {
		*this.dialog=new Dialog_Instance();//创建一个 Dialog_Instance 类的实例对象 dialog。
		*this.dialog.dragArea="0,0,150,50";//设置 dialog 的拖拽区域。
		*this.dialog.show();//显示 dialog。
		*this.dialog.closeHandler=new Handler(this,this.onClose);//设置 dialog 的关闭函数处理器。
		*}
	*private onClose(name:string):void {
		*if (name==Dialog.CLOSE){
			*console.log("通过点击 name 为"+name+"的组件，关闭了dialog。");
			*}
		*}
	*}
*import Button=laya.ui.Button;
*class Dialog_Instance extends Dialog {
	*Dialog_Instance():void {
		*var bg:laya.ui.Image=new laya.ui.Image("resource/ui/bg.png");
		*bg.sizeGrid="40,10,5,10";
		*bg.width=150;
		*bg.height=250;
		*this.addChild(bg);
		*var image:laya.ui.Image=new laya.ui.Image("resource/ui/image.png");
		*this.addChild(image);
		*var button:Button=new Button("resource/ui/btn_close.png");
		*button.name=Dialog.CLOSE;//设置button的name属性值。
		*button.x=0;
		*button.y=0;
		*this.addChild(button);
		*}
	*}
*/
//class laya.ui.Dialog extends laya.ui.View
var Dialog=(function(_super){
	function Dialog(){
		/**
		*一个布尔值，指定对话框是否居中弹。
		*<p>如果值为true，则居中弹出，否则，则根据对象坐标显示，默认为true。</p>
		*/
		this.popupCenter=true;
		/**
		*对话框被关闭时会触发的回调函数处理器。
		*<p>回调函数参数为用户点击的按钮名字name:String。</p>
		*/
		this.closeHandler=null;
		/**
		*弹出对话框效果，可以设置一个效果代替默认的弹出效果，如果不想有任何效果，可以赋值为null
		*全局默认弹出效果可以通过manager.popupEffect修改
		*/
		this.popupEffect=null;
		/**
		*关闭对话框效果，可以设置一个效果代替默认的关闭效果，如果不想有任何效果，可以赋值为null
		*全局默认关闭效果可以通过manager.closeEffect修改
		*/
		this.closeEffect=null;
		/**组名称*/
		this.group=null;
		/**是否是模式窗口*/
		this.isModal=false;
		/**@private */
		this._dragArea=null;
		Dialog.__super.call(this);
	}

	__class(Dialog,'laya.ui.Dialog',_super);
	var __proto=Dialog.prototype;
	/**@inheritDoc */
	__proto.initialize=function(){
		this.popupEffect=Dialog.manager.popupEffectHandler;
		this.closeEffect=Dialog.manager.closeEffectHandler;
		this._dealDragArea();
		this.on(/*laya.events.Event.CLICK*/"click",this,this._onClick);
	}

	/**@private */
	__proto._dealDragArea=function(){
		var dragTarget=this.getChildByName("drag");
		if (dragTarget){
			this.dragArea=dragTarget.x+","+dragTarget.y+","+dragTarget.width+","+dragTarget.height;
			dragTarget.removeSelf();
		}
	}

	/**
	*@private (protected)
	*对象的 <code>Event.CLICK</code> 点击事件侦听处理函数。
	*/
	__proto._onClick=function(e){
		var btn=e.target;
		if (btn){
			switch (btn.name){
				case "close":
				case "cancel":
				case "sure":
				case "no":
				case "ok":
				case "yes":
					this.close(btn.name);
					break ;
				}
		}
	}

	/**
	*显示对话框（以非模式窗口方式显示）。
	*@param closeOther 是否关闭其它的对话框。若值为true则关闭其它对话框。
	*@param showEffect 是否显示弹出效果
	*/
	__proto.show=function(closeOther,showEffect){
		(closeOther===void 0)&& (closeOther=false);
		(showEffect===void 0)&& (showEffect=true);
		this._open(false,closeOther,showEffect);
	}

	/**
	*显示对话框（以模式窗口方式显示）。
	*@param closeOther 是否关闭其它的对话框。若值为true则关闭其它对话框。
	*@param showEffect 是否显示弹出效果
	*/
	__proto.popup=function(closeOther,showEffect){
		(closeOther===void 0)&& (closeOther=false);
		(showEffect===void 0)&& (showEffect=true);
		this._open(true,closeOther,showEffect);
	}

	/**@private */
	__proto._open=function(modal,closeOther,showEffect){
		Dialog.manager.lock(false);
		this.isModal=modal;
		Dialog.manager.open(this,closeOther,showEffect);
	}

	/**打开完成后，调用此方法（如果有弹出动画，则在动画完成后执行）*/
	__proto.onOpened=function(){}
	/**
	*关闭对话框。
	*@param type 如果是点击默认关闭按钮触发，则传入关闭按钮的名字(name)，否则为null。
	*@param showEffect 是否显示关闭效果
	*/
	__proto.close=function(type,showEffect){
		(showEffect===void 0)&& (showEffect=true);
		Dialog.manager.close(this,type,showEffect);
	}

	/**关闭完成后，调用此方法（如果有关闭动画，则在动画完成后执行）
	*@param type 如果是点击默认关闭按钮触发，则传入关闭按钮的名字(name)，否则为null。
	*/
	__proto.onClosed=function(type){}
	/**@private */
	__proto._onMouseDown=function(e){
		var point=this.getMousePoint();
		if (this._dragArea.contains(point.x,point.y))this.startDrag();
		else this.stopDrag();
	}

	/**
	*用来指定对话框的拖拽区域。默认值为"0,0,0,0"。
	*<p><b>格式：</b>构成一个矩形所需的 x,y,width,heith 值，用逗号连接为字符串。
	*例如："0,0,100,200"。
	*</p>
	*
	*@see #includeExamplesSummary 请参考示例
	*/
	__getset(0,__proto,'dragArea',function(){
		if (this._dragArea)return this._dragArea.toString();
		return null;
		},function(value){
		if (value){
			var a=UIUtils.fillArray([0,0,0,0],value,Number);
			this._dragArea=new Rectangle(a[0],a[1],a[2],a[3]);
			this.on(/*laya.events.Event.MOUSE_DOWN*/"mousedown",this,this._onMouseDown);
			}else {
			this._dragArea=null;
			this.off(/*laya.events.Event.MOUSE_DOWN*/"mousedown",this,this._onMouseDown);
		}
	});

	/**
	*弹出框的显示状态；如果弹框处于显示中，则为true，否则为false;
	*/
	__getset(0,__proto,'isPopup',function(){
		return this.parent !=null;
	});

	__getset(0,__proto,'zOrder',_super.prototype._$get_zOrder,function(value){
		Laya.superSet(View,this,'zOrder',value);
		Dialog.manager._checkMask();
	});

	/**对话框管理容器，所有的对话框都在该容器内，并且受管理器管，可以自定义自己的管理器，来更改窗口管理的流程。
	*任意对话框打开和关闭，都会触发管理类的open和close事件*/
	__getset(1,Dialog,'manager',function(){
		return Dialog._manager=Dialog._manager|| new DialogManager();
		},function(value){
		Dialog._manager=value;
	});

	Dialog.setLockView=function(view){
		Dialog.manager.setLockView(view);
	}

	Dialog.lock=function(value){
		Dialog.manager.lock(value);
	}

	Dialog.closeAll=function(){
		Dialog.manager.closeAll();
	}

	Dialog.getDialogsByGroup=function(group){
		return Dialog.manager.getDialogsByGroup(group);
	}

	Dialog.closeByGroup=function(group){
		return Dialog.manager.closeByGroup(group);
	}

	Dialog.CLOSE="close";
	Dialog.CANCEL="cancel";
	Dialog.SURE="sure";
	Dialog.NO="no";
	Dialog.OK="ok";
	Dialog.YES="yes";
	Dialog._manager=null;
	return Dialog;
})(View)


/**
*<code>HBox</code> 是一个水平布局容器类。
*/
//class laya.ui.HBox extends laya.ui.LayoutBox
var HBox=(function(_super){
	function HBox(){
		HBox.__super.call(this);;
	}

	__class(HBox,'laya.ui.HBox',_super);
	var __proto=HBox.prototype;
	/**@inheritDoc */
	__proto.sortItem=function(items){
		if (items)items.sort(function(a,b){return a.x-b.x;});
	}

	/**@inheritDoc */
	__proto.changeItems=function(){
		this._itemChanged=false;
		var items=[];
		var maxHeight=0;
		for (var i=0,n=this.numChildren;i < n;i++){
			var item=this.getChildAt(i);
			if (item&&item.layoutEnabled){
				items.push(item);
				maxHeight=this._height?this._height:Math.max(maxHeight,item.height *item.scaleY);
			}
		}
		this.sortItem(items);
		var left=0;
		for (i=0,n=items.length;i < n;i++){
			item=items[i];
			item.x=left;
			left+=item.width *item.scaleX+this._space;
			if (this._align=="top"){
				item.y=0;
				}else if (this._align=="middle"){
				item.y=(maxHeight-item.height *item.scaleY)*0.5;
				}else if (this._align=="bottom"){
				item.y=maxHeight-item.height *item.scaleY;
			}
		}
		this.changeSize();
	}

	__getset(0,__proto,'height',_super.prototype._$get_height,function(value){
		if (this._height !=value){
			Laya.superSet(LayoutBox,this,'height',value);
			this.callLater(this.changeItems);
		}
	});

	HBox.NONE="none";
	HBox.TOP="top";
	HBox.MIDDLE="middle";
	HBox.BOTTOM="bottom";
	return HBox;
})(LayoutBox)


/**
*<code>VBox</code> 是一个垂直布局容器类。
*/
//class laya.ui.VBox extends laya.ui.LayoutBox
var VBox=(function(_super){
	function VBox(){
		VBox.__super.call(this);;
	}

	__class(VBox,'laya.ui.VBox',_super);
	var __proto=VBox.prototype;
	/**@inheritDoc */
	__proto.changeItems=function(){
		this._itemChanged=false;
		var items=[];
		var maxWidth=0;
		for (var i=0,n=this.numChildren;i < n;i++){
			var item=this.getChildAt(i);
			if (item&&item.layoutEnabled){
				items.push(item);
				maxWidth=this._width?this._width:Math.max(maxWidth,item.width *item.scaleX);
			}
		}
		this.sortItem(items);
		var top=0;
		for (i=0,n=items.length;i < n;i++){
			item=items[i];
			item.y=top;
			top+=item.height *item.scaleY+this._space;
			if (this._align=="left"){
				item.x=0;
				}else if (this._align=="center"){
				item.x=(maxWidth-item.width *item.scaleX)*0.5;
				}else if (this._align=="right"){
				item.x=maxWidth-item.width *item.scaleX;
			}
		}
		this.changeSize();
	}

	__getset(0,__proto,'width',_super.prototype._$get_width,function(value){
		if (this._width !=value){
			Laya.superSet(LayoutBox,this,'width',value);
			this.callLater(this.changeItems);
		}
	});

	VBox.NONE="none";
	VBox.LEFT="left";
	VBox.CENTER="center";
	VBox.RIGHT="right";
	return VBox;
})(LayoutBox)


/**
*<code>RadioGroup</code> 控件定义一组 <code>Radio</code> 控件，这些控件相互排斥；
*因此，用户每次只能选择一个 <code>Radio</code> 控件。
*
*@example <caption>以下示例代码，创建了一个 <code>RadioGroup</code> 实例。</caption>
*package
*{
	*import laya.ui.Radio;
	*import laya.ui.RadioGroup;
	*import laya.utils.Handler;
	*public class RadioGroup_Example
	*{
		*public function RadioGroup_Example()
		*{
			*Laya.init(640,800);//设置游戏画布宽高。
			*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
			*Laya.loader.load(["resource/ui/radio.png"],Handler.create(this,onLoadComplete));//加载资源。
			*}
		*private function onLoadComplete():void
		*{
			*var radioGroup:RadioGroup=new RadioGroup();//创建一个 RadioGroup 类的实例对象 radioGroup 。
			*radioGroup.pos(100,100);//设置 radioGroup 的位置信息。
			*radioGroup.labels="item0,item1,item2";//设置 radioGroup 的标签集。
			*radioGroup.skin="resource/ui/radio.png";//设置 radioGroup 的皮肤。
			*radioGroup.space=10;//设置 radioGroup 的项间隔距离。
			*radioGroup.selectHandler=new Handler(this,onSelect);//设置 radioGroup 的选择项发生改变时执行的处理器。
			*Laya.stage.addChild(radioGroup);//将 radioGroup 添加到显示列表。
			*}
		*private function onSelect(index:int):void
		*{
			*trace("当前选择的单选按钮索引: index= ",index);
			*}
		*}
	*}
*@example
*Laya.init(640,800);//设置游戏画布宽高、渲染模式
*Laya.stage.bgColor="#efefef";//设置画布的背景颜色
*Laya.loader.load(["resource/ui/radio.png"],laya.utils.Handler.create(this,onLoadComplete));
*function onLoadComplete(){
	*var radioGroup=new laya.ui.RadioGroup();//创建一个 RadioGroup 类的实例对象 radioGroup 。
	*radioGroup.pos(100,100);//设置 radioGroup 的位置信息。
	*radioGroup.labels="item0,item1,item2";//设置 radioGroup 的标签集。
	*radioGroup.skin="resource/ui/radio.png";//设置 radioGroup 的皮肤。
	*radioGroup.space=10;//设置 radioGroup 的项间隔距离。
	*radioGroup.selectHandler=new laya.utils.Handler(this,onSelect);//设置 radioGroup 的选择项发生改变时执行的处理器。
	*Laya.stage.addChild(radioGroup);//将 radioGroup 添加到显示列表。
	*}
*function onSelect(index){
	*console.log("当前选择的单选按钮索引: index= ",index);
	*}
*@example
*import Radio=laya.ui.Radio;
*import RadioGroup=laya.ui.RadioGroup;
*import Handler=laya.utils.Handler;
*class RadioGroup_Example {
	*constructor(){
		*Laya.init(640,800);//设置游戏画布宽高。
		*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
		*Laya.loader.load(["resource/ui/radio.png"],Handler.create(this,this.onLoadComplete));//加载资源。
		*}
	*private onLoadComplete():void {
		*var radioGroup:RadioGroup=new RadioGroup();//创建一个 RadioGroup 类的实例对象 radioGroup 。
		*radioGroup.pos(100,100);//设置 radioGroup 的位置信息。
		*radioGroup.labels="item0,item1,item2";//设置 radioGroup 的标签集。
		*radioGroup.skin="resource/ui/radio.png";//设置 radioGroup 的皮肤。
		*radioGroup.space=10;//设置 radioGroup 的项间隔距离。
		*radioGroup.selectHandler=new Handler(this,this.onSelect);//设置 radioGroup 的选择项发生改变时执行的处理器。
		*Laya.stage.addChild(radioGroup);//将 radioGroup 添加到显示列表。
		*}
	*private onSelect(index:number):void {
		*console.log("当前选择的单选按钮索引: index= ",index);
		*}
	*}
*/
//class laya.ui.RadioGroup extends laya.ui.UIGroup
var RadioGroup=(function(_super){
	function RadioGroup(){
		RadioGroup.__super.call(this);;
	}

	__class(RadioGroup,'laya.ui.RadioGroup',_super);
	var __proto=RadioGroup.prototype;
	/**@inheritDoc */
	__proto.createItem=function(skin,label){
		return new Radio(skin,label);
	}

	return RadioGroup;
})(UIGroup)


/**
*<code>Tab</code> 组件用来定义选项卡按钮组。 *
*@internal <p>属性：<code>selectedIndex</code> 的默认值为-1。</p>
*
*@example <caption>以下示例代码，创建了一个 <code>Tab</code> 实例。</caption>
*package
*{
	*import laya.ui.Tab;
	*import laya.utils.Handler;
	*public class Tab_Example
	*{
		*public function Tab_Example()
		*{
			*Laya.init(640,800);//设置游戏画布宽高。
			*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
			*Laya.loader.load(["resource/ui/tab.png"],Handler.create(this,onLoadComplete));//加载资源。
			*}
		*private function onLoadComplete():void
		*{
			*var tab:Tab=new Tab();//创建一个 Tab 类的实例对象 tab 。
			*tab.skin="resource/ui/tab.png";//设置 tab 的皮肤。
			*tab.labels="item0,item1,item2";//设置 tab 的标签集。
			*tab.x=100;//设置 tab 对象的属性 x 的值，用于控制 tab 对象的显示位置。
			*tab.y=100;//设置 tab 对象的属性 y 的值，用于控制 tab 对象的显示位置。
			*tab.selectHandler=new Handler(this,onSelect);//设置 tab 的选择项发生改变时执行的处理器。
			*Laya.stage.addChild(tab);//将 tab 添到显示列表。
			*}
		*private function onSelect(index:int):void
		*{
			*trace("当前选择的表情页索引: index= ",index);
			*}
		*}
	*}
*@example
*Laya.init(640,800);//设置游戏画布宽高
*Laya.stage.bgColor="#efefef";//设置画布的背景颜色
*Laya.loader.load(["resource/ui/tab.png"],laya.utils.Handler.create(this,onLoadComplete));
*function onLoadComplete(){
	*var tab=new laya.ui.Tab();//创建一个 Tab 类的实例对象 tab 。
	*tab.skin="resource/ui/tab.png";//设置 tab 的皮肤。
	*tab.labels="item0,item1,item2";//设置 tab 的标签集。
	*tab.x=100;//设置 tab 对象的属性 x 的值，用于控制 tab 对象的显示位置。
	*tab.y=100;//设置 tab 对象的属性 y 的值，用于控制 tab 对象的显示位置。
	*tab.selectHandler=new laya.utils.Handler(this,onSelect);//设置 tab 的选择项发生改变时执行的处理器。
	*Laya.stage.addChild(tab);//将 tab 添到显示列表。
	*}
*function onSelect(index){
	*console.log("当前选择的标签页索引: index= ",index);
	*}
*@example
*import Tab=laya.ui.Tab;
*import Handler=laya.utils.Handler;
*class Tab_Example {
	*constructor(){
		*Laya.init(640,800);//设置游戏画布宽高。
		*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
		*Laya.loader.load(["resource/ui/tab.png"],Handler.create(this,this.onLoadComplete));//加载资源。
		*}
	*private onLoadComplete():void {
		*var tab:Tab=new Tab();//创建一个 Tab 类的实例对象 tab 。
		*tab.skin="resource/ui/tab.png";//设置 tab 的皮肤。
		*tab.labels="item0,item1,item2";//设置 tab 的标签集。
		*tab.x=100;//设置 tab 对象的属性 x 的值，用于控制 tab 对象的显示位置。
		*tab.y=100;//设置 tab 对象的属性 y 的值，用于控制 tab 对象的显示位置。
		*tab.selectHandler=new Handler(this,this.onSelect);//设置 tab 的选择项发生改变时执行的处理器。
		*Laya.stage.addChild(tab);//将 tab 添到显示列表。
		*}
	*private onSelect(index:number):void {
		*console.log("当前选择的表情页索引: index= ",index);
		*}
	*}
*/
//class laya.ui.Tab extends laya.ui.UIGroup
var Tab=(function(_super){
	function Tab(){
		Tab.__super.call(this);;
	}

	__class(Tab,'laya.ui.Tab',_super);
	var __proto=Tab.prototype;
	/**
	*@private
	*@inheritDoc
	*/
	__proto.createItem=function(skin,label){
		return new Button(skin,label);
	}

	return Tab;
})(UIGroup)


/**
*<code>TextArea</code> 类用于创建显示对象以显示和输入文本。
*@example <caption>以下示例代码，创建了一个 <code>TextArea</code> 实例。</caption>
*package
*{
	*import laya.ui.TextArea;
	*import laya.utils.Handler;
	*public class TextArea_Example
	*{
		*public function TextArea_Example()
		*{
			*Laya.init(640,800);//设置游戏画布宽高。
			*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
			*Laya.loader.load(["resource/ui/input.png"],Handler.create(this,onLoadComplete));//加载资源。
			*}
		*private function onLoadComplete():void
		*{
			*var textArea:TextArea=new TextArea("这个一个TextArea实例。");//创建一个 TextArea 类的实例对象 textArea 。
			*textArea.skin="resource/ui/input.png";//设置 textArea 的皮肤。
			*textArea.sizeGrid="4,4,4,4";//设置 textArea 的网格信息。
			*textArea.color="#008fff";//设置 textArea 的文本颜色。
			*textArea.font="Arial";//设置 textArea 的字体。
			*textArea.bold=true;//设置 textArea 的文本显示为粗体。
			*textArea.fontSize=20;//设置 textArea 的文本字体大小。
			*textArea.wordWrap=true;//设置 textArea 的文本自动换行。
			*textArea.x=100;//设置 textArea 对象的属性 x 的值，用于控制 textArea 对象的显示位置。
			*textArea.y=100;//设置 textArea 对象的属性 y 的值，用于控制 textArea 对象的显示位置。
			*textArea.width=300;//设置 textArea 的宽度。
			*textArea.height=200;//设置 textArea 的高度。
			*Laya.stage.addChild(textArea);//将 textArea 添加到显示列表。
			*}
		*}
	*}
*@example
*Laya.init(640,800);//设置游戏画布宽高、渲染模式
*Laya.stage.bgColor="#efefef";//设置画布的背景颜色
*Laya.loader.load(["resource/ui/input.png"],laya.utils.Handler.create(this,onLoadComplete));//加载资源。
*function onLoadComplete(){
	*var textArea=new laya.ui.TextArea("这个一个TextArea实例。");//创建一个 TextArea 类的实例对象 textArea 。
	*textArea.skin="resource/ui/input.png";//设置 textArea 的皮肤。
	*textArea.sizeGrid="4,4,4,4";//设置 textArea 的网格信息。
	*textArea.color="#008fff";//设置 textArea 的文本颜色。
	*textArea.font="Arial";//设置 textArea 的字体。
	*textArea.bold=true;//设置 textArea 的文本显示为粗体。
	*textArea.fontSize=20;//设置 textArea 的文本字体大小。
	*textArea.wordWrap=true;//设置 textArea 的文本自动换行。
	*textArea.x=100;//设置 textArea 对象的属性 x 的值，用于控制 textArea 对象的显示位置。
	*textArea.y=100;//设置 textArea 对象的属性 y 的值，用于控制 textArea 对象的显示位置。
	*textArea.width=300;//设置 textArea 的宽度。
	*textArea.height=200;//设置 textArea 的高度。
	*Laya.stage.addChild(textArea);//将 textArea 添加到显示列表。
	*}
*@example
*import TextArea=laya.ui.TextArea;
*import Handler=laya.utils.Handler;
*class TextArea_Example {
	*constructor(){
		*Laya.init(640,800);//设置游戏画布宽高、渲染模式。
		*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
		*Laya.loader.load(["resource/ui/input.png"],Handler.create(this,this.onLoadComplete));//加载资源。
		*}
	*private onLoadComplete():void {
		*var textArea:TextArea=new TextArea("这个一个TextArea实例。");//创建一个 TextArea 类的实例对象 textArea 。
		*textArea.skin="resource/ui/input.png";//设置 textArea 的皮肤。
		*textArea.sizeGrid="4,4,4,4";//设置 textArea 的网格信息。
		*textArea.color="#008fff";//设置 textArea 的文本颜色。
		*textArea.font="Arial";//设置 textArea 的字体。
		*textArea.bold=true;//设置 textArea 的文本显示为粗体。
		*textArea.fontSize=20;//设置 textArea 的文本字体大小。
		*textArea.wordWrap=true;//设置 textArea 的文本自动换行。
		*textArea.x=100;//设置 textArea 对象的属性 x 的值，用于控制 textArea 对象的显示位置。
		*textArea.y=100;//设置 textArea 对象的属性 y 的值，用于控制 textArea 对象的显示位置。
		*textArea.width=300;//设置 textArea 的宽度。
		*textArea.height=200;//设置 textArea 的高度。
		*Laya.stage.addChild(textArea);//将 textArea 添加到显示列表。
		*}
	*}
*/
//class laya.ui.TextArea extends laya.ui.TextInput
var TextArea=(function(_super){
	function TextArea(text){
		/**@private */
		this._vScrollBar=null;
		/**@private */
		this._hScrollBar=null;
		(text===void 0)&& (text="");
		TextArea.__super.call(this,text);
	}

	__class(TextArea,'laya.ui.TextArea',_super);
	var __proto=TextArea.prototype;
	__proto.destroy=function(destroyChild){
		(destroyChild===void 0)&& (destroyChild=true);
		_super.prototype.destroy.call(this,destroyChild);
		this._vScrollBar && this._vScrollBar.destroy();
		this._hScrollBar && this._hScrollBar.destroy();
		this._vScrollBar=null;
		this._hScrollBar=null;
	}

	__proto.initialize=function(){
		this.width=180;
		this.height=150;
		this._tf.wordWrap=true;
		this.multiline=true;
	}

	__proto.onVBarChanged=function(e){
		if (this._tf.scrollY !=this._vScrollBar.value){
			this._tf.scrollY=this._vScrollBar.value;
		}
	}

	__proto.onHBarChanged=function(e){
		if (this._tf.scrollX !=this._hScrollBar.value){
			this._tf.scrollX=this._hScrollBar.value;
		}
	}

	__proto.changeScroll=function(){
		var vShow=this._vScrollBar && this._tf.maxScrollY > 0;
		var hShow=this._hScrollBar && this._tf.maxScrollX > 0;
		var showWidth=vShow ? this._width-this._vScrollBar.width :this._width;
		var showHeight=hShow ? this._height-this._hScrollBar.height :this._height;
		var padding=this._tf.padding || Styles.labelPadding;
		this._tf.width=showWidth;
		this._tf.height=showHeight;
		if (this._vScrollBar){
			this._vScrollBar.x=this._width-this._vScrollBar.width-padding[2];
			this._vScrollBar.y=padding[1];
			this._vScrollBar.height=this._height-(hShow ? this._hScrollBar.height :0)-padding[1]-padding[3];
			this._vScrollBar.scrollSize=1;
			this._vScrollBar.thumbPercent=showHeight / Math.max(this._tf.textHeight,showHeight);
			this._vScrollBar.setScroll(1,this._tf.maxScrollY,this._tf.scrollY);
			this._vScrollBar.visible=vShow;
		}
		if (this._hScrollBar){
			this._hScrollBar.x=padding[0];
			this._hScrollBar.y=this._height-this._hScrollBar.height-padding[3];
			this._hScrollBar.width=this._width-(vShow ? this._vScrollBar.width :0)-padding[0]-padding[2];
			this._hScrollBar.scrollSize=Math.max(showWidth *0.033,1);
			this._hScrollBar.thumbPercent=showWidth / Math.max(this._tf.textWidth,showWidth);
			this._hScrollBar.setScroll(0,this.maxScrollX,this.scrollX);
			this._hScrollBar.visible=hShow;
		}
	}

	/**滚动到某个位置*/
	__proto.scrollTo=function(y){
		this.commitMeasure();
		this._tf.scrollY=y;
	}

	/**垂直滚动值*/
	__getset(0,__proto,'scrollY',function(){
		return this._tf.scrollY;
	});

	__getset(0,__proto,'width',_super.prototype._$get_width,function(value){
		Laya.superSet(TextInput,this,'width',value);
		this.callLater(this.changeScroll);
	});

	/**水平滚动条实体*/
	__getset(0,__proto,'hScrollBar',function(){
		return this._hScrollBar;
	});

	__getset(0,__proto,'height',_super.prototype._$get_height,function(value){
		Laya.superSet(TextInput,this,'height',value);
		this.callLater(this.changeScroll);
	});

	/**水平滚动最大值*/
	__getset(0,__proto,'maxScrollX',function(){
		return this._tf.maxScrollX;
	});

	/**垂直滚动条皮肤*/
	__getset(0,__proto,'vScrollBarSkin',function(){
		return this._vScrollBar ? this._vScrollBar.skin :null;
		},function(value){
		if (this._vScrollBar==null){
			this.addChild(this._vScrollBar=new VScrollBar());
			this._vScrollBar.on(/*laya.events.Event.CHANGE*/"change",this,this.onVBarChanged);
			this._vScrollBar.target=this._tf;
			this.callLater(this.changeScroll);
		}
		this._vScrollBar.skin=value;
	});

	/**水平滚动条皮肤*/
	__getset(0,__proto,'hScrollBarSkin',function(){
		return this._hScrollBar ? this._hScrollBar.skin :null;
		},function(value){
		if (this._hScrollBar==null){
			this.addChild(this._hScrollBar=new HScrollBar());
			this._hScrollBar.on(/*laya.events.Event.CHANGE*/"change",this,this.onHBarChanged);
			this._hScrollBar.mouseWheelEnable=false;
			this._hScrollBar.target=this._tf;
			this.callLater(this.changeScroll);
		}
		this._hScrollBar.skin=value;
	});

	/**垂直滚动条实体*/
	__getset(0,__proto,'vScrollBar',function(){
		return this._vScrollBar;
	});

	/**垂直滚动最大值*/
	__getset(0,__proto,'maxScrollY',function(){
		return this._tf.maxScrollY;
	});

	/**水平滚动值*/
	__getset(0,__proto,'scrollX',function(){
		return this._tf.scrollX;
	});

	return TextArea;
})(TextInput)


/**
*异步Dialog的生命周期:show或者popup > onCreate(如果没有创建过)> onOpen > onClose > onDestroy(如果销毁)
*onCreate在页面未创建时执行一次，再次打开页面不会再执行，适合写一些只执行一次的逻辑，比如资源加载，节点事件监听
*onOpen在页面每次打开都会执行，适合做一些每次都需要处理的事情，比如消息请求，根据数据初始化页面
*onClose在每次关闭的时候调用，适合关闭时停止动画，网络消息监听等逻辑
*onDestroy在页面被销毁的时候调用，适合置空引用对象
*/
//class laya.ui.AsynDialog extends laya.ui.Dialog
var AsynDialog=(function(_super){
	function AsynDialog(){
		/**@private */
		this._uiView=null;
		/**打开时是否关闭其他页面*/
		this.isCloseOther=false;
		AsynDialog.__super.call(this);
	}

	__class(AsynDialog,'laya.ui.AsynDialog',_super);
	var __proto=AsynDialog.prototype;
	/**@private */
	__proto.createView=function(uiView){
		this._uiView=uiView;
	}

	__proto._open=function(modal,closeOther,showEffect){
		this.isModal=modal;
		this.isCloseOther=closeOther;
		Dialog.manager.lock(true);
		if (this._uiView)this.onCreated();
		else this.onOpen();
	}

	/**
	*在页面未创建时执行一次，再次打开页面不会再执行，适合写一些只执行一次的逻辑，比如资源加载，节点事件监听
	*/
	__proto.onCreated=function(){
		this.createUI();
		this.onOpen();
	}

	/**根据节点数据创建UI*/
	__proto.createUI=function(){
		laya.ui.View.prototype.createView.call(this,this._uiView);
		this._uiView=null;
		this._dealDragArea();
	}

	/**
	*在页面每次打开都会执行，适合做一些每次都需要处理的事情，比如消息请求，根据数据初始化页面
	*/
	__proto.onOpen=function(){
		Dialog.manager.open(this,this.isCloseOther);
		Dialog.manager.lock(false);
	}

	__proto.close=function(type,showEffect){
		(showEffect===void 0)&& (showEffect=true);
		Dialog.manager.close(this);
		this.onClose();
	}

	/**
	*在每次关闭的时候调用，适合关闭时停止动画，网络消息监听等逻辑
	*/
	__proto.onClose=function(){}
	__proto.destroy=function(destroyChild){
		(destroyChild===void 0)&& (destroyChild=true);
		laya.ui.View.prototype.destroy.call(this,destroyChild);
		this._uiView=null;
		this.onDestroy();
	}

	/**
	*在页面被销毁的时候调用，适合置空引用对象
	*/
	__proto.onDestroy=function(){}
	return AsynDialog;
})(Dialog)


	Laya.__init([View]);
})(window,document,Laya);

if (typeof define === 'function' && define.amd){
	define('laya.core', ['require', "exports"], function(require, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        for (var i in Laya) {
			var o = Laya[i];
            o && o.__isclass && (exports[i] = o);
        }
    });
}

(function(window,document,Laya){
	var __un=Laya.un,__uns=Laya.uns,__static=Laya.static,__class=Laya.class,__getset=Laya.getset,__newvec=Laya.__newvec;

	var AnimationContent=laya.ani.AnimationContent,AnimationPlayer=laya.ani.AnimationPlayer,AnimationState=laya.ani.AnimationState;
	var AnimationTemplet=laya.ani.AnimationTemplet,Arith=laya.maths.Arith,AtlasResourceManager=laya.webgl.atlas.AtlasResourceManager;
	var BaseShader=laya.webgl.shader.BaseShader,Browser=laya.utils.Browser,Buffer=laya.webgl.utils.Buffer,Byte=laya.utils.Byte;
	var CacheAbleSkinMesh=laya.ani.bone.canvasmesh.CacheAbleSkinMesh,ClassUtils=laya.utils.ClassUtils,Config=Laya.Config;
	var Event=laya.events.Event,EventDispatcher=laya.events.EventDispatcher,Handler=laya.utils.Handler,Loader=laya.net.Loader;
	var LoaderManager=laya.net.LoaderManager,MathUtil=laya.maths.MathUtil,Node=laya.display.Node,Render=laya.renders.Render;
	var RenderContext=laya.renders.RenderContext,RenderSprite=laya.renders.RenderSprite,RenderState2D=laya.webgl.utils.RenderState2D;
	var Resource=laya.resource.Resource,RunDriver=laya.utils.RunDriver,Shader=laya.webgl.shader.Shader,ShaderCompile=laya.webgl.utils.ShaderCompile;
	var Sprite=laya.display.Sprite,Stat=laya.utils.Stat,StringKey=laya.utils.StringKey,Style=laya.display.css.Style;
	var Texture=laya.resource.Texture,URL=laya.net.URL,Utils=laya.utils.Utils,WebGL=laya.webgl.WebGL,WebGLContext=laya.webgl.WebGLContext;
	var WebGLContext2D=laya.webgl.canvas.WebGLContext2D;
Laya.interface('laya.d3.core.IClone');
Laya.interface('laya.d3.graphics.IVertex');
Laya.interface('laya.d3.core.render.IUpdate');
Laya.interface('laya.d3.core.scene.ITreeNode');
Laya.interface('laya.d3.core.render.IRenderable');
/**
*@private
*/
//class laya.d3.animation.AnimationClipParser01
var AnimationClipParser01=(function(){
	function AnimationClipParser01(){}
	__class(AnimationClipParser01,'laya.d3.animation.AnimationClipParser01');
	AnimationClipParser01.READ_DATA=function(){
		AnimationClipParser01._DATA.offset=AnimationClipParser01._reader.getUint32();
		AnimationClipParser01._DATA.size=AnimationClipParser01._reader.getUint32();
	}

	AnimationClipParser01.READ_BLOCK=function(){
		var count=AnimationClipParser01._BLOCK.count=AnimationClipParser01._reader.getUint16();
		var blockStarts=AnimationClipParser01._BLOCK.blockStarts=[];
		var blockLengths=AnimationClipParser01._BLOCK.blockLengths=[];
		for (var i=0;i < count;i++){
			blockStarts.push(AnimationClipParser01._reader.getUint32());
			blockLengths.push(AnimationClipParser01._reader.getUint32());
		}
	}

	AnimationClipParser01.READ_STRINGS=function(){
		var offset=AnimationClipParser01._reader.getUint32();
		var count=AnimationClipParser01._reader.getUint16();
		var prePos=AnimationClipParser01._reader.pos;
		AnimationClipParser01._reader.pos=offset+AnimationClipParser01._DATA.offset;
		for (var i=0;i < count;i++)
		AnimationClipParser01._strings[i]=AnimationClipParser01._reader.readUTFString();
		AnimationClipParser01._reader.pos=prePos;
	}

	AnimationClipParser01.parse=function(clip,reader){
		AnimationClipParser01._animationClip=clip;
		AnimationClipParser01._reader=reader;
		var arrayBuffer=reader.__getBuffer();
		AnimationClipParser01.READ_DATA();
		AnimationClipParser01.READ_BLOCK();
		AnimationClipParser01.READ_STRINGS();
		for (var i=0,n=AnimationClipParser01._BLOCK.count;i < n;i++){
			var index=reader.getUint16();
			var blockName=AnimationClipParser01._strings[index];
			var fn=AnimationClipParser01["READ_"+blockName];
			if (fn==null)
				throw new Error("model file err,no this function:"+index+" "+blockName);
			else
			fn.call();
		}
	}

	AnimationClipParser01.READ_ANIMATIONS=function(){
		var i=0,j=0;
		var node;
		var reader=AnimationClipParser01._reader;
		var buffer=reader.__getBuffer();
		var lengthTypes=[];
		var lenghthTypeCount=reader.getUint8();
		lengthTypes.length=lenghthTypeCount;
		for (i=0;i < lenghthTypeCount;i++)
		lengthTypes[i]=reader.getUint16();
		var startTimeTypes=[];
		var startTimeTypeCount=reader.getUint16();
		startTimeTypes.length=startTimeTypeCount;
		for (i=0;i < startTimeTypeCount;i++)
		startTimeTypes[i]=reader.getFloat32();
		var clip=AnimationClipParser01._animationClip;
		clip.name=AnimationClipParser01._strings[reader.getUint16()];
		var clipDur=clip._duration=reader.getFloat32();
		clip.islooping=!!reader.getByte();
		clip._frameRate=reader.getInt16();
		var nodeCount=reader.getInt16();
		var nodes=clip._nodes=new Array;
		nodes.length=nodeCount;
		var publicDatas=clip._publicClipDatas=[];
		publicDatas.length=nodeCount;
		var nodesMap=clip._nodesMap={};
		var cachePropertyToNodeIndex=0,unCachePropertyToNodeIndex=0;
		for (i=0;i < nodeCount;i++){
			node=nodes[i]=new KeyframeNode();
			var pathLength=reader.getUint16();
			var path=node.path=[];
			path.length=pathLength;
			for (j=0;j < pathLength;j++)
			path[j]=AnimationClipParser01._strings[reader.getUint16()];
			var nodePath=path.join("/");
			var mapArray=nodesMap[nodePath];
			(mapArray)|| (nodesMap[nodePath]=mapArray=[]);
			mapArray.push(node);
			var componentTypeStrIndex=reader.getInt16();
			(componentTypeStrIndex!==-1)&& (node.componentType=AnimationClipParser01._strings[componentTypeStrIndex]);
			var propertyNameID=AnimationNode._propertyIndexDic[AnimationClipParser01._strings[reader.getUint16()]];
			if (propertyNameID !=null){
				var isTransformProperty=propertyNameID < 4;
				var cacheProperty=!isTransformProperty || (isTransformProperty && path[0]==="");
				node._cacheProperty=cacheProperty;
				if (cacheProperty)
					cachePropertyToNodeIndex++;
				else
				unCachePropertyToNodeIndex++;
				node.propertyNameID=propertyNameID;
				}else {
				throw new Error("AnimationClipParser01:unknown property name.");
			};
			var dataLength=lengthTypes[reader.getUint8()];
			node.keyFrameWidth=dataLength / 4;
			var keyFrames=node.keyFrames=[];
			var keyframeCount=keyFrames.length=reader.getUint16();
			var lastKeyFrame=null;
			var startTime=NaN;
			for (j=0;j < keyframeCount;j++){
				var keyFrame=keyFrames[j]=new Keyframe();
				startTime=keyFrame.startTime=startTimeTypes[reader.getUint16()];
				var offset=reader.pos;
				keyFrame.inTangent=new Float32Array(buffer.slice(offset,offset+dataLength));
				reader.pos+=dataLength;
				offset=reader.pos;
				keyFrame.outTangent=new Float32Array(buffer.slice(offset,offset+dataLength));
				reader.pos+=dataLength;
				offset=reader.pos;
				keyFrame.data=new Float32Array(buffer.slice(offset,offset+dataLength));
				reader.pos+=dataLength;
				if (lastKeyFrame){
					lastKeyFrame.next=keyFrame;
					lastKeyFrame.duration=startTime-lastKeyFrame.startTime;
				}
				lastKeyFrame=keyFrame;
			}
			keyFrame.next=null;
			keyFrame.duration=clipDur-startTime;
		};
		var nodeToCachePropertyMap=clip._nodeToCachePropertyMap=new Int32Array(nodeCount);
		var cachePropertyToNodeMap=clip._cachePropertyMap=new Int32Array(cachePropertyToNodeIndex);
		var unCachePropertyToNodeMap=clip._unCachePropertyMap=new Int32Array(unCachePropertyToNodeIndex);
		cachePropertyToNodeIndex=unCachePropertyToNodeIndex=0;
		for (i=0;i < nodeCount;i++){
			node=nodes[i];
			if (node._cacheProperty){
				nodeToCachePropertyMap[i]=cachePropertyToNodeIndex;
				cachePropertyToNodeMap[cachePropertyToNodeIndex++]=i;
				}else {
				unCachePropertyToNodeMap[unCachePropertyToNodeIndex++]=i;
			}
		}
	}

	AnimationClipParser01._animationClip=null;
	AnimationClipParser01._reader=null;
	AnimationClipParser01._strings=[];
	__static(AnimationClipParser01,
	['_BLOCK',function(){return this._BLOCK={count:0};},'_DATA',function(){return this._DATA={offset:0,size:0};}
	]);
	return AnimationClipParser01;
})()


/**
*@private
*/
//class laya.d3.animation.AnimationClipParser02
var AnimationClipParser02=(function(){
	function AnimationClipParser02(){}
	__class(AnimationClipParser02,'laya.d3.animation.AnimationClipParser02');
	AnimationClipParser02.READ_DATA=function(){
		AnimationClipParser02._DATA.offset=AnimationClipParser02._reader.getUint32();
		AnimationClipParser02._DATA.size=AnimationClipParser02._reader.getUint32();
	}

	AnimationClipParser02.READ_BLOCK=function(){
		var count=AnimationClipParser02._BLOCK.count=AnimationClipParser02._reader.getUint16();
		var blockStarts=AnimationClipParser02._BLOCK.blockStarts=[];
		var blockLengths=AnimationClipParser02._BLOCK.blockLengths=[];
		for (var i=0;i < count;i++){
			blockStarts.push(AnimationClipParser02._reader.getUint32());
			blockLengths.push(AnimationClipParser02._reader.getUint32());
		}
	}

	AnimationClipParser02.READ_STRINGS=function(){
		var offset=AnimationClipParser02._reader.getUint32();
		var count=AnimationClipParser02._reader.getUint16();
		var prePos=AnimationClipParser02._reader.pos;
		AnimationClipParser02._reader.pos=offset+AnimationClipParser02._DATA.offset;
		for (var i=0;i < count;i++)
		AnimationClipParser02._strings[i]=AnimationClipParser02._reader.readUTFString();
		AnimationClipParser02._reader.pos=prePos;
	}

	AnimationClipParser02.parse=function(clip,reader){
		AnimationClipParser02._animationClip=clip;
		AnimationClipParser02._reader=reader;
		var arrayBuffer=reader.__getBuffer();
		AnimationClipParser02.READ_DATA();
		AnimationClipParser02.READ_BLOCK();
		AnimationClipParser02.READ_STRINGS();
		for (var i=0,n=AnimationClipParser02._BLOCK.count;i < n;i++){
			var index=reader.getUint16();
			var blockName=AnimationClipParser02._strings[index];
			var fn=AnimationClipParser02["READ_"+blockName];
			if (fn==null)
				throw new Error("model file err,no this function:"+index+" "+blockName);
			else
			fn.call();
		}
	}

	AnimationClipParser02.READ_ANIMATIONS=function(){
		var i=0,j=0;
		var node;
		var reader=AnimationClipParser02._reader;
		var buffer=reader.__getBuffer();
		var lengthTypes=[];
		var lenghthTypeCount=reader.getUint8();
		lengthTypes.length=lenghthTypeCount;
		for (i=0;i < lenghthTypeCount;i++)
		lengthTypes[i]=reader.getUint16();
		var startTimeTypes=[];
		var startTimeTypeCount=reader.getUint16();
		startTimeTypes.length=startTimeTypeCount;
		for (i=0;i < startTimeTypeCount;i++)
		startTimeTypes[i]=reader.getFloat32();
		var clip=AnimationClipParser02._animationClip;
		clip.name=AnimationClipParser02._strings[reader.getUint16()];
		var clipDur=clip._duration=reader.getFloat32();
		clip.islooping=!!reader.getByte();
		clip._frameRate=reader.getInt16();
		var nodeCount=reader.getInt16();
		var nodes=clip._nodes=new Array;
		nodes.length=nodeCount;
		var publicDatas=clip._publicClipDatas=[];
		publicDatas.length=nodeCount;
		var nodesMap=clip._nodesMap={};
		var cachePropertyToNodeIndex=0,unCachePropertyToNodeIndex=0;
		for (i=0;i < nodeCount;i++){
			node=nodes[i]=new KeyframeNode();
			var pathLength=reader.getUint16();
			var path=node.path=[];
			path.length=pathLength;
			for (j=0;j < pathLength;j++)
			path[j]=AnimationClipParser02._strings[reader.getUint16()];
			var nodePath=path.join("/");
			var mapArray=nodesMap[nodePath];
			(mapArray)|| (nodesMap[nodePath]=mapArray=[]);
			mapArray.push(node);
			var componentTypeStrIndex=reader.getInt16();
			(componentTypeStrIndex!==-1)&& (node.componentType=AnimationClipParser02._strings[componentTypeStrIndex]);
			var propertyNameID=AnimationNode._propertyIndexDic[AnimationClipParser02._strings[reader.getUint16()]];
			if (propertyNameID !=null){
				var isTransformProperty=propertyNameID < 4;
				var cacheProperty=!isTransformProperty || (isTransformProperty && path[0]==="");
				node._cacheProperty=cacheProperty;
				if (cacheProperty)
					cachePropertyToNodeIndex++;
				else
				unCachePropertyToNodeIndex++;
				node.propertyNameID=propertyNameID;
				}else {
				throw new Error("AnimationClipParser02:unknown property name.");
			};
			var dataLength=lengthTypes[reader.getUint8()];
			node.keyFrameWidth=dataLength / 4;
			var keyFrames=node.keyFrames=[];
			var keyframeCount=keyFrames.length=reader.getUint16();
			var lastKeyFrame=null;
			var startTime=NaN;
			for (j=0;j < keyframeCount;j++){
				var keyFrame=keyFrames[j]=new Keyframe();
				startTime=keyFrame.startTime=startTimeTypes[reader.getUint16()];
				var offset=reader.pos;
				keyFrame.inTangent=new Float32Array(buffer.slice(offset,offset+dataLength));
				reader.pos+=dataLength;
				offset=reader.pos;
				keyFrame.outTangent=new Float32Array(buffer.slice(offset,offset+dataLength));
				reader.pos+=dataLength;
				offset=reader.pos;
				keyFrame.data=new Float32Array(buffer.slice(offset,offset+dataLength));
				reader.pos+=dataLength;
				if (lastKeyFrame){
					lastKeyFrame.next=keyFrame;
					lastKeyFrame.duration=startTime-lastKeyFrame.startTime;
				}
				lastKeyFrame=keyFrame;
			}
			keyFrame.next=null;
			keyFrame.duration=clipDur-startTime;
		};
		var eventCount=reader.getUint16();
		for (i=0;i < eventCount;i++){
			var event=new AnimationEvent();
			event.time=reader.getFloat32();
			event.eventName=AnimationClipParser02._strings[reader.getUint16()];
			var params;
			var paramCount=reader.getUint16();
			(paramCount > 0)&& (event.params=params=[]);
			for (j=0;j < paramCount;j++){
				var type=reader.getByte();
				switch (type){
					case 0:
						params.push(!!reader.getByte());
						break ;
					case 1:
						params.push(reader.getInt32());
						break ;
					case 2:
						params.push(reader.getFloat32());
						break ;
					case 3:
						params.push(AnimationClipParser02._strings[reader.getUint16()]);
						break ;
					default :
						throw new Error("unknown type.");
					}
			}
			clip.addEvent(event);
		};
		var nodeToCachePropertyMap=clip._nodeToCachePropertyMap=new Int32Array(nodeCount);
		var cachePropertyToNodeMap=clip._cachePropertyMap=new Int32Array(cachePropertyToNodeIndex);
		var unCachePropertyToNodeMap=clip._unCachePropertyMap=new Int32Array(unCachePropertyToNodeIndex);
		cachePropertyToNodeIndex=unCachePropertyToNodeIndex=0;
		for (i=0;i < nodeCount;i++){
			node=nodes[i];
			if (node._cacheProperty){
				nodeToCachePropertyMap[i]=cachePropertyToNodeIndex;
				cachePropertyToNodeMap[cachePropertyToNodeIndex++]=i;
				}else {
				unCachePropertyToNodeMap[unCachePropertyToNodeIndex++]=i;
			}
		}
	}

	AnimationClipParser02._animationClip=null;
	AnimationClipParser02._reader=null;
	AnimationClipParser02._strings=[];
	__static(AnimationClipParser02,
	['_BLOCK',function(){return this._BLOCK={count:0};},'_DATA',function(){return this._DATA={offset:0,size:0};}
	]);
	return AnimationClipParser02;
})()


/**
*<code>AnimationEvent</code> 类用于实现动画事件。
*/
//class laya.d3.animation.AnimationEvent
var AnimationEvent=(function(){
	function AnimationEvent(){
		/**事件触发时间。*/
		this.time=NaN;
		/**事件触发名称。*/
		this.eventName=null;
		/**事件触发参数。*/
		this.params=null;
	}

	__class(AnimationEvent,'laya.d3.animation.AnimationEvent');
	return AnimationEvent;
})()


/**
*<code>BoneNode</code> 类用于实现骨骼节点。
*/
//class laya.d3.animation.AnimationNode
var AnimationNode=(function(){
	function AnimationNode(){
		/**@private */
		//this._childs=null;
		/**@private */
		//this._parent=null;
		/**@private [只读]*/
		//this.transform=null;
		/**节点名称。 */
		//this.name=null;
		this._childs=[];
		this.transform=new AnimationTransform3D(this);
	}

	__class(AnimationNode,'laya.d3.animation.AnimationNode');
	var __proto=AnimationNode.prototype;
	Laya.imps(__proto,{"laya.d3.core.IClone":true})
	/**
	*添加子节点。
	*@param child 子节点。
	*/
	__proto.addChild=function(child){
		child._parent=this;
		child.transform.setParent(this.transform);
		this._childs.push(child);
	}

	/**
	*移除子节点。
	*@param child 子节点。
	*/
	__proto.removeChild=function(child){
		var index=this._childs.indexOf(child);
		(index!==-1)&& (this._childs.splice(index,1));
	}

	/**
	*根据名字获取子节点。
	*@param name 名字。
	*/
	__proto.getChildByName=function(name){
		for (var i=0,n=this._childs.length;i < n;i++){
			var child=this._childs[i];
			if (child.name===name)
				return child;
		}
		return null;
	}

	/**
	*根据索引获取子节点。
	*@param index 索引。
	*/
	__proto.getChildByIndex=function(index){
		return this._childs[index];
	}

	/**
	*获取子节点的个数。
	*/
	__proto.getChildCount=function(){
		return this._childs.length;
	}

	/**
	*克隆。
	*@param destObject 克隆源。
	*/
	__proto.cloneTo=function(destObject){
		var destNode=destObject;
		destNode.name=this.name;
		for (var i=0,n=this._childs.length;i < n;i++){
			var child=this._childs[i];
			var destChild=child.clone();
			destNode.addChild(destChild);
			var transform=child.transform;
			var destTransform=destChild.transform;
			destTransform.setLocalPosition(transform.getLocalPosition());
			destTransform.setLocalRotation(transform.getLocalRotation());
			destTransform.setLocalScale(transform.getLocalScale());
			destTransform._localRotationEuler=transform._localRotationEuler;
			destTransform._setWorldMatrixIgnoreUpdate(transform.getWorldMatrix());
		}
	}

	/**
	*克隆。
	*@return 克隆副本。
	*/
	__proto.clone=function(){
		var dest=/*__JS__ */new this.constructor();
		this.cloneTo(dest);
		return dest;
	}

	AnimationNode.__init__=function(){
		AnimationNode.registerAnimationNodeProperty("localPosition",AnimationNode._getLocalPosition,AnimationNode._setLocalPosition);
		AnimationNode.registerAnimationNodeProperty("localRotation",AnimationNode._getLocalRotation,AnimationNode._setLocalRotation);
		AnimationNode.registerAnimationNodeProperty("localScale",AnimationNode._getLocalScale,AnimationNode._setLocalScale);
		AnimationNode.registerAnimationNodeProperty("localRotationEuler",AnimationNode._getLocalRotationEuler,AnimationNode._setLocalRotationEuler);
		AnimationNode.registerAnimationNodeProperty("particleRender.sharedMaterial.tintColor",AnimationNode._getParticleRenderSharedMaterialTintColor,AnimationNode._setParticleRenderSharedMaterialTintColor);
		AnimationNode.registerAnimationNodeProperty("meshRender.sharedMaterial.tilingOffset",AnimationNode._getMeshRenderSharedMaterialTilingOffset,AnimationNode._setMeshRenderSharedMaterialTilingOffset);
		AnimationNode.registerAnimationNodeProperty("meshRender.sharedMaterial.albedoColor",AnimationNode._getMeshRenderSharedMaterialAlbedo,AnimationNode._setMeshRenderSharedMaterialAlbedo);
		AnimationNode.registerAnimationNodeProperty("skinnedMeshRender.sharedMaterial.tilingOffset",AnimationNode._getSkinnedMeshRenderSharedMaterialTilingOffset,AnimationNode._setSkinnedMeshRenderSharedMaterialTilingOffset);
		AnimationNode.registerAnimationNodeProperty("skinnedMeshRender.sharedMaterial.albedoColor",AnimationNode._getSkinnedMeshRenderSharedMaterialAlbedo,AnimationNode._setSkinnedMeshRenderSharedMaterialAlbedo);
		AnimationNode.registerAnimationNodeProperty("meshRender.sharedMaterial.albedo",AnimationNode._getMeshRenderSharedMaterialAlbedo,AnimationNode._setMeshRenderSharedMaterialAlbedo);
		AnimationNode.registerAnimationNodeProperty("skinnedMeshRender.sharedMaterial.albedo",AnimationNode._getSkinnedMeshRenderSharedMaterialAlbedo,AnimationNode._setSkinnedMeshRenderSharedMaterialAlbedo);
		AnimationNode.registerAnimationNodeProperty("meshRender.sharedMaterial.intensity",AnimationNode._getMeshRenderSharedMaterialIntensity,AnimationNode._setMeshRenderSharedMaterialIntensity);
		AnimationNode.registerAnimationNodeProperty("meshRender.sharedMaterial.alpha",AnimationNode._getMeshRenderSharedMaterialAlpha,AnimationNode._setMeshRenderSharedMaterialAlpha);
		AnimationNode.registerAnimationNodeProperty("meshRender.sharedMaterial.alphaColor",AnimationNode._getMeshRenderSharedMaterialAlphaColor,AnimationNode._setMeshRenderSharedMaterialAlphaColor);
		AnimationNode.registerAnimationNodeProperty("meshRender.sharedMaterial.baseColor",AnimationNode._getMeshRenderSharedMaterialBaseColor,AnimationNode._setMeshRenderSharedMaterialBaseColor);
		AnimationNode.registerAnimationNodeProperty("meshRender.sharedMaterial.dissolve",AnimationNode._getMeshRenderSharedMaterialDissolve,AnimationNode._setMeshRenderSharedMaterialDissolve);
		AnimationNode.registerAnimationNodeProperty("meshRender.sharedMaterial.dissolveSpeed",AnimationNode._getMeshRenderSharedMaterialDissolveSpeed,AnimationNode._setMeshRenderSharedMaterialDissolveSpeed);
		AnimationNode.registerAnimationNodeProperty("meshRender.sharedMaterial.mMultiplier",AnimationNode._getMeshRenderSharedMaterialMMultiplier,AnimationNode._setMeshRenderSharedMaterialMMultiplier);
		AnimationNode.registerAnimationNodeProperty("meshRender.sharedMaterial.baseScrollSpeedX",AnimationNode._getMeshRenderSharedMaterialBaseScrollSpeedX,AnimationNode._setMeshRenderSharedMaterialBaseScrollSpeedX);
		AnimationNode.registerAnimationNodeProperty("meshRender.sharedMaterial.baseScrollSpeedY",AnimationNode._getMeshRenderSharedMaterialBaseScrollSpeedY,AnimationNode._setMeshRenderSharedMaterialBaseScrollSpeedY);
		AnimationNode.registerAnimationNodeProperty("meshRender.sharedMaterial.secondScrollSpeedX",AnimationNode._getMeshRenderSharedMaterialSecondScrollSpeedX,AnimationNode._setMeshRenderSharedMaterialSecondScrollSpeedX);
		AnimationNode.registerAnimationNodeProperty("meshRender.sharedMaterial.secondScrollSpeedY",AnimationNode._getMeshRenderSharedMaterialSecondScrollSpeedY,AnimationNode._setMeshRenderSharedMaterialSecondScrollSpeedY);
		AnimationNode.registerAnimationNodeProperty("meshRender.sharedMaterial.detailTilingOffset",AnimationNode._getMeshRenderSharedMaterialDetailTilingOffset,AnimationNode._setMeshRenderSharedMaterialDetailTilingOffset);
		AnimationNode.registerAnimationNodeProperty("meshRender.sharedMaterial.dissolveTilingOffset",AnimationNode._getMeshRenderSharedMaterialDissolveTilingOffset,AnimationNode._setMeshRenderSharedMaterialDissolveTilingOffset);
		AnimationNode.registerAnimationNodeProperty("meshRender.sharedMaterial.maskTilingOffset",AnimationNode._getMeshRenderSharedMaterialMaskTilingOffset,AnimationNode._setMeshRenderSharedMaterialMaskTilingOffset);
	}

	AnimationNode.registerAnimationNodeProperty=function(propertyName,getFunc,setFunc){
		if (AnimationNode._propertyIndexDic[propertyName]){
			throw new Error("AnimationNode: this propertyName has registered.");
			}else {
			AnimationNode._propertyIndexDic[propertyName]=AnimationNode._propertyIDCounter;
			AnimationNode._propertyGetFuncs[AnimationNode._propertyIDCounter]=getFunc;
			AnimationNode._propertySetFuncs[AnimationNode._propertyIDCounter]=setFunc;
			AnimationNode._propertyIDCounter++;
		}
	}

	AnimationNode._getLocalPosition=function(animationNode,sprite3D){
		if (animationNode)
			return animationNode.transform.getLocalPosition();
		else
		return sprite3D._transform.localPosition.elements;
	}

	AnimationNode._setLocalPosition=function(animationNode,sprite3D,value){
		if (animationNode){
			animationNode.transform.setLocalPosition(value);
			}else {
			var spriteTransform=sprite3D._transform;
			var localPosition=spriteTransform.localPosition;
			localPosition.elements=value;
			spriteTransform.localPosition=localPosition;
		}
	}

	AnimationNode._getLocalRotation=function(animationNode,sprite3D){
		if (animationNode)
			return animationNode.transform.getLocalRotation();
		else
		return sprite3D._transform.localRotation.elements;
	}

	AnimationNode._setLocalRotation=function(animationNode,sprite3D,value){
		if (animationNode){
			animationNode.transform.setLocalRotation(value);
			}else {
			var spriteTransform=sprite3D._transform;
			var localRotation=spriteTransform.localRotation;
			localRotation.elements=value;
			spriteTransform.localRotation=localRotation;
		}
	}

	AnimationNode._getLocalScale=function(animationNode,sprite3D){
		if (animationNode)
			return animationNode.transform.getLocalScale();
		else
		return sprite3D._transform.localScale.elements;
	}

	AnimationNode._setLocalScale=function(animationNode,sprite3D,value){
		if (animationNode){
			animationNode.transform.setLocalScale(value);
			}else {
			var spriteTransform=sprite3D._transform;
			var localScale=spriteTransform.localScale;
			localScale.elements=value;
			spriteTransform.localScale=localScale;
		}
	}

	AnimationNode._getLocalRotationEuler=function(animationNode,sprite3D){
		if (animationNode)
			return animationNode.transform.getLocalRotationEuler();
		else
		return sprite3D._transform.localRotationEuler.elements;
	}

	AnimationNode._setLocalRotationEuler=function(animationNode,sprite3D,value){
		if (animationNode){
			animationNode.transform.setLocalRotationEuler(value);
			}else {
			var spriteTransform=sprite3D._transform;
			var localRotationEuler=spriteTransform.localRotationEuler;
			localRotationEuler.elements=value;
			spriteTransform.localRotationEuler=localRotationEuler;
		}
	}

	AnimationNode._getMeshRenderSharedMaterialTilingOffset=function(animationNode,sprite3D){
		var material;
		if (animationNode){
			var entity=animationNode.transform._entity;
			if (entity){
				material=(entity.owner).meshRender.sharedMaterial;
				return material.tilingOffset.elements;
			}else
			return null;
			}else {
			material=(sprite3D).meshRender.sharedMaterial;
			return material.tilingOffset.elements;
		}
	}

	AnimationNode._setMeshRenderSharedMaterialTilingOffset=function(animationNode,sprite3D,value){
		var material,tilingOffset;
		if (animationNode){
			var entity=animationNode.transform._entity;
			if (entity){
				material=(entity.owner).meshRender.material;
				tilingOffset=material.tilingOffset;
				tilingOffset.elements=value;
				material.tilingOffset=tilingOffset;
			}
			}else {
			material=(sprite3D).meshRender.material;
			tilingOffset=material.tilingOffset;
			tilingOffset.elements=value;
			material.tilingOffset=tilingOffset;
		}
	}

	AnimationNode._getMeshRenderSharedMaterialAlbedo=function(animationNode,sprite3D){
		var material;
		if (animationNode){
			var entity=animationNode.transform._entity;
			if (entity){
				material=(entity.owner).meshRender.sharedMaterial;
				return material.albedoColor.elements;
			}else
			return null;
			}else {
			material=(sprite3D).meshRender.sharedMaterial;
			return material.albedoColor.elements;
		}
	}

	AnimationNode._setMeshRenderSharedMaterialAlbedo=function(animationNode,sprite3D,value){
		var material,albedo;
		if (animationNode){
			var entity=animationNode.transform._entity;
			if (entity){
				material=(entity.owner).meshRender.material;
				albedo=material.albedoColor;
				albedo.elements=value;
				material.albedoColor=albedo;
			}
			}else {
			material=(sprite3D).meshRender.material;
			albedo=material.albedoColor;
			albedo.elements=value;
			material.albedoColor=albedo;
		}
	}

	AnimationNode._getSkinnedMeshRenderSharedMaterialTilingOffset=function(animationNode,sprite3D){
		var material;
		if (animationNode){
			var entity=animationNode.transform._entity;
			if (entity){
				material=(entity.owner).skinnedMeshRender.sharedMaterial;
				return material.tilingOffset.elements;
			}else
			return null;
			}else {
			material=(sprite3D).skinnedMeshRender.sharedMaterial;
			return material.tilingOffset.elements;
		}
	}

	AnimationNode._setSkinnedMeshRenderSharedMaterialTilingOffset=function(animationNode,sprite3D,value){
		var material,tilingOffset;
		if (animationNode){
			var entity=animationNode.transform._entity;
			if (entity){
				material=(entity.owner).skinnedMeshRender.material;
				tilingOffset=material.tilingOffset;
				tilingOffset.elements=value;
				material.tilingOffset=tilingOffset;
			}
			}else {
			material=(sprite3D).skinnedMeshRender.material;
			tilingOffset=material.tilingOffset;
			tilingOffset.elements=value;
			material.tilingOffset=tilingOffset;
		}
	}

	AnimationNode._getSkinnedMeshRenderSharedMaterialAlbedo=function(animationNode,sprite3D){
		var material;
		if (animationNode){
			var entity=animationNode.transform._entity;
			if (entity){
				material=(entity.owner).skinnedMeshRender.sharedMaterial;
				return material.albedoColor.elements;
				}else {
				return null;
			}
			}else {
			material=(sprite3D).skinnedMeshRender.sharedMaterial;
			return material.albedoColor.elements;
		}
	}

	AnimationNode._setSkinnedMeshRenderSharedMaterialAlbedo=function(animationNode,sprite3D,value){
		var material,albedo;
		if (animationNode){
			var entity=animationNode.transform._entity;
			if (entity){
				material=(entity.owner).skinnedMeshRender.material;
				albedo=material.albedoColor;
				albedo.elements=value;
				material.albedoColor=albedo;
			}
			}else {
			material=(sprite3D).skinnedMeshRender.material;
			albedo=material.albedoColor;
			albedo.elements=value;
			material.albedoColor=albedo;
		}
	}

	AnimationNode._getParticleRenderSharedMaterialTintColor=function(animationNode,sprite3D){
		var material;
		if (animationNode){
			var entity=animationNode.transform._entity;
			if (entity){
				material=(entity.owner).particleRender.sharedMaterial;
				return material.tintColor.elements;
			}else
			return null;
			}else {
			material=(sprite3D).particleRender.sharedMaterial;
			return material.tintColor.elements;
		}
	}

	AnimationNode._setParticleRenderSharedMaterialTintColor=function(animationNode,sprite3D,value){
		var material,tintColor;
		if (animationNode){
			var entity=animationNode.transform._entity;
			if (entity){
				material=(entity.owner).particleRender.material;
				tintColor=material.tintColor;
				tintColor.elements=value;
				material.tintColor=tintColor;
			}
			}else {
			material=(sprite3D).particleRender.material;
			tintColor=material.tintColor;
			tintColor.elements=value;
			material.tintColor=tintColor;
		}
	}

	AnimationNode._getMeshRenderSharedMaterialAlphaColor=function(animationNode,sprite3D){
		var material;
		if (animationNode){
			var entity=animationNode.transform._entity;
			if (entity){
				material=(entity.owner).meshRender.sharedMaterial;
				return material.alphaColor.elements;
			}else
			return null;
			}else {
			material=(sprite3D).meshRender.sharedMaterial;
			return material.alphaColor.elements;
		}
	}

	AnimationNode._setMeshRenderSharedMaterialAlphaColor=function(animationNode,sprite3D,value){
		var material,alphaColor;
		if (animationNode){
			var entity=animationNode.transform._entity;
			if (entity){
				material=(entity.owner).meshRender.material;
				alphaColor=material.alphaColor;
				alphaColor.elements=value;
				material.alphaColor=alphaColor;
			}
			}else {
			material=(sprite3D).meshRender.material;
			alphaColor=material.alphaColor;
			alphaColor.elements=value;
			material.alphaColor=alphaColor;
		}
	}

	AnimationNode._getMeshRenderSharedMaterialBaseColor=function(animationNode,sprite3D){
		var material;
		if (animationNode){
			var entity=animationNode.transform._entity;
			if (entity){
				material=(entity.owner).meshRender.sharedMaterial;
				return material.baseColor.elements;
			}else
			return null;
			}else {
			material=(sprite3D).meshRender.sharedMaterial;
			return material.baseColor.elements;
		}
	}

	AnimationNode._setMeshRenderSharedMaterialBaseColor=function(animationNode,sprite3D,value){
		var material,baseColor;
		if (animationNode){
			var entity=animationNode.transform._entity;
			if (entity){
				material=(entity.owner).meshRender.material;
				baseColor=material.baseColor;
				baseColor.elements=value;
				material.baseColor=baseColor;
			}
			}else {
			material=(sprite3D).meshRender.material;
			baseColor=material.baseColor;
			baseColor.elements=value;
			material.baseColor=baseColor;
		}
	}

	AnimationNode._getMeshRenderSharedMaterialDissolve=function(animationNode,sprite3D){
		var material;
		if (animationNode){
			var entity=animationNode.transform._entity;
			if (entity){
				material=(entity.owner).meshRender.sharedMaterial;
				return material.dissolve;
			}else
			return 0.0;
			}else {
			material=(sprite3D).meshRender.sharedMaterial;
			return material.dissolve;
		}
	}

	AnimationNode._setMeshRenderSharedMaterialDissolve=function(animationNode,sprite3D,value){
		var material;
		if (animationNode){
			var entity=animationNode.transform._entity;
			if (entity){
				material=(entity.owner).meshRender.material;
				material.dissolve=value[0];
			}
			}else {
			material=(sprite3D).meshRender.material;
			material.dissolve=value[0];
		}
	}

	AnimationNode._getMeshRenderSharedMaterialDissolveSpeed=function(animationNode,sprite3D){
		var material;
		if (animationNode){
			var entity=animationNode.transform._entity;
			if (entity){
				material=(entity.owner).meshRender.sharedMaterial;
				return material.dissolveSpeed;
			}else
			return 0.0;
			}else {
			material=(sprite3D).meshRender.sharedMaterial;
			return material.dissolveSpeed;
		}
	}

	AnimationNode._setMeshRenderSharedMaterialDissolveSpeed=function(animationNode,sprite3D,value){
		var material;
		if (animationNode){
			var entity=animationNode.transform._entity;
			if (entity){
				material=(entity.owner).meshRender.material;
				material.dissolveSpeed=value[0];
			}
			}else {
			material=(sprite3D).meshRender.material;
			material.dissolveSpeed=value[0];
		}
	}

	AnimationNode._getMeshRenderSharedMaterialMMultiplier=function(animationNode,sprite3D){
		var material;
		if (animationNode){
			var entity=animationNode.transform._entity;
			if (entity){
				material=(entity.owner).meshRender.sharedMaterial;
				return material.mMultiplier;
			}else
			return 0.0;
			}else {
			material=(sprite3D).meshRender.sharedMaterial;
			return material.mMultiplier;
		}
	}

	AnimationNode._setMeshRenderSharedMaterialMMultiplier=function(animationNode,sprite3D,value){
		var material;
		if (animationNode){
			var entity=animationNode.transform._entity;
			if (entity){
				material=(entity.owner).meshRender.material;
				material.mMultiplier=value[0];
			}
			}else {
			material=(sprite3D).meshRender.material;
			material.mMultiplier=value[0];
		}
	}

	AnimationNode._getMeshRenderSharedMaterialBaseScrollSpeedX=function(animationNode,sprite3D){
		var material;
		if (animationNode){
			var entity=animationNode.transform._entity;
			if (entity){
				material=(entity.owner).meshRender.sharedMaterial;
				return material.baseScrollSpeedX;
			}else
			return 0.0;
			}else {
			material=(sprite3D).meshRender.sharedMaterial;
			return material.baseScrollSpeedX;
		}
	}

	AnimationNode._setMeshRenderSharedMaterialBaseScrollSpeedX=function(animationNode,sprite3D,value){
		var material;
		if (animationNode){
			var entity=animationNode.transform._entity;
			if (entity){
				material=(entity.owner).meshRender.material;
				material.baseScrollSpeedX=value[0];
			}
			}else {
			material=(sprite3D).meshRender.material;
			material.baseScrollSpeedX=value[0];
		}
	}

	AnimationNode._getMeshRenderSharedMaterialBaseScrollSpeedY=function(animationNode,sprite3D){
		var material;
		if (animationNode){
			var entity=animationNode.transform._entity;
			if (entity){
				material=(entity.owner).meshRender.sharedMaterial;
				return material.baseScrollSpeedY;
			}else
			return 0.0;
			}else {
			material=(sprite3D).meshRender.sharedMaterial;
			return material.baseScrollSpeedY;
		}
	}

	AnimationNode._setMeshRenderSharedMaterialBaseScrollSpeedY=function(animationNode,sprite3D,value){
		var material;
		if (animationNode){
			var entity=animationNode.transform._entity;
			if (entity){
				material=(entity.owner).meshRender.material;
				material.baseScrollSpeedY=value[0];
			}
			}else {
			material=(sprite3D).meshRender.material;
			material.baseScrollSpeedY=value[0];
		}
	}

	AnimationNode._getMeshRenderSharedMaterialSecondScrollSpeedX=function(animationNode,sprite3D){
		var material;
		if (animationNode){
			var entity=animationNode.transform._entity;
			if (entity){
				material=(entity.owner).meshRender.sharedMaterial;
				return material.secondScrollSpeedX;
			}else
			return 0.0;
			}else {
			material=(sprite3D).meshRender.sharedMaterial;
			return material.secondScrollSpeedX;
		}
	}

	AnimationNode._setMeshRenderSharedMaterialSecondScrollSpeedX=function(animationNode,sprite3D,value){
		var material;
		if (animationNode){
			var entity=animationNode.transform._entity;
			if (entity){
				material=(entity.owner).meshRender.material;
				material.secondScrollSpeedX=value[0];
			}
			}else {
			material=(sprite3D).meshRender.material;
			material.secondScrollSpeedX=value[0];
		}
	}

	AnimationNode._getMeshRenderSharedMaterialSecondScrollSpeedY=function(animationNode,sprite3D){
		var material;
		if (animationNode){
			var entity=animationNode.transform._entity;
			if (entity){
				material=(entity.owner).meshRender.sharedMaterial;
				return material.secondScrollSpeedY;
			}else
			return 0.0;
			}else {
			material=(sprite3D).meshRender.sharedMaterial;
			return material.secondScrollSpeedY;
		}
	}

	AnimationNode._setMeshRenderSharedMaterialSecondScrollSpeedY=function(animationNode,sprite3D,value){
		var material;
		if (animationNode){
			var entity=animationNode.transform._entity;
			if (entity){
				material=(entity.owner).meshRender.material;
				material.secondScrollSpeedY=value[0];
			}
			}else {
			material=(sprite3D).meshRender.material;
			material.secondScrollSpeedY=value[0];
		}
	}

	AnimationNode._getMeshRenderSharedMaterialAlpha=function(animationNode,sprite3D){
		var material;
		if (animationNode){
			var entity=animationNode.transform._entity;
			if (entity){
				material=(entity.owner).meshRender.sharedMaterial;
				return material.alpha;
			}else
			return 0.0;
			}else {
			material=(sprite3D).meshRender.sharedMaterial;
			return material.alpha;
		}
	}

	AnimationNode._setMeshRenderSharedMaterialAlpha=function(animationNode,sprite3D,value){
		var material;
		if (animationNode){
			var entity=animationNode.transform._entity;
			if (entity){
				material=(entity.owner).meshRender.material;
				material.alpha=value[0];
			}
			}else {
			material=(sprite3D).meshRender.material;
			material.alpha=value[0];
		}
	}

	AnimationNode._getMeshRenderSharedMaterialIntensity=function(animationNode,sprite3D){
		var material;
		if (animationNode){
			var entity=animationNode.transform._entity;
			if (entity){
				material=(entity.owner).meshRender.sharedMaterial;
				return material.intensity;
			}else
			return 0.0;
			}else {
			material=(sprite3D).meshRender.sharedMaterial;
			return material.intensity;
		}
	}

	AnimationNode._setMeshRenderSharedMaterialIntensity=function(animationNode,sprite3D,value){
		var material;
		if (animationNode){
			var entity=animationNode.transform._entity;
			if (entity){
				material=(entity.owner).meshRender.material;
				material.intensity=value[0];
			}
			}else {
			material=(sprite3D).meshRender.material;
			material.intensity=value[0];
		}
	}

	AnimationNode._getMeshRenderSharedMaterialDetailTilingOffset=function(animationNode,sprite3D){
		var material;
		if (animationNode){
			var entity=animationNode.transform._entity;
			if (entity){
				material=(entity.owner).meshRender.sharedMaterial;
				return material.detailTilingOffset.elements;
			}else
			return null;
			}else {
			material=(sprite3D).meshRender.sharedMaterial;
			return material.detailTilingOffset.elements;
		}
	}

	AnimationNode._setMeshRenderSharedMaterialDetailTilingOffset=function(animationNode,sprite3D,value){
		var material,detailTilingOffset;
		if (animationNode){
			var entity=animationNode.transform._entity;
			if (entity){
				material=(entity.owner).meshRender.material;
				detailTilingOffset=material.detailTilingOffset;
				detailTilingOffset.elements=value;
				material.detailTilingOffset=detailTilingOffset;
			}
			}else {
			material=(sprite3D).meshRender.material;
			detailTilingOffset=material.detailTilingOffset;
			detailTilingOffset.elements=value;
			material.detailTilingOffset=detailTilingOffset;
		}
	}

	AnimationNode._getMeshRenderSharedMaterialDissolveTilingOffset=function(animationNode,sprite3D){
		var material;
		if (animationNode){
			var entity=animationNode.transform._entity;
			if (entity){
				material=(entity.owner).meshRender.sharedMaterial;
				return material.dissolveTilingOffset.elements;
			}else
			return null;
			}else {
			material=(sprite3D).meshRender.sharedMaterial;
			return material.dissolveTilingOffset.elements;
		}
	}

	AnimationNode._setMeshRenderSharedMaterialDissolveTilingOffset=function(animationNode,sprite3D,value){
		var material,dissolveTilingOffset;
		if (animationNode){
			var entity=animationNode.transform._entity;
			if (entity){
				material=(entity.owner).meshRender.material;
				dissolveTilingOffset=material.dissolveTilingOffset;
				dissolveTilingOffset.elements=value;
				material.dissolveTilingOffset=dissolveTilingOffset;
			}
			}else {
			material=(sprite3D).meshRender.material;
			dissolveTilingOffset=material.dissolveTilingOffset;
			dissolveTilingOffset.elements=value;
			material.dissolveTilingOffset=dissolveTilingOffset;
		}
	}

	AnimationNode._getMeshRenderSharedMaterialMaskTilingOffset=function(animationNode,sprite3D){
		var material;
		if (animationNode){
			var entity=animationNode.transform._entity;
			if (entity){
				material=(entity.owner).meshRender.sharedMaterial;
				return material.maskTilingOffset.elements;
			}else
			return null;
			}else {
			material=(sprite3D).meshRender.sharedMaterial;
			return material.maskTilingOffset.elements;
		}
	}

	AnimationNode._setMeshRenderSharedMaterialMaskTilingOffset=function(animationNode,sprite3D,value){
		var material,maskTilingOffset;
		if (animationNode){
			var entity=animationNode.transform._entity;
			if (entity){
				material=(entity.owner).meshRender.material;
				maskTilingOffset=material.maskTilingOffset;
				maskTilingOffset.elements=value;
				material.maskTilingOffset=maskTilingOffset;
			}
			}else {
			material=(sprite3D).meshRender.material;
			maskTilingOffset=material.maskTilingOffset;
			maskTilingOffset.elements=value;
			material.maskTilingOffset=maskTilingOffset;
		}
	}

	AnimationNode._propertyIDCounter=0;
	AnimationNode._propertyIndexDic={};
	AnimationNode._propertySetFuncs=[];
	AnimationNode._propertyGetFuncs=[];
	return AnimationNode;
})()


/**
*@private
*/
//class laya.d3.animation.Keyframe
var Keyframe=(function(){
	function Keyframe(){
		this.startTime=NaN;
		this.inTangent=null;
		this.outTangent=null;
		this.data=null;
		this.duration=NaN;
		this.next=null;
	}

	__class(Keyframe,'laya.d3.animation.Keyframe');
	return Keyframe;
})()


/**
*@private
*/
//class laya.d3.animation.KeyframeNode
var KeyframeNode=(function(){
	function KeyframeNode(){
		this._cacheProperty=false;
		this.path=null;
		this.componentType=null;
		//TODO:是否去掉
		this.propertyNameID=0;
		this.keyFrameWidth=0;
		this.defaultData=null;
		this.keyFrames=null;
	}

	__class(KeyframeNode,'laya.d3.animation.KeyframeNode');
	return KeyframeNode;
})()


/**
*<code>SplineCurvePositionVelocity</code> 类用于通过顶点和速度创建闪光插值。
*/
//class laya.d3.core.glitter.SplineCurvePositionVelocity
var SplineCurvePositionVelocity=(function(){
	function SplineCurvePositionVelocity(){
		this._tempVector30=new Vector3();
		this._tempVector31=new Vector3();
		this._tempVector32=new Vector3();
		this._a=new Vector3();
		this._b=new Vector3();
		this._c=new Vector3();
		this._d=new Vector3();
	}

	__class(SplineCurvePositionVelocity,'laya.d3.core.glitter.SplineCurvePositionVelocity');
	var __proto=SplineCurvePositionVelocity.prototype;
	/**
	*初始化插值所需信息。
	*@param position0 顶点0的位置。
	*@param velocity0 顶点0的速度。
	*@param position1 顶点1的位置。
	*@param velocity1 顶点1的速度。
	*/
	__proto.Init=function(position0,velocity0,position1,velocity1){
		position0.cloneTo(this._d);
		velocity0.cloneTo(this._c);
		Vector3.scale(position0,2.0,this._a);
		Vector3.scale(position1,2.0,this._tempVector30);
		Vector3.subtract(this._a,this._tempVector30,this._a);
		Vector3.add(this._a,velocity0,this._a);
		Vector3.add(this._a,velocity1,this._a);
		Vector3.scale(position1,3.0,this._b);
		Vector3.scale(position0,3.0,this._tempVector30);
		Vector3.subtract(this._b,this._tempVector30,this._b);
		Vector3.subtract(this._b,velocity1,this._b);
		Vector3.scale(velocity0,2.0,this._tempVector30);
		Vector3.subtract(this._b,this._tempVector30,this._b);
	}

	/**
	*初始化插值所需信息。
	*@param t 插值比例
	*@param out 输出结果
	*/
	__proto.Slerp=function(t,out){
		Vector3.scale(this._a,t *t *t,this._tempVector30);
		Vector3.scale(this._b,t *t,this._tempVector31);
		Vector3.scale(this._c,t,this._tempVector32);
		Vector3.add(this._tempVector30,this._tempVector31,out);
		Vector3.add(out,this._tempVector32,out);
		Vector3.add(out,this._d,out);
	}

	return SplineCurvePositionVelocity;
})()


/**
*<code>HeightMap</code> 类用于实现高度图数据。
*/
//class laya.d3.core.HeightMap
var HeightMap=(function(){
	function HeightMap(width,height,minHeight,maxHeight){
		/**@private */
		this._datas=null;
		/**@private */
		this._w=0;
		/**@private */
		this._h=0;
		/**@private */
		this._minHeight=NaN;
		/**@private */
		this._maxHeight=NaN;
		this._datas=[];
		this._w=width;
		this._h=height;
		this._minHeight=minHeight;
		this._maxHeight=maxHeight;
	}

	__class(HeightMap,'laya.d3.core.HeightMap');
	var __proto=HeightMap.prototype;
	/**@private */
	__proto._inBounds=function(row,col){
		return row >=0 && row < this._h && col >=0 && col < this._w;
	}

	/**
	*获取高度。
	*@param row 列数。
	*@param col 行数。
	*@return 高度。
	*/
	__proto.getHeight=function(row,col){
		if (this._inBounds(row,col))
			return this._datas[row][col];
		else
		return NaN;
	}

	/**
	*获取宽度。
	*@return value 宽度。
	*/
	__getset(0,__proto,'width',function(){
		return this._w;
	});

	/**
	*获取高度。
	*@return value 高度。
	*/
	__getset(0,__proto,'height',function(){
		return this._h;
	});

	/**
	*最大高度。
	*@return value 最大高度。
	*/
	__getset(0,__proto,'maxHeight',function(){
		return this._maxHeight;
	});

	/**
	*最大高度。
	*@return value 最大高度。
	*/
	__getset(0,__proto,'minHeight',function(){
		return this._minHeight;
	});

	HeightMap.creatFromMesh=function(mesh,width,height,outCellSize){
		var vertices=[];
		var indexs=[];
		var submesheCount=mesh.getSubMeshCount();
		for (var i=0;i < submesheCount;i++){
			var subMesh=mesh.getSubMesh(i);
			var vertexBuffer=subMesh._getVertexBuffer();
			var verts=vertexBuffer.getData();
			var subMeshVertices=[];
			for (var j=0;j < verts.length;j+=vertexBuffer.vertexDeclaration.vertexStride / 4){
				var position=new Vector3(verts[j+0],verts[j+1],verts[j+2]);
				subMeshVertices.push(position);
			}
			vertices.push(subMeshVertices);
			var ib=subMesh._getIndexBuffer();
			indexs.push(ib.getData());
		};
		var boundingBox=mesh.boundingBox;
		var minX=boundingBox.min.x;
		var minZ=boundingBox.min.z;
		var maxX=boundingBox.max.x;
		var maxZ=boundingBox.max.z;
		var minY=boundingBox.min.y;
		var maxY=boundingBox.max.y;
		var widthSize=maxX-minX;
		var heightSize=maxZ-minZ;
		var cellWidth=outCellSize.elements[0]=widthSize / (width-1);
		var cellHeight=outCellSize.elements[1]=heightSize / (height-1);
		var heightMap=new HeightMap(width,height,minY,maxY);
		var ray=HeightMap._tempRay;
		var rayDirE=ray.direction.elements;
		rayDirE[0]=0;
		rayDirE[1]=-1;
		rayDirE[2]=0;
		var heightOffset=0.1;
		var rayY=maxY+heightOffset;
		ray.origin.elements[1]=rayY;
		for (var h=0;h < height;h++){
			var posZ=minZ+h *cellHeight;
			heightMap._datas[h]=[];
			for (var w=0;w < width;w++){
				var posX=minX+w *cellWidth;
				var rayOriE=ray.origin.elements;
				rayOriE[0]=posX;
				rayOriE[2]=posZ;
				var closestIntersection=HeightMap._getPosition(ray,vertices,indexs);
				heightMap._datas[h][w]=(closestIntersection===Number.MAX_VALUE)? NaN :rayY-closestIntersection;
			}
		}
		return heightMap;
	}

	HeightMap.createFromImage=function(texture,minHeight,maxHeight){
		var textureWidth=texture.width;
		var textureHeight=texture.height;
		var heightMap=new HeightMap(textureWidth,textureHeight,minHeight,maxHeight);
		var compressionRatio=(maxHeight-minHeight)/ 254;
		var pixelsInfo=texture.getPixels();
		var index=0;
		for (var h=0;h <textureHeight;h++){
			var colDatas=heightMap._datas[h]=[];
			for (var w=0;w < textureWidth;w++){
				var r=pixelsInfo[index++];
				var g=pixelsInfo[index++];
				var b=pixelsInfo[index++];
				var a=pixelsInfo[index++];
				if (r==255 && g==255 && b==255 && a==255)
					colDatas[w]=NaN;
				else {
					colDatas[w]=(r+g+b)/ 3 *compressionRatio+minHeight;
				}
			}
		}
		return heightMap;
	}

	HeightMap._getPosition=function(ray,vertices,indexs){
		var closestIntersection=Number.MAX_VALUE;
		for (var i=0;i < vertices.length;i++){
			var subMeshVertices=vertices[i];
			var subMeshIndexes=indexs[i];
			for (var j=0;j < subMeshIndexes.length;j+=3){
				var vertex1=subMeshVertices[subMeshIndexes[j+0]];
				var vertex2=subMeshVertices[subMeshIndexes[j+1]];
				var vertex3=subMeshVertices[subMeshIndexes[j+2]];
				var intersection=Picker.rayIntersectsTriangle(ray,vertex1,vertex2,vertex3);
				if (!isNaN(intersection)&& intersection < closestIntersection){
					closestIntersection=intersection;
				}
			}
		}
		return closestIntersection;
	}

	__static(HeightMap,
	['_tempRay',function(){return this._tempRay=new Ray(new Vector3(),new Vector3());}
	]);
	return HeightMap;
})()


/**
*<code>Layer</code> 类用于实现层。
*/
//class laya.d3.core.Layer
var Layer=(function(){
	function Layer(){
		/**@private 编号。*/
		//this._number=0;
		/**@private 蒙版值。*/
		//this._mask=0;
		/**@private 是否显示。*/
		//this._visible=false;
		/**@private 只读,不允许修改。*/
		//this._nonRigidbodyOffset=0;
		/**@private 只读,不允许修改。*/
		//this._colliders=null;
		/**名字。*/
		//this.name=null;
		this._visible=true;
		this._nonRigidbodyOffset=0;
		this._colliders=[];
	}

	__class(Layer,'laya.d3.core.Layer');
	var __proto=Layer.prototype;
	/**
	*@private
	*/
	__proto._binarySearchIndex=function(){
		var start=0;
		var end=Layer._collsionTestList.length-1;
		var mid=0;
		while (start <=end){
			mid=Math.floor((start+end)/ 2);
			var midValue=Layer._collsionTestList[mid];
			if (midValue==this._number)
				return mid;
			else if (midValue > this._number)
			end=mid-1;
			else
			start=mid+1;
		}
		return start;
	}

	/**
	*@private
	*/
	__proto._addCollider=function(collider){
		(this._colliders.length===0)&& (Layer._collsionTestList.splice(this._binarySearchIndex(),0,this._number));
		if (collider._isRigidbody){
			this._colliders.unshift(collider);
			this._nonRigidbodyOffset++;
			}else {
			this._colliders.push(collider);
		}
	}

	/**
	*@private
	*/
	__proto._removeCollider=function(collider){
		var index=this._colliders.indexOf(collider);
		if (index < this._nonRigidbodyOffset)
			this._nonRigidbodyOffset--;
		this._colliders.splice(index,1);
		(this._colliders.length===0)&& (Layer._collsionTestList.splice(Layer._collsionTestList.indexOf(this._number),1));
	}

	/**
	*获取编号。
	*@return 编号。
	*/
	__getset(0,__proto,'number',function(){
		return this._number;
	});

	/**
	*设置是否显示。
	*@param value 是否显示。
	*/
	/**
	*获取是否显示。
	*@return 是否显示。
	*/
	__getset(0,__proto,'visible',function(){
		return this._visible;
		},function(value){
		this._visible=value;
		if (value)
			Layer._visibleLayers=Layer._visibleLayers | this.mask;
		else
		Layer._visibleLayers=Layer._visibleLayers & ~this.mask;
	});

	/**
	*获取蒙版值。
	*@return 蒙版值。
	*/
	__getset(0,__proto,'mask',function(){
		return this._mask;
	});

	/**
	*设置Layer显示层。
	*@param value 显示层。
	*/
	/**
	*获取Layer显示层。
	*@return 显示层。
	*/
	__getset(1,Layer,'visibleLayers',function(){
		return Layer._visibleLayers;
		},function(value){
		Layer._visibleLayers=value;
		for (var i=0,n=Layer._layerList.length;i < n;i++){
			var layer=Layer._layerList[i];
			layer._visible=(layer._mask & Layer._visibleLayers)!==0;
		}
	});

	Layer.__init__=function(){
		Layer._layerList.length=31;
		for (var i=0;i < 31;i++){
			var layer=new Layer();
			Layer._layerList[i]=layer;
			if (i===0){
				layer.name="Default Layer";
				layer.visible=true;
				}else {
				layer.name="Layer-"+i;
				layer.visible=false;
			}
			layer._number=i;
			layer._mask=Math.pow(2,i);
		}
		Layer.currentCreationLayer=Layer._layerList[0];
	}

	Layer.getLayerByNumber=function(number){
		if (number < 0 || number > 30)
			throw new Error("无法返回指定Layer，该number超出范围！");
		return Layer._layerList[number];
	}

	Layer.getLayerByName=function(name){
		for (var i=0;i < 31;i++){
			if (Layer._layerList[i].name===name)
				return Layer._layerList[i];
		}
		throw new Error("无法返回指定Layer,该name不存在");
	}

	Layer.isVisible=function(mask){
		return (mask & Layer._currentCameraCullingMask & Layer._visibleLayers)!=0;
	}

	Layer._layerList=[];
	Layer._visibleLayers=2147483647;
	Layer._collsionTestList=[];
	Layer._currentCameraCullingMask=2147483647;
	Layer.maxCount=31;
	Layer.currentCreationLayer=null;
	return Layer;
})()


/**
*<code>Burst</code> 类用于粒子的爆裂描述。
*/
//class laya.d3.core.particleShuriKen.module.Burst
var Burst=(function(){
	function Burst(time,minCount,maxCount){
		/**@private 爆裂时间,单位为秒。*/
		this._time=NaN;
		/**@private 爆裂的最小数量。*/
		this._minCount=0;
		/**@private 爆裂的最大数量。*/
		this._maxCount=0;
		this._time=time;
		this._minCount=minCount;
		this._maxCount=maxCount;
	}

	__class(Burst,'laya.d3.core.particleShuriKen.module.Burst');
	var __proto=Burst.prototype;
	Laya.imps(__proto,{"laya.d3.core.IClone":true})
	/**
	*克隆。
	*@param destObject 克隆源。
	*/
	__proto.cloneTo=function(destObject){
		var destBurst=destObject;
		destBurst._time=this._time
		destBurst._minCount=this._minCount;
		destBurst._maxCount=this._maxCount;
	}

	/**
	*克隆。
	*@return 克隆副本。
	*/
	__proto.clone=function(){
		var destBurst=/*__JS__ */new this.constructor();
		this.cloneTo(destBurst);
		return destBurst;
	}

	/**
	*获取爆裂时间,单位为秒。
	*@return 爆裂时间,单位为秒。
	*/
	__getset(0,__proto,'time',function(){
		return this._time;
	});

	/**
	*获取爆裂的最小数量。
	*@return 爆裂的最小数量。
	*/
	__getset(0,__proto,'minCount',function(){
		return this._minCount;
	});

	/**
	*获取爆裂的最大数量。
	*@return 爆裂的最大数量。
	*/
	__getset(0,__proto,'maxCount',function(){
		return this._maxCount;
	});

	return Burst;
})()


/**
*<code>ColorOverLifetime</code> 类用于粒子的生命周期颜色。
*/
//class laya.d3.core.particleShuriKen.module.ColorOverLifetime
var ColorOverLifetime=(function(){
	function ColorOverLifetime(color){
		/**@private */
		this._color=null;
		/**是否启用。*/
		this.enbale=false;
		this._color=color;
	}

	__class(ColorOverLifetime,'laya.d3.core.particleShuriKen.module.ColorOverLifetime');
	var __proto=ColorOverLifetime.prototype;
	/**
	*克隆。
	*@param destObject 克隆源。
	*/
	__proto.cloneTo=function(destObject){
		var destColorOverLifetime=destObject;
		this._color.cloneTo(destColorOverLifetime._color);
		destColorOverLifetime.enbale=this.enbale;
	}

	/**
	*克隆。
	*@return 克隆副本。
	*/
	__proto.clone=function(){
		var destColor;
		switch (this._color.type){
			case 0:
				destColor=GradientColor.createByConstant(this._color.constant.clone());
				break ;
			case 1:
				destColor=GradientColor.createByGradient(this._color.gradient.clone());
				break ;
			case 2:
				destColor=GradientColor.createByRandomTwoConstant(this._color.constantMin.clone(),this._color.constantMax.clone());
				break ;
			case 3:
				destColor=GradientColor.createByRandomTwoGradient(this._color.gradientMin.clone(),this._color.gradientMax.clone());
				break ;
			};
		var destColorOverLifetime=/*__JS__ */new this.constructor(destColor);
		destColorOverLifetime.enbale=this.enbale;
		return destColorOverLifetime;
	}

	/**
	*获取颜色。
	*/
	__getset(0,__proto,'color',function(){
		return this._color;
	});

	return ColorOverLifetime;
})()


/**
*<code>Emission</code> 类用于粒子发射器。
*/
//class laya.d3.core.particleShuriKen.module.Emission
var Emission=(function(){
	function Emission(){
		/**@private */
		this._destroyed=false;
		/**@private 粒子发射速率,每秒发射的个数。*/
		this._emissionRate=0;
		/**@private 粒子的爆裂,不允许修改。*/
		this._bursts=null;
		/**是否启用。*/
		this.enbale=false;
		this._destroyed=false;
		this.emissionRate=10;
		this._bursts=[];
	}

	__class(Emission,'laya.d3.core.particleShuriKen.module.Emission');
	var __proto=Emission.prototype;
	Laya.imps(__proto,{"laya.d3.core.IClone":true,"laya.resource.IDestroy":true})
	/**
	*@private
	*/
	__proto._destroy=function(){
		this._bursts=null;
		this._destroyed=true;
	}

	/**
	*获取粒子爆裂个数。
	*@return 粒子爆裂个数。
	*/
	__proto.getBurstsCount=function(){
		return this._bursts.length;
	}

	/**
	*通过索引获取粒子爆裂。
	*@param index 爆裂索引。
	*@return 粒子爆裂。
	*/
	__proto.getBurstByIndex=function(index){
		return this._bursts[index];
	}

	/**
	*增加粒子爆裂。
	*@param burst 爆裂。
	*/
	__proto.addBurst=function(burst){
		var burstsCount=this._bursts.length;
		if (burstsCount > 0)
			for (var i=0;i < burstsCount;i++){
			if (this._bursts[i].time > burst.time)
				this._bursts.splice(i,0,burst);
		}
		this._bursts.push(burst);
	}

	/**
	*移除粒子爆裂。
	*@param burst 爆裂。
	*/
	__proto.removeBurst=function(burst){
		var index=this._bursts.indexOf(burst);
		if (index!==-1){
			this._bursts.splice(index,1);
		}
	}

	/**
	*通过索引移除粒子爆裂。
	*@param index 爆裂索引。
	*/
	__proto.removeBurstByIndex=function(index){
		this._bursts.splice(index,1);
	}

	/**
	*清空粒子爆裂。
	*/
	__proto.clearBurst=function(){
		this._bursts.length=0;
	}

	/**
	*克隆。
	*@param destObject 克隆源。
	*/
	__proto.cloneTo=function(destObject){
		var destEmission=destObject;
		var destBursts=destEmission._bursts;
		destBursts.length=this._bursts.length;
		for (var i=0,n=this._bursts.length;i < n;i++){
			var destBurst=destBursts[i];
			if (destBurst)
				this._bursts[i].cloneTo(destBurst);
			else
			destBursts[i]=this._bursts[i].clone();
		}
		destEmission._emissionRate=this._emissionRate;
		destEmission.enbale=this.enbale;
	}

	/**
	*克隆。
	*@return 克隆副本。
	*/
	__proto.clone=function(){
		var destEmission=/*__JS__ */new this.constructor();
		this.cloneTo(destEmission);
		return destEmission;
	}

	/**
	*获取是否已销毁。
	*@return 是否已销毁。
	*/
	__getset(0,__proto,'destroyed',function(){
		return this._destroyed;
	});

	/**
	*设置粒子发射速率。
	*@param emissionRate 粒子发射速率 (个/秒)。
	*/
	/**
	*获取粒子发射速率。
	*@return 粒子发射速率 (个/秒)。
	*/
	__getset(0,__proto,'emissionRate',function(){
		return this._emissionRate;
		},function(value){
		if (value < 0)
			throw new Error("ParticleBaseShape:emissionRate value must large or equal than 0.");
		this._emissionRate=value;
	});

	return Emission;
})()


/**
*<code>FrameOverTime</code> 类用于创建时间帧。
*/
//class laya.d3.core.particleShuriKen.module.FrameOverTime
var FrameOverTime=(function(){
	function FrameOverTime(){
		/**@private */
		this._type=0;
		/**@private */
		this._constant=0;
		/**@private */
		this._overTime=null;
		/**@private */
		this._constantMin=0;
		/**@private */
		this._constantMax=0;
		/**@private */
		this._overTimeMin=null;
		/**@private */
		this._overTimeMax=null;
	}

	__class(FrameOverTime,'laya.d3.core.particleShuriKen.module.FrameOverTime');
	var __proto=FrameOverTime.prototype;
	Laya.imps(__proto,{"laya.d3.core.IClone":true})
	/**
	*克隆。
	*@param destObject 克隆源。
	*/
	__proto.cloneTo=function(destObject){
		var destFrameOverTime=destObject;
		destFrameOverTime._type=this._type;
		destFrameOverTime._constant=this._constant;
		this._overTime.cloneTo(destFrameOverTime._overTime);
		destFrameOverTime._constantMin=this._constantMin;
		destFrameOverTime._constantMax=this._constantMax;
		this._overTimeMin.cloneTo(destFrameOverTime._overTimeMin);
		this._overTimeMax.cloneTo(destFrameOverTime._overTimeMax);
	}

	/**
	*克隆。
	*@return 克隆副本。
	*/
	__proto.clone=function(){
		var destFrameOverTime=/*__JS__ */new this.constructor();
		this.cloneTo(destFrameOverTime);
		return destFrameOverTime;
	}

	/**
	*时间帧。
	*/
	__getset(0,__proto,'frameOverTimeData',function(){
		return this._overTime;
	});

	/**
	*固定帧。
	*/
	__getset(0,__proto,'constant',function(){
		return this._constant;
	});

	/**
	*生命周期旋转类型,0常量模式，1曲线模式，2随机双常量模式，3随机双曲线模式。
	*/
	__getset(0,__proto,'type',function(){
		return this._type;
	});

	/**
	*最小时间帧。
	*/
	__getset(0,__proto,'frameOverTimeDataMin',function(){
		return this._overTimeMin;
	});

	/**
	*最小固定帧。
	*/
	__getset(0,__proto,'constantMin',function(){
		return this._constantMin;
	});

	/**
	*最大时间帧。
	*/
	__getset(0,__proto,'frameOverTimeDataMax',function(){
		return this._overTimeMax;
	});

	/**
	*最大固定帧。
	*/
	__getset(0,__proto,'constantMax',function(){
		return this._constantMax;
	});

	FrameOverTime.createByConstant=function(constant){
		var rotationOverLifetime=new FrameOverTime();
		rotationOverLifetime._type=0;
		rotationOverLifetime._constant=constant;
		return rotationOverLifetime;
	}

	FrameOverTime.createByOverTime=function(overTime){
		var rotationOverLifetime=new FrameOverTime();
		rotationOverLifetime._type=1;
		rotationOverLifetime._overTime=overTime;
		return rotationOverLifetime;
	}

	FrameOverTime.createByRandomTwoConstant=function(constantMin,constantMax){
		var rotationOverLifetime=new FrameOverTime();
		rotationOverLifetime._type=2;
		rotationOverLifetime._constantMin=constantMin;
		rotationOverLifetime._constantMax=constantMax;
		return rotationOverLifetime;
	}

	FrameOverTime.createByRandomTwoOverTime=function(gradientFrameMin,gradientFrameMax){
		var rotationOverLifetime=new FrameOverTime();
		rotationOverLifetime._type=3;
		rotationOverLifetime._overTimeMin=gradientFrameMin;
		rotationOverLifetime._overTimeMax=gradientFrameMax;
		return rotationOverLifetime;
	}

	return FrameOverTime;
})()


/**
*<code>GradientRotation</code> 类用于创建渐变角速度。
*/
//class laya.d3.core.particleShuriKen.module.GradientAngularVelocity
var GradientAngularVelocity=(function(){
	function GradientAngularVelocity(){
		/**@private */
		this._type=0;
		/**@private */
		this._separateAxes=false;
		/**@private */
		this._constant=NaN;
		/**@private */
		this._constantSeparate=null;
		/**@private */
		this._gradient=null;
		/**@private */
		this._gradientX=null;
		/**@private */
		this._gradientY=null;
		/**@private */
		this._gradientZ=null;
		/**@private */
		this._gradientW=null;
		/**@private */
		this._constantMin=NaN;
		/**@private */
		this._constantMax=NaN;
		/**@private */
		this._constantMinSeparate=null;
		/**@private */
		this._constantMaxSeparate=null;
		/**@private */
		this._gradientMin=null;
		/**@private */
		this._gradientMax=null;
		/**@private */
		this._gradientXMin=null;
		/**@private */
		this._gradientXMax=null;
		/**@private */
		this._gradientYMin=null;
		/**@private */
		this._gradientYMax=null;
		/**@private */
		this._gradientZMin=null;
		/**@private */
		this._gradientZMax=null;
		/**@private */
		this._gradientWMin=null;
		/**@private */
		this._gradientWMax=null;
	}

	__class(GradientAngularVelocity,'laya.d3.core.particleShuriKen.module.GradientAngularVelocity');
	var __proto=GradientAngularVelocity.prototype;
	Laya.imps(__proto,{"laya.d3.core.IClone":true})
	/**
	*克隆。
	*@param destObject 克隆源。
	*/
	__proto.cloneTo=function(destObject){
		var destGradientAngularVelocity=destObject;
		destGradientAngularVelocity._type=this._type;
		destGradientAngularVelocity._separateAxes=this._separateAxes;
		destGradientAngularVelocity._constant=this._constant;
		this._constantSeparate.cloneTo(destGradientAngularVelocity._constantSeparate);
		this._gradient.cloneTo(destGradientAngularVelocity._gradient);
		this._gradientX.cloneTo(destGradientAngularVelocity._gradientX);
		this._gradientY.cloneTo(destGradientAngularVelocity._gradientY);
		this._gradientZ.cloneTo(destGradientAngularVelocity._gradientZ);
		destGradientAngularVelocity._constantMin=this._constantMin;
		destGradientAngularVelocity._constantMax=this._constantMax;
		this._constantMinSeparate.cloneTo(destGradientAngularVelocity._constantMinSeparate);
		this._constantMaxSeparate.cloneTo(destGradientAngularVelocity._constantMaxSeparate);
		this._gradientMin.cloneTo(destGradientAngularVelocity._gradientMin);
		this._gradientMax.cloneTo(destGradientAngularVelocity._gradientMax);
		this._gradientXMin.cloneTo(destGradientAngularVelocity._gradientXMin);
		this._gradientXMax.cloneTo(destGradientAngularVelocity._gradientXMax);
		this._gradientYMin.cloneTo(destGradientAngularVelocity._gradientYMin);
		this._gradientYMax.cloneTo(destGradientAngularVelocity._gradientYMax);
		this._gradientZMin.cloneTo(destGradientAngularVelocity._gradientZMin);
		this._gradientZMax.cloneTo(destGradientAngularVelocity._gradientZMax);
	}

	/**
	*克隆。
	*@return 克隆副本。
	*/
	__proto.clone=function(){
		var destGradientAngularVelocity=/*__JS__ */new this.constructor();
		this.cloneTo(destGradientAngularVelocity);
		return destGradientAngularVelocity;
	}

	/**
	*渐变角速度Z。
	*/
	__getset(0,__proto,'gradientZ',function(){
		return this._gradientZ;
	});

	/**
	*固定角速度。
	*/
	__getset(0,__proto,'constant',function(){
		return this._constant;
	});

	/**
	*渐变角速度。
	*/
	__getset(0,__proto,'gradient',function(){
		return this._gradient;
	});

	/**
	*是否分轴。
	*/
	__getset(0,__proto,'separateAxes',function(){
		return this._separateAxes;
	});

	/**
	*生命周期角速度类型,0常量模式，1曲线模式，2随机双常量模式，3随机双曲线模式。
	*/
	__getset(0,__proto,'type',function(){
		return this._type;
	});

	/**
	*分轴固定角速度。
	*/
	__getset(0,__proto,'constantSeparate',function(){
		return this._constantSeparate;
	});

	/**
	*渐变角角速度X。
	*/
	__getset(0,__proto,'gradientX',function(){
		return this._gradientX;
	});

	/**
	*渐变角速度Y。
	*/
	__getset(0,__proto,'gradientY',function(){
		return this._gradientY;
	});

	/**
	*渐变角速度Z。
	*/
	__getset(0,__proto,'gradientW',function(){
		return this._gradientW;
	});

	/**
	*最小渐变角速度。
	*/
	__getset(0,__proto,'gradientMin',function(){
		return this._gradientMin;
	});

	/**
	*最小随机双固定角速度。
	*/
	__getset(0,__proto,'constantMin',function(){
		return this._constantMin;
	});

	/**
	*最大渐变角速度。
	*/
	__getset(0,__proto,'gradientMax',function(){
		return this._gradientMax;
	});

	/**
	*最大随机双固定角速度。
	*/
	__getset(0,__proto,'constantMax',function(){
		return this._constantMax;
	});

	/**
	*最小渐变角速度Z。
	*/
	__getset(0,__proto,'gradientWMin',function(){
		return this._gradientWMin;
	});

	/**
	*最小分轴随机双固定角速度。
	*/
	__getset(0,__proto,'constantMinSeparate',function(){
		return this._constantMinSeparate;
	});

	/**
	*最大分轴随机双固定角速度。
	*/
	__getset(0,__proto,'constantMaxSeparate',function(){
		return this._constantMaxSeparate;
	});

	/**
	*最小渐变角速度X。
	*/
	__getset(0,__proto,'gradientXMin',function(){
		return this._gradientXMin;
	});

	/**
	*最大渐变角速度X。
	*/
	__getset(0,__proto,'gradientXMax',function(){
		return this._gradientXMax;
	});

	/**
	*最大渐变角速度Z。
	*/
	__getset(0,__proto,'gradientWMax',function(){
		return this._gradientWMax;
	});

	/**
	*最小渐变角速度Y。
	*/
	__getset(0,__proto,'gradientYMin',function(){
		return this._gradientYMin;
	});

	/**
	*最大渐变角速度Y。
	*/
	__getset(0,__proto,'gradientYMax',function(){
		return this._gradientYMax;
	});

	/**
	*最小渐变角速度Z。
	*/
	__getset(0,__proto,'gradientZMin',function(){
		return this._gradientZMin;
	});

	/**
	*最大渐变角速度Z。
	*/
	__getset(0,__proto,'gradientZMax',function(){
		return this._gradientZMax;
	});

	GradientAngularVelocity.createByConstant=function(constant){
		var gradientAngularVelocity=new GradientAngularVelocity();
		gradientAngularVelocity._type=0;
		gradientAngularVelocity._separateAxes=false;
		gradientAngularVelocity._constant=constant;
		return gradientAngularVelocity;
	}

	GradientAngularVelocity.createByConstantSeparate=function(separateConstant){
		var gradientAngularVelocity=new GradientAngularVelocity();
		gradientAngularVelocity._type=0;
		gradientAngularVelocity._separateAxes=true;
		gradientAngularVelocity._constantSeparate=separateConstant;
		return gradientAngularVelocity;
	}

	GradientAngularVelocity.createByGradient=function(gradient){
		var gradientAngularVelocity=new GradientAngularVelocity();
		gradientAngularVelocity._type=1;
		gradientAngularVelocity._separateAxes=false;
		gradientAngularVelocity._gradient=gradient;
		return gradientAngularVelocity;
	}

	GradientAngularVelocity.createByGradientSeparate=function(gradientX,gradientY,gradientZ,gradientW){
		var gradientAngularVelocity=new GradientAngularVelocity();
		gradientAngularVelocity._type=1;
		gradientAngularVelocity._separateAxes=true;
		gradientAngularVelocity._gradientX=gradientX;
		gradientAngularVelocity._gradientY=gradientY;
		gradientAngularVelocity._gradientZ=gradientZ;
		gradientAngularVelocity._gradientW=gradientW;
		return gradientAngularVelocity;
	}

	GradientAngularVelocity.createByRandomTwoConstant=function(constantMin,constantMax){
		var gradientAngularVelocity=new GradientAngularVelocity();
		gradientAngularVelocity._type=2;
		gradientAngularVelocity._separateAxes=false;
		gradientAngularVelocity._constantMin=constantMin;
		gradientAngularVelocity._constantMax=constantMax;
		return gradientAngularVelocity;
	}

	GradientAngularVelocity.createByRandomTwoConstantSeparate=function(separateConstantMin,separateConstantMax){
		var gradientAngularVelocity=new GradientAngularVelocity();
		gradientAngularVelocity._type=2;
		gradientAngularVelocity._separateAxes=true;
		gradientAngularVelocity._constantMinSeparate=separateConstantMin;
		gradientAngularVelocity._constantMaxSeparate=separateConstantMax;
		return gradientAngularVelocity;
	}

	GradientAngularVelocity.createByRandomTwoGradient=function(gradientMin,gradientMax){
		var gradientAngularVelocity=new GradientAngularVelocity();
		gradientAngularVelocity._type=3;
		gradientAngularVelocity._separateAxes=false;
		gradientAngularVelocity._gradientMin=gradientMin;
		gradientAngularVelocity._gradientMax=gradientMax;
		return gradientAngularVelocity;
	}

	GradientAngularVelocity.createByRandomTwoGradientSeparate=function(gradientXMin,gradientXMax,gradientYMin,gradientYMax,gradientZMin,gradientZMax,gradientWMin,gradientWMax){
		var gradientAngularVelocity=new GradientAngularVelocity();
		gradientAngularVelocity._type=3;
		gradientAngularVelocity._separateAxes=true;
		gradientAngularVelocity._gradientXMin=gradientXMin;
		gradientAngularVelocity._gradientXMax=gradientXMax;
		gradientAngularVelocity._gradientYMin=gradientYMin;
		gradientAngularVelocity._gradientYMax=gradientYMax;
		gradientAngularVelocity._gradientZMin=gradientZMin;
		gradientAngularVelocity._gradientZMax=gradientZMax;
		gradientAngularVelocity._gradientWMin=gradientWMin;
		gradientAngularVelocity._gradientWMax=gradientWMax;
		return gradientAngularVelocity;
	}

	return GradientAngularVelocity;
})()


/**
*<code>GradientColor</code> 类用于创建渐变颜色。
*/
//class laya.d3.core.particleShuriKen.module.GradientColor
var GradientColor=(function(){
	function GradientColor(){
		/**@private */
		this._type=0;
		/**@private */
		this._constant=null;
		/**@private */
		this._constantMin=null;
		/**@private */
		this._constantMax=null;
		/**@private */
		this._gradient=null;
		/**@private */
		this._gradientMin=null;
		/**@private */
		this._gradientMax=null;
	}

	__class(GradientColor,'laya.d3.core.particleShuriKen.module.GradientColor');
	var __proto=GradientColor.prototype;
	Laya.imps(__proto,{"laya.d3.core.IClone":true})
	/**
	*克隆。
	*@param destObject 克隆源。
	*/
	__proto.cloneTo=function(destObject){
		var destGradientColor=destObject;
		destGradientColor._type=this._type;
		this._constant.cloneTo(destGradientColor._constant);
		this._constantMin.cloneTo(destGradientColor._constantMin);
		this._constantMax.cloneTo(destGradientColor._constantMax);
		this._gradient.cloneTo(destGradientColor._gradient);
		this._gradientMin.cloneTo(destGradientColor._gradientMin);
		this._gradientMax.cloneTo(destGradientColor._gradientMax);
	}

	/**
	*克隆。
	*@return 克隆副本。
	*/
	__proto.clone=function(){
		var destGradientColor=/*__JS__ */new this.constructor();
		this.cloneTo(destGradientColor);
		return destGradientColor;
	}

	/**
	*渐变颜色。
	*/
	__getset(0,__proto,'gradient',function(){
		return this._gradient;
	});

	/**
	*固定颜色。
	*/
	__getset(0,__proto,'constant',function(){
		return this._constant;
	});

	/**
	*生命周期颜色类型,0为固定颜色模式,1渐变模式,2为随机双固定颜色模式,3随机双渐变模式。
	*/
	__getset(0,__proto,'type',function(){
		return this._type;
	});

	/**
	*最小渐变颜色。
	*/
	__getset(0,__proto,'gradientMin',function(){
		return this._gradientMin;
	});

	/**
	*最小固定颜色。
	*/
	__getset(0,__proto,'constantMin',function(){
		return this._constantMin;
	});

	/**
	*最大渐变颜色。
	*/
	__getset(0,__proto,'gradientMax',function(){
		return this._gradientMax;
	});

	/**
	*最大固定颜色。
	*/
	__getset(0,__proto,'constantMax',function(){
		return this._constantMax;
	});

	GradientColor.createByConstant=function(constant){
		var gradientColor=new GradientColor();
		gradientColor._type=0;
		gradientColor._constant=constant;
		return gradientColor;
	}

	GradientColor.createByGradient=function(gradient){
		var gradientColor=new GradientColor();
		gradientColor._type=1;
		gradientColor._gradient=gradient;
		return gradientColor;
	}

	GradientColor.createByRandomTwoConstant=function(minConstant,maxConstant){
		var gradientColor=new GradientColor();
		gradientColor._type=2;
		gradientColor._constantMin=minConstant;
		gradientColor._constantMax=maxConstant;
		return gradientColor;
	}

	GradientColor.createByRandomTwoGradient=function(minGradient,maxGradient){
		var gradientColor=new GradientColor();
		gradientColor._type=3;
		gradientColor._gradientMin=minGradient;
		gradientColor._gradientMax=maxGradient;
		return gradientColor;
	}

	return GradientColor;
})()


/**
*<code>GradientDataColor</code> 类用于创建颜色渐变。
*/
//class laya.d3.core.particleShuriKen.module.GradientDataColor
var GradientDataColor=(function(){
	function GradientDataColor(){
		/**@private */
		this._alphaCurrentLength=0;
		/**@private */
		this._rgbCurrentLength=0;
		/**@private 开发者禁止修改。*/
		this._alphaElements=null;
		/**@private 开发者禁止修改。*/
		this._rgbElements=null;
		this._alphaElements=new Float32Array(8);
		this._rgbElements=new Float32Array(16);
	}

	__class(GradientDataColor,'laya.d3.core.particleShuriKen.module.GradientDataColor');
	var __proto=GradientDataColor.prototype;
	Laya.imps(__proto,{"laya.d3.core.IClone":true})
	/**
	*增加Alpha渐变。
	*@param key 生命周期，范围为0到1。
	*@param value rgb值。
	*/
	__proto.addAlpha=function(key,value){
		if (this._alphaCurrentLength < 8){
			if ((this._alphaCurrentLength===6)&& ((key!==1))){
				key=1;
				console.log("GradientDataColor warning:the forth key is  be force set to 1.");
			}
			this._alphaElements[this._alphaCurrentLength++]=key;
			this._alphaElements[this._alphaCurrentLength++]=value;
			}else {
			console.log("GradientDataColor warning:data count must lessEqual than 4");
		}
	}

	/**
	*增加RGB渐变。
	*@param key 生命周期，范围为0到1。
	*@param value RGB值。
	*/
	__proto.addRGB=function(key,value){
		if (this._rgbCurrentLength < 16){
			if ((this._rgbCurrentLength===12)&& ((key!==1))){
				key=1;
				console.log("GradientDataColor warning:the forth key is  be force set to 1.");
			}
			this._rgbElements[this._rgbCurrentLength++]=key;
			this._rgbElements[this._rgbCurrentLength++]=value.x;
			this._rgbElements[this._rgbCurrentLength++]=value.y;
			this._rgbElements[this._rgbCurrentLength++]=value.z;
			}else {
			console.log("GradientDataColor warning:data count must lessEqual than 4");
		}
	}

	/**
	*克隆。
	*@param destObject 克隆源。
	*/
	__proto.cloneTo=function(destObject){
		var destGradientDataColor=destObject;
		var i=0,n=0;
		destGradientDataColor._alphaCurrentLength=this._alphaCurrentLength;
		var destAlphaElements=destGradientDataColor._alphaElements;
		destAlphaElements.length=this._alphaElements.length;
		for (i=0,n=this._alphaElements.length;i < n;i++)
		destAlphaElements[i]=this._alphaElements[i];
		destGradientDataColor._rgbCurrentLength=this._rgbCurrentLength;
		var destRGBElements=destGradientDataColor._rgbElements;
		destRGBElements.length=this._rgbElements.length;
		for (i=0,n=this._rgbElements.length;i < n;i++)
		destRGBElements[i]=this._rgbElements[i];
	}

	/**
	*克隆。
	*@return 克隆副本。
	*/
	__proto.clone=function(){
		var destGradientDataColor=/*__JS__ */new this.constructor();
		this.cloneTo(destGradientDataColor);
		return destGradientDataColor;
	}

	/**渐变Alpha数量。*/
	__getset(0,__proto,'alphaGradientCount',function(){
		return this._alphaCurrentLength / 2;
	});

	/**渐变RGB数量。*/
	__getset(0,__proto,'rgbGradientCount',function(){
		return this._rgbCurrentLength / 4;
	});

	return GradientDataColor;
})()


/**
*<code>GradientDataInt</code> 类用于创建整形渐变。
*/
//class laya.d3.core.particleShuriKen.module.GradientDataInt
var GradientDataInt=(function(){
	function GradientDataInt(){
		/**@private */
		this._currentLength=0;
		/**@private 开发者禁止修改。*/
		this._elements=null;
		this._elements=new Float32Array(8);
	}

	__class(GradientDataInt,'laya.d3.core.particleShuriKen.module.GradientDataInt');
	var __proto=GradientDataInt.prototype;
	Laya.imps(__proto,{"laya.d3.core.IClone":true})
	/**
	*增加整形渐变。
	*@param key 生命周期，范围为0到1。
	*@param value 整形值。
	*/
	__proto.add=function(key,value){
		if (this._currentLength < 8){
			if ((this._currentLength===6)&& ((key!==1))){
				key=1;
				console.log("Warning:the forth key is  be force set to 1.");
			}
			this._elements[this._currentLength++]=key;
			this._elements[this._currentLength++]=value;
			}else {
			console.log("Warning:data count must lessEqual than 4");
		}
	}

	/**
	*克隆。
	*@param destObject 克隆源。
	*/
	__proto.cloneTo=function(destObject){
		var destGradientDataInt=destObject;
		destGradientDataInt._currentLength=this._currentLength;
		var destElements=destGradientDataInt._elements;
		destElements.length=this._elements.length;
		for (var i=0,n=this._elements.length;i < n;i++){
			destElements[i]=this._elements[i];
		}
	}

	/**
	*克隆。
	*@return 克隆副本。
	*/
	__proto.clone=function(){
		var destGradientDataInt=/*__JS__ */new this.constructor();
		this.cloneTo(destGradientDataInt);
		return destGradientDataInt;
	}

	/**整形渐变数量。*/
	__getset(0,__proto,'gradientCount',function(){
		return this._currentLength / 2;
	});

	return GradientDataInt;
})()


/**
*<code>GradientDataNumber</code> 类用于创建浮点渐变。
*/
//class laya.d3.core.particleShuriKen.module.GradientDataNumber
var GradientDataNumber=(function(){
	function GradientDataNumber(){
		/**@private */
		this._currentLength=0;
		/**@private 开发者禁止修改。*/
		this._elements=null;
		this._elements=new Float32Array(8);
	}

	__class(GradientDataNumber,'laya.d3.core.particleShuriKen.module.GradientDataNumber');
	var __proto=GradientDataNumber.prototype;
	Laya.imps(__proto,{"laya.d3.core.IClone":true})
	/**
	*增加浮点渐变。
	*@param key 生命周期，范围为0到1。
	*@param value 浮点值。
	*/
	__proto.add=function(key,value){
		if (this._currentLength < 8){
			if ((this._currentLength===6)&& ((key!==1))){
				key=1;
				console.log("GradientDataNumber warning:the forth key is  be force set to 1.");
			}
			this._elements[this._currentLength++]=key;
			this._elements[this._currentLength++]=value;
			}else {
			console.log("GradientDataNumber warning:data count must lessEqual than 4");
		}
	}

	/**
	*通过索引获取键。
	*@param index 索引。
	*@return value 键。
	*/
	__proto.getKeyByIndex=function(index){
		return this._elements[index *2];
	}

	/**
	*通过索引获取值。
	*@param index 索引。
	*@return value 值。
	*/
	__proto.getValueByIndex=function(index){
		return this._elements[index *2+1];
	}

	/**
	*获取平均值。
	*/
	__proto.getAverageValue=function(){
		var total=0;
		for (var i=0,n=this._currentLength-2;i < n;i+=2){
			var subValue=this._elements[i+1];
			subValue+=this._elements[i+3];
			subValue=subValue *(this._elements[i+2]-this._elements[i]);
		}
		return total / 2;
	}

	/**
	*克隆。
	*@param destObject 克隆源。
	*/
	__proto.cloneTo=function(destObject){
		var destGradientDataNumber=destObject;
		destGradientDataNumber._currentLength=this._currentLength;
		var destElements=destGradientDataNumber._elements;
		destElements.length=this._elements.length;
		for (var i=0,n=this._elements.length;i < n;i++)
		destElements[i]=this._elements[i];
	}

	/**
	*克隆。
	*@return 克隆副本。
	*/
	__proto.clone=function(){
		var destGradientDataNumber=/*__JS__ */new this.constructor();
		this.cloneTo(destGradientDataNumber);
		return destGradientDataNumber;
	}

	/**渐变浮点数量。*/
	__getset(0,__proto,'gradientCount',function(){
		return this._currentLength / 2;
	});

	return GradientDataNumber;
})()


/**
*<code>GradientDataVector2</code> 类用于创建二维向量渐变。
*/
//class laya.d3.core.particleShuriKen.module.GradientDataVector2
var GradientDataVector2=(function(){
	function GradientDataVector2(){
		/**@private */
		this._currentLength=0;
		/**@private 开发者禁止修改。*/
		this._elements=null;
		this._elements=new Float32Array(12);
	}

	__class(GradientDataVector2,'laya.d3.core.particleShuriKen.module.GradientDataVector2');
	var __proto=GradientDataVector2.prototype;
	Laya.imps(__proto,{"laya.d3.core.IClone":true})
	/**
	*增加二维向量渐变。
	*@param key 生命周期，范围为0到1。
	*@param value 二维向量值。
	*/
	__proto.add=function(key,value){
		if (this._currentLength < 8){
			if ((this._currentLength===6)&& ((key!==1))){
				key=1;
				console.log("GradientDataVector2 warning:the forth key is  be force set to 1.");
			}
			this._elements[this._currentLength++]=key;
			this._elements[this._currentLength++]=value.x;
			this._elements[this._currentLength++]=value.y;
			}else {
			console.log("GradientDataVector2 warning:data count must lessEqual than 4");
		}
	}

	/**
	*克隆。
	*@param destObject 克隆源。
	*/
	__proto.cloneTo=function(destObject){
		var destGradientDataVector2=destObject;
		destGradientDataVector2._currentLength=this._currentLength;
		var destElements=destGradientDataVector2._elements;
		destElements.length=this._elements.length;
		for (var i=0,n=this._elements.length;i < n;i++){
			destElements[i]=this._elements[i];
		}
	}

	/**
	*克隆。
	*@return 克隆副本。
	*/
	__proto.clone=function(){
		var destGradientDataVector2=/*__JS__ */new this.constructor();
		this.cloneTo(destGradientDataVector2);
		return destGradientDataVector2;
	}

	/**二维向量渐变数量。*/
	__getset(0,__proto,'gradientCount',function(){
		return this._currentLength / 3;
	});

	return GradientDataVector2;
})()


/**
*<code>GradientSize</code> 类用于创建渐变尺寸。
*/
//class laya.d3.core.particleShuriKen.module.GradientSize
var GradientSize=(function(){
	function GradientSize(){
		/**@private */
		this._type=0;
		/**@private */
		this._separateAxes=false;
		/**@private */
		this._gradient=null;
		/**@private */
		this._gradientX=null;
		/**@private */
		this._gradientY=null;
		/**@private */
		this._gradientZ=null;
		/**@private */
		this._constantMin=NaN;
		/**@private */
		this._constantMax=NaN;
		/**@private */
		this._constantMinSeparate=null;
		/**@private */
		this._constantMaxSeparate=null;
		/**@private */
		this._gradientMin=null;
		/**@private */
		this._gradientMax=null;
		/**@private */
		this._gradientXMin=null;
		/**@private */
		this._gradientXMax=null;
		/**@private */
		this._gradientYMin=null;
		/**@private */
		this._gradientYMax=null;
		/**@private */
		this._gradientZMin=null;
		/**@private */
		this._gradientZMax=null;
	}

	__class(GradientSize,'laya.d3.core.particleShuriKen.module.GradientSize');
	var __proto=GradientSize.prototype;
	Laya.imps(__proto,{"laya.d3.core.IClone":true})
	/**
	*获取最大尺寸。
	*/
	__proto.getMaxSizeInGradient=function(){
		var i=0,n=0;
		var maxSize=-Number.MAX_VALUE;
		switch (this._type){
			case 0:
				if (this._separateAxes){
					for (i=0,n=this._gradientX.gradientCount;i < n;i++)
					maxSize=Math.max(maxSize,this._gradientX.getValueByIndex(i));
					for (i=0,n=this._gradientY.gradientCount;i < n;i++)
					maxSize=Math.max(maxSize,this._gradientY.getValueByIndex(i));
					}else {
					for (i=0,n=this._gradient.gradientCount;i < n;i++)
					maxSize=Math.max(maxSize,this._gradient.getValueByIndex(i));
				}
				break ;
			case 1:
				if (this._separateAxes){
					maxSize=Math.max(this._constantMinSeparate.x,this._constantMaxSeparate.x);
					maxSize=Math.max(maxSize,this._constantMinSeparate.y);
					maxSize=Math.max(maxSize,this._constantMaxSeparate.y);
					}else {
					maxSize=Math.max(this._constantMin,this._constantMax);
				}
				break ;
			case 2:
				if (this._separateAxes){
					for (i=0,n=this._gradientXMin.gradientCount;i < n;i++)
					maxSize=Math.max(maxSize,this._gradientXMin.getValueByIndex(i));
					for (i=0,n=this._gradientXMax.gradientCount;i < n;i++)
					maxSize=Math.max(maxSize,this._gradientXMax.getValueByIndex(i));
					for (i=0,n=this._gradientYMin.gradientCount;i < n;i++)
					maxSize=Math.max(maxSize,this._gradientYMin.getValueByIndex(i));
					for (i=0,n=this._gradientZMax.gradientCount;i < n;i++)
					maxSize=Math.max(maxSize,this._gradientZMax.getValueByIndex(i));
					}else {
					for (i=0,n=this._gradientMin.gradientCount;i < n;i++)
					maxSize=Math.max(maxSize,this._gradientMin.getValueByIndex(i));
					for (i=0,n=this._gradientMax.gradientCount;i < n;i++)
					maxSize=Math.max(maxSize,this._gradientMax.getValueByIndex(i));
				}
				break ;
			}
		return maxSize;
	}

	/**
	*克隆。
	*@param destObject 克隆源。
	*/
	__proto.cloneTo=function(destObject){
		var destGradientSize=destObject;
		destGradientSize._type=this._type;
		destGradientSize._separateAxes=this._separateAxes;
		this._gradient.cloneTo(destGradientSize._gradient);
		this._gradientX.cloneTo(destGradientSize._gradientX);
		this._gradientY.cloneTo(destGradientSize._gradientY);
		this._gradientZ.cloneTo(destGradientSize._gradientZ);
		destGradientSize._constantMin=this._constantMin;
		destGradientSize._constantMax=this._constantMax;
		this._constantMinSeparate.cloneTo(destGradientSize._constantMinSeparate);
		this._constantMaxSeparate.cloneTo(destGradientSize._constantMaxSeparate);
		this._gradientMin.cloneTo(destGradientSize._gradientMin);
		this._gradientMax.cloneTo(destGradientSize._gradientMax);
		this._gradientXMin.cloneTo(destGradientSize._gradientXMin);
		this._gradientXMax.cloneTo(destGradientSize._gradientXMax);
		this._gradientYMin.cloneTo(destGradientSize._gradientYMin);
		this._gradientYMax.cloneTo(destGradientSize._gradientYMax);
		this._gradientZMin.cloneTo(destGradientSize._gradientZMin);
		this._gradientZMax.cloneTo(destGradientSize._gradientZMax);
	}

	/**
	*克隆。
	*@return 克隆副本。
	*/
	__proto.clone=function(){
		var destGradientSize=/*__JS__ */new this.constructor();
		this.cloneTo(destGradientSize);
		return destGradientSize;
	}

	/**
	*渐变尺寸Z。
	*/
	__getset(0,__proto,'gradientZ',function(){
		return this._gradientZ;
	});

	/**
	*渐变尺寸。
	*/
	__getset(0,__proto,'gradient',function(){
		return this._gradient;
	});

	/**
	*是否分轴。
	*/
	__getset(0,__proto,'separateAxes',function(){
		return this._separateAxes;
	});

	/**
	*生命周期尺寸类型，0曲线模式，1随机双常量模式，2随机双曲线模式。
	*/
	__getset(0,__proto,'type',function(){
		return this._type;
	});

	/**
	*渐变最小尺寸。
	*/
	__getset(0,__proto,'gradientMin',function(){
		return this._gradientMin;
	});

	/**
	*最小随机双固定尺寸。
	*/
	__getset(0,__proto,'constantMin',function(){
		return this._constantMin;
	});

	/**
	*渐变尺寸X。
	*/
	__getset(0,__proto,'gradientX',function(){
		return this._gradientX;
	});

	/**
	*渐变尺寸Y。
	*/
	__getset(0,__proto,'gradientY',function(){
		return this._gradientY;
	});

	/**
	*渐变最大尺寸。
	*/
	__getset(0,__proto,'gradientMax',function(){
		return this._gradientMax;
	});

	/**
	*最大随机双固定尺寸。
	*/
	__getset(0,__proto,'constantMax',function(){
		return this._constantMax;
	});

	/**
	*最小分轴随机双固定尺寸。
	*/
	__getset(0,__proto,'constantMinSeparate',function(){
		return this._constantMinSeparate;
	});

	/**
	*最小分轴随机双固定尺寸。
	*/
	__getset(0,__proto,'constantMaxSeparate',function(){
		return this._constantMaxSeparate;
	});

	/**
	*渐变最小尺寸X。
	*/
	__getset(0,__proto,'gradientXMin',function(){
		return this._gradientXMin;
	});

	/**
	*渐变最大尺寸X。
	*/
	__getset(0,__proto,'gradientXMax',function(){
		return this._gradientXMax;
	});

	/**
	*渐变最小尺寸Y。
	*/
	__getset(0,__proto,'gradientYMin',function(){
		return this._gradientYMin;
	});

	/**
	*渐变最大尺寸Y。
	*/
	__getset(0,__proto,'gradientYMax',function(){
		return this._gradientYMax;
	});

	/**
	*渐变最小尺寸Z。
	*/
	__getset(0,__proto,'gradientZMin',function(){
		return this._gradientZMin;
	});

	/**
	*渐变最大尺寸Z。
	*/
	__getset(0,__proto,'gradientZMax',function(){
		return this._gradientZMax;
	});

	GradientSize.createByGradient=function(gradient){
		var gradientSize=new GradientSize();
		gradientSize._type=0;
		gradientSize._separateAxes=false;
		gradientSize._gradient=gradient;
		return gradientSize;
	}

	GradientSize.createByGradientSeparate=function(gradientX,gradientY,gradientZ){
		var gradientSize=new GradientSize();
		gradientSize._type=0;
		gradientSize._separateAxes=true;
		gradientSize._gradientX=gradientX;
		gradientSize._gradientY=gradientY;
		gradientSize._gradientZ=gradientZ;
		return gradientSize;
	}

	GradientSize.createByRandomTwoConstant=function(constantMin,constantMax){
		var gradientSize=new GradientSize();
		gradientSize._type=1;
		gradientSize._separateAxes=false;
		gradientSize._constantMin=constantMin;
		gradientSize._constantMax=constantMax;
		return gradientSize;
	}

	GradientSize.createByRandomTwoConstantSeparate=function(constantMinSeparate,constantMaxSeparate){
		var gradientSize=new GradientSize();
		gradientSize._type=1;
		gradientSize._separateAxes=true;
		gradientSize._constantMinSeparate=constantMinSeparate;
		gradientSize._constantMaxSeparate=constantMaxSeparate;
		return gradientSize;
	}

	GradientSize.createByRandomTwoGradient=function(gradientMin,gradientMax){
		var gradientSize=new GradientSize();
		gradientSize._type=2;
		gradientSize._separateAxes=false;
		gradientSize._gradientMin=gradientMin;
		gradientSize._gradientMax=gradientMax;
		return gradientSize;
	}

	GradientSize.createByRandomTwoGradientSeparate=function(gradientXMin,gradientXMax,gradientYMin,gradientYMax,gradientZMin,gradientZMax){
		var gradientSize=new GradientSize();
		gradientSize._type=2;
		gradientSize._separateAxes=true;
		gradientSize._gradientXMin=gradientXMin;
		gradientSize._gradientXMax=gradientXMax;
		gradientSize._gradientYMin=gradientYMin;
		gradientSize._gradientYMax=gradientYMax;
		gradientSize._gradientZMin=gradientZMin;
		gradientSize._gradientZMax=gradientZMax;
		return gradientSize;
	}

	return GradientSize;
})()


/**
*<code>GradientVelocity</code> 类用于创建渐变速度。
*/
//class laya.d3.core.particleShuriKen.module.GradientVelocity
var GradientVelocity=(function(){
	function GradientVelocity(){
		/**@private */
		this._type=0;
		/**@private */
		this._constant=null;
		/**@private */
		this._gradientX=null;
		/**@private */
		this._gradientY=null;
		/**@private */
		this._gradientZ=null;
		/**@private */
		this._constantMin=null;
		/**@private */
		this._constantMax=null;
		/**@private */
		this._gradientXMin=null;
		/**@private */
		this._gradientXMax=null;
		/**@private */
		this._gradientYMin=null;
		/**@private */
		this._gradientYMax=null;
		/**@private */
		this._gradientZMin=null;
		/**@private */
		this._gradientZMax=null;
	}

	__class(GradientVelocity,'laya.d3.core.particleShuriKen.module.GradientVelocity');
	var __proto=GradientVelocity.prototype;
	Laya.imps(__proto,{"laya.d3.core.IClone":true})
	/**
	*克隆。
	*@param destObject 克隆源。
	*/
	__proto.cloneTo=function(destObject){
		var destGradientVelocity=destObject;
		destGradientVelocity._type=this._type;
		this._constant.cloneTo(destGradientVelocity._constant);
		this._gradientX.cloneTo(destGradientVelocity._gradientX);
		this._gradientY.cloneTo(destGradientVelocity._gradientY);
		this._gradientZ.cloneTo(destGradientVelocity._gradientZ);
		this._constantMin.cloneTo(destGradientVelocity._constantMin);
		this._constantMax.cloneTo(destGradientVelocity._constantMax);
		this._gradientXMin.cloneTo(destGradientVelocity._gradientXMin);
		this._gradientXMax.cloneTo(destGradientVelocity._gradientXMax);
		this._gradientYMin.cloneTo(destGradientVelocity._gradientYMin);
		this._gradientYMax.cloneTo(destGradientVelocity._gradientYMax);
		this._gradientZMin.cloneTo(destGradientVelocity._gradientZMin);
		this._gradientZMax.cloneTo(destGradientVelocity._gradientZMax);
	}

	/**
	*克隆。
	*@return 克隆副本。
	*/
	__proto.clone=function(){
		var destGradientVelocity=/*__JS__ */new this.constructor();
		this.cloneTo(destGradientVelocity);
		return destGradientVelocity;
	}

	/**
	*渐变速度Z。
	*/
	__getset(0,__proto,'gradientZ',function(){
		return this._gradientZ;
	});

	/**固定速度。*/
	__getset(0,__proto,'constant',function(){
		return this._constant;
	});

	/**
	*生命周期速度类型，0常量模式，1曲线模式，2随机双常量模式，3随机双曲线模式。
	*/
	__getset(0,__proto,'type',function(){
		return this._type;
	});

	/**
	*渐变最大速度X。
	*/
	__getset(0,__proto,'gradientXMax',function(){
		return this._gradientXMax;
	});

	/**最小固定速度。*/
	__getset(0,__proto,'constantMin',function(){
		return this._constantMin;
	});

	/**
	*渐变速度X。
	*/
	__getset(0,__proto,'gradientX',function(){
		return this._gradientX;
	});

	/**
	*渐变速度Y。
	*/
	__getset(0,__proto,'gradientY',function(){
		return this._gradientY;
	});

	/**
	*渐变最小速度X。
	*/
	__getset(0,__proto,'gradientXMin',function(){
		return this._gradientXMin;
	});

	/**最大固定速度。*/
	__getset(0,__proto,'constantMax',function(){
		return this._constantMax;
	});

	/**
	*渐变最小速度Y。
	*/
	__getset(0,__proto,'gradientYMin',function(){
		return this._gradientYMin;
	});

	/**
	*渐变最大速度Y。
	*/
	__getset(0,__proto,'gradientYMax',function(){
		return this._gradientYMax;
	});

	/**
	*渐变最小速度Z。
	*/
	__getset(0,__proto,'gradientZMin',function(){
		return this._gradientZMin;
	});

	/**
	*渐变最大速度Z。
	*/
	__getset(0,__proto,'gradientZMax',function(){
		return this._gradientZMax;
	});

	GradientVelocity.createByConstant=function(constant){
		var gradientVelocity=new GradientVelocity();
		gradientVelocity._type=0;
		gradientVelocity._constant=constant;
		return gradientVelocity;
	}

	GradientVelocity.createByGradient=function(gradientX,gradientY,gradientZ){
		var gradientVelocity=new GradientVelocity();
		gradientVelocity._type=1;
		gradientVelocity._gradientX=gradientX;
		gradientVelocity._gradientY=gradientY;
		gradientVelocity._gradientZ=gradientZ;
		return gradientVelocity;
	}

	GradientVelocity.createByRandomTwoConstant=function(constantMin,constantMax){
		var gradientVelocity=new GradientVelocity();
		gradientVelocity._type=2;
		gradientVelocity._constantMin=constantMin;
		gradientVelocity._constantMax=constantMax;
		return gradientVelocity;
	}

	GradientVelocity.createByRandomTwoGradient=function(gradientXMin,gradientXMax,gradientYMin,gradientYMax,gradientZMin,gradientZMax){
		var gradientVelocity=new GradientVelocity();
		gradientVelocity._type=3;
		gradientVelocity._gradientXMin=gradientXMin;
		gradientVelocity._gradientXMax=gradientXMax;
		gradientVelocity._gradientYMin=gradientYMin;
		gradientVelocity._gradientYMax=gradientYMax;
		gradientVelocity._gradientZMin=gradientZMin;
		gradientVelocity._gradientZMax=gradientZMax;
		return gradientVelocity;
	}

	return GradientVelocity;
})()


/**
*<code>RotationOverLifetime</code> 类用于粒子的生命周期旋转。
*/
//class laya.d3.core.particleShuriKen.module.RotationOverLifetime
var RotationOverLifetime=(function(){
	function RotationOverLifetime(angularVelocity){
		/**@private */
		this._angularVelocity=null;
		/**是否启用*/
		this.enbale=false;
		this._angularVelocity=angularVelocity;
	}

	__class(RotationOverLifetime,'laya.d3.core.particleShuriKen.module.RotationOverLifetime');
	var __proto=RotationOverLifetime.prototype;
	Laya.imps(__proto,{"laya.d3.core.IClone":true})
	/**
	*克隆。
	*@param destObject 克隆源。
	*/
	__proto.cloneTo=function(destObject){
		var destRotationOverLifetime=destObject;
		this._angularVelocity.cloneTo(destRotationOverLifetime._angularVelocity);
		destRotationOverLifetime.enbale=this.enbale;
	}

	/**
	*克隆。
	*@return 克隆副本。
	*/
	__proto.clone=function(){
		var destAngularVelocity;
		switch (this._angularVelocity.type){
			case 0:
				if (this._angularVelocity.separateAxes)
					destAngularVelocity=GradientAngularVelocity.createByConstantSeparate(this._angularVelocity.constantSeparate.clone());
				else
				destAngularVelocity=GradientAngularVelocity.createByConstant(this._angularVelocity.constant);
				break ;
			case 1:
				if (this._angularVelocity.separateAxes)
					destAngularVelocity=GradientAngularVelocity.createByGradientSeparate(this._angularVelocity.gradientX.clone(),this._angularVelocity.gradientY.clone(),this._angularVelocity.gradientZ.clone(),this._angularVelocity.gradientW.clone());
				else
				destAngularVelocity=GradientAngularVelocity.createByGradient(this._angularVelocity.gradient.clone());
				break ;
			case 2:
				if (this._angularVelocity.separateAxes)
					destAngularVelocity=GradientAngularVelocity.createByRandomTwoConstantSeparate(this._angularVelocity.constantMinSeparate.clone(),this._angularVelocity.constantMaxSeparate.clone());
				else
				destAngularVelocity=GradientAngularVelocity.createByRandomTwoConstant(this._angularVelocity.constantMin,this._angularVelocity.constantMax);
				break ;
			case 3:
				if (this._angularVelocity.separateAxes)
					destAngularVelocity=GradientAngularVelocity.createByRandomTwoGradientSeparate(this._angularVelocity.gradientXMin.clone(),this._angularVelocity.gradientYMin.clone(),this._angularVelocity.gradientZMin.clone(),this._angularVelocity.gradientWMin.clone(),this._angularVelocity.gradientXMax.clone(),this._angularVelocity.gradientYMax.clone(),this._angularVelocity.gradientZMax.clone(),this._angularVelocity.gradientWMax.clone());
				else
				destAngularVelocity=GradientAngularVelocity.createByRandomTwoGradient(this._angularVelocity.gradientMin.clone(),this._angularVelocity.gradientMax.clone());
				break ;
			};
		var destRotationOverLifetime=/*__JS__ */new this.constructor(destAngularVelocity);
		destRotationOverLifetime.enbale=this.enbale;
		return destRotationOverLifetime;
	}

	/**
	*获取角速度。
	*/
	__getset(0,__proto,'angularVelocity',function(){
		return this._angularVelocity;
	});

	return RotationOverLifetime;
})()


/**
*<code>BaseShape</code> 类用于粒子形状。
*/
//class laya.d3.core.particleShuriKen.module.shape.BaseShape
var BaseShape=(function(){
	function BaseShape(){
		/**是否启用。*/
		this.enable=false;
		/**随机方向。*/
		this.randomDirection=false;
	}

	__class(BaseShape,'laya.d3.core.particleShuriKen.module.shape.BaseShape');
	var __proto=BaseShape.prototype;
	Laya.imps(__proto,{"laya.d3.core.IClone":true})
	/**@private */
	__proto._getShapeBoundBox=function(boundBox){
		throw new Error("BaseShape: must override it.");
	}

	/**@private */
	__proto._getSpeedBoundBox=function(boundBox){
		throw new Error("BaseShape: must override it.");
	}

	/**
	*用于生成粒子初始位置和方向。
	*@param position 粒子位置。
	*@param direction 粒子方向。
	*/
	__proto.generatePositionAndDirection=function(position,direction,rand,randomSeeds){
		throw new Error("BaseShape: must override it.");
	}

	/**
	*@private
	*/
	__proto._calculateProceduralBounds=function(boundBox,emitterPosScale,minMaxBounds){
		this._getShapeBoundBox(boundBox);
		var min=boundBox.min;
		var max=boundBox.max;
		Vector3.multiply(min,emitterPosScale,min);
		Vector3.multiply(max,emitterPosScale,max);
		var speedBounds=new BoundBox(new Vector3(),new Vector3());
		if (this.randomDirection){
			speedBounds.min=new Vector3(-1,-1,-1);
			speedBounds.max=new Vector3(1,1,1);
		}
		else{
			this._getSpeedBoundBox(speedBounds);
		};
		var maxSpeedBound=new BoundBox(new Vector3(),new Vector3());
		var maxSpeedMin=maxSpeedBound.min;
		var maxSpeedMax=maxSpeedBound.max;
		Vector3.scale(speedBounds.min,minMaxBounds.y,maxSpeedMin);
		Vector3.scale(speedBounds.max,minMaxBounds.y,maxSpeedMax);
		Vector3.add(boundBox.min,maxSpeedMin,maxSpeedMin);
		Vector3.add(boundBox.max,maxSpeedMax,maxSpeedMax);
		Vector3.min(boundBox.min,maxSpeedMin,boundBox.min);
		Vector3.max(boundBox.max,maxSpeedMin,boundBox.max);
		var minSpeedBound=new BoundBox(new Vector3(),new Vector3());
		var minSpeedMin=minSpeedBound.min;
		var minSpeedMax=minSpeedBound.max;
		Vector3.scale(speedBounds.min,minMaxBounds.x,minSpeedMin);
		Vector3.scale(speedBounds.max,minMaxBounds.x,minSpeedMax);
		Vector3.min(minSpeedBound.min,minSpeedMax,maxSpeedMin);
		Vector3.max(minSpeedBound.min,minSpeedMax,maxSpeedMax);
		Vector3.min(boundBox.min,maxSpeedMin,boundBox.min);
		Vector3.max(boundBox.max,maxSpeedMin,boundBox.max);
	}

	/**
	*克隆。
	*@param destObject 克隆源。
	*/
	__proto.cloneTo=function(destObject){
		var destShape=destObject;
		destShape.enable=this.enable;
	}

	/**
	*克隆。
	*@return 克隆副本。
	*/
	__proto.clone=function(){
		var destShape=/*__JS__ */new this.constructor();
		this.cloneTo(destShape);
		return destShape;
	}

	return BaseShape;
})()


/**
*...
*@author ...
*/
//class laya.d3.core.particleShuriKen.module.shape.ShapeUtils
var ShapeUtils=(function(){
	function ShapeUtils(){}
	__class(ShapeUtils,'laya.d3.core.particleShuriKen.module.shape.ShapeUtils');
	ShapeUtils._randomPointUnitArcCircle=function(arc,out,rand){
		var outE=out.elements;
		var angle=NaN;
		if (rand)
			angle=rand.getFloat()*arc;
		else
		angle=Math.random()*arc;
		outE[0]=Math.cos(angle);
		outE[1]=Math.sin(angle);
	}

	ShapeUtils._randomPointInsideUnitArcCircle=function(arc,out,rand){
		var outE=out.elements;
		ShapeUtils._randomPointUnitArcCircle(arc,out,rand);
		var range=NaN;
		if (rand)
			range=Math.pow(rand.getFloat(),1.0 / 2.0);
		else
		range=Math.pow(Math.random(),1.0 / 2.0);
		outE[0]=outE[0] *range;
		outE[1]=outE[1] *range;
	}

	ShapeUtils._randomPointUnitCircle=function(out,rand){
		var outE=out.elements;
		var angle=NaN;
		if (rand)
			angle=rand.getFloat()*Math.PI *2;
		else
		angle=Math.random()*Math.PI *2;
		outE[0]=Math.cos(angle);
		outE[1]=Math.sin(angle);
	}

	ShapeUtils._randomPointInsideUnitCircle=function(out,rand){
		var outE=out.elements;
		ShapeUtils._randomPointUnitCircle(out);
		var range=NaN;
		if (rand)
			range=Math.pow(rand.getFloat(),1.0 / 2.0);
		else
		range=Math.pow(Math.random(),1.0 / 2.0);
		outE[0]=outE[0] *range;
		outE[1]=outE[1] *range;
	}

	ShapeUtils._randomPointUnitSphere=function(out,rand){
		var outE=out.elements;
		var z=NaN;
		var a=NaN;
		if (rand){
			z=outE[2]=rand.getFloat()*2-1.0;
			a=rand.getFloat()*Math.PI *2;
			}else {
			z=outE[2]=Math.random()*2-1.0;
			a=Math.random()*Math.PI *2;
		};
		var r=Math.sqrt(1.0-z *z);
		outE[0]=r *Math.cos(a);
		outE[1]=r *Math.sin(a);
	}

	ShapeUtils._randomPointInsideUnitSphere=function(out,rand){
		var outE=out.elements;
		ShapeUtils._randomPointUnitSphere(out);
		var range=NaN;
		if (rand)
			range=Math.pow(rand.getFloat(),1.0 / 3.0);
		else
		range=Math.pow(Math.random(),1.0 / 3.0);
		outE[0]=outE[0] *range;
		outE[1]=outE[1] *range;
		outE[2]=outE[2] *range;
	}

	ShapeUtils._randomPointInsideHalfUnitBox=function(out,rand){
		var outE=out.elements;
		if (rand){
			outE[0]=(rand.getFloat()-0.5);
			outE[1]=(rand.getFloat()-0.5);
			outE[2]=(rand.getFloat()-0.5);
			}else {
			outE[0]=(Math.random()-0.5);
			outE[1]=(Math.random()-0.5);
			outE[2]=(Math.random()-0.5);
		}
	}

	return ShapeUtils;
})()


/**
*<code>SizeOverLifetime</code> 类用于粒子的生命周期尺寸。
*/
//class laya.d3.core.particleShuriKen.module.SizeOverLifetime
var SizeOverLifetime=(function(){
	function SizeOverLifetime(size){
		/**@private */
		this._size=null;
		/**是否启用*/
		this.enbale=false;
		this._size=size;
	}

	__class(SizeOverLifetime,'laya.d3.core.particleShuriKen.module.SizeOverLifetime');
	var __proto=SizeOverLifetime.prototype;
	Laya.imps(__proto,{"laya.d3.core.IClone":true})
	/**
	*克隆。
	*@param destObject 克隆源。
	*/
	__proto.cloneTo=function(destObject){
		var destSizeOverLifetime=destObject;
		this._size.cloneTo(destSizeOverLifetime._size);
		destSizeOverLifetime.enbale=this.enbale;
	}

	/**
	*克隆。
	*@return 克隆副本。
	*/
	__proto.clone=function(){
		var destSize;
		switch (this._size.type){
			case 0:
				if (this._size.separateAxes)
					destSize=GradientSize.createByGradientSeparate(this._size.gradientX.clone(),this._size.gradientY.clone(),this._size.gradientZ.clone());
				else
				destSize=GradientSize.createByGradient(this._size.gradient.clone());
				break ;
			case 1:
				if (this._size.separateAxes)
					destSize=GradientSize.createByRandomTwoConstantSeparate(this._size.constantMinSeparate.clone(),this._size.constantMaxSeparate.clone());
				else
				destSize=GradientSize.createByRandomTwoConstant(this._size.constantMin,this._size.constantMax);
				break ;
			case 2:
				if (this._size.separateAxes)
					destSize=GradientSize.createByRandomTwoGradientSeparate(this._size.gradientXMin.clone(),this._size.gradientYMin.clone(),this._size.gradientZMin.clone(),this._size.gradientXMax.clone(),this._size.gradientYMax.clone(),this._size.gradientZMax.clone());
				else
				destSize=GradientSize.createByRandomTwoGradient(this._size.gradientMin.clone(),this._size.gradientMax.clone());
				break ;
			};
		var destSizeOverLifetime=/*__JS__ */new this.constructor(destSize);
		destSizeOverLifetime.enbale=this.enbale;
		return destSizeOverLifetime;
	}

	/**
	*获取尺寸。
	*/
	__getset(0,__proto,'size',function(){
		return this._size;
	});

	return SizeOverLifetime;
})()


/**
*<code>StartFrame</code> 类用于创建开始帧。
*/
//class laya.d3.core.particleShuriKen.module.StartFrame
var StartFrame=(function(){
	function StartFrame(){
		/**@private */
		this._type=0;
		/**@private */
		this._constant=NaN;
		/**@private */
		this._constantMin=NaN;
		/**@private */
		this._constantMax=NaN;
	}

	__class(StartFrame,'laya.d3.core.particleShuriKen.module.StartFrame');
	var __proto=StartFrame.prototype;
	Laya.imps(__proto,{"laya.d3.core.IClone":true})
	/**
	*克隆。
	*@param destObject 克隆源。
	*/
	__proto.cloneTo=function(destObject){
		var destStartFrame=destObject;
		destStartFrame._type=this._type;
		destStartFrame._constant=this._constant;
		destStartFrame._constantMin=this._constantMin;
		destStartFrame._constantMax=this._constantMax;
	}

	/**
	*克隆。
	*@return 克隆副本。
	*/
	__proto.clone=function(){
		var destStartFrame=/*__JS__ */new this.constructor();
		this.cloneTo(destStartFrame);
		return destStartFrame;
	}

	/**
	*固定帧。
	*/
	__getset(0,__proto,'constant',function(){
		return this._constant;
	});

	/**
	*开始帧类型,0常量模式，1随机双常量模式。
	*/
	__getset(0,__proto,'type',function(){
		return this._type;
	});

	/**
	*最小固定帧。
	*/
	__getset(0,__proto,'constantMin',function(){
		return this._constantMin;
	});

	/**
	*最大固定帧。
	*/
	__getset(0,__proto,'constantMax',function(){
		return this._constantMax;
	});

	StartFrame.createByConstant=function(constant){
		var rotationOverLifetime=new StartFrame();
		rotationOverLifetime._type=0;
		rotationOverLifetime._constant=constant;
		return rotationOverLifetime;
	}

	StartFrame.createByRandomTwoConstant=function(constantMin,constantMax){
		var rotationOverLifetime=new StartFrame();
		rotationOverLifetime._type=1;
		rotationOverLifetime._constantMin=constantMin;
		rotationOverLifetime._constantMax=constantMax;
		return rotationOverLifetime;
	}

	return StartFrame;
})()


/**
*<code>TextureSheetAnimation</code> 类用于创建粒子帧动画。
*/
//class laya.d3.core.particleShuriKen.module.TextureSheetAnimation
var TextureSheetAnimation=(function(){
	function TextureSheetAnimation(frame,startFrame){
		/**@private */
		this._frame=null;
		/**@private */
		this._startFrame=null;
		/**纹理平铺。*/
		this.tiles=null;
		/**类型,0为whole sheet、1为singal row。*/
		this.type=0;
		/**是否随机行，type为1时有效。*/
		this.randomRow=false;
		/**行索引,type为1时有效。*/
		this.rowIndex=0;
		/**循环次数。*/
		this.cycles=0;
		/**UV通道类型,0为Noting,1为Everything,待补充,暂不支持。*/
		this.enableUVChannels=0;
		/**是否启用*/
		this.enable=false;
		this.tiles=new Vector2(1,1);
		this.type=0;
		this.randomRow=true;
		this.rowIndex=0;
		this.cycles=1;
		this.enableUVChannels=1;
		this._frame=frame;
		this._startFrame=startFrame;
	}

	__class(TextureSheetAnimation,'laya.d3.core.particleShuriKen.module.TextureSheetAnimation');
	var __proto=TextureSheetAnimation.prototype;
	Laya.imps(__proto,{"laya.d3.core.IClone":true})
	/**
	*克隆。
	*@param destObject 克隆源。
	*/
	__proto.cloneTo=function(destObject){
		var destTextureSheetAnimation=destObject;
		this.tiles.cloneTo(destTextureSheetAnimation.tiles);
		destTextureSheetAnimation.type=this.type;
		destTextureSheetAnimation.randomRow=this.randomRow;
		this._frame.cloneTo(destTextureSheetAnimation._frame);
		this._startFrame.cloneTo(destTextureSheetAnimation._startFrame);
		destTextureSheetAnimation.cycles=this.cycles;
		destTextureSheetAnimation.enableUVChannels=this.enableUVChannels;
		destTextureSheetAnimation.enable=this.enable;
	}

	/**
	*克隆。
	*@return 克隆副本。
	*/
	__proto.clone=function(){
		var destFrame;
		switch (this._frame.type){
			case 0:
				destFrame=FrameOverTime.createByConstant(this._frame.constant);
				break ;
			case 1:
				destFrame=FrameOverTime.createByOverTime(this._frame.frameOverTimeData.clone());
				break ;
			case 2:
				destFrame=FrameOverTime.createByRandomTwoConstant(this._frame.constantMin,this._frame.constantMax);
				break ;
			case 3:
				destFrame=FrameOverTime.createByRandomTwoOverTime(this._frame.frameOverTimeDataMin.clone(),this._frame.frameOverTimeDataMax.clone());
				break ;
			};
		var destStartFrame;
		switch (this._startFrame.type){
			case 0:
				destStartFrame=StartFrame.createByConstant(this._startFrame.constant);
				break ;
			case 1:
				destStartFrame=StartFrame.createByRandomTwoConstant(this._startFrame.constantMin,this._startFrame.constantMax);
				break ;
			};
		var destTextureSheetAnimation=/*__JS__ */new this.constructor(destFrame,destStartFrame);
		this.tiles.cloneTo(destTextureSheetAnimation.tiles);
		destTextureSheetAnimation.type=this.type;
		destTextureSheetAnimation.randomRow=this.randomRow;
		destTextureSheetAnimation.cycles=this.cycles;
		destTextureSheetAnimation.enableUVChannels=this.enableUVChannels;
		destTextureSheetAnimation.enable=this.enable;
		return destTextureSheetAnimation;
	}

	/**获取时间帧率。*/
	__getset(0,__proto,'frame',function(){
		return this._frame;
	});

	/**获取开始帧率。*/
	__getset(0,__proto,'startFrame',function(){
		return this._startFrame;
	});

	return TextureSheetAnimation;
})()


/**
*<code>VelocityOverLifetime</code> 类用于粒子的生命周期速度。
*/
//class laya.d3.core.particleShuriKen.module.VelocityOverLifetime
var VelocityOverLifetime=(function(){
	function VelocityOverLifetime(velocity){
		/**@private */
		this._velocity=null;
		/**是否启用*/
		this.enbale=false;
		/**速度空间,0为local,1为world。*/
		this.space=0;
		this._velocity=velocity;
	}

	__class(VelocityOverLifetime,'laya.d3.core.particleShuriKen.module.VelocityOverLifetime');
	var __proto=VelocityOverLifetime.prototype;
	Laya.imps(__proto,{"laya.d3.core.IClone":true})
	/**
	*克隆。
	*@param destObject 克隆源。
	*/
	__proto.cloneTo=function(destObject){
		var destVelocityOverLifetime=destObject;
		this._velocity.cloneTo(destVelocityOverLifetime._velocity);
		destVelocityOverLifetime.enbale=this.enbale;
		destVelocityOverLifetime.space=this.space;
	}

	/**
	*克隆。
	*@return 克隆副本。
	*/
	__proto.clone=function(){
		var destVelocity;
		switch(this._velocity.type){
			case 0:
				destVelocity=GradientVelocity.createByConstant(this._velocity.constant.clone());
				break ;
			case 1:
				destVelocity=GradientVelocity.createByGradient(this._velocity.gradientX.clone(),this._velocity.gradientY.clone(),this._velocity.gradientZ.clone());
				break ;
			case 2:
				destVelocity=GradientVelocity.createByRandomTwoConstant(this._velocity.constantMin.clone(),this._velocity.constantMax.clone());
				break ;
			case 3:
				destVelocity=GradientVelocity.createByRandomTwoGradient(this._velocity.gradientXMin.clone(),this._velocity.gradientYMin.clone(),this._velocity.gradientZMin.clone(),this._velocity.gradientXMax.clone(),this._velocity.gradientYMax.clone(),this._velocity.gradientZMax.clone());
				break ;
			};
		var destVelocityOverLifetime=/*__JS__ */new this.constructor(destVelocity);
		destVelocityOverLifetime.enbale=this.enbale;
		destVelocityOverLifetime.space=this.space;
		return destVelocityOverLifetime;
	}

	/**
	*获取尺寸。
	*/
	__getset(0,__proto,'velocity',function(){
		return this._velocity;
	});

	return VelocityOverLifetime;
})()


/**
*@private
*/
//class laya.d3.core.particleShuriKen.ShurikenParticleData
var ShurikenParticleData=(function(){
	function ShurikenParticleData(){}
	__class(ShurikenParticleData,'laya.d3.core.particleShuriKen.ShurikenParticleData');
	ShurikenParticleData._getStartLifetimeFromGradient=function(startLifeTimeGradient,emissionTime){
		for (var i=1,n=startLifeTimeGradient.gradientCount;i < n;i++){
			var key=startLifeTimeGradient.getKeyByIndex(i);
			if (key >=emissionTime){
				var lastKey=startLifeTimeGradient.getKeyByIndex(i-1);
				var age=(emissionTime-lastKey)/ (key-lastKey);
				return MathUtil.lerp(startLifeTimeGradient.getValueByIndex(i-1),startLifeTimeGradient.getValueByIndex(i),age)
			}
		}
		throw new Error("ShurikenParticleData: can't get value foam startLifeTimeGradient.");
	}

	ShurikenParticleData._randomInvertRoationArray=function(rotatonE,outE,randomizeRotationDirection,rand,randomSeeds){
		var randDic=NaN;
		if (rand){
			rand.seed=randomSeeds[6];
			randDic=rand.getFloat();
			randomSeeds[6]=rand.seed;
			}else {
			randDic=Math.random();
		}
		if (randDic < randomizeRotationDirection){
			outE[0]=-rotatonE[0];
			outE[1]=-rotatonE[1];
			outE[2]=-rotatonE[2];
			}else {
			outE[0]=rotatonE[0];
			outE[1]=rotatonE[1];
			outE[2]=rotatonE[2];
		}
	}

	ShurikenParticleData._randomInvertRoation=function(rotaton,randomizeRotationDirection,rand,randomSeeds){
		var randDic=NaN;
		if (rand){
			rand.seed=randomSeeds[6];
			randDic=rand.getFloat();
			randomSeeds[6]=rand.seed;
			}else {
			randDic=Math.random();
		}
		if (randDic < randomizeRotationDirection)
			rotaton=-rotaton;
		return rotaton;
	}

	ShurikenParticleData.create=function(particleSystem,particleRender,transform){
		var autoRandomSeed=particleSystem.autoRandomSeed;
		var rand=particleSystem._rand;
		var randomSeeds=particleSystem._randomSeeds;
		switch (particleSystem.startColorType){
			case 0:;
				var constantStartColorE=particleSystem.startColorConstant.elements;
				ShurikenParticleData.startColor[0]=constantStartColorE[0];
				ShurikenParticleData.startColor[1]=constantStartColorE[1];
				ShurikenParticleData.startColor[2]=constantStartColorE[2];
				ShurikenParticleData.startColor[3]=constantStartColorE[3];
				break ;
			case 2:
				if (autoRandomSeed){
					MathUtil.lerpVector4(particleSystem.startColorConstantMin.elements,particleSystem.startColorConstantMax.elements,Math.random(),ShurikenParticleData.startColor);
					}else {
					rand.seed=randomSeeds[3];
					MathUtil.lerpVector4(particleSystem.startColorConstantMin.elements,particleSystem.startColorConstantMax.elements,rand.getFloat(),ShurikenParticleData.startColor);
					randomSeeds[3]=rand.seed;
				}
				break ;
			};
		var colorOverLifetime=particleSystem.colorOverLifetime;
		if (colorOverLifetime && colorOverLifetime.enbale){
			var color=colorOverLifetime.color;
			switch (color.type){
				case 0:
					ShurikenParticleData.startColor[0]=ShurikenParticleData.startColor[0] *color.constant.x;
					ShurikenParticleData.startColor[1]=ShurikenParticleData.startColor[1] *color.constant.y;
					ShurikenParticleData.startColor[2]=ShurikenParticleData.startColor[2] *color.constant.z;
					ShurikenParticleData.startColor[3]=ShurikenParticleData.startColor[3] *color.constant.w;
					break ;
				case 2:;
					var colorRandom=NaN;
					if (autoRandomSeed){
						colorRandom=Math.random();
						}else {
						rand.seed=randomSeeds[10];
						colorRandom=rand.getFloat();
						randomSeeds[10]=rand.seed;
					};
					var minConstantColor=color.constantMin;
					var maxConstantColor=color.constantMax;
					ShurikenParticleData.startColor[0]=ShurikenParticleData.startColor[0] *MathUtil.lerp(minConstantColor.x,maxConstantColor.x,colorRandom);
					ShurikenParticleData.startColor[1]=ShurikenParticleData.startColor[1] *MathUtil.lerp(minConstantColor.y,maxConstantColor.y,colorRandom);
					ShurikenParticleData.startColor[2]=ShurikenParticleData.startColor[2] *MathUtil.lerp(minConstantColor.z,maxConstantColor.z,colorRandom);
					ShurikenParticleData.startColor[3]=ShurikenParticleData.startColor[3] *MathUtil.lerp(minConstantColor.w,maxConstantColor.w,colorRandom);
					break ;
				}
		};
		var particleSize=ShurikenParticleData.startSize;
		switch (particleSystem.startSizeType){
			case 0:
				if (particleSystem.threeDStartSize){
					var startSizeConstantSeparate=particleSystem.startSizeConstantSeparate;
					particleSize[0]=startSizeConstantSeparate.x;
					particleSize[1]=startSizeConstantSeparate.y;
					particleSize[2]=startSizeConstantSeparate.z;
					}else {
					particleSize[0]=particleSize[1]=particleSize[2]=particleSystem.startSizeConstant;
				}
				break ;
			case 2:
				if (particleSystem.threeDStartSize){
					var startSizeConstantMinSeparate=particleSystem.startSizeConstantMinSeparate;
					var startSizeConstantMaxSeparate=particleSystem.startSizeConstantMaxSeparate;
					if (autoRandomSeed){
						particleSize[0]=MathUtil.lerp(startSizeConstantMinSeparate.x,startSizeConstantMaxSeparate.x,Math.random());
						particleSize[1]=MathUtil.lerp(startSizeConstantMinSeparate.y,startSizeConstantMaxSeparate.y,Math.random());
						particleSize[2]=MathUtil.lerp(startSizeConstantMinSeparate.z,startSizeConstantMaxSeparate.z,Math.random());
						}else {
						rand.seed=randomSeeds[4];
						particleSize[0]=MathUtil.lerp(startSizeConstantMinSeparate.x,startSizeConstantMaxSeparate.x,rand.getFloat());
						particleSize[1]=MathUtil.lerp(startSizeConstantMinSeparate.y,startSizeConstantMaxSeparate.y,rand.getFloat());
						particleSize[2]=MathUtil.lerp(startSizeConstantMinSeparate.z,startSizeConstantMaxSeparate.z,rand.getFloat());
						randomSeeds[4]=rand.seed;
					}
					}else {
					if (autoRandomSeed){
						particleSize[0]=particleSize[1]=particleSize[2]=MathUtil.lerp(particleSystem.startSizeConstantMin,particleSystem.startSizeConstantMax,Math.random());
						}else {
						rand.seed=randomSeeds[4];
						particleSize[0]=particleSize[1]=particleSize[2]=MathUtil.lerp(particleSystem.startSizeConstantMin,particleSystem.startSizeConstantMax,rand.getFloat());
						randomSeeds[4]=rand.seed;
					}
				}
				break ;
			};
		var sizeOverLifetime=particleSystem.sizeOverLifetime;
		if (sizeOverLifetime && sizeOverLifetime.enbale && sizeOverLifetime.size.type===1){
			var size=sizeOverLifetime.size;
			if (size.separateAxes){
				if (autoRandomSeed){
					particleSize[0]=particleSize[0] *MathUtil.lerp(size.constantMinSeparate.x,size.constantMaxSeparate.x,Math.random());
					particleSize[1]=particleSize[1] *MathUtil.lerp(size.constantMinSeparate.y,size.constantMaxSeparate.y,Math.random());
					particleSize[2]=particleSize[2] *MathUtil.lerp(size.constantMinSeparate.z,size.constantMaxSeparate.z,Math.random());
					}else {
					rand.seed=randomSeeds[11];
					particleSize[0]=particleSize[0] *MathUtil.lerp(size.constantMinSeparate.x,size.constantMaxSeparate.x,rand.getFloat());
					particleSize[1]=particleSize[1] *MathUtil.lerp(size.constantMinSeparate.y,size.constantMaxSeparate.y,rand.getFloat());
					particleSize[2]=particleSize[2] *MathUtil.lerp(size.constantMinSeparate.z,size.constantMaxSeparate.z,rand.getFloat());
					randomSeeds[11]=rand.seed;
				}
				}else {
				var randomSize=NaN;
				if (autoRandomSeed){
					randomSize=MathUtil.lerp(size.constantMin,size.constantMax,Math.random());
					}else {
					rand.seed=randomSeeds[11];
					randomSize=MathUtil.lerp(size.constantMin,size.constantMax,rand.getFloat());
					randomSeeds[11]=rand.seed;
				}
				particleSize[0]=particleSize[0] *randomSize;
				particleSize[1]=particleSize[1] *randomSize;
				particleSize[2]=particleSize[2] *randomSize;
			}
		};
		var renderMode=particleRender.renderMode;
		if (renderMode!==1){
			switch (particleSystem.startRotationType){
				case 0:
					if (particleSystem.threeDStartRotation){
						var startRotationConstantSeparate=particleSystem.startRotationConstantSeparate;
						var randomRotationE=ShurikenParticleData._tempVector30.elements;
						ShurikenParticleData._randomInvertRoationArray(startRotationConstantSeparate.elements,randomRotationE,particleSystem.randomizeRotationDirection,autoRandomSeed ? null :rand,randomSeeds);
						ShurikenParticleData.startRotation[0]=randomRotationE[0];
						ShurikenParticleData.startRotation[1]=randomRotationE[1];
						if (renderMode!==4)
							ShurikenParticleData.startRotation[2]=-randomRotationE[2];
						else
						ShurikenParticleData.startRotation[2]=randomRotationE[2];
						}else {
						ShurikenParticleData.startRotation[0]=ShurikenParticleData._randomInvertRoation(particleSystem.startRotationConstant,particleSystem.randomizeRotationDirection,autoRandomSeed ? null :rand,randomSeeds);
					}
					break ;
				case 2:
					if (particleSystem.threeDStartRotation){
						var startRotationConstantMinSeparate=particleSystem.startRotationConstantMinSeparate;
						var startRotationConstantMaxSeparate=particleSystem.startRotationConstantMaxSeparate;
						var lerpRoationE=ShurikenParticleData._tempVector30.elements;
						if (autoRandomSeed){
							lerpRoationE[0]=MathUtil.lerp(startRotationConstantMinSeparate.x,startRotationConstantMaxSeparate.x,Math.random());
							lerpRoationE[1]=MathUtil.lerp(startRotationConstantMinSeparate.y,startRotationConstantMaxSeparate.y,Math.random());
							lerpRoationE[2]=MathUtil.lerp(startRotationConstantMinSeparate.z,startRotationConstantMaxSeparate.z,Math.random());
							}else {
							rand.seed=randomSeeds[5];
							lerpRoationE[0]=MathUtil.lerp(startRotationConstantMinSeparate.x,startRotationConstantMaxSeparate.x,rand.getFloat());
							lerpRoationE[1]=MathUtil.lerp(startRotationConstantMinSeparate.y,startRotationConstantMaxSeparate.y,rand.getFloat());
							lerpRoationE[2]=MathUtil.lerp(startRotationConstantMinSeparate.z,startRotationConstantMaxSeparate.z,rand.getFloat());
							randomSeeds[5]=rand.seed;
						}
						ShurikenParticleData._randomInvertRoationArray(lerpRoationE,lerpRoationE,particleSystem.randomizeRotationDirection,autoRandomSeed ? null :rand,randomSeeds);
						ShurikenParticleData.startRotation[0]=lerpRoationE[0];
						ShurikenParticleData.startRotation[1]=lerpRoationE[1];
						if (renderMode!==4)
							ShurikenParticleData.startRotation[2]=-lerpRoationE[2];
						else
						ShurikenParticleData.startRotation[2]=lerpRoationE[2];
						}else {
						if (autoRandomSeed){
							ShurikenParticleData.startRotation[0]=ShurikenParticleData._randomInvertRoation(MathUtil.lerp(particleSystem.startRotationConstantMin,particleSystem.startRotationConstantMax,Math.random()),particleSystem.randomizeRotationDirection,autoRandomSeed ? null :rand,randomSeeds);
							}else {
							rand.seed=randomSeeds[5];
							ShurikenParticleData.startRotation[0]=ShurikenParticleData._randomInvertRoation(MathUtil.lerp(particleSystem.startRotationConstantMin,particleSystem.startRotationConstantMax,rand.getFloat()),particleSystem.randomizeRotationDirection,autoRandomSeed ? null :rand,randomSeeds);
							randomSeeds[5]=rand.seed;
						}
					}
					break ;
				}
		}
		switch (particleSystem.startLifetimeType){
			case 0:
				ShurikenParticleData.startLifeTime=particleSystem.startLifetimeConstant;
				break ;
			case 1:
				ShurikenParticleData.startLifeTime=ShurikenParticleData._getStartLifetimeFromGradient(particleSystem.startLifeTimeGradient,particleSystem.emissionTime);
				break ;
			case 2:
				if (autoRandomSeed){
					ShurikenParticleData.startLifeTime=MathUtil.lerp(particleSystem.startLifetimeConstantMin,particleSystem.startLifetimeConstantMax,Math.random());
					}else {
					rand.seed=randomSeeds[7];
					ShurikenParticleData.startLifeTime=MathUtil.lerp(particleSystem.startLifetimeConstantMin,particleSystem.startLifetimeConstantMax,rand.getFloat());
					randomSeeds[7]=rand.seed;
				}
				break ;
			case 3:;
				var emissionTime=particleSystem.emissionTime;
				if (autoRandomSeed){
					ShurikenParticleData.startLifeTime=MathUtil.lerp(ShurikenParticleData._getStartLifetimeFromGradient(particleSystem.startLifeTimeGradientMin,emissionTime),ShurikenParticleData._getStartLifetimeFromGradient(particleSystem.startLifeTimeGradientMax,emissionTime),Math.random());
					}else {
					rand.seed=randomSeeds[7];
					ShurikenParticleData.startLifeTime=MathUtil.lerp(ShurikenParticleData._getStartLifetimeFromGradient(particleSystem.startLifeTimeGradientMin,emissionTime),ShurikenParticleData._getStartLifetimeFromGradient(particleSystem.startLifeTimeGradientMax,emissionTime),rand.getFloat());
					randomSeeds[7]=rand.seed;
				}
				break ;
			}
		switch (particleSystem.startSpeedType){
			case 0:
				ShurikenParticleData.startSpeed=particleSystem.startSpeedConstant;
				break ;
			case 2:
				if (autoRandomSeed){
					ShurikenParticleData.startSpeed=MathUtil.lerp(particleSystem.startSpeedConstantMin,particleSystem.startSpeedConstantMax,Math.random());
					}else {
					rand.seed=randomSeeds[8];
					ShurikenParticleData.startSpeed=MathUtil.lerp(particleSystem.startSpeedConstantMin,particleSystem.startSpeedConstantMax,rand.getFloat());
					randomSeeds[8]=rand.seed;
				}
				break ;
			};
		var textureSheetAnimation=particleSystem.textureSheetAnimation;
		var enableSheetAnimation=textureSheetAnimation && textureSheetAnimation.enable;
		if (enableSheetAnimation){
			var title=textureSheetAnimation.tiles;
			var titleX=title.x,titleY=title.y;
			var subU=1.0 / titleX,subV=1.0 / titleY;
			var startFrameCount=0;
			var startFrame=textureSheetAnimation.startFrame;
			switch (startFrame.type){
				case 0:
					startFrameCount=startFrame.constant;
					break ;
				case 1:
					if (autoRandomSeed){
						startFrameCount=MathUtil.lerp(startFrame.constantMin,startFrame.constantMax,Math.random());
						}else {
						rand.seed=randomSeeds[14];
						startFrameCount=MathUtil.lerp(startFrame.constantMin,startFrame.constantMax,rand.getFloat());
						randomSeeds[14]=rand.seed;
					}
					break ;
				};
			var frame=textureSheetAnimation.frame;
			switch (frame.type){
				case 0:
					startFrameCount+=frame.constant;
					break ;
				case 2:
					if (autoRandomSeed){
						startFrameCount+=MathUtil.lerp(frame.constantMin,frame.constantMax,Math.random());
						}else {
						rand.seed=randomSeeds[15];
						startFrameCount+=MathUtil.lerp(frame.constantMin,frame.constantMax,rand.getFloat());
						randomSeeds[15]=rand.seed;
					}
					break ;
				};
			var startRow=0;
			switch (textureSheetAnimation.type){
				case 0:
					startRow=Math.floor(startFrameCount / titleX);
					break ;
				case 1:
					if (textureSheetAnimation.randomRow){
						if (autoRandomSeed){
							startRow=Math.floor(Math.random()*titleY);
							}else {
							rand.seed=randomSeeds[13];
							startRow=Math.floor(rand.getFloat()*titleY);
							randomSeeds[13]=rand.seed;
						}
						}else {
						startRow=textureSheetAnimation.rowIndex;
					}
					break ;
				};
			var startCol=Math.floor(startFrameCount % titleX);
			ShurikenParticleData.startUVInfo=ShurikenParticleData.startUVInfo;
			ShurikenParticleData.startUVInfo[0]=subU;
			ShurikenParticleData.startUVInfo[1]=subV;
			ShurikenParticleData.startUVInfo[2]=startCol *subU;
			ShurikenParticleData.startUVInfo[3]=startRow *subV;
			}else {
			ShurikenParticleData.startUVInfo=ShurikenParticleData.startUVInfo;
			ShurikenParticleData.startUVInfo[0]=1.0;
			ShurikenParticleData.startUVInfo[1]=1.0;
			ShurikenParticleData.startUVInfo[2]=0.0;
			ShurikenParticleData.startUVInfo[3]=0.0;
		}
		switch (particleSystem.simulationSpace){
			case 0:;
				var positionE=transform.position.elements;
				ShurikenParticleData.simulationWorldPostion[0]=positionE[0];
				ShurikenParticleData.simulationWorldPostion[1]=positionE[1];
				ShurikenParticleData.simulationWorldPostion[2]=positionE[2];
				var rotationE=transform.rotation.elements;
				ShurikenParticleData.simulationWorldRotation[0]=rotationE[0];
				ShurikenParticleData.simulationWorldRotation[1]=rotationE[1];
				ShurikenParticleData.simulationWorldRotation[2]=rotationE[2];
				ShurikenParticleData.simulationWorldRotation[3]=rotationE[3];
				break ;
			case 1:
				break ;
			default :
				throw new Error("ShurikenParticleMaterial: SimulationSpace value is invalid.");
				break ;
			}
	}

	ShurikenParticleData.startLifeTime=NaN;
	ShurikenParticleData.startSpeed=NaN;
	__static(ShurikenParticleData,
	['_tempVector30',function(){return this._tempVector30=new Vector3();},'_tempQuaternion',function(){return this._tempQuaternion=new Quaternion();},'startColor',function(){return this.startColor=new Float32Array(4);},'startSize',function(){return this.startSize=new Float32Array(3);},'startRotation',function(){return this.startRotation=new Float32Array(3);},'startUVInfo',function(){return this.startUVInfo=new Float32Array(4);},'simulationWorldPostion',function(){return this.simulationWorldPostion=new Float32Array(3);},'simulationWorldRotation',function(){return this.simulationWorldRotation=new Float32Array(4);}
	]);
	return ShurikenParticleData;
})()


/**
*@private
*<code>PhasorSpriter3D</code> 类用于创建矢量笔刷。
*/
//class laya.d3.core.PhasorSpriter3D
var PhasorSpriter3D=(function(){
	function PhasorSpriter3D(){
		this._tempInt0=0;
		this._tempInt1=0;
		this._tempUint0=0;
		this._tempUint1=0;
		this._tempUint2=0;
		this._tempUint3=0;
		this._tempUint4=0;
		this._tempUint5=0;
		this._tempUint6=0;
		this._tempUint7=0;
		this._tempNumver0=NaN;
		this._tempNumver1=NaN;
		this._tempNumver2=NaN;
		this._tempNumver3=NaN;
		this._floatSizePerVer=7;
		//顶点结构为Position(3个float)+Color(4个float)
		this._defaultBufferSize=600 *this._floatSizePerVer;
		this._vb=null;
		this._posInVBData=0;
		this._ib=null;
		this._posInIBData=0;
		this._primitiveType=NaN;
		this._hasBegun=false;
		this._numVertsPerPrimitive=0;
		this._camera=null;
		this._sharderNameID=0;
		this._shader=null;
		/**@private */
		this._shaderCompile=null;
		this._vbData=new Float32Array(this._defaultBufferSize);
		this._ibData=new Uint16Array(this._defaultBufferSize);
		this._spriteShaderValue=new ValusArray();
		;
		this._vb=VertexBuffer3D.create(PhasorSpriter3D._vertexDeclaration,this._defaultBufferSize / this._floatSizePerVer,/*laya.webgl.WebGLContext.DYNAMIC_DRAW*/0x88E8);
		this._ib=IndexBuffer3D.create(/*laya.d3.graphics.IndexBuffer3D.INDEXTYPE_USHORT*/"ushort",this._defaultBufferSize,/*laya.webgl.WebGLContext.DYNAMIC_DRAW*/0x88E8);
		this._sharderNameID=Shader3D.nameKey.getID("LINE");
		this._shaderCompile=ShaderCompile3D._preCompileShader[this._sharderNameID];
	}

	__class(PhasorSpriter3D,'laya.d3.core.PhasorSpriter3D');
	var __proto=PhasorSpriter3D.prototype;
	__proto.line=function(startPosition,startColor,endPosition,endColor){
		if (!this._hasBegun || this._primitiveType!==/*laya.webgl.WebGLContext.LINES*/0x0001)
			this.drawLinesException();
		if (this._posInVBData+2 *this._floatSizePerVer > this._vbData.length || this._posInIBData+2 > this._ibData.length)
			this.flush();
		this._tempUint0=this._posInVBData / this._floatSizePerVer;
		this.addVertex(startPosition.x,startPosition.y,startPosition.z,startColor.x,startColor.y,startColor.z,startColor.w);
		this.addVertex(endPosition.x,endPosition.y,endPosition.z,endColor.x,endColor.y,endColor.z,endColor.w);
		this.addIndexes(this._tempUint0,this._tempUint0+1);
		return this;
	}

	__proto.circle=function(radius,numberOfPoints,r,g,b,a){
		if (!this._hasBegun || (this._primitiveType!==/*laya.webgl.WebGLContext.LINES*/0x0001))
			this.drawLinesException();
		this._tempUint0=numberOfPoints *2;
		if (this._posInVBData+this._tempUint0 *this._floatSizePerVer > this._vbData.length || this._posInIBData+2 *this._tempUint0 > this._ibData.length)
			this.flush();
		this._tempUint1=this._posInVBData / this._floatSizePerVer;
		for (this._tempNumver0=0,this._tempInt0=0;this._tempNumver0 < 3.1416 *2;this._tempNumver0=this._tempNumver0+(3.1416 / numberOfPoints),this._tempInt0++){
			this.addVertex(Math.sin(this._tempNumver0)*radius,Math.cos(this._tempNumver0)*radius,0,r,g,b,a);
			if (this._tempInt0===0){
				this.addIndexes(this._tempUint1);
				}else if (this._tempInt0===this._tempUint0-1){
				this._tempUint2=this._tempUint1+this._tempInt0;
				this.addIndexes(this._tempUint2,this._tempUint2,this._tempUint1);
				}else {
				this._tempUint2=this._tempUint1+this._tempInt0;
				this.addIndexes(this._tempUint2,this._tempUint2);
			}
		}
		return this;
	}

	__proto.plane=function(positionX,positionY,positionZ,width,height,r,g,b,a){
		if (!this._hasBegun || this._primitiveType!==/*laya.webgl.WebGLContext.TRIANGLES*/0x0004)
			this.drawTrianglesException();
		if (this._posInVBData+4 *this._floatSizePerVer > this._vbData.length || this._posInIBData+6 > this._ibData.length)
			this.flush();
		this._tempNumver0=width / 2;
		this._tempNumver1=height / 2;
		this._tempUint0=this._posInVBData / this._floatSizePerVer;
		this.addVertex(positionX-this._tempNumver0,positionY+this._tempNumver1,positionZ,r,g,b,a);
		this.addVertex(positionX+this._tempNumver0,positionY+this._tempNumver1,positionZ,r,g,b,a);
		this.addVertex(positionX-this._tempNumver0,positionY-this._tempNumver1,positionZ,r,g,b,a);
		this.addVertex(positionX+this._tempNumver0,positionY-this._tempNumver1,positionZ,r,g,b,a);
		this._tempUint1=this._tempUint0+1;
		this._tempUint2=this._tempUint0+2;
		this.addIndexes(this._tempUint0,this._tempUint1,this._tempUint2,this._tempUint2,this._tempUint1,this._tempUint0+3);
		return this;
	}

	__proto.box=function(positionX,positionY,positionZ,width,height,depth,r,g,b,a){
		if (!this._hasBegun || this._primitiveType!==/*laya.webgl.WebGLContext.TRIANGLES*/0x0004)
			this.drawTrianglesException();
		if (this._posInVBData+8 *this._floatSizePerVer > this._vbData.length || this._posInIBData+36 > this._ibData.length)
			this.flush();
		this._tempNumver0=width / 2;
		this._tempNumver1=height / 2;
		this._tempNumver2=depth / 2;
		this._tempUint0=this._posInVBData / this._floatSizePerVer;
		this.addVertex(positionX-this._tempNumver0,positionY+this._tempNumver1,positionZ+this._tempNumver2,r,g,b,a);
		this.addVertex(positionX+this._tempNumver0,positionY+this._tempNumver1,positionZ+this._tempNumver2,r,g,b,a);
		this.addVertex(positionX-this._tempNumver0,positionY-this._tempNumver1,positionZ+this._tempNumver2,r,g,b,a);
		this.addVertex(positionX+this._tempNumver0,positionY-this._tempNumver1,positionZ+this._tempNumver2,r,g,b,a);
		this.addVertex(positionX+this._tempNumver0,positionY+this._tempNumver1,positionZ-this._tempNumver2,r,g,b,a);
		this.addVertex(positionX-this._tempNumver0,positionY+this._tempNumver1,positionZ-this._tempNumver2,r,g,b,a);
		this.addVertex(positionX+this._tempNumver0,positionY-this._tempNumver1,positionZ-this._tempNumver2,r,g,b,a);
		this.addVertex(positionX-this._tempNumver0,positionY-this._tempNumver1,positionZ-this._tempNumver2,r,g,b,a);
		this._tempUint1=this._tempUint0+1;
		this._tempUint2=this._tempUint0+2;
		this._tempUint3=this._tempUint0+3;
		this._tempUint4=this._tempUint0+4;
		this._tempUint5=this._tempUint0+5;
		this._tempUint6=this._tempUint0+6;
		this._tempUint7=this._tempUint0+7;
		this.addIndexes(this._tempUint0,this._tempUint1,this._tempUint2,this._tempUint2,this._tempUint1,this._tempUint3,
		this._tempUint4,this._tempUint5,this._tempUint6,this._tempUint6,this._tempUint5,this._tempUint7,
		this._tempUint5,this._tempUint0,this._tempUint7,this._tempUint7,this._tempUint0,this._tempUint2,
		this._tempUint1,this._tempUint4,this._tempUint3,this._tempUint3,this._tempUint4,this._tempUint6,
		this._tempUint5,this._tempUint4,this._tempUint0,this._tempUint0,this._tempUint4,this._tempUint1,
		this._tempUint2,this._tempUint3,this._tempUint7,this._tempUint7,this._tempUint3,this._tempUint6);
		return this;
	}

	__proto.cone=function(radius,length,Slices,r,g,b,a){
		if (!this._hasBegun || this._primitiveType!==/*laya.webgl.WebGLContext.TRIANGLES*/0x0004)
			this.drawTrianglesException();
		if (this._posInVBData+(2 *Slices+2)*this._floatSizePerVer > this._vbData.length || this._posInIBData+6 *Slices > this._ibData.length)
			this.flush();
		this._tempUint0=this._posInVBData;
		this._tempUint1=this._posInVBData / this._floatSizePerVer;
		this._tempNumver0=Math.PI *2 / Slices;
		this.addVertexIndex(0,length,0,r,g,b,a,this._tempUint0);
		this.addVertexIndex(0,0,0,r,g,b,a,this._tempUint0+this._floatSizePerVer);
		this._tempInt0=2;
		this._tempNumver1=0;
		for (this._tempInt1=0;this._tempInt1 < Slices;this._tempInt1++){
			this._tempNumver2=Math.cos(this._tempNumver1);
			this._tempNumver3=Math.sin(this._tempNumver1);
			this.addVertexIndex(radius *this._tempNumver2,0,radius *this._tempNumver3,r,g,b,a,this._tempUint0+this._tempInt0 *this._floatSizePerVer);
			this.addIndexes(this._tempUint1,this._tempUint1+this._tempInt0);
			if (this._tempInt1==Slices-1)
				this.addIndexes(this._tempUint1+2);
			else
			this.addIndexes(this._tempUint1+this._tempInt0+1);
			this.addVertexIndex(radius *this._tempNumver2,0,radius *this._tempNumver3,r,g,b,a,this._tempUint0+(this._tempInt0+Slices)*this._floatSizePerVer);
			this.addIndexes(this._tempUint1+1);
			if (this._tempInt1==Slices-1)
				this.addIndexes(this._tempUint1+Slices+2);
			else
			this.addIndexes(this._tempUint1+this._tempInt0+Slices+1);
			this.addIndexes(this._tempUint1+this._tempInt0+Slices);
			this._tempInt0++;
			this._tempNumver1+=this._tempNumver0;
		}
		return this;
	}

	__proto.boundingBoxLine=function(minX,minY,minZ,maxX,maxY,maxZ,r,g,b,a){
		if (!this._hasBegun || this._primitiveType!==/*laya.webgl.WebGLContext.LINES*/0x0001)
			this.drawLinesException();
		if (this._posInVBData+8 *this._floatSizePerVer > this._vbData.length || this._posInIBData+48 > this._ibData.length)
			this.flush();
		this._tempUint0=this._posInVBData / this._floatSizePerVer;
		this.addVertex(minX,maxY,maxZ,r,g,b,a);
		this.addVertex(maxX,maxY,maxZ,r,g,b,a);
		this.addVertex(minX,minY,maxZ,r,g,b,a);
		this.addVertex(maxX,minY,maxZ,r,g,b,a);
		this.addVertex(maxX,maxY,minZ,r,g,b,a);
		this.addVertex(minX,maxY,minZ,r,g,b,a);
		this.addVertex(maxX,minY,minZ,r,g,b,a);
		this.addVertex(minX,minY,minZ,r,g,b,a);
		this._tempUint1=this._tempUint0+1;
		this._tempUint2=this._tempUint0+2;
		this._tempUint3=this._tempUint0+3;
		this._tempUint4=this._tempUint0+4;
		this._tempUint5=this._tempUint0+5;
		this._tempUint6=this._tempUint0+6;
		this._tempUint7=this._tempUint0+7;
		this.addIndexes(this._tempUint0,this._tempUint1,this._tempUint1,this._tempUint3,this._tempUint3,this._tempUint2,this._tempUint2,this._tempUint0,
		this._tempUint4,this._tempUint5,this._tempUint5,this._tempUint7,this._tempUint7,this._tempUint6,this._tempUint6,this._tempUint4,
		this._tempUint5,this._tempUint0,this._tempUint0,this._tempUint2,this._tempUint2,this._tempUint7,this._tempUint7,this._tempUint5,
		this._tempUint1,this._tempUint4,this._tempUint4,this._tempUint6,this._tempUint6,this._tempUint3,this._tempUint3,this._tempUint1,
		this._tempUint5,this._tempUint4,this._tempUint4,this._tempUint1,this._tempUint1,this._tempUint0,this._tempUint0,this._tempUint5,
		this._tempUint2,this._tempUint3,this._tempUint3,this._tempUint6,this._tempUint6,this._tempUint7,this._tempUint7,this._tempUint2);
		return this;
	}

	__proto.addVertex=function(x,y,z,r,g,b,a){
		if (!this._hasBegun)
			this.addVertexIndexException();
		this._vbData[this._posInVBData]=x,this._vbData[this._posInVBData+1]=y,this._vbData[this._posInVBData+2]=z;
		this._vbData[this._posInVBData+3]=r,this._vbData[this._posInVBData+4]=g,this._vbData[this._posInVBData+5]=b,this._vbData[this._posInVBData+6]=a;
		this._posInVBData+=this._floatSizePerVer;
		return this;
	}

	__proto.addVertexIndex=function(x,y,z,r,g,b,a,index){
		if (!this._hasBegun)
			this.addVertexIndexException();
		this._vbData[index]=x,this._vbData[index+1]=y,this._vbData[index+2]=z;
		this._vbData[index+3]=r,this._vbData[index+4]=g,this._vbData[index+5]=b,this._vbData[index+6]=a;
		index+=this._floatSizePerVer;
		if (index > this._posInVBData)
			this._posInVBData=index;
		return this;
	}

	__proto.addIndexes=function(__indexes){
		var indexes=arguments;
		if (!this._hasBegun)
			this.addVertexIndexException();
		for (var i=0;i < indexes.length;i++){
			this._ibData[this._posInIBData]=indexes[i];
			this._posInIBData++;
		}
		return this;
	}

	__proto.begin=function(primitive,camera){
		if (this._hasBegun)
			this.beginException0();
		if (primitive!==/*laya.webgl.WebGLContext.LINES*/0x0001 && primitive!==/*laya.webgl.WebGLContext.TRIANGLES*/0x0004)
			this.beginException1();
		this._primitiveType=primitive;
		this._camera=camera;
		this._hasBegun=true;
		return this;
	}

	__proto.end=function(){
		if (!this._hasBegun)
			this.endException();
		this.flush();
		this._hasBegun=false;
		return this;
	}

	__proto.flush=function(){
		if (this._posInVBData===0)
			return;
		this._ib.setData(this._ibData);
		this._vb.setData(this._vbData);
		this._vb._bind();
		this._ib._bind();
		this._shader=this._shaderCompile.withCompile(0,0,0);
		this._shader.bind();
		this._shader.uploadAttributes(PhasorSpriter3D._vertexDeclaration.shaderValues.data,null);
		this._spriteShaderValue.setValue(/*laya.d3.core.Sprite3D.MVPMATRIX*/1,(this._camera).projectionViewMatrix.elements);
		this._shader.uploadSpriteUniforms(this._spriteShaderValue.data);
		Stat.drawCall++;
		WebGL.mainContext.drawElements(this._primitiveType,this._posInIBData,/*laya.webgl.WebGLContext.UNSIGNED_SHORT*/0x1403,0);
		this._posInIBData=0;
		this._posInVBData=0;
	}

	__proto.addVertexIndexException=function(){
		throw new Error("请先调用begin()函数");
	}

	__proto.beginException0=function(){
		throw new Error("调用begin()前请确保已成功调用end()！");
	}

	__proto.beginException1=function(){
		throw new Error("只支持“LINES”和“TRIANGLES”两种基元！");
	}

	__proto.endException=function(){
		throw new Error("调用end()前请确保已成功调用begin()！");
	}

	__proto.drawLinesException=function(){
		throw new Error("您必须确保在此之前已调用begin()且使用“LINES”基元！");
	}

	__proto.drawTrianglesException=function(){
		throw new Error("您必须确保在此之前已调用begin()且使用“TRIANGLES”基元！");
	}

	__static(PhasorSpriter3D,
	['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(28,[new VertexElement(0,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.POSITION0*/0),new VertexElement(12,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.COLOR0*/1)]);}
	]);
	return PhasorSpriter3D;
})()


/**
*@private
*<code>RenderElement</code> 类用于实现渲染物体。
*/
//class laya.d3.core.render.RenderElement
var RenderElement=(function(){
	function RenderElement(){
		/**@private */
		this._id=0;
		/**@private 类型0为默认，2为DynamicBatch。*/
		this._type=0;
		/**@private 排序ID。*/
		this._mainSortID=0;
		/**@private */
		this._render=null;
		/**@private 所属Sprite3D精灵。*/
		this._sprite3D=null;
		/**@private 渲染所用材质。*/
		this._material=null;
		/**@private 渲染元素。*/
		this._renderObj=null;
		/**@private */
		this._staticBatch=null;
		//...............临时...........................
		this._tempBatchIndexStart=0;
		//TODO:
		this._tempBatchIndexEnd=0;
		/**@private */
		this._canDynamicBatch=false;
		/**当前ShaderValue。*/
		this._shaderValue=null;
		this._onPreRenderFunction=null;
		this._id=++RenderElement._uniqueIDCounter;
		this._canDynamicBatch=true;
		this._shaderValue=new ValusArray();
	}

	__class(RenderElement,'laya.d3.core.render.RenderElement');
	var __proto=RenderElement.prototype;
	/**
	*@private
	*/
	__proto.getDynamicBatchBakedVertexs=function(index){
		var byteSizeInFloat=4;
		var vb=this._renderObj._getVertexBuffer(index);
		var bakedVertexes=vb.getData().slice();
		var vertexDeclaration=vb.vertexDeclaration;
		var positionOffset=vertexDeclaration.getVertexElementByUsage(/*laya.d3.graphics.VertexElementUsage.POSITION0*/0).offset / byteSizeInFloat;
		var normalOffset=vertexDeclaration.getVertexElementByUsage(/*laya.d3.graphics.VertexElementUsage.NORMAL0*/3).offset / byteSizeInFloat;
		var transform=this._sprite3D.transform;
		var worldMatrix=transform.worldMatrix;
		var rotation=transform.rotation;
		var vertexFloatCount=vertexDeclaration.vertexStride / byteSizeInFloat;
		for (var i=0,n=bakedVertexes.length;i < n;i+=vertexFloatCount){
			var posOffset=i+positionOffset;
			var norOffset=i+normalOffset;
			Utils3D.transformVector3ArrayToVector3ArrayCoordinate(bakedVertexes,posOffset,worldMatrix,bakedVertexes,posOffset);
			Utils3D.transformVector3ArrayByQuat(bakedVertexes,norOffset,rotation,bakedVertexes,norOffset);
		}
		return bakedVertexes;
	}

	/**
	*@private
	*/
	__proto.getBakedIndices=function(){
		return this._renderObj._getIndexBuffer().getData();
	}

	/**
	*@private
	*/
	__proto._destroy=function(){
		(this._staticBatch)&& (this._staticBatch._manager._garbageCollection(this));
	}

	/**
	*获取唯一标识ID,通常用于识别。
	*/
	__getset(0,__proto,'id',function(){
		return this._id;
	});

	__getset(0,__proto,'renderObj',function(){
		return this._renderObj;
		},function(value){
		if (this._renderObj!==value){
			this._renderObj=value;
		}
	});

	RenderElement._uniqueIDCounter=0;
	return RenderElement;
})()


/**
*@private
*<code>RenderQuene</code> 类用于实现渲染队列。
*/
//class laya.d3.core.render.RenderQueue
var RenderQueue=(function(){
	function RenderQueue(scene){
		/**@private */
		this._id=0;
		/**@private */
		this._needSort=false;
		/**@private */
		this._renderElements=null;
		/**@private */
		this._renderableRenderObjects=null;
		/**@private */
		this._dynamicBatchCombineRenderElements=null;
		/**@private */
		this._finalElements=null;
		/**@private */
		this._scene=null;
		this._id=++RenderQueue._uniqueIDCounter;
		this._needSort=false;
		this._scene=scene;
		this._renderElements=[];
		this._renderableRenderObjects=[];
		this._dynamicBatchCombineRenderElements=[];
	}

	__class(RenderQueue,'laya.d3.core.render.RenderQueue');
	var __proto=RenderQueue.prototype;
	__proto._sortOpaqueFunc=function(a,b){
		if (a._render && b._render){
			var renderQueue=a._material.renderQueue-b._material.renderQueue;
			if (renderQueue===0){
				return a._render._distanceForSort-b._render._distanceForSort;
				}else {
				return renderQueue
			}
			}else {
			return 0;
		}
	}

	__proto._sortAlphaFunc=function(a,b){
		if (a._render && b._render){
			var renderQueue=a._material.renderQueue-b._material.renderQueue;
			if (renderQueue===0){
				return b._render._distanceForSort-a._render._distanceForSort;
				}else {
				return renderQueue;
			}
		}else
		return 0;
	}

	/**
	*@private
	*/
	__proto._begainRenderElement=function(state,renderObj,material){
		if (renderObj._beforeRender(state)){
			return true;
		}
		return false;
	}

	/**
	*@private
	*/
	__proto._sortAlpha=function(cameraPos){
		RenderQueue._cameraPosition=cameraPos;
		this._finalElements.sort(this._sortAlphaFunc);
	}

	/**
	*@private
	*/
	__proto._sortOpaque=function(cameraPos){
		RenderQueue._cameraPosition=cameraPos;
		this._finalElements.sort(this._sortOpaqueFunc);
	}

	/**
	*@private
	*准备渲染队列。
	*@param state 渲染状态。
	*/
	__proto._preRender=function(state){
		this._finalElements=this._renderElements.concat(this._dynamicBatchCombineRenderElements);
	}

	/**
	*@private
	*渲染队列。
	*@param state 渲染状态。
	*/
	__proto._render=function(state,isTarget){
		var loopCount=Stat.loopCount;
		var scene=this._scene;
		var camera=state.camera;
		var cameraID=camera.id;
		var vbs;
		var vertexBuffer,vertexDeclaration,shader;
		var forceUploadParams=false;
		var lastStateMaterial,lastStateOwner;
		for (var i=0,n=this._finalElements.length;i < n;i++){
			var renderElement=this._finalElements[i];
			var renderObj,material,owner;
			if (renderElement._onPreRenderFunction !=null){
				renderElement._onPreRenderFunction.call(renderElement._sprite3D,state);
			}
			if (renderElement._type===0){
				state.owner=owner=renderElement._sprite3D;
				state.renderElement=renderElement;
				owner._preRenderUpdateComponents(state);
				renderObj=renderElement.renderObj,material=renderElement._material;
				if (this._begainRenderElement(state,renderObj,material)){
					vbs=renderObj._getVertexBuffers();
					vertexBuffer=renderObj._getVertexBuffer(0);
					vertexDeclaration=vertexBuffer.vertexDeclaration;
					shader=state._shader=material._getShader(scene._shaderDefineValue,vertexDeclaration.shaderDefineValue,owner._shaderDefineValue);
					forceUploadParams=shader.bind()|| (loopCount!==shader._uploadLoopCount);
					if (vbs){
						if (shader._uploadVertexBuffer!==vbs || forceUploadParams){
							for (var j=0;j < vbs.length;j++){
								var vb=vbs[j];
								shader.uploadAttributesX(vb.vertexDeclaration.shaderValues.data,vb);
							}
							shader._uploadVertexBuffer=vbs;
						}
						}else {
						if (shader._uploadVertexBuffer!==vertexBuffer || forceUploadParams){
							shader.uploadAttributes(vertexDeclaration.shaderValues.data,null);
							shader._uploadVertexBuffer=vertexBuffer;
						}
					}
					if (shader._uploadScene!==scene || forceUploadParams){
						shader.uploadSceneUniforms(scene._shaderValues.data);
						shader._uploadScene=scene;
					}
					if (camera!==shader._uploadCamera || shader._uploadSprite3D!==owner || forceUploadParams){
						shader.uploadSpriteUniforms(owner._shaderValues.data);
						shader._uploadSprite3D=owner;
					}
					if (camera!==shader._uploadCamera || forceUploadParams){
						shader.uploadCameraUniforms(camera._shaderValues.data);
						shader._uploadCamera=camera;
					}
					if (shader._uploadMaterial!==material || forceUploadParams){
						material._upload();
						shader._uploadMaterial=material;
					}
					if (lastStateMaterial!==material){
						material._setRenderStateBlendDepth();
						material._setRenderStateFrontFace(isTarget,owner.transform);
						lastStateMaterial=material;
						lastStateOwner=owner;
						}else {
						if (lastStateOwner!==owner){
							material._setRenderStateFrontFace(isTarget,owner.transform);
							lastStateOwner=owner;
						}
					}
					renderObj._render(state);
					shader._uploadLoopCount=loopCount;
				}
				owner._postRenderUpdateComponents(state);
				}else if (renderElement._type===2){
				var dynamicBatch=renderElement.renderObj;
				state.owner=owner=renderElement._sprite3D;
				state.renderElement=renderElement;
				state._batchIndexStart=renderElement._tempBatchIndexStart;
				state._batchIndexEnd=renderElement._tempBatchIndexEnd;
				renderObj=renderElement.renderObj,material=renderElement._material;
				if (this._begainRenderElement(state,renderObj,material)){
					vertexBuffer=renderObj._getVertexBuffer(0);
					vertexDeclaration=vertexBuffer.vertexDeclaration;
					shader=state._shader=material._getShader(scene._shaderDefineValue,vertexDeclaration.shaderDefineValue,owner._shaderDefineValue);
					forceUploadParams=shader.bind()|| (loopCount!==shader._uploadLoopCount);
					if (shader._uploadVertexBuffer!==vertexBuffer || forceUploadParams){
						shader.uploadAttributes(vertexDeclaration.shaderValues.data,null);
						shader._uploadVertexBuffer=vertexBuffer;
					}
					if (shader._uploadScene!==scene || forceUploadParams){
						shader.uploadSceneUniforms(scene._shaderValues.data);
						shader._uploadScene=scene;
					}
					if (camera!==shader._uploadCamera || shader._uploadSprite3D!==owner || forceUploadParams){
						shader.uploadSpriteUniforms(owner._shaderValues.data);
						shader._uploadSprite3D=owner;
					}
					if (camera!==shader._uploadCamera || forceUploadParams){
						shader.uploadCameraUniforms(camera._shaderValues.data);
						shader._uploadCamera=camera;
					}
					if (shader._uploadMaterial!==material || forceUploadParams){
						material._upload();
						shader._uploadMaterial=material;
					}
					if (lastStateMaterial!==material){
						material._setRenderStateBlendDepth();
						material._setRenderStateFrontFace(isTarget,owner.transform);
						lastStateMaterial=material;
						lastStateOwner=owner;
						}else {
						if (lastStateOwner!==owner){
							material._setRenderStateFrontFace(isTarget,owner.transform);
							lastStateOwner=owner;
						}
					}
					renderObj._render(state);
					shader._uploadLoopCount=loopCount;
				}
			}
		}
	}

	/**
	*@private
	*渲染队列。
	*@param state 渲染状态。
	*/
	__proto._renderShadow=function(state,isOnePSSM){
		var loopCount=Stat.loopCount;
		var scene=this._scene;
		var camera=state.camera;
		var vertexBuffer,vertexDeclaration,shader;
		var forceUploadParams=false;
		var lastStateMaterial,lastStateOwner;
		for (var i=0,n=this._finalElements.length;i < n;i++){
			var renderElement=this._finalElements[i];
			var renderObj,material,owner;
			if (renderElement._type===0){
				state.owner=owner=renderElement._sprite3D;
				if (!isOnePSSM && (owner._projectionViewWorldUpdateCamera!==camera || owner._projectionViewWorldUpdateLoopCount!==Stat.loopCount)){
					owner._render._renderUpdate(state._projectionViewMatrix);
					owner._projectionViewWorldUpdateLoopCount=Stat.loopCount;
					owner._projectionViewWorldUpdateCamera=camera;
				}
				state.renderElement=renderElement;
				owner._preRenderUpdateComponents(state);
				renderObj=renderElement.renderObj,material=renderElement._material;
				if (this._begainRenderElement(state,renderObj,null)){
					vertexBuffer=renderObj._getVertexBuffer(0);
					vertexDeclaration=vertexBuffer.vertexDeclaration;
					shader=state._shader=material._getShader(scene._shaderDefineValue,vertexDeclaration.shaderDefineValue,owner._shaderDefineValue);
					forceUploadParams=shader.bind()|| (loopCount!==shader._uploadLoopCount);
					if (shader._uploadVertexBuffer!==vertexBuffer || forceUploadParams){
						shader.uploadAttributes(vertexDeclaration.shaderValues.data,null);
						shader._uploadVertexBuffer=vertexBuffer;
					}
					if (camera!==shader._uploadCamera || shader._uploadSprite3D!==owner || forceUploadParams){
						shader.uploadSpriteUniforms(owner._shaderValues.data);
						shader._uploadSprite3D=owner;
					}
					if (camera!==shader._uploadCamera || forceUploadParams){
						shader.uploadCameraUniforms(camera._shaderValues.data);
						shader._uploadCamera=camera;
					}
					if (shader._uploadMaterial!==material || forceUploadParams){
						material._upload();
						shader._uploadMaterial=material;
					}
					if (shader._uploadRenderElement!==renderElement || forceUploadParams){}
						if (lastStateMaterial!==material){
						material._setRenderStateFrontFace(false,owner.transform);
						lastStateMaterial=material;
						lastStateOwner=owner;
						}else {
						if (lastStateOwner!==owner){
							material._setRenderStateFrontFace(false,owner.transform);
							lastStateOwner=owner;
						}
					}
					renderObj._render(state);
					shader._uploadLoopCount=loopCount;
				}
				owner._postRenderUpdateComponents(state);
			}
		}
	}

	/**
	*清空队列中的渲染物体。
	*/
	__proto._clearRenderElements=function(){
		this._dynamicBatchCombineRenderElements.length=0;
		this._renderElements.length=0;
		this._needSort=true;
	}

	/**
	*添加渲染物体。
	*@param renderObj 渲染物体。
	*/
	__proto._addRenderElement=function(renderElement){
		this._renderElements.push(renderElement);
		this._needSort=true;
	}

	/**
	*添加动态批处理。
	*@param renderObj 动态批处理。
	*/
	__proto._addDynamicBatchElement=function(dynamicBatchElement){
		this._dynamicBatchCombineRenderElements.push(dynamicBatchElement);
	}

	/**
	*获取唯一标识ID(通常用于优化或识别)。
	*/
	__getset(0,__proto,'id',function(){
		return this._id;
	});

	RenderQueue._uniqueIDCounter=0;
	RenderQueue._cameraPosition=null;
	return RenderQueue;
})()


/**
*<code>RenderState</code> 类用于实现渲染状态。
*/
//class laya.d3.core.render.RenderState
var RenderState=(function(){
	function RenderState(){
		/**@private */
		this._staticBatch=null;
		/**@private */
		this._batchIndexStart=0;
		/**@private */
		this._batchIndexEnd=0;
		/**@private */
		this._viewMatrix=null;
		/**@private */
		this._projectionMatrix=null;
		/**@private */
		this._projectionViewMatrix=null;
		/**@private */
		this._viewport=null;
		/**@private */
		this._shader=null;
		/**距上一帧间隔时间。*/
		this.elapsedTime=NaN;
		/**当前场景。*/
		this.scene=null;
		/**当前渲染3D精灵。*/
		this.owner=null;
		/**当前渲染物体。*/
		this.renderElement=null;
		/**当前摄像机。*/
		this.camera=null;
	}

	__class(RenderState,'laya.d3.core.render.RenderState');
	RenderState.clientWidth=0;
	RenderState.clientHeight=0;
	return RenderState;
})()


//class laya.d3.core.scene.OctreeNode
var OctreeNode=(function(){
	function OctreeNode(scene,currentDepth){
		this._exactBox=null;
		this._relaxBox=null;
		this._scene=null;
		this._parent=null;
		this._currentDepth=0;
		this._boundingSphere=new BoundSphere(new Vector3(),0);
		this._corners=/*new vector.<>*/[new Vector3(),new Vector3(),new Vector3(),new Vector3(),new Vector3(),new Vector3(),new Vector3(),new Vector3()];
		this._boundingBoxCenter=new Vector3();
		this._children=__newvec(8);
		this._objects=[];
		this._tempBoundBoxCorners=/*new vector.<>*/[new Vector3(),new Vector3(),new Vector3(),new Vector3(),new Vector3(),new Vector3(),new Vector3(),new Vector3()];
		this._scene=scene;
		this._currentDepth=currentDepth;
	}

	__class(OctreeNode,'laya.d3.core.scene.OctreeNode');
	var __proto=OctreeNode.prototype;
	Laya.imps(__proto,{"laya.d3.core.scene.ITreeNode":true})
	__proto.init=function(center,treeSize){
		var min=new Vector3();
		var max=new Vector3();
		Vector3.scale(treeSize,-0.5,min);
		Vector3.scale(treeSize,0.5,max);
		Vector3.add(min,center,min);
		Vector3.add(max,center,max);
		this.exactBox=new BoundBox(min,max);
		this.relaxBox=new BoundBox(min,max);
	}

	__proto.addTreeNode=function(render){
		if (Collision.boxContainsBox(this._relaxBox,render.boundingBox)===/*laya.d3.math.ContainmentType.Contains*/1)
			this.addNodeDown(render,0);
		else
		this.addObject(render);
	}

	__proto.addChild=function(index){
		var child=this._children[index];
		if (child==null){
			child=new OctreeNode(this._scene,this._currentDepth+1);
			this._children[index]=child;
			child._parent=this;
			Vector3.subtract(this._exactBox.max,this._exactBox.min,OctreeNode.tempSize);
			Vector3.multiply(OctreeNode.tempSize,OctreeNode._octreeSplit[index],OctreeNode.tempCenter);
			Vector3.add(this._exactBox.min,OctreeNode.tempCenter,OctreeNode.tempCenter);
			Vector3.scale(OctreeNode.tempSize,0.25,OctreeNode.tempSize);
			var min=new Vector3();
			var max=new Vector3();
			Vector3.subtract(OctreeNode.tempCenter,OctreeNode.tempSize,min);
			Vector3.add(OctreeNode.tempCenter,OctreeNode.tempSize,max);
			child.exactBox=new BoundBox(min,max);
			Vector3.scale(OctreeNode.tempSize,OctreeNode.relax,OctreeNode.tempSize);
			var relaxMin=new Vector3();
			var relaxMax=new Vector3();
			Vector3.subtract(OctreeNode.tempCenter,OctreeNode.tempSize,relaxMin);
			Vector3.add(OctreeNode.tempCenter,OctreeNode.tempSize,relaxMax);
			child.relaxBox=new BoundBox(relaxMin,relaxMax);
		}
		return child;
	}

	__proto.addObject=function(object){
		object._treeNode=this;
		this._objects.push(object);
	}

	__proto.removeObject=function(object){
		if (object._treeNode !=this){
			console.log("OctreeNode::removeObject error");
			return false;
		};
		var index=this._objects.indexOf(object);
		if (index!==-1){
			this._objects.splice(index,1);
			return true;
		}
		return false;
	}

	__proto.clearObject=function(){
		this._objects.length=0;
	}

	__proto.addNodeUp=function(render,depth){
		if (this._parent && (Collision.boxContainsBox(this._exactBox,render.boundingBox)!==/*laya.d3.math.ContainmentType.Contains*/1)){
			this._parent.addNodeUp(render,depth-1);
		}else
		this.addNodeDown(render,depth);
	}

	__proto.addNodeDown=function(render,depth){
		if (depth < this._scene.treeLevel){
			var childIndex=this.inChildIndex(render.boundingBoxCenter);
			var child=this.addChild(childIndex);
			if (Collision.boxContainsBox(child._relaxBox,render.boundingBox)===/*laya.d3.math.ContainmentType.Contains*/1){
				child.addNodeDown(render,++depth);
			}else
			this.addObject(render);
			}else {
			this.addObject(render);
		}
	}

	__proto.inChildIndex=function(objectCenter){
		var z=objectCenter.z < this._boundingBoxCenter.z ? 0 :1;
		var y=objectCenter.y < this._boundingBoxCenter.y ? 0 :1;
		var x=objectCenter.x < this._boundingBoxCenter.x ? 0 :1;
		return z *4+y *2+x;
	}

	__proto.updateObject=function(render){
		if (Collision.boxContainsBox(this._relaxBox,render.boundingBox)===/*laya.d3.math.ContainmentType.Contains*/1){
			this.removeObject(render);
			render._treeNode=null;
			this.addNodeDown(render,this._currentDepth);
			}else if (this._parent){
			this.removeObject(render);
			render._treeNode=null;
			this._parent.addNodeUp(render,this._currentDepth-1);
		}
	}

	__proto.cullingObjects=function(boundFrustum,testVisible,flags,cameraPosition,projectionView){
		var i=0,j=0,n=0,m=0;
		var dynamicBatchManager=this._scene._dynamicBatchManager;
		for (i=0,n=this._objects.length;i < n;i++){
			var render=this._objects[i];
			if (Layer.isVisible(render._owner.layer.mask)&& render.enable){
				if (testVisible){
					Stat.treeSpriteCollision+=1;
					if (boundFrustum.containsBoundSphere(render.boundingSphere)===/*laya.d3.math.ContainmentType.Disjoint*/0)
						continue ;
				}
				render._renderUpdate(projectionView);
				render._distanceForSort=Vector3.distance(render.boundingSphere.center,cameraPosition)+render.sortingFudge;
				var renderElements=render._renderElements;
				for (j=0,m=renderElements.length;j < m;j++){
					var renderElement=renderElements[j];
					var staticBatch=renderElement._staticBatch;
					if (staticBatch && (staticBatch._material===renderElement._material)){
						staticBatch._addBatchRenderElement(renderElement);
						}else {
						var renderObj=renderElement.renderObj;
						if ((renderObj.triangleCount < /*laya.d3.graphics.DynamicBatch.maxCombineTriangleCount*/10)&& (renderObj._vertexBufferCount===1)&& (renderObj._getIndexBuffer())&& (renderElement._material.renderQueue < 2)&& renderElement._canDynamicBatch && (!render._owner.isStatic))
							dynamicBatchManager._addPrepareRenderElement(renderElement);
						else
						this._scene.getRenderQueue(renderElement._material.renderQueue)._addRenderElement(renderElement);
					}
				}
			}
		}
		for (i=0;i < 8;i++){
			var child=this._children[i];
			if (child==null)
				continue ;
			var testVisibleChild=testVisible;
			if (testVisible){
				var type=boundFrustum.containsBoundBox(child._relaxBox);
				Stat.treeNodeCollision+=1;
				if (type===/*laya.d3.math.ContainmentType.Disjoint*/0)
					continue ;
				testVisibleChild=(type===/*laya.d3.math.ContainmentType.Intersects*/2);
			}
			child.cullingObjects(boundFrustum,testVisibleChild,flags,cameraPosition,projectionView);
		}
	}

	/**
	*@private
	*/
	__proto.cullingShadowObjects=function(lightBoundFrustum,splitShadowQueues,testVisible,flags,scene){
		var i=0,j=0,n=0,m=0;
		var dynamicBatchManager=this._scene._dynamicBatchManager;
		for (i=0,n=this._objects.length;i < n;i++){
			var baseRender=this._objects[i];
			if (baseRender.castShadow && Layer.isVisible(baseRender._owner.layer.mask)&& baseRender.enable){
				if (testVisible && lightBoundFrustum[0].containsBoundSphere(baseRender.boundingSphere)===/*laya.d3.math.ContainmentType.Disjoint*/0)
					continue ;
				for (var k=1,kNum=lightBoundFrustum.length;k < kNum;k++){
					var shadowQueue=splitShadowQueues[k-1];
					if (lightBoundFrustum[k].containsBoundSphere(baseRender.boundingSphere)!==/*laya.d3.math.ContainmentType.Disjoint*/0){
						var renderElements=baseRender._renderElements;
						for (j=0,m=renderElements.length;j < m;j++)
						shadowQueue._addRenderElement(renderElements[j]);
					}
				}
			}
		}
		for (i=0;i < 8;i++){
			var child=this._children[i];
			if (child==null)
				continue ;
			var testVisibleChild=testVisible;
			if (testVisible){
				var type=lightBoundFrustum[0].containsBoundBox(child._relaxBox);
				if (type===/*laya.d3.math.ContainmentType.Disjoint*/0)
					continue ;
				testVisibleChild=(type===/*laya.d3.math.ContainmentType.Intersects*/2);
			}
			child.cullingShadowObjects(lightBoundFrustum,splitShadowQueues,testVisibleChild,flags,scene);
		}
	}

	/**
	*@private
	*/
	__proto.cullingShadowObjectsOnePSSM=function(lightBoundFrustum,splitShadowQueues,lightViewProjectMatrix,testVisible,flags,scene){
		var shadowQueue=splitShadowQueues[0];
		var i=0,j=0,n=0,m=0;
		for (i=0,n=this._objects.length;i < n;i++){
			var baseRender=this._objects[i];
			if (baseRender.castShadow && Layer.isVisible(baseRender._owner.layer.mask)&& baseRender.enable){
				if (testVisible && lightBoundFrustum.containsBoundSphere(baseRender.boundingSphere)===/*laya.d3.math.ContainmentType.Disjoint*/0)
					continue ;
				baseRender._renderUpdate(lightViewProjectMatrix);
				var renderElements=baseRender._renderElements;
				for (j=0,m=renderElements.length;j < m;j++)
				shadowQueue._addRenderElement(renderElements[j]);
			}
		}
		for (i=0;i < 8;i++){
			var child=this._children[i];
			if (child==null)
				continue ;
			var testVisibleChild=testVisible;
			if (testVisible){
				var type=lightBoundFrustum.containsBoundBox(child._relaxBox);
				if (type===/*laya.d3.math.ContainmentType.Disjoint*/0)
					continue ;
				testVisibleChild=(type===/*laya.d3.math.ContainmentType.Intersects*/2);
			}
			child.cullingShadowObjectsOnePSSM(lightBoundFrustum,splitShadowQueues,lightViewProjectMatrix,testVisibleChild,flags,scene);
		}
	}

	__proto.renderBoudingBox=function(linePhasor){
		this._renderBoudingBox(linePhasor);
		for (var i=0;i < 8;++i){
			var pChild=this._children[i];
			if (pChild){
				pChild.renderBoudingBox(linePhasor);
			}
		}
	}

	__proto.buildAllChild=function(depth){
		if (depth < this._scene.treeLevel){
			for (var i=0;i < 8;i++){
				var child=this.addChild(i);
				child.buildAllChild(depth+1);
			}
		}
	}

	__proto._renderBoudingBox=function(linePhasor){}
	__getset(0,__proto,'exactBox',function(){
		return this._exactBox;
		},function(value){
		this._exactBox=value;
		Vector3.add(value.min,value.max,this._boundingBoxCenter);
		Vector3.scale(this._boundingBoxCenter,0.5,this._boundingBoxCenter);
	});

	__getset(0,__proto,'relaxBox',function(){
		return this._relaxBox;
		},function(value){
		this._relaxBox=value;
		value.getCorners(this._corners);
		BoundSphere.createfromPoints(this._corners,this._boundingSphere);
	});

	OctreeNode.debugMode=false;
	OctreeNode.relax=1.15;
	OctreeNode.CHILDNUM=8;
	__static(OctreeNode,
	['tempVector0',function(){return this.tempVector0=new Vector3();},'tempSize',function(){return this.tempSize=new Vector3();},'tempCenter',function(){return this.tempCenter=new Vector3();},'_octreeSplit',function(){return this._octreeSplit=[new Vector3(0.250,0.250,0.250),new Vector3(0.750,0.250,0.250),new Vector3(0.250,0.750,0.250),new Vector3(0.750,0.750,0.250),new Vector3(0.250,0.250,0.750),new Vector3(0.750,0.250,0.750),new Vector3(0.250,0.750,0.750),new Vector3(0.750,0.750,0.750)];}
	]);
	return OctreeNode;
})()


/**
*...
*@author ...
*/
//class laya.d3.core.scene.SceneManager
var SceneManager=(function(){
	function SceneManager(){}
	__class(SceneManager,'laya.d3.core.scene.SceneManager');
	return SceneManager;
})()


//class laya.d3.core.trail.module.Color
var Color$1=(function(){
	function Color(r,g,b,a){
		this._r=NaN;
		this._g=NaN;
		this._b=NaN;
		this._a=NaN;
		(r===void 0)&& (r=1);
		(g===void 0)&& (g=1);
		(b===void 0)&& (b=1);
		(a===void 0)&& (a=1);
		this._r=r;
		this._g=g;
		this._b=b;
		this._a=a;
	}

	__class(Color,'laya.d3.core.trail.module.Color',null,'Color$1');
	var __proto=Color.prototype;
	__proto.cloneTo=function(destObject){
		destObject._r=this._r;
		destObject._g=this._g;
		destObject._b=this._b;
		destObject._a=this._a;
	}

	__static(Color,
	['RED',function(){return this.RED=new Color(1,0,0,1);},'GREEN',function(){return this.GREEN=new Color(0,1,0,1);},'BLUE',function(){return this.BLUE=new Color(0,0,1,1);},'CYAN',function(){return this.CYAN=new Color(0,1,1,1);},'YELLOW',function(){return this.YELLOW=new Color(1,0.92,0.016,1);},'MAGENTA',function(){return this.MAGENTA=new Color(1,0,1,1);},'GRAY',function(){return this.GRAY=new Color(0.5,0.5,0.5,1);},'WHITE',function(){return this.WHITE=new Color(1,1,1,1);},'BLACK',function(){return this.BLACK=new Color(0,0,0,1);}
	]);
	return Color;
})()


//class laya.d3.core.trail.module.Gradient
var Gradient=(function(){
	function Gradient(){
		/**
		*梯度模式
		*/
		this._mode=0;
		/**
		*颜色值关键帧数据,最大长度为10
		*/
		this._colorKeys=null;
		/**
		*透明度关键帧数据,最大长度为10
		*/
		this._alphaKeys=null;
		this.index=0;
		this._colorKeyData=new Float32Array(40);
		this._alphaKeyData=new Float32Array(20);
		this._colorKeys=[];
		this._alphaKeys=[];
	}

	__class(Gradient,'laya.d3.core.trail.module.Gradient');
	var __proto=Gradient.prototype;
	/**
	*设置渐变，使用一组颜色关键帧数据和透明度关键帧数据。
	*@param colorKeys 渐变的颜色值关键帧数据(最大长度为10)。
	*@param alphaKeys 渐变的透明度关键帧数据(最大长度为10)。
	*/
	__proto.setKeys=function(colorKeys,alphaKeys){
		this._colorKeys=colorKeys;
		this.index=0;
		var gradientColorKey;
		for (var i=0;i < colorKeys.length;i++){
			gradientColorKey=colorKeys[i];
			var color=gradientColorKey.color;
			this._colorKeyData[this.index++]=color._r;
			this._colorKeyData[this.index++]=color._g;
			this._colorKeyData[this.index++]=color._b;
			this._colorKeyData[this.index++]=gradientColorKey.time;
		}
		this._alphaKeys=alphaKeys;
		this.index=0;
		var gradientAlphaKey;
		for (var j=0;j < alphaKeys.length;j++){
			gradientAlphaKey=alphaKeys[j];
			this._alphaKeyData[this.index++]=gradientAlphaKey.alpha;
			this._alphaKeyData[this.index++]=gradientAlphaKey.time;
		}
	}

	__proto.cloneTo=function(destObject){
		var i=0,j=0;
		var cks=this.colorKeys;
		var _cks=[];
		for (i=0,j=cks.length;i < j;i++){
			var _ck=new GradientColorKey();
			cks[i].cloneTo(_ck);
			_cks.push(_ck);
		};
		var aks=this.alphaKeys;
		var _aks=[];
		for (i=0,j=aks.length;i < j;i++){
			var _ak=new GradientAlphaKey();
			aks[i].cloneTo(_ak);
			_aks.push(_ak);
		}
		destObject.setKeys(_cks,_aks);
	}

	/**
	*设置梯度模式。
	*@param value 梯度模式。
	*/
	/**
	*获取梯度模式。
	*@return 梯度模式。
	*/
	__getset(0,__proto,'mode',function(){
		return this._mode;
		},function(value){
		this._mode=value;
	});

	/**
	*设置颜色值关键帧数据
	*/
	/**
	*获取颜色值关键帧数据
	*/
	__getset(0,__proto,'colorKeys',function(){
		return this._colorKeys;
		},function(values){
		this._colorKeys=values;
		this.index=0;
		for (var i=0;i < values.length;i++){
			var value=values[i];
			var color=value.color;
			this._colorKeyData[this.index++]=color._r;
			this._colorKeyData[this.index++]=color._g;
			this._colorKeyData[this.index++]=color._b;
			this._colorKeyData[this.index++]=value.time;
		}
	});

	/**
	*设置透明度关键帧数据
	*/
	/**
	*获取透明度关键帧数据
	*/
	__getset(0,__proto,'alphaKeys',function(){
		return this._alphaKeys;
		},function(values){
		this._alphaKeys=values;
		this.index=0;
		for (var i=0;i < values.length;i++){
			var value=values[i];
			this._alphaKeyData[this.index++]=value.alpha;
			this._alphaKeyData[this.index++]=value.time;
		}
	});

	return Gradient;
})()


//class laya.d3.core.trail.module.GradientAlphaKey
var GradientAlphaKey=(function(){
	function GradientAlphaKey(alpha,time){
		this._alpha=NaN;
		this._time=NaN;
		(alpha===void 0)&& (alpha=0);
		(time===void 0)&& (time=0);
		this._alpha=alpha;
		this._time=time;
	}

	__class(GradientAlphaKey,'laya.d3.core.trail.module.GradientAlphaKey');
	var __proto=GradientAlphaKey.prototype;
	__proto.cloneTo=function(destObject){
		destObject.alpha=this.alpha;
		destObject.time=this.time;
	}

	/**
	*设置透明度。
	*@param value 透明度。
	*/
	/**
	*获取透明度。
	*@return 透明度。
	*/
	__getset(0,__proto,'alpha',function(){
		return this._alpha;
		},function(value){
		this._alpha=value;
	});

	/**
	*设置时间。
	*@param value 时间。
	*/
	/**
	*获取时间。
	*@return 时间。
	*/
	__getset(0,__proto,'time',function(){
		return this._time;
		},function(value){
		this._time=value;
	});

	return GradientAlphaKey;
})()


//class laya.d3.core.trail.module.GradientColorKey
var GradientColorKey=(function(){
	function GradientColorKey(color,time){
		this._color=null;
		this._time=NaN;
		(time===void 0)&& (time=0);
		this._color=color||new Color$1();
		this._time=time;
	}

	__class(GradientColorKey,'laya.d3.core.trail.module.GradientColorKey');
	var __proto=GradientColorKey.prototype;
	__proto.cloneTo=function(destObject){
		this.color.cloneTo(destObject.color);
		destObject.time=this.time;
	}

	/**
	*设置颜色值。
	*@param value 颜色值。
	*/
	/**
	*获取颜色值。
	*@return 颜色值。
	*/
	__getset(0,__proto,'color',function(){
		return this._color;
		},function(value){
		this._color=value;
	});

	/**
	*设置时间。
	*@param value 时间。
	*/
	/**
	*获取时间。
	*@return 时间。
	*/
	__getset(0,__proto,'time',function(){
		return this._time;
		},function(value){
		this._time=value;
	});

	return GradientColorKey;
})()


/**
*...
*@author ...
*/
//class laya.d3.core.trail.module.GradientMode
var GradientMode=(function(){
	function GradientMode(){}
	__class(GradientMode,'laya.d3.core.trail.module.GradientMode');
	GradientMode.Blend=0;
	GradientMode.Fixed=1;
	return GradientMode;
})()


/**
*...
*@author ...
*/
//class laya.d3.core.trail.module.TextureMode
var TextureMode=(function(){
	function TextureMode(){}
	__class(TextureMode,'laya.d3.core.trail.module.TextureMode');
	TextureMode.Stretch=0;
	TextureMode.Tile=1;
	return TextureMode;
})()


//class laya.d3.core.trail.module.TrailKeyFrame
var TrailKeyFrame=(function(){
	function TrailKeyFrame(){
		this.time=NaN;
		this.inTangent=NaN;
		this.outTangent=NaN;
		this.value=NaN;
	}

	__class(TrailKeyFrame,'laya.d3.core.trail.module.TrailKeyFrame');
	var __proto=TrailKeyFrame.prototype;
	__proto.cloneTo=function(destObject){
		destObject.time=this.time;
		destObject.inTangent=this.inTangent;
		destObject.outTangent=this.outTangent;
		destObject.value=this.value;
	}

	return TrailKeyFrame;
})()


/**
*...
*@author ...
*/
//class laya.d3.core.trail.TrailRenderElement
var TrailRenderElement=(function(){
	function TrailRenderElement(owner){
		this._id=0;
		this._owner=null;
		this._camera=null;
		this._vertexBuffers=null;
		//固定顶点个数
		this._verticesCount=0;
		//虚拟顶点个数
		this._virtualVerticesCount=0;
		this._maxVerticesCount=256;
		this._vertices1=null;
		this._vertexBuffer1=null;
		this._floatCountPerVertices1=8;
		this._verticesIndex1=0;
		this._everyAddVerticeCount1=0;
		this._delLength=0;
		this._vertices2=null;
		this._vertexBuffer2=null;
		this._floatCountPerVertices2=1;
		this._everyGroupVertexBirthTime=null;
		this._VerticesToTailLength=null;
		this._everyVertexToPreVertexDistance=null;
		this._pointe=null;
		this._pointAtoBVector3e=null;
		this._isStart=false;
		this._isFinish=false;
		this._isDead=false;
		this._curtime=NaN;
		this._curDisappearIndex=0;
		this._lastPosition=new Vector3();
		this._curPosition=new Vector3();
		this._delVector3=new Vector3();
		this._lastFixedVertexPosition=new Vector3();
		this._pointAtoBVector3=new Vector3();
		this._pointA=new Vector3();
		this._pointB=new Vector3();
		this._owner=owner;
		this._id=TrailRenderElement.renderElementCount++;
		if (this._id==0){
			owner._owner.transform.position.cloneTo(this._lastPosition);
			}else {
			owner._curSubTrailFinishPosition.cloneTo(this._lastPosition);
		}
		this._everyGroupVertexBirthTime=[];
		this._VerticesToTailLength=new Float32Array(this._maxVerticesCount);
		this._everyVertexToPreVertexDistance=new Float32Array(this._maxVerticesCount);
		this._vertices1=new Float32Array(this._maxVerticesCount *this._floatCountPerVertices1);
		this._vertices2=new Float32Array(this._maxVerticesCount *this._floatCountPerVertices2);
		this._vertexBuffer1=new VertexBuffer3D(VertexTrail.vertexDeclaration1,this._maxVerticesCount,/*laya.webgl.WebGLContext.STATIC_DRAW*/0x88E4,true);
		this._vertexBuffer2=new VertexBuffer3D(VertexTrail.vertexDeclaration2,this._maxVerticesCount,/*laya.webgl.WebGLContext.STATIC_DRAW*/0x88E4,true);
		this._vertexBuffers=[];
		this._vertexBuffers.push(this._vertexBuffer1);
		this._vertexBuffers.push(this._vertexBuffer2);
	}

	__class(TrailRenderElement,'laya.d3.core.trail.TrailRenderElement');
	var __proto=TrailRenderElement.prototype;
	Laya.imps(__proto,{"laya.d3.core.render.IRenderable":true})
	/**
	*@private
	*更新Trail数据
	*/
	__proto._updateTrail=function(){
		this._everyAddVerticeCount1=0;
		if (!this._isStart){
			this._addTrailByFirstPosition(this._lastPosition,this._curPosition);
		}
		this._addTrailByNextPosition(this._curPosition);
		this._vertexBuffer1.setData(this._vertices1,this._verticesIndex1,this._verticesIndex1,this._everyAddVerticeCount1);
		this._verticesIndex1+=this._everyAddVerticeCount1;
		this._curPosition.cloneTo(this._lastPosition);
		if (this._virtualVerticesCount==2){
			this._verticesIndex1-=this._floatCountPerVertices1 *2;
		}
	}

	/**
	*@private
	*通过起始位置添加TrailRenderElement起始数据
	*@param firstPosition 起始位置
	*@param secondPosition 第二次位置
	*/
	__proto._addTrailByFirstPosition=function(firstPosition,secondPosition){
		Vector3.subtract(secondPosition,firstPosition,this._delVector3);
		Vector3.cross(this._delVector3,this._camera.forward,this._pointAtoBVector3);
		Vector3.normalize(this._pointAtoBVector3,this._pointAtoBVector3);
		Vector3.scale(this._pointAtoBVector3,this._owner.widthMultiplier / 2,this._pointAtoBVector3);
		this._updateVerticesByPosition(firstPosition);
		firstPosition.cloneTo(this._lastFixedVertexPosition);
		this._verticesCount+=2;
		this._curtime=this._owner._hasLifeSubTrail ? this._owner._curSubTrailFinishCurTime :this._owner._curtime;
		this._everyGroupVertexBirthTime.push(this._curtime);
		this._isStart=true;
		this._owner._hasLifeSubTrail=true;
	}

	/**
	*@private
	*通过位置更新TrailRenderElement数据
	*@param position 位置
	*/
	__proto._addTrailByNextPosition=function(position){
		Vector3.subtract(position,this._lastFixedVertexPosition,this._delVector3);
		Vector3.cross(this._delVector3,this._camera.forward,this._pointAtoBVector3);
		Vector3.normalize(this._pointAtoBVector3,this._pointAtoBVector3);
		Vector3.scale(this._pointAtoBVector3,this._owner.widthMultiplier / 2,this._pointAtoBVector3);
		this._delLength=Vector3.scalarLength(this._delVector3);
		if (this._delLength-this._owner.minVertexDistance >=MathUtils3D.zeroTolerance){
			this._owner._trailTotalLength+=this._delLength;
			this._owner._trailSupplementLength=0;
			this._updateVerticesByPosition(position);
			position.cloneTo(this._lastFixedVertexPosition);
			this._verticesCount+=2;
			this._virtualVerticesCount=0;
			this._everyGroupVertexBirthTime.push(this._owner._curtime);
			if (this._verticesCount==this._maxVerticesCount){
				this._onTrailRenderElementFinish();
			}
		}
		else {
			this._owner._trailSupplementLength=this._delLength;
			this._updateVerticesByPosition(position);
			this._virtualVerticesCount=2;
		}
	}

	/**
	*@private
	*通过位置更新顶点数据
	*@param position 位置
	*/
	__proto._updateVerticesByPosition=function(position){
		this._pointe=position.elements;
		this._pointAtoBVector3e=this._pointAtoBVector3.elements;
		this._curtime=this._owner._curtime;
		if (this._owner._hasLifeSubTrail && this._isStart==false){
			this._pointe=this._owner._curSubTrailFinishPosition.elements;
			this._pointAtoBVector3e=this._owner._curSubTrailFinishDirection.elements;
			this._curtime=this._owner._curSubTrailFinishCurTime;
		}
		this._vertices1[this._verticesIndex1+this._everyAddVerticeCount1++]=this._pointe[0];
		this._vertices1[this._verticesIndex1+this._everyAddVerticeCount1++]=this._pointe[1];
		this._vertices1[this._verticesIndex1+this._everyAddVerticeCount1++]=this._pointe[2];
		this._vertices1[this._verticesIndex1+this._everyAddVerticeCount1++]=-this._pointAtoBVector3e[0];
		this._vertices1[this._verticesIndex1+this._everyAddVerticeCount1++]=-this._pointAtoBVector3e[1];
		this._vertices1[this._verticesIndex1+this._everyAddVerticeCount1++]=-this._pointAtoBVector3e[2];
		this._vertices1[this._verticesIndex1+this._everyAddVerticeCount1++]=this._curtime;
		this._vertices1[this._verticesIndex1+this._everyAddVerticeCount1++]=1.0;
		this._vertices1[this._verticesIndex1+this._everyAddVerticeCount1++]=this._pointe[0];
		this._vertices1[this._verticesIndex1+this._everyAddVerticeCount1++]=this._pointe[1];
		this._vertices1[this._verticesIndex1+this._everyAddVerticeCount1++]=this._pointe[2];
		this._vertices1[this._verticesIndex1+this._everyAddVerticeCount1++]=this._pointAtoBVector3e[0];
		this._vertices1[this._verticesIndex1+this._everyAddVerticeCount1++]=this._pointAtoBVector3e[1];
		this._vertices1[this._verticesIndex1+this._everyAddVerticeCount1++]=this._pointAtoBVector3e[2];
		this._vertices1[this._verticesIndex1+this._everyAddVerticeCount1++]=this._curtime;
		this._vertices1[this._verticesIndex1+this._everyAddVerticeCount1++]=0.0;
		this._VerticesToTailLength[this._verticesCount / 2]=this._owner._trailTotalLength+this._owner._trailSupplementLength;
		if (this._owner._trailSupplementLength==0){
			this._everyVertexToPreVertexDistance[this._verticesCount / 2]=this._delLength;
			}else {
			this._everyVertexToPreVertexDistance[this._verticesCount / 2]=this._isStart ? this._owner._trailSupplementLength :0;
		}
	}

	/**
	*更新VertexBuffer2数据
	*/
	__proto._updateVertexBuffer2=function(){
		var _uvIndex=0;
		var _uvX=0.0;
		var i=0,j=0;
		for (i=0,j=(this._verticesCount+this._virtualVerticesCount)/ 2;i < j;i++){
			if (this._owner.textureMode==/*laya.d3.core.trail.module.TextureMode.Stretch*/0){
				_uvX=(this._VerticesToTailLength[i]-this._owner._trailDeadLength)/ (this._owner._trailTotalLength+this._owner._trailSupplementLength-this._owner._trailDeadLength);
				}else {
				_uvX=this._owner._trailTotalLength+this._owner._trailSupplementLength-this._VerticesToTailLength[i];
			}
			this._vertices2[_uvIndex++]=1.0-_uvX;
			this._vertices2[_uvIndex++]=1.0-_uvX;
		}
		this._vertexBuffer2.setData(this._vertices2,0,0,this._verticesCount+this._virtualVerticesCount);
	}

	/**
	*trailRenderElement完成时调用
	*@param finishedPosition
	*/
	__proto._onTrailRenderElementFinish=function(){
		this._lastFixedVertexPosition.cloneTo(this._owner._curSubTrailFinishPosition);
		this._pointAtoBVector3.cloneTo(this._owner._curSubTrailFinishDirection);
		this._owner._curSubTrailFinishCurTime=this._owner._curtime;
		this._isFinish=true;
	}

	/**
	*@private
	*/
	__proto._updateDisappear=function(){
		var i=0,j=0;
		for (i=this._curDisappearIndex,j=(this._verticesCount+this._virtualVerticesCount)/ 2;i < j;i++){
			if (this._owner._curtime-this._everyGroupVertexBirthTime[i] >=this._owner.time+MathUtils3D.zeroTolerance){
				this._curDisappearIndex++;
				this._owner._trailDeadLength+=this._everyVertexToPreVertexDistance[this._curDisappearIndex];
				if (this._curDisappearIndex >=(this._verticesCount+this._virtualVerticesCount)/ 2){
					this._isDead=true;
				}
			}
		}
	}

	/**
	*渲染前调用
	*@param state 渲染状态
	*@return 是否渲染
	*/
	__proto._beforeRender=function(state){
		this._camera=state.camera;
		if (this._camera==null)
			return false;
		this._owner._owner.transform.position.cloneTo(this._curPosition);
		if (!this._isDead){
			if (this._verticesCount < this._maxVerticesCount){
				if (!this._owner._isStart){
					this._owner._owner.transform.position.cloneTo(this._lastPosition);
					this._owner._isStart=true;
				}
				if (!Vector3.equals(this._lastPosition,this._curPosition)){
					this._updateTrail();
				}
				}else {
				if (this._isFinish){
					this._isFinish=false;
					this._owner._curSubTrailFinished=true;
				}
			}
			if (this._verticesCount > 0){
				this._updateVertexBuffer2();
				this._updateDisappear();
				return true;
			}
		}
		return false;
	}

	/**
	*渲染时调用
	*@param state 渲染状态
	*/
	__proto._render=function(state){
		if (this._isDead)
			return;
		WebGL.mainContext.drawArrays(/*laya.webgl.WebGLContext.TRIANGLE_STRIP*/0x0005,this._curDisappearIndex *2,this._verticesCount+this._virtualVerticesCount-this._curDisappearIndex *2);
		console.log(this._curDisappearIndex *2,this._verticesCount+this._virtualVerticesCount-this._curDisappearIndex *2);
		Stat.drawCall++;
		Stat.trianglesFaces+=(this._verticesCount+this._virtualVerticesCount-this._curDisappearIndex *2-2);
	}

	/**
	*获取vertexBuffer
	*@param index vertexBuffer索引
	*@return vertexBuffer
	*/
	__proto._getVertexBuffer=function(index){
		(index===void 0)&& (index=0);
		if (index===0)
			return this._vertexBuffer1;
		else if (index===1)
		return this._vertexBuffer2;
		else
		return null;
	}

	/**
	*获取vertexBuffer数组
	*@return vertexBuffer数组
	*/
	__proto._getVertexBuffers=function(){
		return this._vertexBuffers;
	}

	/**
	*获取顶点索引缓冲
	*@return 顶点索引缓冲
	*/
	__proto._getIndexBuffer=function(){
		return null;
	}

	/**
	*重新激活该renderElement
	*/
	__proto.reActivate=function(){
		this._id=laya.d3.core.trail.TrailRenderElement.renderElementCount++;
		this._isStart=false;
		this._isFinish=false;
		this._isDead=false;
		this._verticesCount=0;
		this._virtualVerticesCount=0;
		this._verticesIndex1=0;
		this._delLength=0;
		this._curDisappearIndex=0;
		this._everyGroupVertexBirthTime=[];
		this._owner._curSubTrailFinishPosition.cloneTo(this._lastPosition);
	}

	/**
	*@private
	*/
	__proto._destroy=function(){
		this._vertexBuffer1.dispose();
		this._vertexBuffer2.dispose();
		this._vertices1=null;
		this._vertexBuffer1=null;
		this._vertices2=null;
		this._vertexBuffer2=null;
		this._vertexBuffers=null;
		this._everyGroupVertexBirthTime=null;
		this._VerticesToTailLength=null;
		this._everyVertexToPreVertexDistance=null;
		this._lastPosition=null;
		this._curPosition=null;
		this._delVector3=null;
		this._lastFixedVertexPosition=null;
		this._pointAtoBVector3=null;
		this._pointe=null;
		this._pointAtoBVector3e=null;
		this._pointA=null;
		this._pointB=null;
	}

	/**
	*获取vertexBuffer数量
	*@return vertexBuffer数量
	*/
	__getset(0,__proto,'_vertexBufferCount',function(){
		return this._vertexBuffers.length;
	});

	/**
	*获取三角面数量
	*@return 三角面数量
	*/
	__getset(0,__proto,'triangleCount',function(){
		return 0;
	});

	TrailRenderElement.renderElementCount=0;
	return TrailRenderElement;
})()


/**
*<code>VertexTrail</code> 类用于创建拖尾顶点结构。
*/
//class laya.d3.core.trail.VertexTrail
var VertexTrail=(function(){
	function VertexTrail(){}
	__class(VertexTrail,'laya.d3.core.trail.VertexTrail');
	var __proto=VertexTrail.prototype;
	Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
	__getset(0,__proto,'vertexDeclaration',function(){
		return VertexTrail._vertexDeclaration1;
	});

	__getset(1,VertexTrail,'vertexDeclaration1',function(){
		return VertexTrail._vertexDeclaration1;
	});

	__getset(1,VertexTrail,'vertexDeclaration2',function(){
		return VertexTrail._vertexDeclaration2;
	});

	__static(VertexTrail,
	['_vertexDeclaration1',function(){return this._vertexDeclaration1=new VertexDeclaration(32,
		[new VertexElement(0,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.POSITION0*/0),
		new VertexElement(12,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.OFFSETVECTOR*/41),
		new VertexElement(24,/*laya.d3.graphics.VertexElementFormat.Single*/"single",/*laya.d3.graphics.VertexElementUsage.TIME0*/33),
		new VertexElement(28,/*laya.d3.graphics.VertexElementFormat.Single*/"single",/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE0Y*/40)]);},'_vertexDeclaration2',function(){return this._vertexDeclaration2=new VertexDeclaration(4,
		[new VertexElement(0,/*laya.d3.graphics.VertexElementFormat.Single*/"single",/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE0X*/38)]);}
	]);
	return VertexTrail;
})()


/**
*@private
*<code>DynamicBatch</code> 类用于动态批处理。
*/
//class laya.d3.graphics.DynamicBatch
var DynamicBatch=(function(){
	function DynamicBatch(vertexDeclaration){
		this._vertexDeclaration=null;
		this._vertexDatas=null;
		this._indexDatas=null;
		this._vertexBuffer=null;
		this._indexBuffer=null;
		this._currentCombineVertexCount=0;
		this._currentCombineIndexCount=0;
		this._combineRenderElements=null;
		this._materials=null;
		this._materialToRenderElementsOffsets=null;
		this._merageElements=null;
		this._combineRenderElementPool=null;
		this._combineRenderElementPoolIndex=0;
		this._currentCombineVertexCount=0;
		this._currentCombineIndexCount=0;
		this._combineRenderElements=[];
		this._materialToRenderElementsOffsets=[];
		this._materials=[];
		this._merageElements=[];
		this._combineRenderElementPool=[];
		this._combineRenderElementPoolIndex=0;
		this._vertexDeclaration=vertexDeclaration;
	}

	__class(DynamicBatch,'laya.d3.graphics.DynamicBatch');
	var __proto=DynamicBatch.prototype;
	Laya.imps(__proto,{"laya.d3.core.render.IRenderable":true})
	__proto._getVertexBuffer=function(index){
		(index===void 0)&& (index=0);
		if (index===0)
			return this._vertexBuffer;
		else
		return null;
	}

	__proto._getIndexBuffer=function(){
		return this._indexBuffer;
	}

	__proto._getCombineRenderElementFromPool=function(view,projection,projectionView){
		var renderElement=this._combineRenderElementPool[this._combineRenderElementPoolIndex++];
		if (!renderElement){
			this._combineRenderElementPool[this._combineRenderElementPoolIndex-1]=renderElement=new RenderElement();
			renderElement._sprite3D=new MeshSprite3D();
		}
		renderElement._sprite3D._render._renderUpdate(projectionView);
		return renderElement;
	}

	__proto._getRenderElement=function(view,projection,projectionView){
		if (!this._vertexDatas){
			this._vertexDatas=new Float32Array(this._vertexDeclaration.vertexStride / 4 *DynamicBatch.maxVertexCount);
			this._indexDatas=new Uint16Array(DynamicBatch.maxIndexCount);
			this._vertexBuffer=VertexBuffer3D.create(this._vertexDeclaration,DynamicBatch.maxVertexCount,/*laya.webgl.WebGLContext.DYNAMIC_DRAW*/0x88E8);
			this._indexBuffer=IndexBuffer3D.create(/*laya.d3.graphics.IndexBuffer3D.INDEXTYPE_USHORT*/"ushort",DynamicBatch.maxIndexCount,/*laya.webgl.WebGLContext.DYNAMIC_DRAW*/0x88E8);
		}
		this._merageElements.length=0;
		var curMerVerCount=0;
		var curIndexCount=0;
		for (var i=0,n=this._combineRenderElements.length;i < n;i++){
			var renderElement=this._combineRenderElements[i];
			var subVertexDatas=renderElement.getDynamicBatchBakedVertexs(0);
			var subIndexDatas=renderElement.getBakedIndices();
			var isInvert=renderElement._sprite3D.transform._isFrontFaceInvert;
			var indexOffset=curMerVerCount / (this._vertexDeclaration.vertexStride / 4);
			var indexStart=curIndexCount;
			var indexEnd=indexStart+subIndexDatas.length;
			renderElement._tempBatchIndexStart=indexStart;
			renderElement._tempBatchIndexEnd=indexEnd;
			this._indexDatas.set(subIndexDatas,curIndexCount);
			var k=0;
			if (isInvert){
				for (k=indexStart;k < indexEnd;k+=3){
					this._indexDatas[k]=indexOffset+this._indexDatas[k];
					var index1=this._indexDatas[k+1];
					var index2=this._indexDatas[k+2];
					this._indexDatas[k+1]=indexOffset+index2;
					this._indexDatas[k+2]=indexOffset+index1;
				}
				}else {
				for (k=indexStart;k < indexEnd;k+=3){
					this._indexDatas[k]=indexOffset+this._indexDatas[k];
					this._indexDatas[k+1]=indexOffset+this._indexDatas[k+1];
					this._indexDatas[k+2]=indexOffset+this._indexDatas[k+2];
				}
			}
			curIndexCount+=subIndexDatas.length;
			this._vertexDatas.set(subVertexDatas,curMerVerCount);
			curMerVerCount+=subVertexDatas.length;
		}
		this._vertexBuffer.setData(this._vertexDatas);
		this._indexBuffer.setData(this._indexDatas);
		this._combineRenderElementPoolIndex=0;
		for (i=0,n=this._materials.length;i < n;i++){
			var merageElement=this._getCombineRenderElementFromPool(view,projection,projectionView);
			merageElement._type=2;
			merageElement._staticBatch=null;
			merageElement.renderObj=this;
			var renderElementStartIndex=this._combineRenderElements[this._materialToRenderElementsOffsets[i]]._tempBatchIndexStart;
			var renderElementEndIndex=(i+1===this._materialToRenderElementsOffsets.length)? curIndexCount :this._combineRenderElements[this._materialToRenderElementsOffsets[i+1]]._tempBatchIndexStart;
			merageElement._tempBatchIndexStart=renderElementStartIndex;
			merageElement._tempBatchIndexEnd=renderElementEndIndex;
			merageElement._material=this._materials[i];
			this._merageElements.push(merageElement);
		}
	}

	__proto._addCombineRenderObjTest=function(renderElement){
		var renderObj=renderElement.renderObj;
		var indexCount=this._currentCombineIndexCount+renderObj._getIndexBuffer().indexCount;
		var vertexCount=this._currentCombineVertexCount+renderObj._getVertexBuffer().vertexCount;
		if (vertexCount > DynamicBatch.maxVertexCount || indexCount > DynamicBatch.maxIndexCount){
			return false;
		}
		return true;
	}

	__proto._addCombineRenderObj=function(renderElement){
		var renderObj=renderElement.renderObj;
		this._combineRenderElements.push(renderElement);
		this._currentCombineIndexCount=this._currentCombineIndexCount+renderObj._getIndexBuffer().indexCount;
		this._currentCombineVertexCount=this._currentCombineVertexCount+renderObj._getVertexBuffer().vertexCount;
	}

	__proto._addCombineMaterial=function(material){
		this._materials.push(material);
	}

	__proto._addMaterialToRenderElementOffset=function(offset){
		this._materialToRenderElementsOffsets.push(offset);
	}

	__proto._clearRenderElements=function(){
		this._combineRenderElements.length=0;
		this._materials.length=0;
		this._materialToRenderElementsOffsets.length=0;
		this._currentCombineVertexCount=0;
		this._currentCombineIndexCount=0;
	}

	__proto._addToRenderQueue=function(scene,view,projection,projectionView){
		this._getRenderElement(view,projection,projectionView);
		for (var i=0,n=this._materials.length;i < n;i++)
		scene.getRenderQueue(this._materials[i].renderQueue)._addDynamicBatchElement(this._merageElements[i]);
	}

	__proto._beforeRender=function(state){
		this._vertexBuffer._bind();
		this._indexBuffer._bind();
		return true;
	}

	__proto._render=function(state){
		var indexCount=state._batchIndexEnd-state._batchIndexStart;
		WebGL.mainContext.drawElements(/*laya.webgl.WebGLContext.TRIANGLES*/0x0004,indexCount,/*laya.webgl.WebGLContext.UNSIGNED_SHORT*/0x1403,state._batchIndexStart *2);
		Stat.drawCall++;
		Stat.trianglesFaces+=indexCount / 3;
	}

	/**
	*@private
	*/
	__proto._getVertexBuffers=function(){
		return null;
	}

	__getset(0,__proto,'_vertexBufferCount',function(){
		return 1;
	});

	__getset(0,__proto,'triangleCount',function(){
		return this._indexBuffer.indexCount / 3;
	});

	__getset(0,__proto,'combineRenderElementsCount',function(){
		return this._combineRenderElements.length;
	});

	DynamicBatch.maxVertexCount=20000;
	DynamicBatch.maxIndexCount=40000;
	DynamicBatch.maxCombineTriangleCount=10;
	return DynamicBatch;
})()


/**
*@private
*<code>DynamicBatchManager</code> 类用于管理动态批处理。
*/
//class laya.d3.graphics.DynamicBatchManager
var DynamicBatchManager=(function(){
	function DynamicBatchManager(){
		this._dynamicBatches=null;
		this._prepareDynamicBatchCombineElements=null;
		this._dynamicBatches={};
		this._prepareDynamicBatchCombineElements=[];
	}

	__class(DynamicBatchManager,'laya.d3.graphics.DynamicBatchManager');
	var __proto=DynamicBatchManager.prototype;
	__proto.getDynamicBatch=function(_vertexDeclaration,number){
		var dynamicBatch;
		var key=_vertexDeclaration.id.toString()+number;
		if (!this._dynamicBatches[key]){
			this._dynamicBatches[key]=dynamicBatch=new DynamicBatch(_vertexDeclaration);
			}else {
			dynamicBatch=this._dynamicBatches[key];
		}
		return dynamicBatch;
	}

	/**需手动调用*/
	__proto._garbageCollection=function(){
		for (var key in this._dynamicBatches)
		if (this._dynamicBatches[key].combineRenderElementsCount===0)
			delete this._dynamicBatches[key];
	}

	__proto._addPrepareRenderElement=function(renderElement){
		this._prepareDynamicBatchCombineElements.push(renderElement);
	}

	/**@private */
	__proto._finishCombineDynamicBatch=function(scene){
		this._prepareDynamicBatchCombineElements.sort(DynamicBatchManager._sortPrepareDynamicBatch);
		var lastMaterial;
		var lastVertexDeclaration;
		var lastRenderElement;
		var lastBatchNumber=-1;
		var lastCanMerage=true;
		var curMaterial;
		var curRenderElement;
		var curDynamicBatch;
		var curbatchNumber=0;
		var laterAddMaterial;
		var laterAddRenderElement;
		var laterAddMatToElementOffset=-1;
		for (var i=0,n=this._prepareDynamicBatchCombineElements.length;i < n;i++){
			curRenderElement=this._prepareDynamicBatchCombineElements[i];
			var curDeclaration=curRenderElement.renderObj._getVertexBuffer(0).vertexDeclaration;
			var declarationChanged=(lastVertexDeclaration!==curDeclaration);
			declarationChanged && (curbatchNumber=0,lastVertexDeclaration=curDeclaration);
			var batchNumbrChanged=(curbatchNumber!==lastBatchNumber);
			batchNumbrChanged && (lastBatchNumber=curbatchNumber);
			if ((declarationChanged)|| batchNumbrChanged){
				curDynamicBatch=this.getDynamicBatch(curDeclaration,curbatchNumber);
				lastMaterial=null;
			}
			if (lastCanMerage){
				if (curDynamicBatch._addCombineRenderObjTest(curRenderElement)){
					curMaterial=curRenderElement._material;
					if (lastMaterial!==curMaterial){
						if (laterAddMaterial){
							scene.getRenderQueue(laterAddRenderElement._material.renderQueue)._addRenderElement(laterAddRenderElement);
							laterAddMaterial=null;
							laterAddRenderElement=null;
							laterAddMatToElementOffset=-1;
						}
						laterAddMaterial=curMaterial;
						laterAddMatToElementOffset=curDynamicBatch.combineRenderElementsCount;
						laterAddRenderElement=curRenderElement;
						lastMaterial=curMaterial;
						}else {
						if (laterAddMaterial){
							var lastRenderObj=laterAddRenderElement.renderObj;
							var curRenderObj=curRenderElement.renderObj;
							if (((lastRenderObj._getVertexBuffer().vertexCount+curRenderObj._getVertexBuffer().vertexCount)> DynamicBatch.maxVertexCount)|| ((lastRenderObj._getIndexBuffer().indexCount+curRenderObj._getIndexBuffer().indexCount)> DynamicBatch.maxIndexCount)){
								scene.getRenderQueue(laterAddRenderElement._material.renderQueue)._addRenderElement(laterAddRenderElement);
								laterAddMaterial=curMaterial;
								laterAddMatToElementOffset=curDynamicBatch.combineRenderElementsCount;
								laterAddRenderElement=curRenderElement;
								}else {
								curDynamicBatch._addCombineMaterial(laterAddMaterial);
								curDynamicBatch._addMaterialToRenderElementOffset(laterAddMatToElementOffset);
								curDynamicBatch._addCombineRenderObj(laterAddRenderElement);
								laterAddMaterial=null;
								laterAddRenderElement=null;
								laterAddMatToElementOffset=-1;
								curDynamicBatch._addCombineRenderObj(curRenderElement);
							}
							}else {
							curDynamicBatch._addCombineRenderObj(curRenderElement);
						}
					}
					lastCanMerage=true;
					}else {
					if (laterAddMaterial){
						scene.getRenderQueue(laterAddRenderElement._material.renderQueue)._addRenderElement(laterAddRenderElement);
						laterAddMaterial=null;
						laterAddRenderElement=null;
						laterAddMatToElementOffset=-1;
					}
					curbatchNumber++;
					lastCanMerage=false;
				}
				}else {
				lastRenderElement=this._prepareDynamicBatchCombineElements[i-1];
				curDynamicBatch._addMaterialToRenderElementOffset(curDynamicBatch.combineRenderElementsCount);
				lastMaterial=lastRenderElement._material;
				curDynamicBatch._addCombineMaterial(lastMaterial);
				curDynamicBatch._addCombineRenderObj(lastRenderElement);
				lastCanMerage=true;
				curMaterial=curRenderElement._material;
				if (lastMaterial!==curMaterial){
					laterAddMaterial=curMaterial;
					laterAddMatToElementOffset=curDynamicBatch.combineRenderElementsCount;
					laterAddRenderElement=curRenderElement;
					}else {
					curDynamicBatch._addCombineRenderObj(curRenderElement);
				}
				lastMaterial=curMaterial;
			}
		}
		if (laterAddMaterial){
			scene.getRenderQueue(laterAddRenderElement._material.renderQueue)._addRenderElement(laterAddRenderElement);
			laterAddMaterial=null;
			laterAddRenderElement=null;
			laterAddMatToElementOffset=-1;
		}
		this._prepareDynamicBatchCombineElements.length=0;
	}

	__proto._clearRenderElements=function(){
		for (var key in this._dynamicBatches)
		this._dynamicBatches[key]._clearRenderElements();
	}

	__proto._addToRenderQueue=function(scene,view,projection,projectionView){
		for (var key in this._dynamicBatches){
			var dynamicBatch=this._dynamicBatches[key];
			(dynamicBatch.combineRenderElementsCount > 0)&& (dynamicBatch._addToRenderQueue(scene,view,projection,projectionView));
		}
	}

	__proto.dispose=function(){
		this._dynamicBatches=null;
	}

	DynamicBatchManager._sortPrepareDynamicBatch=function(a,b){
		return a._mainSortID-b._mainSortID;
	}

	return DynamicBatchManager;
})()


/**
*@private
*/
//class laya.d3.graphics.FrustumCulling
var FrustumCulling=(function(){
	function FrustumCulling(){}
	__class(FrustumCulling,'laya.d3.graphics.FrustumCulling');
	FrustumCulling.renderShadowObjectCulling=function(scene,lightFrustum,shadowQueues,lightViewProjectMatrix,nPSSMNum){
		var i=0,j=0,n=0,m=0;
		for (i=0,n=shadowQueues.length;i < n;i++){
			var quene=shadowQueues[i];
			(quene)&& (quene._clearRenderElements());
		};
		var frustumCullingObjects=scene._cullingRenders;
		var baseRender,shadowQueue,renderElements;
		if (nPSSMNum > 1){
			for (i=0,n=scene._cullingRendersLength;i < n;i++){
				baseRender=frustumCullingObjects[i];
				if (baseRender.castShadow && Layer.isVisible(baseRender._owner.layer.mask)&& baseRender.enable){
					for (var k=1,kNum=lightFrustum.length;k < kNum;k++){
						shadowQueue=shadowQueues[k-1];
						if (lightFrustum[k].containsBoundSphere(baseRender.boundingSphere)!==/*laya.d3.math.ContainmentType.Disjoint*/0){
							renderElements=baseRender._renderElements;
							for (j=0,m=renderElements.length;j < m;j++)
							shadowQueue._addRenderElement(renderElements[j]);
						}
					}
				}
			}
			}else {
			for (i=0,n=scene._cullingRendersLength;i < n;i++){
				baseRender=frustumCullingObjects[i];
				if (baseRender.castShadow && Layer.isVisible(baseRender._owner.layer.mask)&& baseRender.enable){
					if (lightFrustum[0].containsBoundSphere(baseRender.boundingSphere)!==/*laya.d3.math.ContainmentType.Disjoint*/0){
						baseRender._renderUpdate(lightViewProjectMatrix);
						shadowQueue=shadowQueues[0];
						renderElements=baseRender._renderElements;
						for (j=0,m=renderElements.length;j < m;j++)
						shadowQueue._addRenderElement(renderElements[j]);
					}
				}
			}
		}
	}

	FrustumCulling.renderShadowObjectCullingOctree=function(scene,lightFrustum,quenesResult,lightViewProjectMatrix,nPSSMNum){
		for (var i=0,n=quenesResult.length;i < n;i++){
			var quene=quenesResult[i];
			(quene)&& (quene._clearRenderElements());
		}
		if (nPSSMNum > 1){
			scene.treeRoot.cullingShadowObjects(lightFrustum,quenesResult,true,0,scene);
			}else {
			scene.treeRoot.cullingShadowObjectsOnePSSM(lightFrustum[0],quenesResult,lightViewProjectMatrix,true,0,scene);
		}
	}

	FrustumCulling.renderObjectCulling=function(boundFrustum,scene,camera,view,projection,projectionView){
		var i=0,n=0,j=0,m=0;
		var queues=scene._quenes;
		var dynamicBatchManager=scene._dynamicBatchManager;
		var frustumCullingObjects=scene._cullingRenders;
		for (i=0,n=queues.length;i < n;i++){
			var queue=queues[i];
			(queue)&& (queue._clearRenderElements());
		};
		var staticBatchManagers=StaticBatchManager._staticBatchManagers;
		for (i=0,n=staticBatchManagers.length;i < n;i++)
		staticBatchManagers[i]._clearRenderElements();
		dynamicBatchManager._clearRenderElements();
		var cameraPosition=camera.transform.position;
		for (i=0,n=scene._cullingRendersLength;i < n;i++){
			var baseRender=frustumCullingObjects[i];
			if (Layer.isVisible(baseRender._owner.layer.mask)&& baseRender.enable && (boundFrustum.containsBoundSphere(baseRender.boundingSphere)!==/*laya.d3.math.ContainmentType.Disjoint*/0)){
				if (baseRender._renderUpdate(projectionView)){
					baseRender._distanceForSort=Vector3.distance(baseRender.boundingSphere.center,cameraPosition)+baseRender.sortingFudge;
					var renderElements=baseRender._renderElements;
					for (j=0,m=renderElements.length;j < m;j++){
						var renderElement=renderElements[j];
						var staticBatch=renderElement._staticBatch;
						if (staticBatch && (staticBatch._material===renderElement._material)){
							staticBatch._addBatchRenderElement(renderElement);
							}else {
							var renderObj=renderElement.renderObj;
							if ((renderObj.triangleCount < /*laya.d3.graphics.DynamicBatch.maxCombineTriangleCount*/10)&& (renderObj._vertexBufferCount===1)&& (renderObj._getIndexBuffer())&& (renderElement._material.renderQueue < 2)&& renderElement._canDynamicBatch && (!baseRender._owner.isStatic))
								dynamicBatchManager._addPrepareRenderElement(renderElement);
							else
							scene.getRenderQueue(renderElement._material.renderQueue)._addRenderElement(renderElement);
						}
					}
				}
			}
		}
		for (i=0,n=staticBatchManagers.length;i < n;i++)
		staticBatchManagers[i]._addToRenderQueue(scene,view,projection,projectionView);
		dynamicBatchManager._finishCombineDynamicBatch(scene);
		dynamicBatchManager._addToRenderQueue(scene,view,projection,projectionView);
	}

	FrustumCulling.renderObjectCullingOctree=function(boundFrustum,scene,camera,view,projection,projectionView){
		var i=0,n=0;
		var queues=scene._quenes;
		var dynamicBatchManager=scene._dynamicBatchManager;
		for (i=0,n=queues.length;i < n;i++){
			var queue=queues[i];
			(queue)&& (queue._clearRenderElements());
		};
		var staticBatchManagers=StaticBatchManager._staticBatchManagers;
		for (i=0,n=staticBatchManagers.length;i < n;i++)
		staticBatchManagers[i]._clearRenderElements();
		dynamicBatchManager._clearRenderElements();
		scene._cullingRenders.length=0;
		scene.treeRoot.cullingObjects(boundFrustum,true,0,camera.transform.position,projectionView);
		for (i=0,n=staticBatchManagers.length;i < n;i++)
		staticBatchManagers[i]._addToRenderQueue(scene,view,projection,projectionView);
		dynamicBatchManager._finishCombineDynamicBatch(scene);
		dynamicBatchManager._addToRenderQueue(scene,view,projection,projectionView);
	}

	FrustumCulling.renderObjectCullingNoBoundFrustum=function(scene,camera,view,projection,projectionView){
		var i=0,n=0,j=0,m=0;
		var queues=scene._quenes;
		var dynamicBatchManager=scene._dynamicBatchManager;
		var frustumCullingObjects=scene._cullingRenders;
		for (i=0,n=queues.length;i < n;i++){
			var queue=queues[i];
			(queue)&& (queue._clearRenderElements());
		};
		var staticBatchManagers=StaticBatchManager._staticBatchManagers;
		for (i=0,n=staticBatchManagers.length;i < n;i++)
		staticBatchManagers[i]._clearRenderElements();
		dynamicBatchManager._clearRenderElements();
		var cameraPosition=camera.transform.position;
		for (i=0,n=scene._cullingRendersLength;i < n;i++){
			var baseRender=frustumCullingObjects[i];
			if (Layer.isVisible(baseRender._owner.layer.mask)&& baseRender.enable){
				baseRender._renderUpdate(projectionView);
				baseRender._distanceForSort=Vector3.distance(baseRender.boundingSphere.center,cameraPosition)+baseRender.sortingFudge;
				var renderElements=baseRender._renderElements;
				for (j=0,m=renderElements.length;j < m;j++){
					var renderElement=renderElements[j];
					var staticBatch=renderElement._staticBatch;
					if (staticBatch && (staticBatch._material===renderElement._material)){
						staticBatch._addBatchRenderElement(renderElement);
						}else {
						var renderObj=renderElement.renderObj;
						if ((renderObj.triangleCount < /*laya.d3.graphics.DynamicBatch.maxCombineTriangleCount*/10)&& (renderObj._vertexBufferCount===1)&& (renderObj._getIndexBuffer())&& (renderElement._material.renderQueue < 2)&& renderElement._canDynamicBatch && (!baseRender._owner.isStatic))
							dynamicBatchManager._addPrepareRenderElement(renderElement);
						else
						scene.getRenderQueue(renderElement._material.renderQueue)._addRenderElement(renderElement);
					}
				}
			}
		}
		for (i=0,n=staticBatchManagers.length;i < n;i++)
		staticBatchManagers[i]._addToRenderQueue(scene,view,projection,projectionView);
		dynamicBatchManager._finishCombineDynamicBatch(scene);
		dynamicBatchManager._addToRenderQueue(scene,view,projection,projectionView);
	}

	return FrustumCulling;
})()


/**
*@private
*<code>StaticBatchManager</code> 类用于静态批处理管理的父类。
*/
//class laya.d3.graphics.StaticBatchManager
var StaticBatchManager=(function(){
	function StaticBatchManager(){
		/**@private */
		this._initBatchRenderElements=null;
		/**@private */
		this._staticBatches=null;
		this._initBatchRenderElements=[];
		this._staticBatches={};
	}

	__class(StaticBatchManager,'laya.d3.graphics.StaticBatchManager');
	var __proto=StaticBatchManager.prototype;
	/**
	*@private
	*/
	__proto._finishInit=function(){
		for (var key in this._staticBatches)
		this._staticBatches[key]._finishInit();
		this._initBatchRenderElements.length=0;
	}

	/**
	*@private
	*/
	__proto._initStaticBatchs=function(rootSprite){
		throw new Error("StaticBatchManager:must override this function.");
	}

	/**
	*@private
	*/
	__proto._addInitBatchSprite=function(renderableSprite3D){
		var renderElements=renderableSprite3D._render._renderElements;
		for (var i=0,n=renderElements.length;i < n;i++)
		this._initBatchRenderElements.push(renderElements[i]);
	}

	/**
	*@private
	*/
	__proto._clearRenderElements=function(){
		for (var key in this._staticBatches)
		this._staticBatches[key]._clearRenderElements();
	}

	/**
	*@private
	*/
	__proto._garbageCollection=function(renderElement){
		var staticBatch=renderElement._staticBatch;
		var initBatchRenderElements=staticBatch._initBatchRenderElements;
		var index=initBatchRenderElements.indexOf(renderElement);
		initBatchRenderElements.splice(index,1);
		if (initBatchRenderElements.length===0){
			staticBatch.dispose();
			delete this._staticBatches[staticBatch._key];
		}
	}

	/**
	*@private
	*/
	__proto._addToRenderQueue=function(scene,view,projection,projectionView){
		for (var key in this._staticBatches){
			var staticBatch=this._staticBatches[key];
			if (staticBatch._batchRenderElements.length > 0)
				staticBatch._updateToRenderQueue(scene,projectionView);
		}
	}

	__proto.dispose=function(){
		this._staticBatches=null;
	}

	StaticBatchManager._addToStaticBatchQueue=function(sprite3D){
		if ((sprite3D instanceof laya.d3.core.RenderableSprite3D ))
			(sprite3D)._addToInitStaticBatchManager();
		for (var i=0,n=sprite3D.numChildren;i < n;i++)
		StaticBatchManager._addToStaticBatchQueue(sprite3D._childs [i]);
	}

	StaticBatchManager.combine=function(staticBatchRoot,renderableSprite3Ds){
		var i=0,n=0,staticBatchManager;
		if (renderableSprite3Ds){
			for (i=0,n=renderableSprite3Ds.length;i < n;i++){
				var renderableSprite3D=renderableSprite3Ds[i];
				renderableSprite3D._addToInitStaticBatchManager();
			}
			}else {
			if (staticBatchRoot)
				StaticBatchManager._addToStaticBatchQueue(staticBatchRoot);
		}
		for (i=0,n=StaticBatchManager._staticBatchManagers.length;i < n;i++){
			staticBatchManager=StaticBatchManager._staticBatchManagers[i];
			staticBatchManager._initStaticBatchs(staticBatchRoot);
			staticBatchManager._finishInit();
		}
	}

	StaticBatchManager._staticBatchManagers=[];
	return StaticBatchManager;
})()


/**
*<code>StaticBatch</code> 类用于静态合并的父类,该类为抽象类。
*/
//class laya.d3.graphics.StaticBatch
var StaticBatch=(function(){
	function StaticBatch(key,manager,rootOwner){
		/**@private */
		this._combineRenderElementPoolIndex=0;
		/**@private */
		this._combineRenderElementPool=null;
		/**@private */
		this._initBatchRenderElements=null;
		/**@private */
		this._batchRenderElements=null;
		/**@private */
		this._material=null;
		/**@private */
		this._rootOwner=null;
		/**@private */
		this._key=null;
		/**@private */
		this._manager=null;
		this._key=key;
		this._manager=manager;
		this._combineRenderElementPoolIndex=0;
		this._combineRenderElementPool=[];
		this._initBatchRenderElements=[];
		this._batchRenderElements=[];
		this._rootOwner=rootOwner;
	}

	__class(StaticBatch,'laya.d3.graphics.StaticBatch');
	var __proto=StaticBatch.prototype;
	Laya.imps(__proto,{"laya.d3.core.render.IRenderable":true,"laya.resource.IDispose":true})
	/**
	*@private
	*/
	__proto._binarySearch=function(renderElement){
		var start=0;
		var end=this._batchRenderElements.length-1;
		var mid=0;
		while (start <=end){
			mid=Math.floor((start+end)/ 2);
			if (this._compareBatchRenderElement(this._batchRenderElements[mid],renderElement))
				end=mid-1;
			else
			start=mid+1;
		}
		return start;
	}

	/**
	*@private
	*/
	__proto._compareBatchRenderElement=function(a,b){
		throw new Error("StaticBatch:must override this function.");
	}

	/**
	*@private
	*/
	__proto._getVertexDecLightMap=function(vertexDeclaration){
		if (vertexDeclaration===VertexPositionNormalTextureSkinSTangent.vertexDeclaration){
			return VertexPositionNormalTexture0Texture1SkinSTangent.vertexDeclaration;
			}else if (vertexDeclaration===VertexPositionNormalTextureSkin.vertexDeclaration){
			return VertexPositionNormalTexture0Texture1Skin.vertexDeclaration;
			}else if (vertexDeclaration===VertexPositionNormalColorTextureSTangent.vertexDeclaration){
			return VertexPositionNormalColorTexture0Texture1STangent.vertexDeclaration;
			}else if (vertexDeclaration===VertexPositionNTBTexture.vertexDeclaration){
			return null;
			}else if (vertexDeclaration===VertexPositionNormalColorTexture.vertexDeclaration){
			return VertexPositionNormalColorTexture0Texture1.vertexDeclaration;
			}else if (vertexDeclaration===VertexPositionNormalTextureSTangent.vertexDeclaration){
			return VertexPositionNormalTexture0Texture1STangent.vertexDeclaration;
			}else if (vertexDeclaration===VertexPositionNormalTexture.vertexDeclaration){
			return VertexPositionNormalTexture0Texture1.vertexDeclaration;
		}
		if (vertexDeclaration===VertexPositionNormalTextureSkinTangent.vertexDeclaration){
			return VertexPositionNormalTexture0Texture1SkinTangent.vertexDeclaration;
			}else if (vertexDeclaration===VertexPositionNormalTextureSkin.vertexDeclaration){
			return VertexPositionNormalTexture0Texture1Skin.vertexDeclaration;
			}else if (vertexDeclaration===VertexPositionNormalColorTextureTangent.vertexDeclaration){
			return VertexPositionNormalColorTexture0Texture1Tangent.vertexDeclaration;
			}else if (vertexDeclaration===VertexPositionNTBTexture.vertexDeclaration){
			return null;
			}else if (vertexDeclaration===VertexPositionNormalColorTexture.vertexDeclaration){
			return VertexPositionNormalColorTexture0Texture1.vertexDeclaration;
			}else if (vertexDeclaration===VertexPositionNormalTextureTangent.vertexDeclaration){
			return VertexPositionNormalTexture0Texture1Tangent.vertexDeclaration;
			}else if (vertexDeclaration===VertexPositionNormalTexture.vertexDeclaration){
			return VertexPositionNormalTexture0Texture1.vertexDeclaration;
			}else {
			return vertexDeclaration;
		}
	}

	/**
	*@private
	*/
	__proto._getCombineRenderElementFromPool=function(){
		throw new Error("StaticBatch:must override this function.");
	}

	/**
	*@private
	*/
	__proto._addBatchRenderElement=function(renderElement){
		this._batchRenderElements.splice(this._binarySearch(renderElement),0,renderElement);
	}

	/**
	*@private
	*/
	__proto._updateToRenderQueue=function(scene,projectionView){
		this._combineRenderElementPoolIndex=0;
		this._getRenderElement(scene.getRenderQueue(this._material.renderQueue)._renderElements,scene,projectionView);
	}

	/**
	*@private
	*/
	__proto._getRenderElement=function(mergeElements,scene,projectionView){
		throw new Error("StaticBatch:must override this function.");
	}

	/**
	*@private
	*/
	__proto._finishInit=function(){
		throw new Error("StaticBatch:must override this function.");
	}

	/**
	*@private
	*/
	__proto._clearRenderElements=function(){
		this._batchRenderElements.length=0;
	}

	/**
	*@private
	*/
	__proto.dispose=function(){}
	//..................临时.................................
	__proto._getVertexBuffer=function(index){
		(index===void 0)&& (index=0);
		return null;
	}

	__proto._getIndexBuffer=function(){
		return null;
	}

	__proto._beforeRender=function(state){
		return true;
	}

	__proto._render=function(state){}
	/**
	*@private
	*/
	__proto._getVertexBuffers=function(){
		return null;
	}

	//..................临时.................................
	__getset(0,__proto,'_vertexBufferCount',function(){
		return 1;
	});

	__getset(0,__proto,'triangleCount',function(){
		return 0;
	});

	StaticBatch.combine=function(staticBatchRoot){
		console.log("StaticBatch: discard property,please use StaticBatchManager.combine() function instead.");
		StaticBatchManager.combine(staticBatchRoot);
	}

	StaticBatch.maxBatchVertexCount=65535;
	return StaticBatch;
})()


/**
*...
*@author ...
*/
//class laya.d3.graphics.VertexDeclaration
var VertexDeclaration=(function(){
	function VertexDeclaration(vertexStride,vertexElements){
		this._id=0;
		this._shaderValues=null;
		this._shaderDefineValue=0;
		//private var _shaderAttribute:*;
		this._vertexStride=0;
		this._vertexElements=null;
		this._vertexElementsDic=null;
		this._id=++VertexDeclaration._uniqueIDCounter;
		if (this._id > VertexDeclaration.maxVertexDeclaration)
			throw new Error("VertexDeclaration: VertexDeclaration count should not large than ",VertexDeclaration.maxVertexDeclaration);
		this._shaderValues=new ValusArray();
		this._vertexElementsDic={};
		this._vertexStride=vertexStride;
		this._vertexElements=vertexElements;
		for (var i=0;i < vertexElements.length;i++){
			var vertexElement=vertexElements[i];
			var attributeName=vertexElement.elementUsage;
			this._vertexElementsDic[attributeName]=vertexElement;
			var value=[VertexDeclaration._getTypeSize(vertexElement.elementFormat)/ 4,/*laya.webgl.WebGLContext.FLOAT*/0x1406,false,this._vertexStride,vertexElement.offset];
			this._shaderValues.setValue(attributeName,value);
			switch (attributeName){
				case /*laya.d3.graphics.VertexElementUsage.COLOR0*/1:
					this._addShaderDefine(ShaderCompile3D.SHADERDEFINE_COLOR);
					break
				case /*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE0*/2:
					this._addShaderDefine(ShaderCompile3D.SHADERDEFINE_UV0);
					break ;
				case /*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE1*/15:
					this._addShaderDefine(ShaderCompile3D.SHADERDEFINE_UV1);
					break ;
				}
		}
	}

	__class(VertexDeclaration,'laya.d3.graphics.VertexDeclaration');
	var __proto=VertexDeclaration.prototype;
	/**
	*增加Shader宏定义。
	*@param value 宏定义。
	*/
	__proto._addShaderDefine=function(value){
		this._shaderDefineValue |=value;
	}

	/**
	*移除Shader宏定义。
	*@param value 宏定义。
	*/
	__proto._removeShaderDefine=function(value){
		this._shaderDefineValue &=~value;
	}

	__proto.getVertexElements=function(){
		return this._vertexElements.slice();
	}

	__proto.getVertexElementByUsage=function(usage){
		return this._vertexElementsDic[usage];
	}

	__proto.unBinding=function(){}
	__getset(0,__proto,'shaderDefineValue',function(){
		return this._shaderDefineValue;
	});

	/**
	*获取唯一标识ID(通常用于优化或识别)。
	*@return 唯一标识ID
	*/
	__getset(0,__proto,'id',function(){
		return this._id;
	});

	__getset(0,__proto,'vertexStride',function(){
		return this._vertexStride;
	});

	__getset(0,__proto,'shaderValues',function(){
		return this._shaderValues;
	});

	VertexDeclaration._getTypeSize=function(format){
		switch (format){
			case /*laya.d3.graphics.VertexElementFormat.Single*/"single":
				return 4;
			case /*laya.d3.graphics.VertexElementFormat.Vector2*/"vector2":
				return 8;
			case /*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3":
				return 12;
			case /*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4":
				return 16;
			case /*laya.d3.graphics.VertexElementFormat.Color*/"color":
				return 4;
			case /*laya.d3.graphics.VertexElementFormat.Byte4*/"byte4":
				return 4;
			case /*laya.d3.graphics.VertexElementFormat.Short2*/"short2":
				return 4;
			case /*laya.d3.graphics.VertexElementFormat.Short4*/"short4":
				return 8;
			case /*laya.d3.graphics.VertexElementFormat.NormalizedShort2*/"normalizedshort2":
				return 4;
			case /*laya.d3.graphics.VertexElementFormat.NormalizedShort4*/"normalizedshort4":
				return 8;
			case /*laya.d3.graphics.VertexElementFormat.HalfVector2*/"halfvector2":
				return 4;
			case /*laya.d3.graphics.VertexElementFormat.HalfVector4*/"halfvector4":
				return 8;
			}
		return 0;
	}

	VertexDeclaration.getVertexStride=function(vertexElements){
		var curStride=0;
		for (var i=0;i < vertexElements.Length;i++){
			var element=vertexElements[i];
			var stride=element.offset+VertexDeclaration._getTypeSize(element.elementFormat);
			if (curStride < stride){
				curStride=stride;
			}
		}
		return curStride;
	}

	VertexDeclaration._maxVertexDeclarationBit=1000;
	VertexDeclaration._uniqueIDCounter=1;
	__static(VertexDeclaration,
	['maxVertexDeclaration',function(){return this.maxVertexDeclaration=2147483647-Math.floor(2147483647 / 1000)*1000;}
	]);
	return VertexDeclaration;
})()


/**
*<code>VertexElement</code> 类用于创建顶点结构分配。
*/
//class laya.d3.graphics.VertexElement
var VertexElement=(function(){
	function VertexElement(offset,elementFormat,elementUsage){
		this.offset=0;
		this.elementFormat=null;
		this.elementUsage=0;
		this.offset=offset;
		this.elementFormat=elementFormat;
		this.elementUsage=elementUsage;
	}

	__class(VertexElement,'laya.d3.graphics.VertexElement');
	return VertexElement;
})()


/**
*...
*@author ...
*/
//class laya.d3.graphics.VertexElementFormat
var VertexElementFormat=(function(){
	function VertexElementFormat(){}
	__class(VertexElementFormat,'laya.d3.graphics.VertexElementFormat');
	VertexElementFormat.Single="single";
	VertexElementFormat.Vector2="vector2";
	VertexElementFormat.Vector3="vector3";
	VertexElementFormat.Vector4="vector4";
	VertexElementFormat.Color="color";
	VertexElementFormat.Byte4="byte4";
	VertexElementFormat.Short2="short2";
	VertexElementFormat.Short4="short4";
	VertexElementFormat.NormalizedShort2="normalizedshort2";
	VertexElementFormat.NormalizedShort4="normalizedshort4";
	VertexElementFormat.HalfVector2="halfvector2";
	VertexElementFormat.HalfVector4="halfvector4";
	return VertexElementFormat;
})()


/**
*...
*@author ...
*/
//class laya.d3.graphics.VertexElementUsage
var VertexElementUsage=(function(){
	function VertexElementUsage(){}
	__class(VertexElementUsage,'laya.d3.graphics.VertexElementUsage');
	VertexElementUsage.POSITION0=0;
	VertexElementUsage.COLOR0=1;
	VertexElementUsage.TEXTURECOORDINATE0=2;
	VertexElementUsage.NORMAL0=3;
	VertexElementUsage.BINORMAL0=4;
	VertexElementUsage.TANGENT0=5;
	VertexElementUsage.BLENDINDICES0=6;
	VertexElementUsage.BLENDWEIGHT0=7;
	VertexElementUsage.DEPTH0=8;
	VertexElementUsage.FOG0=9;
	VertexElementUsage.POINTSIZE0=10;
	VertexElementUsage.SAMPLE0=11;
	VertexElementUsage.TESSELLATEFACTOR0=12;
	VertexElementUsage.COLOR1=13;
	VertexElementUsage.NEXTTEXTURECOORDINATE0=14;
	VertexElementUsage.TEXTURECOORDINATE1=15;
	VertexElementUsage.NEXTTEXTURECOORDINATE1=16;
	VertexElementUsage.CORNERTEXTURECOORDINATE0=17;
	VertexElementUsage.VELOCITY0=18;
	VertexElementUsage.STARTCOLOR0=19;
	VertexElementUsage.STARTSIZE=20;
	VertexElementUsage.AGEADDSCALE0=21;
	VertexElementUsage.STARTROTATION=22;
	VertexElementUsage.ENDCOLOR0=23;
	VertexElementUsage.STARTLIFETIME=24;
	VertexElementUsage.TIME0=33;
	VertexElementUsage.SHAPEPOSITIONSTARTLIFETIME=30;
	VertexElementUsage.DIRECTIONTIME=32;
	VertexElementUsage.SIZEROTATION0=27;
	VertexElementUsage.RADIUS0=28;
	VertexElementUsage.RADIAN0=29;
	VertexElementUsage.STARTSPEED=31;
	VertexElementUsage.RANDOM0=34;
	VertexElementUsage.RANDOM1=35;
	VertexElementUsage.SIMULATIONWORLDPOSTION=36;
	VertexElementUsage.SIMULATIONWORLDROTATION=37;
	VertexElementUsage.TEXTURECOORDINATE0X=38;
	VertexElementUsage.TEXTURECOORDINATE0X1=39;
	VertexElementUsage.TEXTURECOORDINATE0Y=40;
	VertexElementUsage.OFFSETVECTOR=41;
	return VertexElementUsage;
})()


/**
*<code>VertexPositionNormalColorTangent</code> 类用于创建粒子顶点结构。
*/
//class laya.d3.graphics.VertexGlitter
var VertexGlitter=(function(){
	function VertexGlitter(position,textureCoordinate,time){
		this._position=null;
		this._textureCoordinate0=null;
		this._time=NaN;
		this._position=position;
		this._textureCoordinate0=textureCoordinate;
		this._time=time;
	}

	__class(VertexGlitter,'laya.d3.graphics.VertexGlitter');
	var __proto=VertexGlitter.prototype;
	Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
	__getset(0,__proto,'textureCoordinate',function(){
		return this._textureCoordinate0;
	});

	__getset(0,__proto,'position',function(){
		return this._position;
	});

	__getset(0,__proto,'time',function(){
		return this._time;
	});

	__getset(0,__proto,'vertexDeclaration',function(){
		return VertexGlitter._vertexDeclaration;
	});

	__getset(1,VertexGlitter,'vertexDeclaration',function(){
		return VertexGlitter._vertexDeclaration;
	});

	__static(VertexGlitter,
	['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(24,
		[new VertexElement(0,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.POSITION0*/0),
		new VertexElement(12,/*laya.d3.graphics.VertexElementFormat.Vector2*/"vector2",/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE0*/2),
		new VertexElement(20,/*laya.d3.graphics.VertexElementFormat.Single*/"single",/*laya.d3.graphics.VertexElementUsage.TIME0*/33)]);}
	]);
	return VertexGlitter;
})()


/**
*<code>VertexPositionNormalColorTangent</code> 类用于创建粒子顶点结构。
*/
//class laya.d3.graphics.VertexParticle
var VertexParticle=(function(){
	function VertexParticle(cornerTextureCoordinate,position,velocity,startColor,endColor,sizeRotation,radius,radian,ageAddScale,time){
		this._cornerTextureCoordinate=null;
		this._position=null;
		this._velocity=null;
		this._startColor=null;
		this._endColor=null;
		this._sizeRotation=null;
		this._radius=null;
		this._radian=null;
		this._ageAddScale=NaN;
		this._time=NaN;
		this._cornerTextureCoordinate=cornerTextureCoordinate;
		this._position=position;
		this._velocity=velocity;
		this._startColor=startColor;
		this._endColor=endColor;
		this._sizeRotation=sizeRotation;
		this._radius=radius;
		this._radian=radian;
		this._ageAddScale=ageAddScale;
		this._time=time;
	}

	__class(VertexParticle,'laya.d3.graphics.VertexParticle');
	var __proto=VertexParticle.prototype;
	Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
	__getset(0,__proto,'endColor',function(){
		return this._endColor;
	});

	__getset(0,__proto,'cornerTextureCoordinate',function(){
		return this._cornerTextureCoordinate;
	});

	__getset(0,__proto,'sizeRotation',function(){
		return this._sizeRotation;
	});

	__getset(0,__proto,'velocity',function(){
		return this._velocity;
	});

	__getset(0,__proto,'position',function(){
		return this._position;
	});

	__getset(0,__proto,'startColor',function(){
		return this._startColor;
	});

	__getset(0,__proto,'radius',function(){
		return this._radius;
	});

	__getset(0,__proto,'radian',function(){
		return this._radian;
	});

	__getset(0,__proto,'ageAddScale',function(){
		return this._ageAddScale;
	});

	__getset(0,__proto,'time',function(){
		return this._time;
	});

	__getset(0,__proto,'vertexDeclaration',function(){
		return VertexParticle._vertexDeclaration;
	});

	__getset(1,VertexParticle,'vertexDeclaration',function(){
		return VertexParticle._vertexDeclaration;
	});

	__static(VertexParticle,
	['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(116,
		[new VertexElement(0,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.CORNERTEXTURECOORDINATE0*/17),
		new VertexElement(16,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.POSITION0*/0),
		new VertexElement(28,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.VELOCITY0*/18),
		new VertexElement(40,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.STARTCOLOR0*/19),
		new VertexElement(56,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.ENDCOLOR0*/23),
		new VertexElement(72,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.SIZEROTATION0*/27),
		new VertexElement(84,/*laya.d3.graphics.VertexElementFormat.Vector2*/"vector2",/*laya.d3.graphics.VertexElementUsage.RADIUS0*/28),
		new VertexElement(92,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.RADIAN0*/29),
		new VertexElement(108,/*laya.d3.graphics.VertexElementFormat.Single*/"single",/*laya.d3.graphics.VertexElementUsage.STARTLIFETIME*/24),
		new VertexElement(112,/*laya.d3.graphics.VertexElementFormat.Single*/"single",/*laya.d3.graphics.VertexElementUsage.TIME0*/33)]);}
	]);
	return VertexParticle;
})()


//class laya.d3.graphics.VertexPosition
var VertexPosition=(function(){
	function VertexPosition(position){
		this._position=null;
		this._position=position;
	}

	__class(VertexPosition,'laya.d3.graphics.VertexPosition');
	var __proto=VertexPosition.prototype;
	Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
	__getset(0,__proto,'position',function(){
		return this._position;
	});

	__getset(0,__proto,'vertexDeclaration',function(){
		return VertexPosition._vertexDeclaration;
	});

	/*INTERFACE laya.d3.graphics.IVertex */
	__getset(1,VertexPosition,'vertexDeclaration',function(){
		return VertexPosition._vertexDeclaration;
	});

	__static(VertexPosition,
	['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(12,[
		new VertexElement(0,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.POSITION0*/0)]);}
	]);
	return VertexPosition;
})()


//class laya.d3.graphics.VertexPositionNormal
var VertexPositionNormal=(function(){
	function VertexPositionNormal(position,normal){
		this._position=null;
		this._normal=null;
		this._position=position;
		this._normal=normal;
	}

	__class(VertexPositionNormal,'laya.d3.graphics.VertexPositionNormal');
	var __proto=VertexPositionNormal.prototype;
	Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
	__getset(0,__proto,'normal',function(){
		return this._normal;
	});

	__getset(0,__proto,'position',function(){
		return this._position;
	});

	__getset(0,__proto,'vertexDeclaration',function(){
		return VertexPositionNormal._vertexDeclaration;
	});

	/*INTERFACE laya.d3.graphics.IVertex */
	__getset(1,VertexPositionNormal,'vertexDeclaration',function(){
		return VertexPositionNormal._vertexDeclaration;
	});

	__static(VertexPositionNormal,
	['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(24,[
		new VertexElement(0,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.POSITION0*/0),
		new VertexElement(12,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.NORMAL0*/3)]);}
	]);
	return VertexPositionNormal;
})()


/**
*<code>VertexPositionNormalColor</code> 类用于创建位置、法线、颜色顶点结构。
*/
//class laya.d3.graphics.VertexPositionNormalColor
var VertexPositionNormalColor=(function(){
	function VertexPositionNormalColor(position,normal,color){
		this._position=null;
		this._normal=null;
		this._color=null;
		this._position=position;
		this._normal=normal;
		this._color=color;
	}

	__class(VertexPositionNormalColor,'laya.d3.graphics.VertexPositionNormalColor');
	var __proto=VertexPositionNormalColor.prototype;
	Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
	__getset(0,__proto,'normal',function(){
		return this._normal;
	});

	__getset(0,__proto,'position',function(){
		return this._position;
	});

	__getset(0,__proto,'color',function(){
		return this._color;
	});

	__getset(0,__proto,'vertexDeclaration',function(){
		return VertexPositionNormalColor._vertexDeclaration;
	});

	__getset(1,VertexPositionNormalColor,'vertexDeclaration',function(){
		return VertexPositionNormalColor._vertexDeclaration;
	});

	__static(VertexPositionNormalColor,
	['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(40,[
		new VertexElement(0,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.POSITION0*/0),
		new VertexElement(12,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.NORMAL0*/3),
		new VertexElement(24,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.COLOR0*/1)]);}
	]);
	return VertexPositionNormalColor;
})()


/**
*<code>VertexPositionNormalColorSkin</code> 类用于创建位置、法线、颜色、骨骼索引、骨骼权重顶点结构。
*/
//class laya.d3.graphics.VertexPositionNormalColorSkin
var VertexPositionNormalColorSkin=(function(){
	function VertexPositionNormalColorSkin(position,normal,color,blendIndex,blendWeight){
		this._position=null;
		this._normal=null;
		this._color=null;
		this._blendIndex=null;
		this._blendWeight=null;
		this._position=position;
		this._normal=normal;
		this._color=color;
		this._blendIndex=blendIndex;
		this._blendWeight=blendWeight;
	}

	__class(VertexPositionNormalColorSkin,'laya.d3.graphics.VertexPositionNormalColorSkin');
	var __proto=VertexPositionNormalColorSkin.prototype;
	Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
	__getset(0,__proto,'normal',function(){
		return this._normal;
	});

	__getset(0,__proto,'position',function(){
		return this._position;
	});

	__getset(0,__proto,'blendWeight',function(){
		return this._blendWeight;
	});

	__getset(0,__proto,'color',function(){
		return this._color;
	});

	__getset(0,__proto,'blendIndex',function(){
		return this._blendIndex;
	});

	__getset(0,__proto,'vertexDeclaration',function(){
		return VertexPositionNormalColorSkin._vertexDeclaration;
	});

	__getset(1,VertexPositionNormalColorSkin,'vertexDeclaration',function(){
		return VertexPositionNormalColorSkin._vertexDeclaration;
	});

	__static(VertexPositionNormalColorSkin,
	['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(72,[
		new VertexElement(0,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.POSITION0*/0),
		new VertexElement(12,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.NORMAL0*/3),
		new VertexElement(24,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.COLOR0*/1),
		new VertexElement(40,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.BLENDWEIGHT0*/7),
		new VertexElement(56,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.BLENDINDICES0*/6)]);}
	]);
	return VertexPositionNormalColorSkin;
})()


/**
*<code>VertexPositionNormalColorSkin</code> 类用于创建位置、法线、颜色、骨骼索引、骨骼权重顶点结构。
*/
//class laya.d3.graphics.VertexPositionNormalColorSkinSTangent
var VertexPositionNormalColorSkinSTangent=(function(){
	function VertexPositionNormalColorSkinSTangent(position,normal,color,tangent,blendIndex,blendWeight){
		this._position=null;
		this._normal=null;
		this._color=null;
		this._blendIndex=null;
		this._blendWeight=null;
		this._tangent=null;
		this._position=position;
		this._normal=normal;
		this._color=color;
		this._tangent=tangent;
		this._blendIndex=blendIndex;
		this._blendWeight=blendWeight;
	}

	__class(VertexPositionNormalColorSkinSTangent,'laya.d3.graphics.VertexPositionNormalColorSkinSTangent');
	var __proto=VertexPositionNormalColorSkinSTangent.prototype;
	Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
	__getset(0,__proto,'tangent',function(){
		return this._tangent;
	});

	__getset(0,__proto,'normal',function(){
		return this._normal;
	});

	__getset(0,__proto,'position',function(){
		return this._position;
	});

	__getset(0,__proto,'blendWeight',function(){
		return this._blendWeight;
	});

	__getset(0,__proto,'color',function(){
		return this._color;
	});

	__getset(0,__proto,'blendIndex',function(){
		return this._blendIndex;
	});

	__getset(0,__proto,'vertexDeclaration',function(){
		return VertexPositionNormalColorSkinSTangent._vertexDeclaration;
	});

	__getset(1,VertexPositionNormalColorSkinSTangent,'vertexDeclaration',function(){
		return VertexPositionNormalColorSkinSTangent._vertexDeclaration;
	});

	__static(VertexPositionNormalColorSkinSTangent,
	['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(88,[
		new VertexElement(0,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.POSITION0*/0),
		new VertexElement(12,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.NORMAL0*/3),
		new VertexElement(24,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.COLOR0*/1),
		new VertexElement(40,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.BLENDWEIGHT0*/7),
		new VertexElement(56,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.BLENDINDICES0*/6),
		new VertexElement(72,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.TANGENT0*/5)]);}
	]);
	return VertexPositionNormalColorSkinSTangent;
})()


/**
*<code>VertexPositionNormalColorSkin</code> 类用于创建位置、法线、颜色、骨骼索引、骨骼权重顶点结构。
*/
//class laya.d3.graphics.VertexPositionNormalColorSkinTangent
var VertexPositionNormalColorSkinTangent=(function(){
	function VertexPositionNormalColorSkinTangent(position,normal,color,tangent,blendIndex,blendWeight){
		this._position=null;
		this._normal=null;
		this._color=null;
		this._blendIndex=null;
		this._blendWeight=null;
		this._tangent=null;
		this._position=position;
		this._normal=normal;
		this._color=color;
		this._tangent=tangent;
		this._blendIndex=blendIndex;
		this._blendWeight=blendWeight;
	}

	__class(VertexPositionNormalColorSkinTangent,'laya.d3.graphics.VertexPositionNormalColorSkinTangent');
	var __proto=VertexPositionNormalColorSkinTangent.prototype;
	Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
	__getset(0,__proto,'tangent',function(){
		return this._tangent;
	});

	__getset(0,__proto,'normal',function(){
		return this._normal;
	});

	__getset(0,__proto,'position',function(){
		return this._position;
	});

	__getset(0,__proto,'blendWeight',function(){
		return this._blendWeight;
	});

	__getset(0,__proto,'color',function(){
		return this._color;
	});

	__getset(0,__proto,'blendIndex',function(){
		return this._blendIndex;
	});

	__getset(0,__proto,'vertexDeclaration',function(){
		return VertexPositionNormalColorSkinTangent._vertexDeclaration;
	});

	__getset(1,VertexPositionNormalColorSkinTangent,'vertexDeclaration',function(){
		return VertexPositionNormalColorSkinTangent._vertexDeclaration;
	});

	__static(VertexPositionNormalColorSkinTangent,
	['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(84,[
		new VertexElement(0,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.POSITION0*/0),
		new VertexElement(12,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.NORMAL0*/3),
		new VertexElement(24,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.COLOR0*/1),
		new VertexElement(40,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.BLENDWEIGHT0*/7),
		new VertexElement(56,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.BLENDINDICES0*/6),
		new VertexElement(72,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.TANGENT0*/5)]);}
	]);
	return VertexPositionNormalColorSkinTangent;
})()


/**
*<code>VertexPositionNormalColorTangent</code> 类用于创建位置、法线、颜色、切线顶点结构。
*/
//class laya.d3.graphics.VertexPositionNormalColorSTangent
var VertexPositionNormalColorSTangent=(function(){
	function VertexPositionNormalColorSTangent(position,normal,color,tangent){
		this._position=null;
		this._normal=null;
		this._color=null;
		this._tangent=null;
		this._position=position;
		this._normal=normal;
		this._color=color;
		this._tangent=tangent;
	}

	__class(VertexPositionNormalColorSTangent,'laya.d3.graphics.VertexPositionNormalColorSTangent');
	var __proto=VertexPositionNormalColorSTangent.prototype;
	Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
	__getset(0,__proto,'tangent',function(){
		return this._tangent;
	});

	__getset(0,__proto,'normal',function(){
		return this._normal;
	});

	__getset(0,__proto,'position',function(){
		return this._position;
	});

	__getset(0,__proto,'color',function(){
		return this._color;
	});

	__getset(0,__proto,'vertexDeclaration',function(){
		return VertexPositionNormalColorSTangent._vertexDeclaration;
	});

	__getset(1,VertexPositionNormalColorSTangent,'vertexDeclaration',function(){
		return VertexPositionNormalColorSTangent._vertexDeclaration;
	});

	__static(VertexPositionNormalColorSTangent,
	['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(56,[
		new VertexElement(0,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.POSITION0*/0),
		new VertexElement(12,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.NORMAL0*/3),
		new VertexElement(24,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.COLOR0*/1),
		new VertexElement(40,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.TANGENT0*/5)]);}
	]);
	return VertexPositionNormalColorSTangent;
})()


/**
*<code>VertexPositionNormalColorTangent</code> 类用于创建位置、法线、颜色、切线顶点结构。
*/
//class laya.d3.graphics.VertexPositionNormalColorTangent
var VertexPositionNormalColorTangent=(function(){
	function VertexPositionNormalColorTangent(position,normal,color,tangent){
		this._position=null;
		this._normal=null;
		this._color=null;
		this._tangent=null;
		this._position=position;
		this._normal=normal;
		this._color=color;
		this._tangent=tangent;
	}

	__class(VertexPositionNormalColorTangent,'laya.d3.graphics.VertexPositionNormalColorTangent');
	var __proto=VertexPositionNormalColorTangent.prototype;
	Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
	__getset(0,__proto,'tangent',function(){
		return this._tangent;
	});

	__getset(0,__proto,'normal',function(){
		return this._normal;
	});

	__getset(0,__proto,'position',function(){
		return this._position;
	});

	__getset(0,__proto,'color',function(){
		return this._color;
	});

	__getset(0,__proto,'vertexDeclaration',function(){
		return VertexPositionNormalColorTangent._vertexDeclaration;
	});

	__getset(1,VertexPositionNormalColorTangent,'vertexDeclaration',function(){
		return VertexPositionNormalColorTangent._vertexDeclaration;
	});

	__static(VertexPositionNormalColorTangent,
	['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(52,[
		new VertexElement(0,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.POSITION0*/0),
		new VertexElement(12,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.NORMAL0*/3),
		new VertexElement(24,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.COLOR0*/1),
		new VertexElement(40,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.TANGENT0*/5)]);}
	]);
	return VertexPositionNormalColorTangent;
})()


/**
*<code>VertexPositionNormalColorTexture</code> 类用于创建位置、法线、颜色、纹理顶点结构。
*/
//class laya.d3.graphics.VertexPositionNormalColorTexture
var VertexPositionNormalColorTexture=(function(){
	function VertexPositionNormalColorTexture(position,normal,color,textureCoordinate){
		this._position=null;
		this._normal=null;
		this._color=null;
		this._textureCoordinate=null;
		this._position=position;
		this._normal=normal;
		this._color=color;
		this._textureCoordinate=textureCoordinate;
	}

	__class(VertexPositionNormalColorTexture,'laya.d3.graphics.VertexPositionNormalColorTexture');
	var __proto=VertexPositionNormalColorTexture.prototype;
	Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
	__getset(0,__proto,'textureCoordinate',function(){
		return this._textureCoordinate;
	});

	__getset(0,__proto,'normal',function(){
		return this._normal;
	});

	__getset(0,__proto,'position',function(){
		return this._position;
	});

	__getset(0,__proto,'color',function(){
		return this._color;
	});

	__getset(0,__proto,'vertexDeclaration',function(){
		return VertexPositionNormalColorTexture._vertexDeclaration;
	});

	__getset(1,VertexPositionNormalColorTexture,'vertexDeclaration',function(){
		return VertexPositionNormalColorTexture._vertexDeclaration;
	});

	__static(VertexPositionNormalColorTexture,
	['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(48,[
		new VertexElement(0,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.POSITION0*/0),
		new VertexElement(12,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.NORMAL0*/3),
		new VertexElement(24,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.COLOR0*/1),
		new VertexElement(40,/*laya.d3.graphics.VertexElementFormat.Vector2*/"vector2",/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE0*/2)]);}
	]);
	return VertexPositionNormalColorTexture;
})()


/**
*<code>VertexPositionNormalColorTexture</code> 类用于创建位置、法线、颜色、纹理顶点结构。
*/
//class laya.d3.graphics.VertexPositionNormalColorTexture0Texture1
var VertexPositionNormalColorTexture0Texture1=(function(){
	function VertexPositionNormalColorTexture0Texture1(position,normal,color,textureCoordinate0,textureCoordinate1){
		this._position=null;
		this._normal=null;
		this._color=null;
		this._textureCoordinate0=null;
		this._textureCoordinate1=null;
		this._position=position;
		this._normal=normal;
		this._color=color;
		this._textureCoordinate0=textureCoordinate0;
		this._textureCoordinate1=textureCoordinate1;
	}

	__class(VertexPositionNormalColorTexture0Texture1,'laya.d3.graphics.VertexPositionNormalColorTexture0Texture1');
	var __proto=VertexPositionNormalColorTexture0Texture1.prototype;
	Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
	__getset(0,__proto,'normal',function(){
		return this._normal;
	});

	__getset(0,__proto,'position',function(){
		return this._position;
	});

	__getset(0,__proto,'color',function(){
		return this._color;
	});

	__getset(0,__proto,'textureCoordinate0',function(){
		return this._textureCoordinate0;
	});

	__getset(0,__proto,'vertexDeclaration',function(){
		return VertexPositionNormalColorTexture0Texture1._vertexDeclaration;
	});

	__getset(0,__proto,'textureCoordinate1',function(){
		return this._textureCoordinate1;
	});

	__getset(1,VertexPositionNormalColorTexture0Texture1,'vertexDeclaration',function(){
		return VertexPositionNormalColorTexture0Texture1._vertexDeclaration;
	});

	__static(VertexPositionNormalColorTexture0Texture1,
	['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(56,[
		new VertexElement(0,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.POSITION0*/0),
		new VertexElement(12,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.NORMAL0*/3),
		new VertexElement(24,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.COLOR0*/1),
		new VertexElement(40,/*laya.d3.graphics.VertexElementFormat.Vector2*/"vector2",/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE0*/2),
		new VertexElement(48,/*laya.d3.graphics.VertexElementFormat.Vector2*/"vector2",/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE1*/15)]);}
	]);
	return VertexPositionNormalColorTexture0Texture1;
})()


/**
*<code>VertexPositionNormalColorTextureSkin</code> 类用于创建位置、法线、颜色、纹理、骨骼索引、骨骼权重顶点结构。
*/
//class laya.d3.graphics.VertexPositionNormalColorTexture0Texture1Skin
var VertexPositionNormalColorTexture0Texture1Skin=(function(){
	function VertexPositionNormalColorTexture0Texture1Skin(position,normal,color,textureCoordinate0,textureCoordinate1,blendIndex,blendWeight){
		this._position=null;
		this._normal=null;
		this._color=null;
		this._textureCoordinate0=null;
		this._textureCoordinate1=null;
		this._blendIndex=null;
		this._blendWeight=null;
		this._position=position;
		this._normal=normal;
		this._color=color;
		this._textureCoordinate0=textureCoordinate0;
		this._textureCoordinate1=textureCoordinate1;
		this._blendIndex=blendIndex;
		this._blendWeight=blendWeight;
	}

	__class(VertexPositionNormalColorTexture0Texture1Skin,'laya.d3.graphics.VertexPositionNormalColorTexture0Texture1Skin');
	var __proto=VertexPositionNormalColorTexture0Texture1Skin.prototype;
	Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
	__getset(0,__proto,'normal',function(){
		return this._normal;
	});

	__getset(0,__proto,'position',function(){
		return this._position;
	});

	__getset(0,__proto,'blendWeight',function(){
		return this._blendWeight;
	});

	__getset(0,__proto,'color',function(){
		return this._color;
	});

	__getset(0,__proto,'textureCoordinate0',function(){
		return this._textureCoordinate0;
	});

	__getset(0,__proto,'vertexDeclaration',function(){
		return VertexPositionNormalColorTexture0Texture1Skin._vertexDeclaration;
	});

	__getset(0,__proto,'textureCoordinate1',function(){
		return this._textureCoordinate1;
	});

	__getset(0,__proto,'blendIndex',function(){
		return this._blendIndex;
	});

	__getset(1,VertexPositionNormalColorTexture0Texture1Skin,'vertexDeclaration',function(){
		return VertexPositionNormalColorTexture0Texture1Skin._vertexDeclaration;
	});

	__static(VertexPositionNormalColorTexture0Texture1Skin,
	['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(88,[
		new VertexElement(0,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.POSITION0*/0),
		new VertexElement(12,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.NORMAL0*/3),
		new VertexElement(24,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.COLOR0*/1),
		new VertexElement(40,/*laya.d3.graphics.VertexElementFormat.Vector2*/"vector2",/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE0*/2),
		new VertexElement(48,/*laya.d3.graphics.VertexElementFormat.Vector2*/"vector2",/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE1*/15),
		new VertexElement(56,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.BLENDWEIGHT0*/7),
		new VertexElement(72,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.BLENDINDICES0*/6)]);}
	]);
	return VertexPositionNormalColorTexture0Texture1Skin;
})()


/**
*<code>VertexPositionNormalTextureSkin</code> 类用于创建位置、法线、纹理、骨骼索引、骨骼权重顶点结构。
*/
//class laya.d3.graphics.VertexPositionNormalColorTexture0Texture1SkinSTangent
var VertexPositionNormalColorTexture0Texture1SkinSTangent=(function(){
	function VertexPositionNormalColorTexture0Texture1SkinSTangent(position,normal,color,textureCoordinate0,textureCoordinate1,tangent,blendIndex,blendWeight){
		this._position=null;
		this._normal=null;
		this._color=null;
		this._textureCoordinate0=null;
		this._textureCoordinate1=null;
		this._blendIndex=null;
		this._blendWeight=null;
		this._tangent=null;
		this._position=position;
		this._normal=normal;
		this._color=color;
		this._textureCoordinate0=textureCoordinate0;
		this._textureCoordinate1=textureCoordinate1;
		this._tangent=tangent;
		this._blendIndex=blendIndex;
		this._blendWeight=blendWeight;
	}

	__class(VertexPositionNormalColorTexture0Texture1SkinSTangent,'laya.d3.graphics.VertexPositionNormalColorTexture0Texture1SkinSTangent');
	var __proto=VertexPositionNormalColorTexture0Texture1SkinSTangent.prototype;
	Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
	__getset(0,__proto,'tangent',function(){
		return this._tangent;
	});

	__getset(0,__proto,'normal',function(){
		return this._normal;
	});

	__getset(0,__proto,'position',function(){
		return this._position;
	});

	__getset(0,__proto,'blendWeight',function(){
		return this._blendWeight;
	});

	__getset(0,__proto,'color',function(){
		return this._color;
	});

	__getset(0,__proto,'textureCoordinate0',function(){
		return this._textureCoordinate0;
	});

	__getset(0,__proto,'vertexDeclaration',function(){
		return VertexPositionNormalColorTexture0Texture1SkinSTangent._vertexDeclaration;
	});

	__getset(0,__proto,'textureCoordinate1',function(){
		return this._textureCoordinate1;
	});

	__getset(0,__proto,'blendIndex',function(){
		return this._blendIndex;
	});

	__getset(1,VertexPositionNormalColorTexture0Texture1SkinSTangent,'vertexDeclaration',function(){
		return VertexPositionNormalColorTexture0Texture1SkinSTangent._vertexDeclaration;
	});

	__static(VertexPositionNormalColorTexture0Texture1SkinSTangent,
	['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(104,[
		new VertexElement(0,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.POSITION0*/0),
		new VertexElement(12,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.NORMAL0*/3),
		new VertexElement(24,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.COLOR0*/1),
		new VertexElement(40,/*laya.d3.graphics.VertexElementFormat.Vector2*/"vector2",/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE0*/2),
		new VertexElement(48,/*laya.d3.graphics.VertexElementFormat.Vector2*/"vector2",/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE1*/15),
		new VertexElement(56,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.BLENDWEIGHT0*/7),
		new VertexElement(72,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.BLENDINDICES0*/6),
		new VertexElement(88,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.TANGENT0*/5)]);}
	]);
	return VertexPositionNormalColorTexture0Texture1SkinSTangent;
})()


/**
*<code>VertexPositionNormalTextureSkin</code> 类用于创建位置、法线、纹理、骨骼索引、骨骼权重顶点结构。
*/
//class laya.d3.graphics.VertexPositionNormalColorTexture0Texture1SkinTangent
var VertexPositionNormalColorTexture0Texture1SkinTangent=(function(){
	function VertexPositionNormalColorTexture0Texture1SkinTangent(){
		this._position=null;
		this._normal=null;
		this._color=null;
		this._textureCoordinate0=null;
		this._textureCoordinate1=null;
		this._blendIndex=null;
		this._blendWeight=null;
		this._tangent=null;
	}

	__class(VertexPositionNormalColorTexture0Texture1SkinTangent,'laya.d3.graphics.VertexPositionNormalColorTexture0Texture1SkinTangent');
	var __proto=VertexPositionNormalColorTexture0Texture1SkinTangent.prototype;
	Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
	__proto.VertexPositionNormalColorTexture0SkinTangent=function(position,normal,color,textureCoordinate0,textureCoordinate1,tangent,blendIndex,blendWeight){
		this._position=position;
		this._normal=normal;
		this._color=color;
		this._textureCoordinate0=textureCoordinate0;
		this._textureCoordinate1=textureCoordinate1;
		this._tangent=tangent;
		this._blendIndex=blendIndex;
		this._blendWeight=blendWeight;
	}

	__getset(0,__proto,'tangent',function(){
		return this._tangent;
	});

	__getset(0,__proto,'normal',function(){
		return this._normal;
	});

	__getset(0,__proto,'position',function(){
		return this._position;
	});

	__getset(0,__proto,'blendWeight',function(){
		return this._blendWeight;
	});

	__getset(0,__proto,'color',function(){
		return this._color;
	});

	__getset(0,__proto,'textureCoordinate0',function(){
		return this._textureCoordinate0;
	});

	__getset(0,__proto,'vertexDeclaration',function(){
		return VertexPositionNormalColorTexture0Texture1SkinTangent._vertexDeclaration;
	});

	__getset(0,__proto,'textureCoordinate1',function(){
		return this._textureCoordinate1;
	});

	__getset(0,__proto,'blendIndex',function(){
		return this._blendIndex;
	});

	__getset(1,VertexPositionNormalColorTexture0Texture1SkinTangent,'vertexDeclaration',function(){
		return VertexPositionNormalColorTexture0Texture1SkinTangent._vertexDeclaration;
	});

	__static(VertexPositionNormalColorTexture0Texture1SkinTangent,
	['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(100,[
		new VertexElement(0,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.POSITION0*/0),
		new VertexElement(12,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.NORMAL0*/3),
		new VertexElement(24,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.COLOR0*/1),
		new VertexElement(40,/*laya.d3.graphics.VertexElementFormat.Vector2*/"vector2",/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE0*/2),
		new VertexElement(48,/*laya.d3.graphics.VertexElementFormat.Vector2*/"vector2",/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE1*/15),
		new VertexElement(56,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.BLENDWEIGHT0*/7),
		new VertexElement(72,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.BLENDINDICES0*/6),
		new VertexElement(88,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.TANGENT0*/5)]);}
	]);
	return VertexPositionNormalColorTexture0Texture1SkinTangent;
})()


/**
*<code>VertexPositionNormalColorTextureTangent</code> 类用于创建位置、法线、颜色、纹理、切线顶点结构。
*/
//class laya.d3.graphics.VertexPositionNormalColorTexture0Texture1STangent
var VertexPositionNormalColorTexture0Texture1STangent=(function(){
	function VertexPositionNormalColorTexture0Texture1STangent(position,normal,color,textureCoordinate0,textureCoordinate1,tangent){
		this._position=null;
		this._normal=null;
		this._color=null;
		this._textureCoordinate0=null;
		this._textureCoordinate1=null;
		this._tangent=null;
		this._position=position;
		this._normal=normal;
		this._color=color;
		this._textureCoordinate0=textureCoordinate0;
		this._textureCoordinate1=textureCoordinate1;
		this._tangent=tangent;
	}

	__class(VertexPositionNormalColorTexture0Texture1STangent,'laya.d3.graphics.VertexPositionNormalColorTexture0Texture1STangent');
	var __proto=VertexPositionNormalColorTexture0Texture1STangent.prototype;
	Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
	__getset(0,__proto,'tangent',function(){
		return this._tangent;
	});

	__getset(0,__proto,'normal',function(){
		return this._normal;
	});

	__getset(0,__proto,'position',function(){
		return this._position;
	});

	__getset(0,__proto,'color',function(){
		return this._color;
	});

	__getset(0,__proto,'textureCoordinate0',function(){
		return this._textureCoordinate0;
	});

	__getset(0,__proto,'vertexDeclaration',function(){
		return VertexPositionNormalColorTexture0Texture1STangent._vertexDeclaration;
	});

	__getset(0,__proto,'textureCoordinate1',function(){
		return this._textureCoordinate1;
	});

	__getset(1,VertexPositionNormalColorTexture0Texture1STangent,'vertexDeclaration',function(){
		return VertexPositionNormalColorTexture0Texture1STangent._vertexDeclaration;
	});

	__static(VertexPositionNormalColorTexture0Texture1STangent,
	['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(72,[
		new VertexElement(0,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.POSITION0*/0),
		new VertexElement(12,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.NORMAL0*/3),
		new VertexElement(24,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.COLOR0*/1),
		new VertexElement(40,/*laya.d3.graphics.VertexElementFormat.Vector2*/"vector2",/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE0*/2),
		new VertexElement(48,/*laya.d3.graphics.VertexElementFormat.Vector2*/"vector2",/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE1*/15),
		new VertexElement(56,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.TANGENT0*/5)]);}
	]);
	return VertexPositionNormalColorTexture0Texture1STangent;
})()


/**
*<code>VertexPositionNormalColorTextureTangent</code> 类用于创建位置、法线、颜色、纹理、切线顶点结构。
*/
//class laya.d3.graphics.VertexPositionNormalColorTexture0Texture1Tangent
var VertexPositionNormalColorTexture0Texture1Tangent=(function(){
	function VertexPositionNormalColorTexture0Texture1Tangent(){
		this._position=null;
		this._normal=null;
		this._color=null;
		this._textureCoordinate0=null;
		this._textureCoordinate1=null;
		this._tangent=null;
	}

	__class(VertexPositionNormalColorTexture0Texture1Tangent,'laya.d3.graphics.VertexPositionNormalColorTexture0Texture1Tangent');
	var __proto=VertexPositionNormalColorTexture0Texture1Tangent.prototype;
	Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
	__proto.VertexPositionNormalColorTexture0Tangent=function(position,normal,color,textureCoordinate0,textureCoordinate1,tangent){
		this._position=position;
		this._normal=normal;
		this._color=color;
		this._textureCoordinate0=textureCoordinate0;
		this._textureCoordinate1=textureCoordinate1;
		this._tangent=tangent;
	}

	__getset(0,__proto,'tangent',function(){
		return this._tangent;
	});

	__getset(0,__proto,'normal',function(){
		return this._normal;
	});

	__getset(0,__proto,'position',function(){
		return this._position;
	});

	__getset(0,__proto,'color',function(){
		return this._color;
	});

	__getset(0,__proto,'textureCoordinate0',function(){
		return this._textureCoordinate0;
	});

	__getset(0,__proto,'vertexDeclaration',function(){
		return VertexPositionNormalColorTexture0Texture1Tangent._vertexDeclaration;
	});

	__getset(0,__proto,'textureCoordinate1',function(){
		return this._textureCoordinate1;
	});

	__getset(1,VertexPositionNormalColorTexture0Texture1Tangent,'vertexDeclaration',function(){
		return VertexPositionNormalColorTexture0Texture1Tangent._vertexDeclaration;
	});

	__static(VertexPositionNormalColorTexture0Texture1Tangent,
	['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(68,[
		new VertexElement(0,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.POSITION0*/0),
		new VertexElement(12,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.NORMAL0*/3),
		new VertexElement(24,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.COLOR0*/1),
		new VertexElement(40,/*laya.d3.graphics.VertexElementFormat.Vector2*/"vector2",/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE0*/2),
		new VertexElement(48,/*laya.d3.graphics.VertexElementFormat.Vector2*/"vector2",/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE1*/15),
		new VertexElement(56,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.TANGENT0*/5)]);}
	]);
	return VertexPositionNormalColorTexture0Texture1Tangent;
})()


/**
*<code>VertexPositionNormalColorTextureSkin</code> 类用于创建位置、法线、颜色、纹理、骨骼索引、骨骼权重顶点结构。
*/
//class laya.d3.graphics.VertexPositionNormalColorTextureSkin
var VertexPositionNormalColorTextureSkin=(function(){
	function VertexPositionNormalColorTextureSkin(position,normal,color,textureCoordinate,blendIndex,blendWeight){
		this._position=null;
		this._normal=null;
		this._color=null;
		this._textureCoordinate=null;
		this._blendIndex=null;
		this._blendWeight=null;
		this._position=position;
		this._normal=normal;
		this._color=color;
		this._textureCoordinate=textureCoordinate;
		this._blendIndex=blendIndex;
		this._blendWeight=blendWeight;
	}

	__class(VertexPositionNormalColorTextureSkin,'laya.d3.graphics.VertexPositionNormalColorTextureSkin');
	var __proto=VertexPositionNormalColorTextureSkin.prototype;
	Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
	__getset(0,__proto,'textureCoordinate',function(){
		return this._textureCoordinate;
	});

	__getset(0,__proto,'normal',function(){
		return this._normal;
	});

	__getset(0,__proto,'position',function(){
		return this._position;
	});

	__getset(0,__proto,'blendWeight',function(){
		return this._blendWeight;
	});

	__getset(0,__proto,'color',function(){
		return this._color;
	});

	__getset(0,__proto,'blendIndex',function(){
		return this._blendIndex;
	});

	__getset(0,__proto,'vertexDeclaration',function(){
		return VertexPositionNormalColorTextureSkin._vertexDeclaration;
	});

	__getset(1,VertexPositionNormalColorTextureSkin,'vertexDeclaration',function(){
		return VertexPositionNormalColorTextureSkin._vertexDeclaration;
	});

	__static(VertexPositionNormalColorTextureSkin,
	['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(80,[
		new VertexElement(0,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.POSITION0*/0),
		new VertexElement(12,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.NORMAL0*/3),
		new VertexElement(24,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.COLOR0*/1),
		new VertexElement(40,/*laya.d3.graphics.VertexElementFormat.Vector2*/"vector2",/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE0*/2),
		new VertexElement(48,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.BLENDWEIGHT0*/7),
		new VertexElement(64,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.BLENDINDICES0*/6)]);}
	]);
	return VertexPositionNormalColorTextureSkin;
})()


/**
*<code>VertexPositionNormalTextureSkin</code> 类用于创建位置、法线、纹理、骨骼索引、骨骼权重顶点结构。
*/
//class laya.d3.graphics.VertexPositionNormalColorTextureSkinSTangent
var VertexPositionNormalColorTextureSkinSTangent=(function(){
	function VertexPositionNormalColorTextureSkinSTangent(position,normal,color,textureCoordinate,tangent,blendIndex,blendWeight){
		this._position=null;
		this._normal=null;
		this._color=null;
		this._textureCoordinate=null;
		this._blendIndex=null;
		this._blendWeight=null;
		this._tangent=null;
		this._position=position;
		this._normal=normal;
		this._color=color;
		this._textureCoordinate=textureCoordinate;
		this._tangent=tangent;
		this._blendIndex=blendIndex;
		this._blendWeight=blendWeight;
	}

	__class(VertexPositionNormalColorTextureSkinSTangent,'laya.d3.graphics.VertexPositionNormalColorTextureSkinSTangent');
	var __proto=VertexPositionNormalColorTextureSkinSTangent.prototype;
	Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
	__getset(0,__proto,'tangent',function(){
		return this._tangent;
	});

	__getset(0,__proto,'textureCoordinate',function(){
		return this._textureCoordinate;
	});

	__getset(0,__proto,'normal',function(){
		return this._normal;
	});

	__getset(0,__proto,'position',function(){
		return this._position;
	});

	__getset(0,__proto,'blendWeight',function(){
		return this._blendWeight;
	});

	__getset(0,__proto,'color',function(){
		return this._color;
	});

	__getset(0,__proto,'blendIndex',function(){
		return this._blendIndex;
	});

	__getset(0,__proto,'vertexDeclaration',function(){
		return VertexPositionNormalColorTextureSkinSTangent._vertexDeclaration;
	});

	__getset(1,VertexPositionNormalColorTextureSkinSTangent,'vertexDeclaration',function(){
		return VertexPositionNormalColorTextureSkinSTangent._vertexDeclaration;
	});

	__static(VertexPositionNormalColorTextureSkinSTangent,
	['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(96,[
		new VertexElement(0,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.POSITION0*/0),
		new VertexElement(12,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.NORMAL0*/3),
		new VertexElement(24,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.COLOR0*/1),
		new VertexElement(40,/*laya.d3.graphics.VertexElementFormat.Vector2*/"vector2",/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE0*/2),
		new VertexElement(48,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.BLENDWEIGHT0*/7),
		new VertexElement(64,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.BLENDINDICES0*/6),
		new VertexElement(80,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.TANGENT0*/5)]);}
	]);
	return VertexPositionNormalColorTextureSkinSTangent;
})()


/**
*<code>VertexPositionNormalTextureSkin</code> 类用于创建位置、法线、纹理、骨骼索引、骨骼权重顶点结构。
*/
//class laya.d3.graphics.VertexPositionNormalColorTextureSkinTangent
var VertexPositionNormalColorTextureSkinTangent=(function(){
	function VertexPositionNormalColorTextureSkinTangent(position,normal,color,textureCoordinate,tangent,blendIndex,blendWeight){
		this._position=null;
		this._normal=null;
		this._color=null;
		this._textureCoordinate=null;
		this._blendIndex=null;
		this._blendWeight=null;
		this._tangent=null;
		this._position=position;
		this._normal=normal;
		this._color=color;
		this._textureCoordinate=textureCoordinate;
		this._tangent=tangent;
		this._blendIndex=blendIndex;
		this._blendWeight=blendWeight;
	}

	__class(VertexPositionNormalColorTextureSkinTangent,'laya.d3.graphics.VertexPositionNormalColorTextureSkinTangent');
	var __proto=VertexPositionNormalColorTextureSkinTangent.prototype;
	Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
	__getset(0,__proto,'tangent',function(){
		return this._tangent;
	});

	__getset(0,__proto,'textureCoordinate',function(){
		return this._textureCoordinate;
	});

	__getset(0,__proto,'normal',function(){
		return this._normal;
	});

	__getset(0,__proto,'position',function(){
		return this._position;
	});

	__getset(0,__proto,'blendWeight',function(){
		return this._blendWeight;
	});

	__getset(0,__proto,'color',function(){
		return this._color;
	});

	__getset(0,__proto,'blendIndex',function(){
		return this._blendIndex;
	});

	__getset(0,__proto,'vertexDeclaration',function(){
		return VertexPositionNormalColorTextureSkinTangent._vertexDeclaration;
	});

	__getset(1,VertexPositionNormalColorTextureSkinTangent,'vertexDeclaration',function(){
		return VertexPositionNormalColorTextureSkinTangent._vertexDeclaration;
	});

	__static(VertexPositionNormalColorTextureSkinTangent,
	['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(92,[
		new VertexElement(0,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.POSITION0*/0),
		new VertexElement(12,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.NORMAL0*/3),
		new VertexElement(24,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.COLOR0*/1),
		new VertexElement(40,/*laya.d3.graphics.VertexElementFormat.Vector2*/"vector2",/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE0*/2),
		new VertexElement(48,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.BLENDWEIGHT0*/7),
		new VertexElement(64,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.BLENDINDICES0*/6),
		new VertexElement(80,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.TANGENT0*/5)]);}
	]);
	return VertexPositionNormalColorTextureSkinTangent;
})()


/**
*<code>VertexPositionNormalColorTextureTangent</code> 类用于创建位置、法线、颜色、纹理、切线顶点结构。
*/
//class laya.d3.graphics.VertexPositionNormalColorTextureSTangent
var VertexPositionNormalColorTextureSTangent=(function(){
	function VertexPositionNormalColorTextureSTangent(position,normal,color,textureCoordinate,tangent){
		this._position=null;
		this._normal=null;
		this._color=null;
		this._textureCoordinate=null;
		this._tangent=null;
		this._position=position;
		this._normal=normal;
		this._color=color;
		this._textureCoordinate=textureCoordinate;
		this._tangent=tangent;
	}

	__class(VertexPositionNormalColorTextureSTangent,'laya.d3.graphics.VertexPositionNormalColorTextureSTangent');
	var __proto=VertexPositionNormalColorTextureSTangent.prototype;
	Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
	__getset(0,__proto,'tangent',function(){
		return this._tangent;
	});

	__getset(0,__proto,'textureCoordinate',function(){
		return this._textureCoordinate;
	});

	__getset(0,__proto,'normal',function(){
		return this._normal;
	});

	__getset(0,__proto,'position',function(){
		return this._position;
	});

	__getset(0,__proto,'color',function(){
		return this._color;
	});

	__getset(0,__proto,'vertexDeclaration',function(){
		return VertexPositionNormalColorTextureSTangent._vertexDeclaration;
	});

	__getset(1,VertexPositionNormalColorTextureSTangent,'vertexDeclaration',function(){
		return VertexPositionNormalColorTextureSTangent._vertexDeclaration;
	});

	__static(VertexPositionNormalColorTextureSTangent,
	['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(64,[
		new VertexElement(0,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.POSITION0*/0),
		new VertexElement(12,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.NORMAL0*/3),
		new VertexElement(24,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.COLOR0*/1),
		new VertexElement(40,/*laya.d3.graphics.VertexElementFormat.Vector2*/"vector2",/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE0*/2),
		new VertexElement(48,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.TANGENT0*/5)]);}
	]);
	return VertexPositionNormalColorTextureSTangent;
})()


/**
*<code>VertexPositionNormalColorTextureTangent</code> 类用于创建位置、法线、颜色、纹理、切线顶点结构。
*/
//class laya.d3.graphics.VertexPositionNormalColorTextureTangent
var VertexPositionNormalColorTextureTangent=(function(){
	function VertexPositionNormalColorTextureTangent(position,normal,color,textureCoordinate,tangent){
		this._position=null;
		this._normal=null;
		this._color=null;
		this._textureCoordinate=null;
		this._tangent=null;
		this._position=position;
		this._normal=normal;
		this._color=color;
		this._textureCoordinate=textureCoordinate;
		this._tangent=tangent;
	}

	__class(VertexPositionNormalColorTextureTangent,'laya.d3.graphics.VertexPositionNormalColorTextureTangent');
	var __proto=VertexPositionNormalColorTextureTangent.prototype;
	Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
	__getset(0,__proto,'tangent',function(){
		return this._tangent;
	});

	__getset(0,__proto,'textureCoordinate',function(){
		return this._textureCoordinate;
	});

	__getset(0,__proto,'normal',function(){
		return this._normal;
	});

	__getset(0,__proto,'position',function(){
		return this._position;
	});

	__getset(0,__proto,'color',function(){
		return this._color;
	});

	__getset(0,__proto,'vertexDeclaration',function(){
		return VertexPositionNormalColorTextureTangent._vertexDeclaration;
	});

	__getset(1,VertexPositionNormalColorTextureTangent,'vertexDeclaration',function(){
		return VertexPositionNormalColorTextureTangent._vertexDeclaration;
	});

	__static(VertexPositionNormalColorTextureTangent,
	['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(60,[
		new VertexElement(0,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.POSITION0*/0),
		new VertexElement(12,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.NORMAL0*/3),
		new VertexElement(24,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.COLOR0*/1),
		new VertexElement(40,/*laya.d3.graphics.VertexElementFormat.Vector2*/"vector2",/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE0*/2),
		new VertexElement(48,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.TANGENT0*/5)]);}
	]);
	return VertexPositionNormalColorTextureTangent;
})()


//class laya.d3.graphics.VertexPositionNormalSTangent
var VertexPositionNormalSTangent=(function(){
	function VertexPositionNormalSTangent(position,normal,tangent){
		this._position=null;
		this._normal=null;
		this._tangent=null;
		this._position=position;
		this._normal=normal;
		this._tangent=tangent;
	}

	__class(VertexPositionNormalSTangent,'laya.d3.graphics.VertexPositionNormalSTangent');
	var __proto=VertexPositionNormalSTangent.prototype;
	Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
	__getset(0,__proto,'tangent',function(){
		return this._tangent;
	});

	__getset(0,__proto,'normal',function(){
		return this._normal;
	});

	__getset(0,__proto,'position',function(){
		return this._position;
	});

	__getset(0,__proto,'vertexDeclaration',function(){
		return VertexPositionNormalSTangent._vertexDeclaration;
	});

	/*INTERFACE laya.d3.graphics.IVertex */
	__getset(1,VertexPositionNormalSTangent,'vertexDeclaration',function(){
		return VertexPositionNormalSTangent._vertexDeclaration;
	});

	__static(VertexPositionNormalSTangent,
	['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(40,[
		new VertexElement(0,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.POSITION0*/0),
		new VertexElement(12,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.NORMAL0*/3),
		new VertexElement(24,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.TANGENT0*/5)]);}
	]);
	return VertexPositionNormalSTangent;
})()


//class laya.d3.graphics.VertexPositionNormalTangent
var VertexPositionNormalTangent=(function(){
	function VertexPositionNormalTangent(position,normal,tangent){
		this._position=null;
		this._normal=null;
		this._tangent=null;
		this._position=position;
		this._normal=normal;
		this._tangent=tangent;
	}

	__class(VertexPositionNormalTangent,'laya.d3.graphics.VertexPositionNormalTangent');
	var __proto=VertexPositionNormalTangent.prototype;
	Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
	__getset(0,__proto,'tangent',function(){
		return this._tangent;
	});

	__getset(0,__proto,'normal',function(){
		return this._normal;
	});

	__getset(0,__proto,'position',function(){
		return this._position;
	});

	__getset(0,__proto,'vertexDeclaration',function(){
		return VertexPositionNormalTangent._vertexDeclaration;
	});

	/*INTERFACE laya.d3.graphics.IVertex */
	__getset(1,VertexPositionNormalTangent,'vertexDeclaration',function(){
		return VertexPositionNormalTangent._vertexDeclaration;
	});

	__static(VertexPositionNormalTangent,
	['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(36,[
		new VertexElement(0,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.POSITION0*/0),
		new VertexElement(12,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.NORMAL0*/3),
		new VertexElement(24,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.TANGENT0*/5)]);}
	]);
	return VertexPositionNormalTangent;
})()


/**
*<code>VertexPositionNormalTexture</code> 类用于创建位置、法线、纹理顶点结构。
*/
//class laya.d3.graphics.VertexPositionNormalTexture
var VertexPositionNormalTexture=(function(){
	function VertexPositionNormalTexture(position,normal,textureCoordinate){
		this._position=null;
		this._normal=null;
		this._textureCoordinate=null;
		this._position=position;
		this._normal=normal;
		this._textureCoordinate=textureCoordinate;
	}

	__class(VertexPositionNormalTexture,'laya.d3.graphics.VertexPositionNormalTexture');
	var __proto=VertexPositionNormalTexture.prototype;
	Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
	__getset(0,__proto,'textureCoordinate',function(){
		return this._textureCoordinate;
	});

	__getset(0,__proto,'normal',function(){
		return this._normal;
	});

	__getset(0,__proto,'position',function(){
		return this._position;
	});

	__getset(0,__proto,'vertexDeclaration',function(){
		return VertexPositionNormalTexture._vertexDeclaration;
	});

	__getset(1,VertexPositionNormalTexture,'vertexDeclaration',function(){
		return VertexPositionNormalTexture._vertexDeclaration;
	});

	__static(VertexPositionNormalTexture,
	['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(32,[
		new VertexElement(0,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.POSITION0*/0),
		new VertexElement(12,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.NORMAL0*/3),
		new VertexElement(24,/*laya.d3.graphics.VertexElementFormat.Vector2*/"vector2",/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE0*/2)]);}
	]);
	return VertexPositionNormalTexture;
})()


/**
*<code>VertexPositionNormalTexture</code> 类用于创建位置、法线、纹理顶点结构。
*/
//class laya.d3.graphics.VertexPositionNormalTexture0Texture1
var VertexPositionNormalTexture0Texture1=(function(){
	function VertexPositionNormalTexture0Texture1(position,normal,textureCoordinate0,textureCoordinate1){
		this._position=null;
		this._normal=null;
		this._textureCoordinate0=null;
		this._textureCoordinate1=null;
		this._position=position;
		this._normal=normal;
		this._textureCoordinate0=textureCoordinate0;
		this._textureCoordinate1=textureCoordinate1;
	}

	__class(VertexPositionNormalTexture0Texture1,'laya.d3.graphics.VertexPositionNormalTexture0Texture1');
	var __proto=VertexPositionNormalTexture0Texture1.prototype;
	Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
	__getset(0,__proto,'normal',function(){
		return this._normal;
	});

	__getset(0,__proto,'position',function(){
		return this._position;
	});

	__getset(0,__proto,'textureCoordinate0',function(){
		return this._textureCoordinate0;
	});

	__getset(0,__proto,'vertexDeclaration',function(){
		return VertexPositionNormalTexture0Texture1._vertexDeclaration;
	});

	__getset(0,__proto,'textureCoordinate1',function(){
		return this._textureCoordinate1;
	});

	__getset(1,VertexPositionNormalTexture0Texture1,'vertexDeclaration',function(){
		return VertexPositionNormalTexture0Texture1._vertexDeclaration;
	});

	__static(VertexPositionNormalTexture0Texture1,
	['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(40,[
		new VertexElement(0,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.POSITION0*/0),
		new VertexElement(12,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.NORMAL0*/3),
		new VertexElement(24,/*laya.d3.graphics.VertexElementFormat.Vector2*/"vector2",/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE0*/2),
		new VertexElement(32,/*laya.d3.graphics.VertexElementFormat.Vector2*/"vector2",/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE1*/15)]);}
	]);
	return VertexPositionNormalTexture0Texture1;
})()


/**
*<code>VertexPositionNormalColorTextureSkin</code> 类用于创建位置、法线、颜色、纹理、骨骼索引、骨骼权重顶点结构。
*/
//class laya.d3.graphics.VertexPositionNormalTexture0Texture1Skin
var VertexPositionNormalTexture0Texture1Skin=(function(){
	function VertexPositionNormalTexture0Texture1Skin(position,normal,textureCoordinate0,textureCoordinate1,blendIndex,blendWeight){
		this._position=null;
		this._normal=null;
		this._textureCoordinate0=null;
		this._textureCoordinate1=null;
		this._blendIndex=null;
		this._blendWeight=null;
		this._position=position;
		this._normal=normal;
		this._textureCoordinate0=textureCoordinate0;
		this._textureCoordinate1=textureCoordinate1;
		this._blendIndex=blendIndex;
		this._blendWeight=blendWeight;
	}

	__class(VertexPositionNormalTexture0Texture1Skin,'laya.d3.graphics.VertexPositionNormalTexture0Texture1Skin');
	var __proto=VertexPositionNormalTexture0Texture1Skin.prototype;
	Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
	__getset(0,__proto,'normal',function(){
		return this._normal;
	});

	__getset(0,__proto,'position',function(){
		return this._position;
	});

	__getset(0,__proto,'textureCoordinate0',function(){
		return this._textureCoordinate0;
	});

	__getset(0,__proto,'vertexDeclaration',function(){
		return VertexPositionNormalTexture0Texture1Skin._vertexDeclaration;
	});

	__getset(0,__proto,'textureCoordinate1',function(){
		return this._textureCoordinate1;
	});

	__getset(0,__proto,'blendIndex',function(){
		return this._blendIndex;
	});

	__getset(0,__proto,'blendWeight',function(){
		return this._blendWeight;
	});

	__getset(1,VertexPositionNormalTexture0Texture1Skin,'vertexDeclaration',function(){
		return VertexPositionNormalTexture0Texture1Skin._vertexDeclaration;
	});

	__static(VertexPositionNormalTexture0Texture1Skin,
	['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(72,[
		new VertexElement(0,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.POSITION0*/0),
		new VertexElement(12,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.NORMAL0*/3),
		new VertexElement(24,/*laya.d3.graphics.VertexElementFormat.Vector2*/"vector2",/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE0*/2),
		new VertexElement(32,/*laya.d3.graphics.VertexElementFormat.Vector2*/"vector2",/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE1*/15),
		new VertexElement(40,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.BLENDWEIGHT0*/7),
		new VertexElement(56,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.BLENDINDICES0*/6)]);}
	]);
	return VertexPositionNormalTexture0Texture1Skin;
})()


/**
*<code>VertexPositionNormalTextureSkin</code> 类用于创建位置、法线、纹理、骨骼索引、骨骼权重顶点结构。
*/
//class laya.d3.graphics.VertexPositionNormalTexture0Texture1SkinSTangent
var VertexPositionNormalTexture0Texture1SkinSTangent=(function(){
	function VertexPositionNormalTexture0Texture1SkinSTangent(position,normal,textureCoordinate0,textureCoordinate1,tangent,blendIndex,blendWeight){
		this._position=null;
		this._normal=null;
		this._textureCoordinate0=null;
		this._textureCoordinate1=null;
		this._blendIndex=null;
		this._blendWeight=null;
		this._tangent=null;
		this._position=position;
		this._normal=normal;
		this._textureCoordinate0=textureCoordinate0;
		this._textureCoordinate1=textureCoordinate1;
		this._tangent=tangent;
		this._blendIndex=blendIndex;
		this._blendWeight=blendWeight;
	}

	__class(VertexPositionNormalTexture0Texture1SkinSTangent,'laya.d3.graphics.VertexPositionNormalTexture0Texture1SkinSTangent');
	var __proto=VertexPositionNormalTexture0Texture1SkinSTangent.prototype;
	Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
	__getset(0,__proto,'tangent',function(){
		return this._tangent;
	});

	__getset(0,__proto,'normal',function(){
		return this._normal;
	});

	__getset(0,__proto,'position',function(){
		return this._position;
	});

	__getset(0,__proto,'textureCoordinate0',function(){
		return this._textureCoordinate0;
	});

	__getset(0,__proto,'vertexDeclaration',function(){
		return VertexPositionNormalTexture0Texture1SkinSTangent._vertexDeclaration;
	});

	__getset(0,__proto,'textureCoordinate1',function(){
		return this._textureCoordinate1;
	});

	__getset(0,__proto,'blendIndex',function(){
		return this._blendIndex;
	});

	__getset(0,__proto,'blendWeight',function(){
		return this._blendWeight;
	});

	__getset(1,VertexPositionNormalTexture0Texture1SkinSTangent,'vertexDeclaration',function(){
		return VertexPositionNormalTexture0Texture1SkinSTangent._vertexDeclaration;
	});

	__static(VertexPositionNormalTexture0Texture1SkinSTangent,
	['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(88,[
		new VertexElement(0,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.POSITION0*/0),
		new VertexElement(12,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.NORMAL0*/3),
		new VertexElement(24,/*laya.d3.graphics.VertexElementFormat.Vector2*/"vector2",/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE0*/2),
		new VertexElement(32,/*laya.d3.graphics.VertexElementFormat.Vector2*/"vector2",/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE1*/15),
		new VertexElement(40,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.BLENDWEIGHT0*/7),
		new VertexElement(56,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.BLENDINDICES0*/6),
		new VertexElement(72,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.TANGENT0*/5)]);}
	]);
	return VertexPositionNormalTexture0Texture1SkinSTangent;
})()


/**
*<code>VertexPositionNormalTextureSkin</code> 类用于创建位置、法线、纹理、骨骼索引、骨骼权重顶点结构。
*/
//class laya.d3.graphics.VertexPositionNormalTexture0Texture1SkinTangent
var VertexPositionNormalTexture0Texture1SkinTangent=(function(){
	function VertexPositionNormalTexture0Texture1SkinTangent(){
		this._position=null;
		this._normal=null;
		this._textureCoordinate0=null;
		this._textureCoordinate1=null;
		this._blendIndex=null;
		this._blendWeight=null;
		this._tangent=null;
	}

	__class(VertexPositionNormalTexture0Texture1SkinTangent,'laya.d3.graphics.VertexPositionNormalTexture0Texture1SkinTangent');
	var __proto=VertexPositionNormalTexture0Texture1SkinTangent.prototype;
	Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
	__proto.VertexPositionNormalTexture0SkinTangent=function(position,normal,textureCoordinate0,textureCoordinate1,tangent,blendIndex,blendWeight){
		this._position=position;
		this._normal=normal;
		this._textureCoordinate0=textureCoordinate0;
		this._textureCoordinate1=textureCoordinate1;
		this._tangent=tangent;
		this._blendIndex=blendIndex;
		this._blendWeight=blendWeight;
	}

	__getset(0,__proto,'tangent',function(){
		return this._tangent;
	});

	__getset(0,__proto,'normal',function(){
		return this._normal;
	});

	__getset(0,__proto,'position',function(){
		return this._position;
	});

	__getset(0,__proto,'textureCoordinate0',function(){
		return this._textureCoordinate0;
	});

	__getset(0,__proto,'vertexDeclaration',function(){
		return VertexPositionNormalTexture0Texture1SkinTangent._vertexDeclaration;
	});

	__getset(0,__proto,'textureCoordinate1',function(){
		return this._textureCoordinate1;
	});

	__getset(0,__proto,'blendIndex',function(){
		return this._blendIndex;
	});

	__getset(0,__proto,'blendWeight',function(){
		return this._blendWeight;
	});

	__getset(1,VertexPositionNormalTexture0Texture1SkinTangent,'vertexDeclaration',function(){
		return VertexPositionNormalTexture0Texture1SkinTangent._vertexDeclaration;
	});

	__static(VertexPositionNormalTexture0Texture1SkinTangent,
	['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(84,[
		new VertexElement(0,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.POSITION0*/0),
		new VertexElement(12,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.NORMAL0*/3),
		new VertexElement(24,/*laya.d3.graphics.VertexElementFormat.Vector2*/"vector2",/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE0*/2),
		new VertexElement(32,/*laya.d3.graphics.VertexElementFormat.Vector2*/"vector2",/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE1*/15),
		new VertexElement(40,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.BLENDWEIGHT0*/7),
		new VertexElement(56,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.BLENDINDICES0*/6),
		new VertexElement(72,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.TANGENT0*/5)]);}
	]);
	return VertexPositionNormalTexture0Texture1SkinTangent;
})()


/**
*<code>VertexPositionNormalTextureTangent</code> 类用于创建位置、法线、纹理、切线顶点结构。
*/
//class laya.d3.graphics.VertexPositionNormalTexture0Texture1STangent
var VertexPositionNormalTexture0Texture1STangent=(function(){
	function VertexPositionNormalTexture0Texture1STangent(position,normal,textureCoordinate0,textureCoordinate1,tangent){
		this._position=null;
		this._normal=null;
		this._textureCoordinate0=null;
		this._textureCoordinate1=null;
		this._tangent=null;
		this._position=position;
		this._normal=normal;
		this._textureCoordinate0=textureCoordinate0;
		this._textureCoordinate1=textureCoordinate1;
		this._tangent=tangent;
	}

	__class(VertexPositionNormalTexture0Texture1STangent,'laya.d3.graphics.VertexPositionNormalTexture0Texture1STangent');
	var __proto=VertexPositionNormalTexture0Texture1STangent.prototype;
	Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
	__getset(0,__proto,'tangent',function(){
		return this._tangent;
	});

	__getset(0,__proto,'normal',function(){
		return this._normal;
	});

	__getset(0,__proto,'position',function(){
		return this._position;
	});

	__getset(0,__proto,'textureCoordinate0',function(){
		return this._textureCoordinate0;
	});

	__getset(0,__proto,'vertexDeclaration',function(){
		return VertexPositionNormalTexture0Texture1STangent._vertexDeclaration;
	});

	__getset(0,__proto,'textureCoordinate1',function(){
		return this._textureCoordinate1;
	});

	__getset(1,VertexPositionNormalTexture0Texture1STangent,'vertexDeclaration',function(){
		return VertexPositionNormalTexture0Texture1STangent._vertexDeclaration;
	});

	__static(VertexPositionNormalTexture0Texture1STangent,
	['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(56,[
		new VertexElement(0,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.POSITION0*/0),
		new VertexElement(12,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.NORMAL0*/3),
		new VertexElement(24,/*laya.d3.graphics.VertexElementFormat.Vector2*/"vector2",/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE0*/2),
		new VertexElement(32,/*laya.d3.graphics.VertexElementFormat.Vector2*/"vector2",/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE1*/15),
		new VertexElement(40,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.TANGENT0*/5)]);}
	]);
	return VertexPositionNormalTexture0Texture1STangent;
})()


/**
*<code>VertexPositionNormalTextureTangent</code> 类用于创建位置、法线、纹理、切线顶点结构。
*/
//class laya.d3.graphics.VertexPositionNormalTexture0Texture1Tangent
var VertexPositionNormalTexture0Texture1Tangent=(function(){
	function VertexPositionNormalTexture0Texture1Tangent(){
		this._position=null;
		this._normal=null;
		this._textureCoordinate0=null;
		this._textureCoordinate1=null;
		this._tangent=null;
	}

	__class(VertexPositionNormalTexture0Texture1Tangent,'laya.d3.graphics.VertexPositionNormalTexture0Texture1Tangent');
	var __proto=VertexPositionNormalTexture0Texture1Tangent.prototype;
	Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
	__proto.VertexPositionNormalTexture0Tangent=function(position,normal,textureCoordinate0,textureCoordinate1,tangent){
		this._position=position;
		this._normal=normal;
		this._textureCoordinate0=textureCoordinate0;
		this._textureCoordinate1=textureCoordinate1;
		this._tangent=tangent;
	}

	__getset(0,__proto,'tangent',function(){
		return this._tangent;
	});

	__getset(0,__proto,'normal',function(){
		return this._normal;
	});

	__getset(0,__proto,'position',function(){
		return this._position;
	});

	__getset(0,__proto,'textureCoordinate0',function(){
		return this._textureCoordinate0;
	});

	__getset(0,__proto,'vertexDeclaration',function(){
		return VertexPositionNormalTexture0Texture1Tangent._vertexDeclaration;
	});

	__getset(0,__proto,'textureCoordinate1',function(){
		return this._textureCoordinate1;
	});

	__getset(1,VertexPositionNormalTexture0Texture1Tangent,'vertexDeclaration',function(){
		return VertexPositionNormalTexture0Texture1Tangent._vertexDeclaration;
	});

	__static(VertexPositionNormalTexture0Texture1Tangent,
	['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(52,[
		new VertexElement(0,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.POSITION0*/0),
		new VertexElement(12,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.NORMAL0*/3),
		new VertexElement(24,/*laya.d3.graphics.VertexElementFormat.Vector2*/"vector2",/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE0*/2),
		new VertexElement(32,/*laya.d3.graphics.VertexElementFormat.Vector2*/"vector2",/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE1*/15),
		new VertexElement(40,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.TANGENT0*/5)]);}
	]);
	return VertexPositionNormalTexture0Texture1Tangent;
})()


/**
*<code>VertexPositionNormalColorTextureSkin</code> 类用于创建位置、法线、颜色、纹理、骨骼索引、骨骼权重顶点结构。
*/
//class laya.d3.graphics.VertexPositionNormalTextureSkin
var VertexPositionNormalTextureSkin=(function(){
	function VertexPositionNormalTextureSkin(position,normal,textureCoordinate,blendIndex,blendWeight){
		this._position=null;
		this._normal=null;
		this._textureCoordinate=null;
		this._blendIndex=null;
		this._blendWeight=null;
		this._position=position;
		this._normal=normal;
		this._textureCoordinate=textureCoordinate;
		this._blendIndex=blendIndex;
		this._blendWeight=blendWeight;
	}

	__class(VertexPositionNormalTextureSkin,'laya.d3.graphics.VertexPositionNormalTextureSkin');
	var __proto=VertexPositionNormalTextureSkin.prototype;
	Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
	__getset(0,__proto,'textureCoordinate',function(){
		return this._textureCoordinate;
	});

	__getset(0,__proto,'normal',function(){
		return this._normal;
	});

	__getset(0,__proto,'position',function(){
		return this._position;
	});

	__getset(0,__proto,'blendIndex',function(){
		return this._blendIndex;
	});

	__getset(0,__proto,'blendWeight',function(){
		return this._blendWeight;
	});

	__getset(0,__proto,'vertexDeclaration',function(){
		return VertexPositionNormalTextureSkin._vertexDeclaration;
	});

	__getset(1,VertexPositionNormalTextureSkin,'vertexDeclaration',function(){
		return VertexPositionNormalTextureSkin._vertexDeclaration;
	});

	__static(VertexPositionNormalTextureSkin,
	['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(64,[
		new VertexElement(0,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.POSITION0*/0),
		new VertexElement(12,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.NORMAL0*/3),
		new VertexElement(24,/*laya.d3.graphics.VertexElementFormat.Vector2*/"vector2",/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE0*/2),
		new VertexElement(32,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.BLENDWEIGHT0*/7),
		new VertexElement(48,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.BLENDINDICES0*/6)]);}
	]);
	return VertexPositionNormalTextureSkin;
})()


/**
*<code>VertexPositionNormalTextureSkin</code> 类用于创建位置、法线、纹理、骨骼索引、骨骼权重顶点结构。
*/
//class laya.d3.graphics.VertexPositionNormalTextureSkinSTangent
var VertexPositionNormalTextureSkinSTangent=(function(){
	function VertexPositionNormalTextureSkinSTangent(position,normal,textureCoordinate,tangent,blendIndex,blendWeight){
		this._position=null;
		this._normal=null;
		this._textureCoordinate=null;
		this._blendIndex=null;
		this._blendWeight=null;
		this._tangent=null;
		this._position=position;
		this._normal=normal;
		this._textureCoordinate=textureCoordinate;
		this._tangent=tangent;
		this._blendIndex=blendIndex;
		this._blendWeight=blendWeight;
	}

	__class(VertexPositionNormalTextureSkinSTangent,'laya.d3.graphics.VertexPositionNormalTextureSkinSTangent');
	var __proto=VertexPositionNormalTextureSkinSTangent.prototype;
	Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
	__getset(0,__proto,'tangent',function(){
		return this._tangent;
	});

	__getset(0,__proto,'textureCoordinate',function(){
		return this._textureCoordinate;
	});

	__getset(0,__proto,'normal',function(){
		return this._normal;
	});

	__getset(0,__proto,'position',function(){
		return this._position;
	});

	__getset(0,__proto,'blendIndex',function(){
		return this._blendIndex;
	});

	__getset(0,__proto,'blendWeight',function(){
		return this._blendWeight;
	});

	__getset(0,__proto,'vertexDeclaration',function(){
		return VertexPositionNormalTextureSkinSTangent._vertexDeclaration;
	});

	__getset(1,VertexPositionNormalTextureSkinSTangent,'vertexDeclaration',function(){
		return VertexPositionNormalTextureSkinSTangent._vertexDeclaration;
	});

	__static(VertexPositionNormalTextureSkinSTangent,
	['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(80,[
		new VertexElement(0,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.POSITION0*/0),
		new VertexElement(12,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.NORMAL0*/3),
		new VertexElement(24,/*laya.d3.graphics.VertexElementFormat.Vector2*/"vector2",/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE0*/2),
		new VertexElement(32,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.BLENDWEIGHT0*/7),
		new VertexElement(48,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.BLENDINDICES0*/6),
		new VertexElement(64,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.TANGENT0*/5)]);}
	]);
	return VertexPositionNormalTextureSkinSTangent;
})()


/**
*<code>VertexPositionNormalTextureSkin</code> 类用于创建位置、法线、纹理、骨骼索引、骨骼权重顶点结构。
*/
//class laya.d3.graphics.VertexPositionNormalTextureSkinTangent
var VertexPositionNormalTextureSkinTangent=(function(){
	function VertexPositionNormalTextureSkinTangent(position,normal,textureCoordinate,tangent,blendIndex,blendWeight){
		this._position=null;
		this._normal=null;
		this._textureCoordinate=null;
		this._blendIndex=null;
		this._blendWeight=null;
		this._tangent=null;
		this._position=position;
		this._normal=normal;
		this._textureCoordinate=textureCoordinate;
		this._tangent=tangent;
		this._blendIndex=blendIndex;
		this._blendWeight=blendWeight;
	}

	__class(VertexPositionNormalTextureSkinTangent,'laya.d3.graphics.VertexPositionNormalTextureSkinTangent');
	var __proto=VertexPositionNormalTextureSkinTangent.prototype;
	Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
	__getset(0,__proto,'tangent',function(){
		return this._tangent;
	});

	__getset(0,__proto,'textureCoordinate',function(){
		return this._textureCoordinate;
	});

	__getset(0,__proto,'normal',function(){
		return this._normal;
	});

	__getset(0,__proto,'position',function(){
		return this._position;
	});

	__getset(0,__proto,'blendIndex',function(){
		return this._blendIndex;
	});

	__getset(0,__proto,'blendWeight',function(){
		return this._blendWeight;
	});

	__getset(0,__proto,'vertexDeclaration',function(){
		return VertexPositionNormalTextureSkinTangent._vertexDeclaration;
	});

	__getset(1,VertexPositionNormalTextureSkinTangent,'vertexDeclaration',function(){
		return VertexPositionNormalTextureSkinTangent._vertexDeclaration;
	});

	__static(VertexPositionNormalTextureSkinTangent,
	['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(76,[
		new VertexElement(0,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.POSITION0*/0),
		new VertexElement(12,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.NORMAL0*/3),
		new VertexElement(24,/*laya.d3.graphics.VertexElementFormat.Vector2*/"vector2",/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE0*/2),
		new VertexElement(32,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.BLENDWEIGHT0*/7),
		new VertexElement(48,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.BLENDINDICES0*/6),
		new VertexElement(64,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.TANGENT0*/5)]);}
	]);
	return VertexPositionNormalTextureSkinTangent;
})()


/**
*<code>VertexPositionNormalTextureTangent</code> 类用于创建位置、法线、纹理、切线顶点结构。
*/
//class laya.d3.graphics.VertexPositionNormalTextureSTangent
var VertexPositionNormalTextureSTangent=(function(){
	function VertexPositionNormalTextureSTangent(position,normal,textureCoordinate,tangent){
		this._position=null;
		this._normal=null;
		this._textureCoordinate=null;
		this._tangent=null;
		this._position=position;
		this._normal=normal;
		this._textureCoordinate=textureCoordinate;
		this._tangent=tangent;
	}

	__class(VertexPositionNormalTextureSTangent,'laya.d3.graphics.VertexPositionNormalTextureSTangent');
	var __proto=VertexPositionNormalTextureSTangent.prototype;
	Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
	__getset(0,__proto,'tangent',function(){
		return this._tangent;
	});

	__getset(0,__proto,'textureCoordinate',function(){
		return this._textureCoordinate;
	});

	__getset(0,__proto,'normal',function(){
		return this._normal;
	});

	__getset(0,__proto,'position',function(){
		return this._position;
	});

	__getset(0,__proto,'vertexDeclaration',function(){
		return VertexPositionNormalTextureSTangent._vertexDeclaration;
	});

	__getset(1,VertexPositionNormalTextureSTangent,'vertexDeclaration',function(){
		return VertexPositionNormalTextureSTangent._vertexDeclaration;
	});

	__static(VertexPositionNormalTextureSTangent,
	['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(48,[
		new VertexElement(0,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.POSITION0*/0),
		new VertexElement(12,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.NORMAL0*/3),
		new VertexElement(24,/*laya.d3.graphics.VertexElementFormat.Vector2*/"vector2",/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE0*/2),
		new VertexElement(32,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.TANGENT0*/5)]);}
	]);
	return VertexPositionNormalTextureSTangent;
})()


/**
*<code>VertexPositionNormalTextureTangent</code> 类用于创建位置、法线、纹理、切线顶点结构。
*/
//class laya.d3.graphics.VertexPositionNormalTextureTangent
var VertexPositionNormalTextureTangent=(function(){
	function VertexPositionNormalTextureTangent(position,normal,textureCoordinate,tangent){
		this._position=null;
		this._normal=null;
		this._textureCoordinate=null;
		this._tangent=null;
		this._position=position;
		this._normal=normal;
		this._textureCoordinate=textureCoordinate;
		this._tangent=tangent;
	}

	__class(VertexPositionNormalTextureTangent,'laya.d3.graphics.VertexPositionNormalTextureTangent');
	var __proto=VertexPositionNormalTextureTangent.prototype;
	Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
	__getset(0,__proto,'tangent',function(){
		return this._tangent;
	});

	__getset(0,__proto,'textureCoordinate',function(){
		return this._textureCoordinate;
	});

	__getset(0,__proto,'normal',function(){
		return this._normal;
	});

	__getset(0,__proto,'position',function(){
		return this._position;
	});

	__getset(0,__proto,'vertexDeclaration',function(){
		return VertexPositionNormalTextureTangent._vertexDeclaration;
	});

	__getset(1,VertexPositionNormalTextureTangent,'vertexDeclaration',function(){
		return VertexPositionNormalTextureTangent._vertexDeclaration;
	});

	__static(VertexPositionNormalTextureTangent,
	['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(44,[
		new VertexElement(0,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.POSITION0*/0),
		new VertexElement(12,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.NORMAL0*/3),
		new VertexElement(24,/*laya.d3.graphics.VertexElementFormat.Vector2*/"vector2",/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE0*/2),
		new VertexElement(32,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.TANGENT0*/5)]);}
	]);
	return VertexPositionNormalTextureTangent;
})()


/**
*<code>VertexPositionNormalTexture</code> 类用于创建位置、法线、纹理顶点结构。
*/
//class laya.d3.graphics.VertexPositionNTBTexture
var VertexPositionNTBTexture=(function(){
	function VertexPositionNTBTexture(position,normal,textureCoordinate){
		this._position=null;
		this._normal=null;
		this._textureCoordinate=null;
		this._position=position;
		this._normal=normal;
		this._textureCoordinate=textureCoordinate;
	}

	__class(VertexPositionNTBTexture,'laya.d3.graphics.VertexPositionNTBTexture');
	var __proto=VertexPositionNTBTexture.prototype;
	Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
	__getset(0,__proto,'textureCoordinate',function(){
		return this._textureCoordinate;
	});

	__getset(0,__proto,'normal',function(){
		return this._normal;
	});

	__getset(0,__proto,'position',function(){
		return this._position;
	});

	__getset(0,__proto,'vertexDeclaration',function(){
		return VertexPositionNTBTexture._vertexDeclaration;
	});

	__getset(1,VertexPositionNTBTexture,'vertexDeclaration',function(){
		return VertexPositionNTBTexture._vertexDeclaration;
	});

	__static(VertexPositionNTBTexture,
	['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(56,[
		new VertexElement(0,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.POSITION0*/0),
		new VertexElement(12,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.NORMAL0*/3),
		new VertexElement(24,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.TANGENT0*/5),
		new VertexElement(36,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.BINORMAL0*/4),
		new VertexElement(48,/*laya.d3.graphics.VertexElementFormat.Vector2*/"vector2",/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE0*/2)]);}
	]);
	return VertexPositionNTBTexture;
})()


/**
*<code>VertexPositionNormalTextureSkin</code> 类用于创建位置、法线、纹理、骨骼索引、骨骼权重顶点结构。
*/
//class laya.d3.graphics.VertexPositionNTBTexture0Texture1Skin
var VertexPositionNTBTexture0Texture1Skin=(function(){
	function VertexPositionNTBTexture0Texture1Skin(position,normal,binormal,textureCoordinate0,textureCoordinate1,tangent,blendIndex,blendWeight){
		this._position=null;
		this._normal=null;
		this._textureCoordinate0=null;
		this._textureCoordinate1=null;
		this._blendIndex=null;
		this._blendWeight=null;
		this._tangent=null;
		this.binormal=null;
		this._position=position;
		this._normal=normal;
		this._textureCoordinate0=textureCoordinate0;
		this._textureCoordinate1=textureCoordinate1;
		this._tangent=tangent;
		binormal=binormal;
		this._blendIndex=blendIndex;
		this._blendWeight=blendWeight;
	}

	__class(VertexPositionNTBTexture0Texture1Skin,'laya.d3.graphics.VertexPositionNTBTexture0Texture1Skin');
	var __proto=VertexPositionNTBTexture0Texture1Skin.prototype;
	Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
	__getset(0,__proto,'tangent',function(){
		return this._tangent;
	});

	__getset(0,__proto,'normal',function(){
		return this._normal;
	});

	__getset(0,__proto,'position',function(){
		return this._position;
	});

	__getset(0,__proto,'textureCoordinate0',function(){
		return this._textureCoordinate0;
	});

	__getset(0,__proto,'vertexDeclaration',function(){
		return VertexPositionNTBTexture0Texture1Skin._vertexDeclaration;
	});

	__getset(0,__proto,'textureCoordinate1',function(){
		return this._textureCoordinate1;
	});

	__getset(0,__proto,'blendIndex',function(){
		return this._blendIndex;
	});

	__getset(0,__proto,'blendWeight',function(){
		return this._blendWeight;
	});

	__getset(1,VertexPositionNTBTexture0Texture1Skin,'vertexDeclaration',function(){
		return VertexPositionNTBTexture0Texture1Skin._vertexDeclaration;
	});

	__static(VertexPositionNTBTexture0Texture1Skin,
	['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(96,[
		new VertexElement(0,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.POSITION0*/0),
		new VertexElement(12,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.NORMAL0*/3),
		new VertexElement(24,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.TANGENT0*/5),
		new VertexElement(36,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.BINORMAL0*/4),
		new VertexElement(48,/*laya.d3.graphics.VertexElementFormat.Vector2*/"vector2",/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE0*/2),
		new VertexElement(56,/*laya.d3.graphics.VertexElementFormat.Vector2*/"vector2",/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE1*/15),
		new VertexElement(64,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.BLENDWEIGHT0*/7),
		new VertexElement(80,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.BLENDINDICES0*/6)]);}
	]);
	return VertexPositionNTBTexture0Texture1Skin;
})()


/**
*<code>VertexPositionNormalTexture</code> 类用于创建位置、法线、纹理顶点结构。
*/
//class laya.d3.graphics.VertexPositionNTBTextureSkin
var VertexPositionNTBTextureSkin=(function(){
	function VertexPositionNTBTextureSkin(position,normal,textureCoordinate){
		this._position=null;
		this._normal=null;
		this._textureCoordinate=null;
		this._position=position;
		this._normal=normal;
		this._textureCoordinate=textureCoordinate;
	}

	__class(VertexPositionNTBTextureSkin,'laya.d3.graphics.VertexPositionNTBTextureSkin');
	var __proto=VertexPositionNTBTextureSkin.prototype;
	Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
	__getset(0,__proto,'textureCoordinate',function(){
		return this._textureCoordinate;
	});

	__getset(0,__proto,'normal',function(){
		return this._normal;
	});

	__getset(0,__proto,'position',function(){
		return this._position;
	});

	__getset(0,__proto,'vertexDeclaration',function(){
		return VertexPositionNTBTextureSkin._vertexDeclaration;
	});

	__getset(1,VertexPositionNTBTextureSkin,'vertexDeclaration',function(){
		return VertexPositionNTBTextureSkin._vertexDeclaration;
	});

	__static(VertexPositionNTBTextureSkin,
	['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(88,[
		new VertexElement(0,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.POSITION0*/0),
		new VertexElement(12,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.NORMAL0*/3),
		new VertexElement(24,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.TANGENT0*/5),
		new VertexElement(36,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.BINORMAL0*/4),
		new VertexElement(48,/*laya.d3.graphics.VertexElementFormat.Vector2*/"vector2",/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE0*/2),
		new VertexElement(56,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.BLENDWEIGHT0*/7),
		new VertexElement(72,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.BLENDINDICES0*/6)]);}
	]);
	return VertexPositionNTBTextureSkin;
})()


/**
*<code>VertexPositionTerrain</code> 类用于创建位置、法线、纹理1、纹理2顶点结构。
*/
//class laya.d3.graphics.VertexPositionTerrain
var VertexPositionTerrain=(function(){
	function VertexPositionTerrain(position,normal,textureCoord0,textureCoord1){
		this._position=null;
		this._normal=null;
		this._textureCoord0=null;
		this._textureCoord1=null;
		this._position=position;
		this._normal=normal;
		this._textureCoord0=textureCoord0;
		this._textureCoord1=textureCoord1;
	}

	__class(VertexPositionTerrain,'laya.d3.graphics.VertexPositionTerrain');
	var __proto=VertexPositionTerrain.prototype;
	Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
	__getset(0,__proto,'normal',function(){
		return this._normal;
	});

	__getset(0,__proto,'position',function(){
		return this._position;
	});

	__getset(0,__proto,'textureCoord0',function(){
		return this._textureCoord0;
	});

	__getset(0,__proto,'textureCoord1',function(){
		return this._textureCoord1;
	});

	__getset(0,__proto,'vertexDeclaration',function(){
		return VertexPositionTerrain._vertexDeclaration;
	});

	__getset(1,VertexPositionTerrain,'vertexDeclaration',function(){
		return VertexPositionTerrain._vertexDeclaration;
	});

	__static(VertexPositionTerrain,
	['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(40,[
		new VertexElement(0,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.POSITION0*/0),
		new VertexElement(12,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.NORMAL0*/3),
		new VertexElement(24,/*laya.d3.graphics.VertexElementFormat.Vector2*/"vector2",/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE0*/2),
		new VertexElement(32,/*laya.d3.graphics.VertexElementFormat.Vector2*/"vector2",/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE1*/15)]);}
	]);
	return VertexPositionTerrain;
})()


/**
*<code>VertexPositionNormalTexture</code> 类用于创建位置、纹理顶点结构。
*/
//class laya.d3.graphics.VertexPositionTexture0
var VertexPositionTexture0=(function(){
	function VertexPositionTexture0(position,textureCoordinate0){
		this._position=null;
		this._textureCoordinate0=null;
		this._position=position;
		this._textureCoordinate0=textureCoordinate0;
	}

	__class(VertexPositionTexture0,'laya.d3.graphics.VertexPositionTexture0');
	var __proto=VertexPositionTexture0.prototype;
	Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
	__getset(0,__proto,'position',function(){
		return this._position;
	});

	__getset(0,__proto,'textureCoordinate0',function(){
		return this._textureCoordinate0;
	});

	__getset(0,__proto,'vertexDeclaration',function(){
		return VertexPositionTexture0._vertexDeclaration;
	});

	__getset(1,VertexPositionTexture0,'vertexDeclaration',function(){
		return VertexPositionTexture0._vertexDeclaration;
	});

	__static(VertexPositionTexture0,
	['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(20,[
		new VertexElement(0,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.POSITION0*/0),
		new VertexElement(12,/*laya.d3.graphics.VertexElementFormat.Vector2*/"vector2",/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE0*/2)]);}
	]);
	return VertexPositionTexture0;
})()


/**
*<code>VertexShurikenParticle</code> 类用于创建粒子顶点结构。
*/
//class laya.d3.graphics.VertexShurikenParticleBillboard
var VertexShurikenParticleBillboard=(function(){
	function VertexShurikenParticleBillboard(cornerTextureCoordinate,positionStartLifeTime,velocity,startColor,startSize,startRotation0,startRotation1,startRotation2,ageAddScale,time,startSpeed,randoms0,randoms1,simulationWorldPostion){
		/**@private */
		this._cornerTextureCoordinate=null;
		/**@private */
		this._positionStartLifeTime=null;
		/**@private */
		this._velocity=null;
		/**@private */
		this._startColor=null;
		/**@private */
		this._startSize=null;
		/**@private */
		this._startRotation0=null;
		/**@private */
		this._startRotation1=null;
		/**@private */
		this._startRotation2=null;
		/**@private */
		this._startLifeTime=NaN;
		/**@private */
		this._time=NaN;
		/**@private */
		this._startSpeed=NaN;
		/**@private */
		this._randoms0=null;
		/**@private */
		this._randoms1=null;
		/**@private */
		this._simulationWorldPostion=null;
		this._cornerTextureCoordinate=cornerTextureCoordinate;
		this._positionStartLifeTime=positionStartLifeTime;
		this._velocity=velocity;
		this._startColor=startColor;
		this._startSize=startSize;
		this._startRotation0=startRotation0;
		this._startRotation1=startRotation1;
		this._startRotation2=startRotation2;
		this._startLifeTime=ageAddScale;
		this._time=time;
		this._startSpeed=startSpeed;
		this._randoms0=this.random0;
		this._randoms1=this.random1;
		this._simulationWorldPostion=simulationWorldPostion;
	}

	__class(VertexShurikenParticleBillboard,'laya.d3.graphics.VertexShurikenParticleBillboard');
	var __proto=VertexShurikenParticleBillboard.prototype;
	Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
	__getset(0,__proto,'cornerTextureCoordinate',function(){
		return this._cornerTextureCoordinate;
	});

	__getset(0,__proto,'random1',function(){
		return this._randoms1;
	});

	__getset(0,__proto,'startRotation2',function(){
		return this._startRotation2;
	});

	__getset(0,__proto,'positionStartLifeTime',function(){
		return this._positionStartLifeTime;
	});

	__getset(0,__proto,'velocity',function(){
		return this._velocity;
	});

	__getset(0,__proto,'random0',function(){
		return this._randoms0;
	});

	__getset(0,__proto,'startSize',function(){
		return this._startSize;
	});

	__getset(0,__proto,'startColor',function(){
		return this._startColor;
	});

	__getset(0,__proto,'startRotation0',function(){
		return this._startRotation0;
	});

	__getset(0,__proto,'startRotation1',function(){
		return this._startRotation1;
	});

	__getset(0,__proto,'startLifeTime',function(){
		return this._startLifeTime;
	});

	__getset(0,__proto,'time',function(){
		return this._time;
	});

	__getset(0,__proto,'startSpeed',function(){
		return this._startSpeed;
	});

	__getset(0,__proto,'simulationWorldPostion',function(){
		return this._simulationWorldPostion;
	});

	__getset(0,__proto,'vertexDeclaration',function(){
		return VertexShurikenParticleBillboard._vertexDeclaration;
	});

	__getset(1,VertexShurikenParticleBillboard,'vertexDeclaration',function(){
		return VertexShurikenParticleBillboard._vertexDeclaration;
	});

	__static(VertexShurikenParticleBillboard,
	['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(152,[
		new VertexElement(0,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.CORNERTEXTURECOORDINATE0*/17),
		new VertexElement(16,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.SHAPEPOSITIONSTARTLIFETIME*/30),
		new VertexElement(32,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.DIRECTIONTIME*/32),
		new VertexElement(48,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.STARTCOLOR0*/19),
		new VertexElement(64,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.STARTSIZE*/20),
		new VertexElement(76,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.STARTROTATION*/22),
		new VertexElement(88,/*laya.d3.graphics.VertexElementFormat.Single*/"single",/*laya.d3.graphics.VertexElementUsage.STARTSPEED*/31),
		new VertexElement(92,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.RANDOM0*/34),
		new VertexElement(108,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.RANDOM1*/35),
		new VertexElement(124,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.SIMULATIONWORLDPOSTION*/36),
		new VertexElement(136,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.SIMULATIONWORLDROTATION*/37)]);}
	]);
	return VertexShurikenParticleBillboard;
})()


/**
*<code>VertexShurikenParticle</code> 类用于创建粒子顶点结构。
*/
//class laya.d3.graphics.VertexShurikenParticleMesh
var VertexShurikenParticleMesh=(function(){
	function VertexShurikenParticleMesh(cornerTextureCoordinate,positionStartLifeTime,velocity,startColor,startSize,startRotation0,startRotation1,startRotation2,ageAddScale,time,startSpeed,randoms0,randoms1,simulationWorldPostion){
		/**@private */
		this._cornerTextureCoordinate=null;
		/**@private */
		this._positionStartLifeTime=null;
		/**@private */
		this._velocity=null;
		/**@private */
		this._startColor=null;
		/**@private */
		this._startSize=null;
		/**@private */
		this._startRotation0=null;
		/**@private */
		this._startRotation1=null;
		/**@private */
		this._startRotation2=null;
		/**@private */
		this._startLifeTime=NaN;
		/**@private */
		this._time=NaN;
		/**@private */
		this._startSpeed=NaN;
		/**@private */
		this._randoms0=null;
		/**@private */
		this._randoms1=null;
		/**@private */
		this._simulationWorldPostion=null;
		this._cornerTextureCoordinate=cornerTextureCoordinate;
		this._positionStartLifeTime=positionStartLifeTime;
		this._velocity=velocity;
		this._startColor=startColor;
		this._startSize=startSize;
		this._startRotation0=startRotation0;
		this._startRotation1=startRotation1;
		this._startRotation2=startRotation2;
		this._startLifeTime=ageAddScale;
		this._time=time;
		this._startSpeed=startSpeed;
		this._randoms0=this.random0;
		this._randoms1=this.random1;
		this._simulationWorldPostion=simulationWorldPostion;
	}

	__class(VertexShurikenParticleMesh,'laya.d3.graphics.VertexShurikenParticleMesh');
	var __proto=VertexShurikenParticleMesh.prototype;
	Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
	__getset(0,__proto,'cornerTextureCoordinate',function(){
		return this._cornerTextureCoordinate;
	});

	__getset(0,__proto,'velocity',function(){
		return this._velocity;
	});

	__getset(0,__proto,'position',function(){
		return this._positionStartLifeTime;
	});

	__getset(0,__proto,'random0',function(){
		return this._randoms0;
	});

	__getset(0,__proto,'startSize',function(){
		return this._startSize;
	});

	__getset(0,__proto,'startColor',function(){
		return this._startColor;
	});

	__getset(0,__proto,'startRotation0',function(){
		return this._startRotation0;
	});

	__getset(0,__proto,'startRotation1',function(){
		return this._startRotation1;
	});

	__getset(0,__proto,'random1',function(){
		return this._randoms1;
	});

	__getset(0,__proto,'startRotation2',function(){
		return this._startRotation2;
	});

	__getset(0,__proto,'startLifeTime',function(){
		return this._startLifeTime;
	});

	__getset(0,__proto,'time',function(){
		return this._time;
	});

	__getset(0,__proto,'startSpeed',function(){
		return this._startSpeed;
	});

	__getset(0,__proto,'simulationWorldPostion',function(){
		return this._simulationWorldPostion;
	});

	__getset(0,__proto,'vertexDeclaration',function(){
		return VertexShurikenParticleMesh._vertexDeclaration;
	});

	__getset(1,VertexShurikenParticleMesh,'vertexDeclaration',function(){
		return VertexShurikenParticleMesh._vertexDeclaration;
	});

	__static(VertexShurikenParticleMesh,
	['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(172,[
		new VertexElement(0,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.POSITION0*/0),
		new VertexElement(12,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.COLOR0*/1),
		new VertexElement(28,/*laya.d3.graphics.VertexElementFormat.Vector2*/"vector2",/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE0*/2),
		new VertexElement(36,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.SHAPEPOSITIONSTARTLIFETIME*/30),
		new VertexElement(52,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.DIRECTIONTIME*/32),
		new VertexElement(68,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.STARTCOLOR0*/19),
		new VertexElement(84,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.STARTSIZE*/20),
		new VertexElement(96,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.STARTROTATION*/22),
		new VertexElement(108,/*laya.d3.graphics.VertexElementFormat.Single*/"single",/*laya.d3.graphics.VertexElementUsage.STARTSPEED*/31),
		new VertexElement(112,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.RANDOM0*/34),
		new VertexElement(128,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.RANDOM1*/35),
		new VertexElement(144,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.SIMULATIONWORLDPOSTION*/36),
		new VertexElement(156,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.SIMULATIONWORLDROTATION*/37)]);}
	]);
	return VertexShurikenParticleMesh;
})()


/**
*@private
*<code>LoadModel</code> 类用于模型加载。
*/
//class laya.d3.loaders.LoadModelV01
var LoadModelV01=(function(){
	function LoadModelV01(readData,version,mesh,materials,subMeshes,materialMap){
		/**@private */
		this._version=null;
		/**@private */
		this._strings=['BLOCK','DATA',"STRINGS"];
		/**@private */
		this._materials=null;
		/**@private */
		this._subMeshes=null;
		/**@private */
		this._materialMap=null;
		/**@private */
		this._readData=null;
		/**@private */
		this._mesh=null;
		/**@private */
		this._BLOCK={count:0};
		/**@private */
		this._DATA={offset:0,size:0};
		/**@private */
		this._STRINGS={offset:0,size:0};
		/**@private */
		this._shaderAttributes=null;
		this._mesh=mesh;
		this._materials=materials;
		this._subMeshes=subMeshes;
		this._materialMap=materialMap;
		this._version=version;
		this._onLoaded(readData);
	}

	__class(LoadModelV01,'laya.d3.loaders.LoadModelV01');
	var __proto=LoadModelV01.prototype;
	/**
	*@private
	*/
	__proto._onLoaded=function(readData){
		this._readData=readData;
		this.READ_BLOCK();
		for (var i=0;i < this._BLOCK.count;i++){
			var index=this._readData.getUint16();
			var blockName=this._strings[index];
			var fn=this["READ_"+blockName];
			if (fn==null)throw new Error("model file err,no this function:"+index+" "+blockName);
			if (!fn.call(this))break ;
		}
		return this._mesh;
	}

	__proto.onError=function(){}
	/**
	*@private
	*/
	__proto._readString=function(){
		return this._strings[this._readData.getUint16()];
	}

	__proto.READ_BLOCK=function(){
		var n=this._readData.getUint16();
		this._BLOCK.count=this._readData.getUint16();
		return true;
	}

	__proto.READ_DATA=function(){
		this._DATA.offset=this._readData.getUint32();
		this._DATA.size=this._readData.getUint32();
		return true;
	}

	__proto.READ_STRINGS=function(){
		this._STRINGS.offset=this._readData.getUint16();
		this._STRINGS.size=this._readData.getUint16();
		var ofs=this._readData.pos;
		this._readData.pos=this._STRINGS.offset+this._DATA.offset;
		for (var i=0;i < this._STRINGS.size;i++){
			this._strings[i]=this._readData.readUTFString();
		}
		this._readData.pos=ofs;
		return true;
	}

	__proto.READ_MATERIAL=function(){
		var i=0,n=0;
		var index=this._readData.getUint16();
		var shaderName=this._readString();
		var url=this._readString();
		if (url!=="null")
			this._materials[index]=Loader.getRes(this._materialMap[url]);
		else
		this._materials[index]=new BaseMaterial();
		return true;
	}

	__proto.READ_MESH=function(){
		var name=this._readString();
		switch (this._version){
			case "LAYAMODEL:01":
				console.log("Warning: The (.lm) file is converted by old fbxTools,please reConverted it use  lastest fbxTools version,later we will remove the  support of old version (.lm) support.");
				break ;
			case "LAYASKINANI:01":
			case "LAYAMODEL:02":;
				var arrayBuffer=this._readData.__getBuffer();
				var i=0,n=0;
				var bindPoseStart=this._readData.getUint32();
				var binPoseLength=this._readData.getUint32();
				var bindPoseDatas=new Float32Array(arrayBuffer.slice(bindPoseStart+this._DATA.offset,bindPoseStart+this._DATA.offset+binPoseLength));
				var inverseGlobalBindPoseStart=this._readData.getUint32();
				var inverseGlobalBinPoseLength=this._readData.getUint32();
				var invGloBindPoseDatas=new Float32Array(arrayBuffer.slice(inverseGlobalBindPoseStart+this._DATA.offset,inverseGlobalBindPoseStart+this._DATA.offset+inverseGlobalBinPoseLength));
				this.mesh._inverseBindPoses=[];
				for (i=0,n=invGloBindPoseDatas.length;i < n;i+=16){
					var inverseGlobalBindPose=new Matrix4x4(invGloBindPoseDatas[i+0],invGloBindPoseDatas[i+1],invGloBindPoseDatas[i+2],invGloBindPoseDatas[i+3],invGloBindPoseDatas[i+4],invGloBindPoseDatas[i+5],invGloBindPoseDatas[i+6],invGloBindPoseDatas[i+7],invGloBindPoseDatas[i+8],invGloBindPoseDatas[i+9],invGloBindPoseDatas[i+10],invGloBindPoseDatas[i+11],invGloBindPoseDatas[i+12],invGloBindPoseDatas[i+13],invGloBindPoseDatas[i+14],invGloBindPoseDatas[i+15]);
					this.mesh._inverseBindPoses.push(inverseGlobalBindPose);
				}
				break ;
			default :
				throw new Error("LoadModel:unknown version.");
			}
		return true;
	}

	__proto.READ_SUBMESH=function(){
		var className=this._readString();
		var material=this._readData.getUint8();
		var bufferAttribute=this._readString();
		this._shaderAttributes=bufferAttribute.match(LoadModelV01._attrReg);
		var ibofs=this._readData.getUint32();
		var ibsize=this._readData.getUint32();
		var vbIndicesofs=this._readData.getUint32();
		var vbIndicessize=this._readData.getUint32();
		var vbofs=this._readData.getUint32();
		var vbsize=this._readData.getUint32();
		var boneDicofs=this._readData.getUint32();
		var boneDicsize=this._readData.getUint32();
		var arrayBuffer=this._readData.__getBuffer();
		var submesh=new SubMesh(this._mesh);
		var vertexDeclaration=this._getVertexDeclaration();
		var vb=VertexBuffer3D.create(vertexDeclaration,vbsize / vertexDeclaration.vertexStride,/*laya.webgl.WebGLContext.STATIC_DRAW*/0x88E4,true);
		var vbStart=vbofs+this._DATA.offset;
		var vbArrayBuffer=arrayBuffer.slice(vbStart,vbStart+vbsize);
		vb.setData(new Float32Array(vbArrayBuffer));
		submesh._vertexBuffer=vb;
		var vertexElements=vb.vertexDeclaration.getVertexElements();
		for (var i=0;i < vertexElements.length;i++)
		submesh._bufferUsage[(vertexElements [i]).elementUsage]=vb;
		var ib=IndexBuffer3D.create(/*laya.d3.graphics.IndexBuffer3D.INDEXTYPE_USHORT*/"ushort",ibsize / 2,/*laya.webgl.WebGLContext.STATIC_DRAW*/0x88E4,true);
		var ibStart=ibofs+this._DATA.offset;
		var ibArrayBuffer=arrayBuffer.slice(ibStart,ibStart+ibsize);
		ib.setData(new Uint16Array(ibArrayBuffer));
		submesh._indexBuffer=ib;
		var boneDicArrayBuffer=arrayBuffer.slice(boneDicofs+this._DATA.offset,boneDicofs+this._DATA.offset+boneDicsize);
		submesh._boneIndicesList[0]=new Uint8Array(boneDicArrayBuffer);
		this._subMeshes.push(submesh);
		return true;
	}

	__proto.READ_DATAAREA=function(){
		return false;
	}

	__proto._getVertexDeclaration=function(){
		var position=false,normal=false,color=false,texcoord0=false,texcoord1=false,tangent=false,blendWeight=false,blendIndex=false;
		var binormal=false;
		for (var i=0;i < this._shaderAttributes.length;i+=8){
			switch (this._shaderAttributes[i]){
				case "POSITION":
					position=true;
					break ;
				case "NORMAL":
					normal=true;
					break ;
				case "COLOR":
					color=true;
					break ;
				case "UV":
					texcoord0=true;
					break ;
				case "UV1":
					texcoord1=true;
					break ;
				case "BLENDWEIGHT":
					blendWeight=true;
					break ;
				case "BLENDINDICES":
					blendIndex=true;
					break ;
				case "TANGENT":
					tangent=true;
					break ;
				case "BINORMAL":
					binormal=true;
					break ;
				}
		};
		var vertexDeclaration;
		if (position && normal && color && texcoord0 && texcoord1 && blendWeight && blendIndex && tangent)
			vertexDeclaration=VertexPositionNormalColorTexture0Texture1SkinTangent.vertexDeclaration;
		else if (position && normal && color && texcoord0 && texcoord1 && blendWeight && blendIndex)
		vertexDeclaration=VertexPositionNormalColorTexture0Texture1Skin.vertexDeclaration;
		else if (position && normal && texcoord0 && texcoord1 && blendWeight && blendIndex && tangent)
		vertexDeclaration=VertexPositionNormalTexture0Texture1SkinTangent.vertexDeclaration;
		else if (position && normal && texcoord0 && texcoord1 && blendWeight && blendIndex)
		vertexDeclaration=VertexPositionNormalTexture0Texture1Skin.vertexDeclaration;
		else if (position && normal && color && texcoord0 && blendWeight && blendIndex && tangent)
		vertexDeclaration=VertexPositionNormalColorTextureSkinTangent.vertexDeclaration;
		else if (position && normal && color && texcoord0 && blendWeight && blendIndex)
		vertexDeclaration=VertexPositionNormalColorTextureSkin.vertexDeclaration;
		else if (position && normal && tangent && binormal && texcoord0 && blendWeight && blendIndex)
		vertexDeclaration=VertexPositionNTBTextureSkin.vertexDeclaration;
		else if (position && normal && texcoord0 && blendWeight && blendIndex && tangent)
		vertexDeclaration=VertexPositionNormalTextureSkinTangent.vertexDeclaration;
		else if (position && normal && texcoord0 && blendWeight && blendIndex)
		vertexDeclaration=VertexPositionNormalTextureSkin.vertexDeclaration;
		else if (position && normal && color && blendWeight && blendIndex && tangent)
		vertexDeclaration=VertexPositionNormalColorSkinTangent.vertexDeclaration;
		else if (position && normal && color && blendWeight && blendIndex)
		vertexDeclaration=VertexPositionNormalColorSkin.vertexDeclaration;
		else if (position && normal && color && texcoord0 && texcoord1 && tangent)
		vertexDeclaration=VertexPositionNormalColorTexture0Texture1Tangent.vertexDeclaration;
		else if (position && normal && color && texcoord0 && texcoord1)
		vertexDeclaration=VertexPositionNormalColorTexture0Texture1.vertexDeclaration;
		else if (position && normal && texcoord0 && texcoord1 && tangent)
		vertexDeclaration=VertexPositionNormalTexture0Texture1Tangent.vertexDeclaration;
		else if (position && normal && texcoord0 && texcoord1)
		vertexDeclaration=VertexPositionNormalTexture0Texture1.vertexDeclaration;
		else if (position && normal && color && texcoord0 && tangent)
		vertexDeclaration=VertexPositionNormalColorTextureTangent.vertexDeclaration;
		else if (position && normal && texcoord0 && tangent && binormal)
		vertexDeclaration=VertexPositionNTBTexture.vertexDeclaration;
		else if (position && normal && color && texcoord0)
		vertexDeclaration=VertexPositionNormalColorTexture.vertexDeclaration;
		else if (position && normal && texcoord0 && tangent)
		vertexDeclaration=VertexPositionNormalTextureTangent.vertexDeclaration;
		else if (position && normal && texcoord0)
		vertexDeclaration=VertexPositionNormalTexture.vertexDeclaration;
		else if (position && normal && color && tangent)
		vertexDeclaration=VertexPositionNormalColorTangent.vertexDeclaration;
		else if (position && normal && color)
		vertexDeclaration=VertexPositionNormalColor.vertexDeclaration;
		return vertexDeclaration;
	}

	__getset(0,__proto,'mesh',function(){
		return this._mesh;
	});

	LoadModelV01._attrReg=new RegExp("(\\w+)|([:,;])","g");
	return LoadModelV01;
})()


/**
*@private
*<code>LoadModel</code> 类用于模型加载。
*/
//class laya.d3.loaders.LoadModelV02
var LoadModelV02=(function(){
	function LoadModelV02(){}
	__class(LoadModelV02,'laya.d3.loaders.LoadModelV02');
	LoadModelV02.parse=function(readData,version,mesh,materials,subMeshes,materialMap){
		LoadModelV02._mesh=mesh;
		LoadModelV02._materials=materials;
		LoadModelV02._subMeshes=subMeshes;
		LoadModelV02._materialMap=materialMap;
		LoadModelV02._version=version;
		LoadModelV02._readData=readData;
		LoadModelV02.READ_DATA();
		LoadModelV02.READ_BLOCK();
		LoadModelV02.READ_STRINGS();
		for (var i=0,n=LoadModelV02._BLOCK.count;i < n;i++){
			LoadModelV02._readData.pos=LoadModelV02._BLOCK.blockStarts[i];
			var index=LoadModelV02._readData.getUint16();
			var blockName=LoadModelV02._strings[index];
			var fn=LoadModelV02["READ_"+blockName];
			if (fn==null)
				throw new Error("model file err,no this function:"+index+" "+blockName);
			else
			fn.call();
		}
		LoadModelV02._strings.length=0;
		LoadModelV02._readData=null;
		LoadModelV02._version=null;
		LoadModelV02._mesh=null;
		LoadModelV02._materials=null;
		LoadModelV02._subMeshes=null;
		LoadModelV02._materialMap=null;
	}

	LoadModelV02._readString=function(){
		return LoadModelV02._strings[LoadModelV02._readData.getUint16()];
	}

	LoadModelV02.READ_DATA=function(){
		LoadModelV02._DATA.offset=LoadModelV02._readData.getUint32();
		LoadModelV02._DATA.size=LoadModelV02._readData.getUint32();
	}

	LoadModelV02.READ_BLOCK=function(){
		var count=LoadModelV02._BLOCK.count=LoadModelV02._readData.getUint16();
		var blockStarts=LoadModelV02._BLOCK.blockStarts=[];
		var blockLengths=LoadModelV02._BLOCK.blockLengths=[];
		for (var i=0;i < count;i++){
			blockStarts.push(LoadModelV02._readData.getUint32());
			blockLengths.push(LoadModelV02._readData.getUint32());
		}
	}

	LoadModelV02.READ_STRINGS=function(){
		var offset=LoadModelV02._readData.getUint32();
		var count=LoadModelV02._readData.getUint16();
		var prePos=LoadModelV02._readData.pos;
		LoadModelV02._readData.pos=offset+LoadModelV02._DATA.offset;
		for (var i=0;i < count;i++)
		LoadModelV02._strings[i]=LoadModelV02._readData.readUTFString();
		LoadModelV02._readData.pos=prePos;
	}

	LoadModelV02.READ_MATERIAL=function(){
		var i=0,n=0;
		var clasName=LoadModelV02._readString();
		var shaderName=LoadModelV02._readString();
		var url=LoadModelV02._readString();
		if (url!=="")
			LoadModelV02._materials.push(Loader.getRes(LoadModelV02._materialMap[url]));
		return true;
	}

	LoadModelV02.READ_MESH=function(){
		var name=LoadModelV02._readString();
		var arrayBuffer=LoadModelV02._readData.__getBuffer();
		var i=0,n=0;
		var vertexBufferCount=LoadModelV02._readData.getInt16();
		var offset=LoadModelV02._DATA.offset;
		for (i=0;i < vertexBufferCount;i++){
			var vbStart=offset+LoadModelV02._readData.getUint32();
			var vbLength=LoadModelV02._readData.getUint32();
			var vbDatas=new Float32Array(arrayBuffer.slice(vbStart,vbStart+vbLength));
			var bufferAttribute=LoadModelV02._readString();
			var shaderAttributes=bufferAttribute.match(LoadModelV02._attrReg);
			var vertexDeclaration=LoadModelV02._getVertexDeclaration(shaderAttributes);
			var vertexBuffer=VertexBuffer3D.create(vertexDeclaration,(vbDatas.length *4)/ vertexDeclaration.vertexStride,/*laya.webgl.WebGLContext.STATIC_DRAW*/0x88E4,true);
			vertexBuffer.setData(vbDatas);
			LoadModelV02._mesh._vertexBuffers.push(vertexBuffer);
		};
		var ibStart=offset+LoadModelV02._readData.getUint32();
		var ibLength=LoadModelV02._readData.getUint32();
		var ibDatas=new Uint16Array(arrayBuffer.slice(ibStart,ibStart+ibLength));
		var indexBuffer=IndexBuffer3D.create(/*laya.d3.graphics.IndexBuffer3D.INDEXTYPE_USHORT*/"ushort",ibLength / 2,/*laya.webgl.WebGLContext.STATIC_DRAW*/0x88E4,true);
		indexBuffer.setData(ibDatas);
		LoadModelV02._mesh._indexBuffer=indexBuffer;
		var boneNames=LoadModelV02._mesh._boneNames=[];
		var boneCount=LoadModelV02._readData.getUint16();
		boneNames.length=boneCount;
		for (i=0;i < boneCount;i++)
		boneNames[i]=LoadModelV02._strings[LoadModelV02._readData.getUint16()];
		var bindPoseStart=LoadModelV02._readData.getUint32();
		var binPoseLength=LoadModelV02._readData.getUint32();
		var bindPoseDatas=new Float32Array(arrayBuffer.slice(offset+bindPoseStart,offset+bindPoseStart+binPoseLength));
		var inverseGlobalBindPoseStart=LoadModelV02._readData.getUint32();
		var inverseGlobalBinPoseLength=LoadModelV02._readData.getUint32();
		var invGloBindPoseDatas=new Float32Array(arrayBuffer.slice(offset+inverseGlobalBindPoseStart,offset+inverseGlobalBindPoseStart+inverseGlobalBinPoseLength));
		LoadModelV02._mesh._inverseBindPoses=[];
		for (i=0,n=invGloBindPoseDatas.length;i < n;i+=16){
			var inverseGlobalBindPose=new Matrix4x4(invGloBindPoseDatas[i+0],invGloBindPoseDatas[i+1],invGloBindPoseDatas[i+2],invGloBindPoseDatas[i+3],invGloBindPoseDatas[i+4],invGloBindPoseDatas[i+5],invGloBindPoseDatas[i+6],invGloBindPoseDatas[i+7],invGloBindPoseDatas[i+8],invGloBindPoseDatas[i+9],invGloBindPoseDatas[i+10],invGloBindPoseDatas[i+11],invGloBindPoseDatas[i+12],invGloBindPoseDatas[i+13],invGloBindPoseDatas[i+14],invGloBindPoseDatas[i+15]);
			LoadModelV02._mesh._inverseBindPoses.push(inverseGlobalBindPose);
		}
		LoadModelV02._mesh._skinnedDatas=new Float32Array(invGloBindPoseDatas.length*16);
		return true;
	}

	LoadModelV02.READ_SUBMESH=function(){
		var arrayBuffer=LoadModelV02._readData.__getBuffer();
		var submesh=new SubMesh(LoadModelV02._mesh);
		var vbIndex=LoadModelV02._readData.getInt16();
		var vbStart=LoadModelV02._readData.getUint32();
		var vbLength=LoadModelV02._readData.getUint32();
		submesh._vertexBuffer=LoadModelV02._mesh._vertexBuffers[vbIndex];
		submesh._vertexStart=vbStart;
		submesh._vertexCount=vbLength;
		var ibStart=LoadModelV02._readData.getUint32();
		var ibCount=LoadModelV02._readData.getUint32();
		var indexBuffer=LoadModelV02._mesh._indexBuffer;
		submesh._indexBuffer=indexBuffer;
		submesh._indexStart=ibStart;
		submesh._indexCount=ibCount;
		submesh._indices=new Uint16Array(indexBuffer.getData().buffer,ibStart *2,ibCount);
		var offset=LoadModelV02._DATA.offset;
		var subIndexBufferStart=submesh._subIndexBufferStart;
		var subIndexBufferCount=submesh._subIndexBufferCount;
		var boneIndicesList=submesh._boneIndicesList;
		var drawCount=LoadModelV02._readData.getUint16();
		subIndexBufferStart.length=drawCount;
		subIndexBufferCount.length=drawCount;
		boneIndicesList.length=drawCount;
		for (var i=0;i < drawCount;i++){
			subIndexBufferStart[i]=LoadModelV02._readData.getUint32();
			subIndexBufferCount[i]=LoadModelV02._readData.getUint32();
			var boneDicofs=LoadModelV02._readData.getUint32();
			var boneDicsize=LoadModelV02._readData.getUint32();
			submesh._boneIndicesList[i]=new Uint8Array(arrayBuffer.slice(offset+boneDicofs,offset+boneDicofs+boneDicsize));
		}
		LoadModelV02._subMeshes.push(submesh);
		return true;
	}

	LoadModelV02._getVertexDeclaration=function(shaderAttributes){
		var position=false,normal=false,color=false,texcoord0=false,texcoord1=false,tangent=false,blendWeight=false,blendIndex=false;
		var binormal=false;
		for (var i=0;i < shaderAttributes.length;i++){
			switch (shaderAttributes[i]){
				case "POSITION":
					position=true;
					break ;
				case "NORMAL":
					normal=true;
					break ;
				case "COLOR":
					color=true;
					break ;
				case "UV":
					texcoord0=true;
					break ;
				case "UV1":
					texcoord1=true;
					break ;
				case "BLENDWEIGHT":
					blendWeight=true;
					break ;
				case "BLENDINDICES":
					blendIndex=true;
					break ;
				case "TANGENT":
					tangent=true;
					break ;
				case "BINORMAL":
					binormal=true;
					break ;
				}
		};
		var vertexDeclaration;
		if (position && normal && color && texcoord0 && texcoord1 && blendWeight && blendIndex && tangent)
			vertexDeclaration=VertexPositionNormalColorTexture0Texture1SkinTangent.vertexDeclaration;
		else if (position && normal && color && texcoord0 && texcoord1 && blendWeight && blendIndex)
		vertexDeclaration=VertexPositionNormalColorTexture0Texture1Skin.vertexDeclaration;
		else if (position && normal && texcoord0 && texcoord1 && blendWeight && blendIndex && tangent)
		vertexDeclaration=VertexPositionNormalTexture0Texture1SkinTangent.vertexDeclaration;
		else if (position && normal && texcoord0 && texcoord1 && blendWeight && blendIndex)
		vertexDeclaration=VertexPositionNormalTexture0Texture1Skin.vertexDeclaration;
		else if (position && normal && color && texcoord0 && blendWeight && blendIndex && tangent)
		vertexDeclaration=VertexPositionNormalColorTextureSkinTangent.vertexDeclaration;
		else if (position && normal && color && texcoord0 && blendWeight && blendIndex)
		vertexDeclaration=VertexPositionNormalColorTextureSkin.vertexDeclaration;
		else if (position && normal && texcoord0 && blendWeight && blendIndex && tangent)
		vertexDeclaration=VertexPositionNormalTextureSkinTangent.vertexDeclaration;
		else if (position && normal && texcoord0 && blendWeight && blendIndex)
		vertexDeclaration=VertexPositionNormalTextureSkin.vertexDeclaration;
		else if (position && normal && color && blendWeight && blendIndex && tangent)
		vertexDeclaration=VertexPositionNormalColorSkinTangent.vertexDeclaration;
		else if (position && normal && color && blendWeight && blendIndex)
		vertexDeclaration=VertexPositionNormalColorSkin.vertexDeclaration;
		else if (position && normal && color && texcoord0 && texcoord1 && tangent)
		vertexDeclaration=VertexPositionNormalColorTexture0Texture1Tangent.vertexDeclaration;
		else if (position && normal && color && texcoord0 && texcoord1)
		vertexDeclaration=VertexPositionNormalColorTexture0Texture1.vertexDeclaration;
		else if (position && normal && texcoord0 && texcoord1 && tangent)
		vertexDeclaration=VertexPositionNormalTexture0Texture1Tangent.vertexDeclaration;
		else if (position && normal && texcoord0 && texcoord1)
		vertexDeclaration=VertexPositionNormalTexture0Texture1.vertexDeclaration;
		else if (position && normal && color && texcoord0 && tangent)
		vertexDeclaration=VertexPositionNormalColorTextureTangent.vertexDeclaration;
		else if (position && normal && texcoord0 && tangent && binormal)
		vertexDeclaration=VertexPositionNTBTexture.vertexDeclaration;
		else if (position && normal && color && texcoord0)
		vertexDeclaration=VertexPositionNormalColorTexture.vertexDeclaration;
		else if (position && normal && texcoord0 && tangent)
		vertexDeclaration=VertexPositionNormalTextureTangent.vertexDeclaration;
		else if (position && normal && texcoord0)
		vertexDeclaration=VertexPositionNormalTexture.vertexDeclaration;
		else if (position && normal && color && tangent)
		vertexDeclaration=VertexPositionNormalColorTangent.vertexDeclaration;
		else if (position && normal && color)
		vertexDeclaration=VertexPositionNormalColor.vertexDeclaration;
		return vertexDeclaration;
	}

	LoadModelV02._attrReg=new RegExp("(\\w+)|([:,;])","g");
	LoadModelV02._strings=[];
	LoadModelV02._readData=null;
	LoadModelV02._version=null;
	LoadModelV02._mesh=null;
	LoadModelV02._materials=null;
	LoadModelV02._subMeshes=null;
	LoadModelV02._materialMap=null;
	__static(LoadModelV02,
	['_BLOCK',function(){return this._BLOCK={count:0};},'_DATA',function(){return this._DATA={offset:0,size:0};}
	]);
	return LoadModelV02;
})()


/**
*@private
*<code>LoadModel</code> 类用于模型加载。
*/
//class laya.d3.loaders.LoadModelV03
var LoadModelV03=(function(){
	function LoadModelV03(){}
	__class(LoadModelV03,'laya.d3.loaders.LoadModelV03');
	LoadModelV03.parse=function(readData,version,mesh,subMeshes,materialMap){
		LoadModelV03._mesh=mesh;
		LoadModelV03._subMeshes=subMeshes;
		LoadModelV03._materialMap=materialMap;
		LoadModelV03._version=version;
		LoadModelV03._readData=readData;
		LoadModelV03.READ_DATA();
		LoadModelV03.READ_BLOCK();
		LoadModelV03.READ_STRINGS();
		for (var i=0,n=LoadModelV03._BLOCK.count;i < n;i++){
			LoadModelV03._readData.pos=LoadModelV03._BLOCK.blockStarts[i];
			var index=LoadModelV03._readData.getUint16();
			var blockName=LoadModelV03._strings[index];
			var fn=LoadModelV03["READ_"+blockName];
			if (fn==null)
				throw new Error("model file err,no this function:"+index+" "+blockName);
			else
			fn.call();
		}
		LoadModelV03._strings.length=0;
		LoadModelV03._readData=null;
		LoadModelV03._version=null;
		LoadModelV03._mesh=null;
		LoadModelV03._subMeshes=null;
		LoadModelV03._materialMap=null;
	}

	LoadModelV03._readString=function(){
		return LoadModelV03._strings[LoadModelV03._readData.getUint16()];
	}

	LoadModelV03.READ_DATA=function(){
		LoadModelV03._DATA.offset=LoadModelV03._readData.getUint32();
		LoadModelV03._DATA.size=LoadModelV03._readData.getUint32();
	}

	LoadModelV03.READ_BLOCK=function(){
		var count=LoadModelV03._BLOCK.count=LoadModelV03._readData.getUint16();
		var blockStarts=LoadModelV03._BLOCK.blockStarts=[];
		var blockLengths=LoadModelV03._BLOCK.blockLengths=[];
		for (var i=0;i < count;i++){
			blockStarts.push(LoadModelV03._readData.getUint32());
			blockLengths.push(LoadModelV03._readData.getUint32());
		}
	}

	LoadModelV03.READ_STRINGS=function(){
		var offset=LoadModelV03._readData.getUint32();
		var count=LoadModelV03._readData.getUint16();
		var prePos=LoadModelV03._readData.pos;
		LoadModelV03._readData.pos=offset+LoadModelV03._DATA.offset;
		for (var i=0;i < count;i++)
		LoadModelV03._strings[i]=LoadModelV03._readData.readUTFString();
		LoadModelV03._readData.pos=prePos;
	}

	LoadModelV03.READ_MESH=function(){
		var name=LoadModelV03._readString();
		var arrayBuffer=LoadModelV03._readData.__getBuffer();
		var i=0,n=0;
		var vertexBufferCount=LoadModelV03._readData.getInt16();
		var offset=LoadModelV03._DATA.offset;
		for (i=0;i < vertexBufferCount;i++){
			var vbStart=offset+LoadModelV03._readData.getUint32();
			var vbLength=LoadModelV03._readData.getUint32();
			var vbDatas=new Float32Array(arrayBuffer.slice(vbStart,vbStart+vbLength));
			var bufferAttribute=LoadModelV03._readString();
			var vertexDeclaration;
			switch(LoadModelV03._version){
				case "LAYAMODEL:03":
					vertexDeclaration=LoadModelV03._vertexDeclarationMap_Discard[bufferAttribute];
					break ;
				case "LAYAMODEL:0301":
					vertexDeclaration=LoadModelV03._vertexDeclarationMap[bufferAttribute];
					break ;
				default :
					throw new Error("LoadModelV03: unknown version.");
				}
			if (!vertexDeclaration)
				throw new Error("LoadModelV03: unknown vertexDeclaration.");
			var vertexBuffer=VertexBuffer3D.create(vertexDeclaration,(vbDatas.length *4)/ vertexDeclaration.vertexStride,/*laya.webgl.WebGLContext.STATIC_DRAW*/0x88E4,true);
			vertexBuffer.setData(vbDatas);
			LoadModelV03._mesh._vertexBuffers.push(vertexBuffer);
		};
		var ibStart=offset+LoadModelV03._readData.getUint32();
		var ibLength=LoadModelV03._readData.getUint32();
		var ibDatas=new Uint16Array(arrayBuffer.slice(ibStart,ibStart+ibLength));
		var indexBuffer=IndexBuffer3D.create(/*laya.d3.graphics.IndexBuffer3D.INDEXTYPE_USHORT*/"ushort",ibLength / 2,/*laya.webgl.WebGLContext.STATIC_DRAW*/0x88E4,true);
		indexBuffer.setData(ibDatas);
		LoadModelV03._mesh._indexBuffer=indexBuffer;
		var boneNames=LoadModelV03._mesh._boneNames=[];
		var boneCount=LoadModelV03._readData.getUint16();
		boneNames.length=boneCount;
		for (i=0;i < boneCount;i++)
		boneNames[i]=LoadModelV03._strings[LoadModelV03._readData.getUint16()];
		LoadModelV03._readData.pos+=8;
		var inverseGlobalBindPoseStart=LoadModelV03._readData.getUint32();
		var inverseGlobalBinPoseLength=LoadModelV03._readData.getUint32();
		var invGloBindPoseDatas=new Float32Array(arrayBuffer.slice(offset+inverseGlobalBindPoseStart,offset+inverseGlobalBindPoseStart+inverseGlobalBinPoseLength));
		LoadModelV03._mesh._inverseBindPoses=[];
		for (i=0,n=invGloBindPoseDatas.length;i < n;i+=16){
			var inverseGlobalBindPose=new Matrix4x4(invGloBindPoseDatas[i+0],invGloBindPoseDatas[i+1],invGloBindPoseDatas[i+2],invGloBindPoseDatas[i+3],invGloBindPoseDatas[i+4],invGloBindPoseDatas[i+5],invGloBindPoseDatas[i+6],invGloBindPoseDatas[i+7],invGloBindPoseDatas[i+8],invGloBindPoseDatas[i+9],invGloBindPoseDatas[i+10],invGloBindPoseDatas[i+11],invGloBindPoseDatas[i+12],invGloBindPoseDatas[i+13],invGloBindPoseDatas[i+14],invGloBindPoseDatas[i+15]);
			LoadModelV03._mesh._inverseBindPoses.push(inverseGlobalBindPose);
		}
		LoadModelV03._mesh._skinnedDatas=new Float32Array(invGloBindPoseDatas.length*16);
		return true;
	}

	LoadModelV03.READ_SUBMESH=function(){
		var arrayBuffer=LoadModelV03._readData.__getBuffer();
		var submesh=new SubMesh(LoadModelV03._mesh);
		var vbIndex=LoadModelV03._readData.getInt16();
		var vbStart=LoadModelV03._readData.getUint32();
		var vbLength=LoadModelV03._readData.getUint32();
		submesh._vertexBuffer=LoadModelV03._mesh._vertexBuffers[vbIndex];
		submesh._vertexStart=vbStart;
		submesh._vertexCount=vbLength;
		var ibStart=LoadModelV03._readData.getUint32();
		var ibCount=LoadModelV03._readData.getUint32();
		var indexBuffer=LoadModelV03._mesh._indexBuffer;
		submesh._indexBuffer=indexBuffer;
		submesh._indexStart=ibStart;
		submesh._indexCount=ibCount;
		submesh._indices=new Uint16Array(indexBuffer.getData().buffer,ibStart *2,ibCount);
		var offset=LoadModelV03._DATA.offset;
		var subIndexBufferStart=submesh._subIndexBufferStart;
		var subIndexBufferCount=submesh._subIndexBufferCount;
		var boneIndicesList=submesh._boneIndicesList;
		var drawCount=LoadModelV03._readData.getUint16();
		subIndexBufferStart.length=drawCount;
		subIndexBufferCount.length=drawCount;
		boneIndicesList.length=drawCount;
		for (var i=0;i < drawCount;i++){
			subIndexBufferStart[i]=LoadModelV03._readData.getUint32();
			subIndexBufferCount[i]=LoadModelV03._readData.getUint32();
			var boneDicofs=LoadModelV03._readData.getUint32();
			var boneDicsize=LoadModelV03._readData.getUint32();
			boneIndicesList[i]=new Uint8Array(arrayBuffer.slice(offset+boneDicofs,offset+boneDicofs+boneDicsize));
		}
		LoadModelV03._subMeshes.push(submesh);
		return true;
	}

	LoadModelV03._strings=[];
	LoadModelV03._readData=null;
	LoadModelV03._version=null;
	LoadModelV03._mesh=null;
	LoadModelV03._subMeshes=null;
	LoadModelV03._materialMap=null;
	__static(LoadModelV03,
	['_vertexDeclarationMap_Discard',function(){return this._vertexDeclarationMap_Discard={
			"POSITION,NORMAL,COLOR,UV,UV1,BLENDWEIGHT,BLENDINDICES,TANGENT":VertexPositionNormalColorTexture0Texture1SkinTangent.vertexDeclaration,
			"POSITION,NORMAL,COLOR,UV,UV1,BLENDWEIGHT,BLENDINDICES":VertexPositionNormalColorTexture0Texture1Skin.vertexDeclaration,
			"POSITION,NORMAL,TANGENT,BINORMAL,UV,UV1,BLENDWEIGHT,BLENDINDICES,":VertexPositionNTBTexture0Texture1Skin.vertexDeclaration,
			"POSITION,NORMAL,UV,UV1,BLENDWEIGHT,BLENDINDICES,TANGENT":VertexPositionNormalTexture0Texture1SkinTangent.vertexDeclaration,
			"POSITION,NORMAL,UV,UV1,BLENDWEIGHT,BLENDINDICES":VertexPositionNormalTexture0Texture1Skin.vertexDeclaration,
			"POSITION,NORMAL,COLOR,UV,BLENDWEIGHT,BLENDINDICES,TANGENT":VertexPositionNormalColorTextureSkinTangent.vertexDeclaration,
			"POSITION,NORMAL,COLOR,UV,BLENDWEIGHT,BLENDINDICES":VertexPositionNormalColorTextureSkin.vertexDeclaration,
			"POSITION,NORMAL,UV,BLENDWEIGHT,BLENDINDICES,TANGENT":VertexPositionNormalTextureSkinTangent.vertexDeclaration,
			"POSITION,NORMAL,UV,BLENDWEIGHT,BLENDINDICES":VertexPositionNormalTextureSkin.vertexDeclaration,
			"POSITION,NORMAL,COLOR,BLENDWEIGHT,BLENDINDICES,TANGENT":VertexPositionNormalColorSkinTangent.vertexDeclaration,
			"POSITION,NORMAL,COLOR,BLENDWEIGHT,BLENDINDICES":VertexPositionNormalColorSkin.vertexDeclaration,
			"POSITION,NORMAL,COLOR,UV,UV1,TANGENT":VertexPositionNormalColorTexture0Texture1Tangent.vertexDeclaration,
			"POSITION,NORMAL,COLOR,UV,UV1":VertexPositionNormalColorTexture0Texture1.vertexDeclaration,
			"POSITION,NORMAL,UV,UV1,TANGENT":VertexPositionNormalTexture0Texture1Tangent.vertexDeclaration,
			"POSITION,NORMAL,UV,UV1":VertexPositionNormalTexture0Texture1.vertexDeclaration,
			"POSITION,NORMAL,COLOR,UV,TANGENT":VertexPositionNormalColorTextureTangent.vertexDeclaration,
			"POSITION,NORMAL,UV,TANGENT,BINORMAL":VertexPositionNTBTexture.vertexDeclaration,
			"POSITION,NORMAL,COLOR,UV":VertexPositionNormalColorTexture.vertexDeclaration,
			"POSITION,NORMAL,UV,TANGENT":VertexPositionNormalTextureTangent.vertexDeclaration,
			"POSITION,NORMAL,UV":VertexPositionNormalTexture.vertexDeclaration,
			"POSITION,NORMAL,COLOR,TANGENT":VertexPositionNormalColorTangent.vertexDeclaration,
			"POSITION,NORMAL,COLOR":VertexPositionNormalColor.vertexDeclaration,
			"POSITION,NORMAL,TANGENT":VertexPositionNormalTangent.vertexDeclaration,
			"POSITION,NORMAL":VertexPositionNormal.vertexDeclaration,
			"POSITION,UV":VertexPositionTexture0.vertexDeclaration,
			"POSITION":VertexPosition.vertexDeclaration};},'_vertexDeclarationMap',function(){return this._vertexDeclarationMap={
			"POSITION,NORMAL,COLOR,UV,UV1,BLENDWEIGHT,BLENDINDICES,TANGENT":VertexPositionNormalColorTexture0Texture1SkinSTangent.vertexDeclaration,
			"POSITION,NORMAL,COLOR,UV,UV1,BLENDWEIGHT,BLENDINDICES":VertexPositionNormalColorTexture0Texture1Skin.vertexDeclaration,
			"POSITION,NORMAL,TANGENT,BINORMAL,UV,UV1,BLENDWEIGHT,BLENDINDICES,":VertexPositionNTBTexture0Texture1Skin.vertexDeclaration,
			"POSITION,NORMAL,UV,UV1,BLENDWEIGHT,BLENDINDICES,TANGENT":VertexPositionNormalTexture0Texture1SkinSTangent.vertexDeclaration,
			"POSITION,NORMAL,UV,UV1,BLENDWEIGHT,BLENDINDICES":VertexPositionNormalTexture0Texture1Skin.vertexDeclaration,
			"POSITION,NORMAL,COLOR,UV,BLENDWEIGHT,BLENDINDICES,TANGENT":VertexPositionNormalColorTextureSkinSTangent.vertexDeclaration,
			"POSITION,NORMAL,COLOR,UV,BLENDWEIGHT,BLENDINDICES":VertexPositionNormalColorTextureSkin.vertexDeclaration,
			"POSITION,NORMAL,UV,BLENDWEIGHT,BLENDINDICES,TANGENT":VertexPositionNormalTextureSkinSTangent.vertexDeclaration,
			"POSITION,NORMAL,UV,BLENDWEIGHT,BLENDINDICES":VertexPositionNormalTextureSkin.vertexDeclaration,
			"POSITION,NORMAL,COLOR,BLENDWEIGHT,BLENDINDICES,TANGENT":VertexPositionNormalColorSkinSTangent.vertexDeclaration,
			"POSITION,NORMAL,COLOR,BLENDWEIGHT,BLENDINDICES":VertexPositionNormalColorSkin.vertexDeclaration,
			"POSITION,NORMAL,COLOR,UV,UV1,TANGENT":VertexPositionNormalColorTexture0Texture1STangent.vertexDeclaration,
			"POSITION,NORMAL,COLOR,UV,UV1":VertexPositionNormalColorTexture0Texture1.vertexDeclaration,
			"POSITION,NORMAL,UV,UV1,TANGENT":VertexPositionNormalTexture0Texture1STangent.vertexDeclaration,
			"POSITION,NORMAL,UV,UV1":VertexPositionNormalTexture0Texture1.vertexDeclaration,
			"POSITION,NORMAL,COLOR,UV,TANGENT":VertexPositionNormalColorTextureSTangent.vertexDeclaration,
			"POSITION,NORMAL,UV,TANGENT,BINORMAL":VertexPositionNTBTexture.vertexDeclaration,
			"POSITION,NORMAL,COLOR,UV":VertexPositionNormalColorTexture.vertexDeclaration,
			"POSITION,NORMAL,UV,TANGENT":VertexPositionNormalTextureSTangent.vertexDeclaration,
			"POSITION,NORMAL,UV":VertexPositionNormalTexture.vertexDeclaration,
			"POSITION,NORMAL,COLOR,TANGENT":VertexPositionNormalColorSTangent.vertexDeclaration,
			"POSITION,NORMAL,COLOR":VertexPositionNormalColor.vertexDeclaration,
			"POSITION,NORMAL,TANGENT":VertexPositionNormalSTangent.vertexDeclaration,
			"POSITION,NORMAL":VertexPositionNormal.vertexDeclaration,
			"POSITION,UV":VertexPositionTexture0.vertexDeclaration,
			"POSITION":VertexPosition.vertexDeclaration};},'_BLOCK',function(){return this._BLOCK={count:0};},'_DATA',function(){return this._DATA={offset:0,size:0};}
	]);
	return LoadModelV03;
})()


/**
*...
*@author ...
*/
//class laya.d3.loaders.MeshReader
var MeshReader=(function(){
	function MeshReader(){}
	__class(MeshReader,'laya.d3.loaders.MeshReader');
	MeshReader.read=function(data,mesh,materials,subMeshes,materialMap){
		var readData=new Byte(data);
		readData.pos=0;
		var version=readData.readUTFString();
		switch (version){
			case "LAYAMODEL:01":
			case "LAYASKINANI:01":
				MeshReader._readVersion01(readData,version,mesh,materials,subMeshes,materialMap);
				break ;
			case "LAYAMODEL:02":
				LoadModelV02.parse(readData,version,mesh,materials,subMeshes,materialMap);
				break ;
			case "LAYAMODEL:03":
			case "LAYAMODEL:0301":
				LoadModelV03.parse(readData,version,mesh,subMeshes,materialMap);
				break ;
			default :
				throw new Error("MeshReader: unknown mesh version.");
			}
		mesh._setSubMeshes(subMeshes);
	}

	MeshReader._readVersion01=function(readData,version,mesh,materials,subMeshes,materialMap){
		new LoadModelV01(readData,version,mesh,materials,subMeshes,materialMap);
	}

	return MeshReader;
})()


/**
*<code>BoundBox</code> 类用于创建包围盒。
*/
//class laya.d3.math.BoundBox
var BoundBox=(function(){
	function BoundBox(min,max){
		/**最小顶点。*/
		this.min=null;
		/**最大顶点。*/
		this.max=null;
		this.min=min;
		this.max=max;
	}

	__class(BoundBox,'laya.d3.math.BoundBox');
	var __proto=BoundBox.prototype;
	Laya.imps(__proto,{"laya.d3.core.IClone":true})
	/**
	*获取包围盒的8个角顶点。
	*@param corners 返回顶点的输出队列。
	*/
	__proto.getCorners=function(corners){
		corners.length=8;
		var mine=this.min.elements;
		var maxe=this.max.elements;
		var minX=mine[0];
		var minY=mine[1];
		var minZ=mine[2];
		var maxX=maxe[0];
		var maxY=maxe[1];
		var maxZ=maxe[2];
		corners[0]=new Vector3(minX,maxY,maxZ);
		corners[1]=new Vector3(maxX,maxY,maxZ);
		corners[2]=new Vector3(maxX,minY,maxZ);
		corners[3]=new Vector3(minX,minY,maxZ);
		corners[4]=new Vector3(minX,maxY,minZ);
		corners[5]=new Vector3(maxX,maxY,minZ);
		corners[6]=new Vector3(maxX,minY,minZ);
		corners[7]=new Vector3(minX,minY,minZ);
	}

	__proto.toDefault=function(){
		this.min.toDefault();
		this.max.toDefault();
	}

	/**
	*克隆。
	*@param destObject 克隆源。
	*/
	__proto.cloneTo=function(destObject){
		var dest=destObject;
		this.min.cloneTo(dest.min);
		this.max.cloneTo(dest.max);
	}

	/**
	*克隆。
	*@return 克隆副本。
	*/
	__proto.clone=function(){
		var dest=/*__JS__ */new this.constructor(new Vector3(),new Vector3());
		this.cloneTo(dest);
		return dest;
	}

	BoundBox.createfromPoints=function(points,out){
		if (points==null)
			throw new Error("points");
		var min=out.min;
		var max=out.max;
		var minE=min.elements;
		minE[0]=Number.MAX_VALUE;
		minE[1]=Number.MAX_VALUE;
		minE[2]=Number.MAX_VALUE;
		var maxE=max.elements;
		maxE[0]=-Number.MAX_VALUE;
		maxE[1]=-Number.MAX_VALUE;
		maxE[2]=-Number.MAX_VALUE;
		for (var i=0,n=points.length;i < n;++i){
			Vector3.min(min,points[i],min);
			Vector3.max(max,points[i],max);
		}
	}

	BoundBox.merge=function(box1,box2,out){
		Vector3.min(box1.min,box2.min,out.min);
		Vector3.max(box1.max,box2.max,out.max);
	}

	return BoundBox;
})()


/**
*<code>BoundFrustum</code> 类用于创建锥截体。
*/
//class laya.d3.math.BoundFrustum
var BoundFrustum=(function(){
	function BoundFrustum(matrix){
		/**4x4矩阵*/
		this._matrix=null;
		/**近平面*/
		this._near=null;
		/**远平面*/
		this._far=null;
		/**左平面*/
		this._left=null;
		/**右平面*/
		this._right=null;
		/**顶平面*/
		this._top=null;
		/**底平面*/
		this._bottom=null;
		this._matrix=matrix;
		this._near=new Plane(new Vector3());
		this._far=new Plane(new Vector3());
		this._left=new Plane(new Vector3());
		this._right=new Plane(new Vector3());
		this._top=new Plane(new Vector3());
		this._bottom=new Plane(new Vector3());
		BoundFrustum._getPlanesFromMatrix(this._matrix,this._near,this._far,this._left,this._right,this._top,this._bottom);
	}

	__class(BoundFrustum,'laya.d3.math.BoundFrustum');
	var __proto=BoundFrustum.prototype;
	/**
	*判断是否与其他锥截体相等。
	*@param other 锥截体。
	*/
	__proto.equalsBoundFrustum=function(other){
		return this._matrix.equalsOtherMatrix(other.matrix)
	}

	/**
	*判断是否与其他对象相等。
	*@param obj 对象。
	*/
	__proto.equalsObj=function(obj){
		if ((obj instanceof laya.d3.math.BoundFrustum )){
			var bf=obj;
			return this.equalsBoundFrustum(bf);
		}
		return false;
	}

	/**
	*获取锥截体的任意一平面。
	*0:近平面
	*1:远平面
	*2:左平面
	*3:右平面
	*4:顶平面
	*5:底平面
	*@param index 索引。
	*/
	__proto.getPlane=function(index){
		switch (index){
			case 0:
				return this._near;
			case 1:
				return this._far;
			case 2:
				return this._left;
			case 3:
				return this._right;
			case 4:
				return this._top;
			case 5:
				return this._bottom;
			default :
				return null;
			}
	}

	/**
	*锥截体的8个顶点。
	*@param corners 返回顶点的输出队列。
	*/
	__proto.getCorners=function(corners){
		BoundFrustum._get3PlaneInterPoint(this._near,this._bottom,this._right).cloneTo(corners[0]);
		BoundFrustum._get3PlaneInterPoint(this._near,this._top,this._right).cloneTo(corners[1]);
		BoundFrustum._get3PlaneInterPoint(this._near,this._top,this._left).cloneTo(corners[2]);
		BoundFrustum._get3PlaneInterPoint(this._near,this._bottom,this._left).cloneTo(corners[3]);
		BoundFrustum._get3PlaneInterPoint(this._far,this._bottom,this._right).cloneTo(corners[4]);
		BoundFrustum._get3PlaneInterPoint(this._far,this._top,this._right).cloneTo(corners[5]);
		BoundFrustum._get3PlaneInterPoint(this._far,this._top,this._left).cloneTo(corners[6]);
		BoundFrustum._get3PlaneInterPoint(this._far,this._bottom,this._left).cloneTo(corners[7]);
	}

	/**
	*与点的位置关系。返回-1,包涵;0,相交;1,不相交
	*@param point 点。
	*/
	__proto.containsPoint=function(point){
		var result=Plane.PlaneIntersectionType_Front;
		var planeResult=Plane.PlaneIntersectionType_Front;
		for (var i=0;i < 6;i++){
			switch (i){
				case 0:
					planeResult=Collision.intersectsPlaneAndPoint(this._near,point);
					break ;
				case 1:
					planeResult=Collision.intersectsPlaneAndPoint(this._far,point);
					break ;
				case 2:
					planeResult=Collision.intersectsPlaneAndPoint(this._left,point);
					break ;
				case 3:
					planeResult=Collision.intersectsPlaneAndPoint(this._right,point);
					break ;
				case 4:
					planeResult=Collision.intersectsPlaneAndPoint(this._top,point);
					break ;
				case 5:
					planeResult=Collision.intersectsPlaneAndPoint(this._bottom,point);
					break ;
				}
			switch (planeResult){
				case Plane.PlaneIntersectionType_Back:
					return /*laya.d3.math.ContainmentType.Disjoint*/0;
				case Plane.PlaneIntersectionType_Intersecting:
					result=Plane.PlaneIntersectionType_Intersecting;
					break ;
				}
		}
		switch (result){
			case Plane.PlaneIntersectionType_Intersecting:
				return /*laya.d3.math.ContainmentType.Intersects*/2;
			default :
				return /*laya.d3.math.ContainmentType.Contains*/1;
			}
	}

	/**
	*与包围盒的位置关系。返回-1,包涵;0,相交;1,不相交
	*@param box 包围盒。
	*/
	__proto.containsBoundBox=function(box){
		var p=BoundFrustum._tempV30,n=BoundFrustum._tempV31;
		var plane;
		var result=/*laya.d3.math.ContainmentType.Contains*/1;
		for (var i=0;i < 6;i++){
			plane=this.getPlane(i);
			this._getBoxToPlanePVertexNVertex(box,plane.normal,p,n);
			if (Collision.intersectsPlaneAndPoint(plane,p)===Plane.PlaneIntersectionType_Back)
				return /*laya.d3.math.ContainmentType.Disjoint*/0;
			if (Collision.intersectsPlaneAndPoint(plane,n)===Plane.PlaneIntersectionType_Back)
				result=/*laya.d3.math.ContainmentType.Intersects*/2;
		}
		return result;
	}

	/**
	*与包围球的位置关系。返回-1,包涵;0,相交;1,不相交
	*@param sphere 包围球。
	*/
	__proto.containsBoundSphere=function(sphere){
		var result=Plane.PlaneIntersectionType_Front;
		var planeResult=Plane.PlaneIntersectionType_Front;
		for (var i=0;i < 6;i++){
			switch (i){
				case 0:
					planeResult=Collision.intersectsPlaneAndSphere(this._near,sphere);
					break ;
				case 1:
					planeResult=Collision.intersectsPlaneAndSphere(this._far,sphere);
					break ;
				case 2:
					planeResult=Collision.intersectsPlaneAndSphere(this._left,sphere);
					break ;
				case 3:
					planeResult=Collision.intersectsPlaneAndSphere(this._right,sphere);
					break ;
				case 4:
					planeResult=Collision.intersectsPlaneAndSphere(this._top,sphere);
					break ;
				case 5:
					planeResult=Collision.intersectsPlaneAndSphere(this._bottom,sphere);
					break ;
				}
			switch (planeResult){
				case Plane.PlaneIntersectionType_Back:
					return /*laya.d3.math.ContainmentType.Disjoint*/0;
				case Plane.PlaneIntersectionType_Intersecting:
					result=Plane.PlaneIntersectionType_Intersecting;
					break ;
				}
		}
		switch (result){
			case Plane.PlaneIntersectionType_Intersecting:
				return /*laya.d3.math.ContainmentType.Intersects*/2;
			default :
				return /*laya.d3.math.ContainmentType.Contains*/1;
			}
	}

	/**
	*@private
	*/
	__proto._getBoxToPlanePVertexNVertex=function(box,planeNormal,outP,outN){
		var boxMin=box.min;
		var boxMinE=boxMin.elements;
		var boxMax=box.max;
		var boxMaxE=boxMax.elements;
		var planeNorE=planeNormal.elements;
		var planeNorEX=planeNorE[0];
		var planeNorEY=planeNorE[1];
		var planeNorEZ=planeNorE[2];
		boxMin.cloneTo(outP);;
		var outPE=outP.elements;
		if (planeNorEX >=0)
			outPE[0]=boxMaxE[0];
		if (planeNorEY >=0)
			outPE[1]=boxMaxE[1];
		if (planeNorEZ >=0)
			outPE[2]=boxMaxE[2];
		boxMax.cloneTo(outN);
		var outNE=outN.elements;
		if (planeNorEX >=0)
			outNE[0]=boxMinE[0];
		if (planeNorEY >=0)
			outNE[1]=boxMinE[1];
		if (planeNorEZ >=0)
			outNE[2]=boxMinE[2];
	}

	/**
	*获取顶平面。
	*@return 顶平面。
	*/
	__getset(0,__proto,'top',function(){
		return this._top;
	});

	/**
	*设置描述矩阵。
	*@param matrix 描述矩阵。
	*/
	/**
	*获取描述矩阵。
	*@return 描述矩阵。
	*/
	__getset(0,__proto,'matrix',function(){
		return this._matrix;
		},function(matrix){
		this._matrix=matrix;
		BoundFrustum._getPlanesFromMatrix(this._matrix,this._near,this._far,this._left,this._right,this._top,this._bottom);
	});

	/**
	*获取近平面。
	*@return 近平面。
	*/
	__getset(0,__proto,'near',function(){
		return this._near;
	});

	/**
	*获取远平面。
	*@return 远平面。
	*/
	__getset(0,__proto,'far',function(){
		return this._far;
	});

	/**
	*获取左平面。
	*@return 左平面。
	*/
	__getset(0,__proto,'left',function(){
		return this._left;
	});

	/**
	*获取右平面。
	*@return 右平面。
	*/
	__getset(0,__proto,'right',function(){
		return this._right;
	});

	/**
	*获取底平面。
	*@return 底平面。
	*/
	__getset(0,__proto,'bottom',function(){
		return this._bottom;
	});

	BoundFrustum._getPlanesFromMatrix=function(m,np,fp,lp,rp,tp,bp){
		var matrixE=m.elements;
		var m11=matrixE[0];
		var m12=matrixE[1];
		var m13=matrixE[2];
		var m14=matrixE[3];
		var m21=matrixE[4];
		var m22=matrixE[5];
		var m23=matrixE[6];
		var m24=matrixE[7];
		var m31=matrixE[8];
		var m32=matrixE[9];
		var m33=matrixE[10];
		var m34=matrixE[11];
		var m41=matrixE[12];
		var m42=matrixE[13];
		var m43=matrixE[14];
		var m44=matrixE[15];
		var nearNorE=np.normal.elements;
		nearNorE[0]=m14+m13;
		nearNorE[1]=m24+m23;
		nearNorE[2]=m34+m33;
		np.distance=m44+m43;
		np.normalize();
		var farNorE=fp.normal.elements;
		farNorE[0]=m14-m13;
		farNorE[1]=m24-m23;
		farNorE[2]=m34-m33;
		fp.distance=m44-m43;
		fp.normalize();
		var leftNorE=lp.normal.elements;
		leftNorE[0]=m14+m11;
		leftNorE[1]=m24+m21;
		leftNorE[2]=m34+m31;
		lp.distance=m44+m41;
		lp.normalize();
		var rightNorE=rp.normal.elements;
		rightNorE[0]=m14-m11;
		rightNorE[1]=m24-m21;
		rightNorE[2]=m34-m31;
		rp.distance=m44-m41;
		rp.normalize();
		var topNorE=tp.normal.elements;
		topNorE[0]=m14-m12;
		topNorE[1]=m24-m22;
		topNorE[2]=m34-m32;
		tp.distance=m44-m42;
		tp.normalize();
		var bottomNorE=bp.normal.elements;
		bottomNorE[0]=m14+m12;
		bottomNorE[1]=m24+m22;
		bottomNorE[2]=m34+m32;
		bp.distance=m44+m42;
		bp.normalize();
	}

	BoundFrustum._get3PlaneInterPoint=function(p1,p2,p3){
		var p1Nor=p1.normal;
		var p2Nor=p2.normal;
		var p3Nor=p3.normal;
		Vector3.cross(p2Nor,p3Nor,BoundFrustum._tempV30);
		Vector3.cross(p3Nor,p1Nor,BoundFrustum._tempV31);
		Vector3.cross(p1Nor,p2Nor,BoundFrustum._tempV32);
		var a=Vector3.dot(p1Nor,BoundFrustum._tempV30);
		var b=Vector3.dot(p2Nor,BoundFrustum._tempV31);
		var c=Vector3.dot(p3Nor,BoundFrustum._tempV32);
		Vector3.scale(BoundFrustum._tempV30,-p1.distance / a,BoundFrustum._tempV33);
		Vector3.scale(BoundFrustum._tempV31,-p2.distance / b,BoundFrustum._tempV34);
		Vector3.scale(BoundFrustum._tempV32,-p3.distance / c,BoundFrustum._tempV35);
		Vector3.add(BoundFrustum._tempV33,BoundFrustum._tempV34,BoundFrustum._tempV36);
		Vector3.add(BoundFrustum._tempV35,BoundFrustum._tempV36,BoundFrustum._tempV37);
		var v=BoundFrustum._tempV37;
		return v;
	}

	__static(BoundFrustum,
	['_tempV30',function(){return this._tempV30=new Vector3();},'_tempV31',function(){return this._tempV31=new Vector3();},'_tempV32',function(){return this._tempV32=new Vector3();},'_tempV33',function(){return this._tempV33=new Vector3();},'_tempV34',function(){return this._tempV34=new Vector3();},'_tempV35',function(){return this._tempV35=new Vector3();},'_tempV36',function(){return this._tempV36=new Vector3();},'_tempV37',function(){return this._tempV37=new Vector3();}
	]);
	return BoundFrustum;
})()


/**
*<code>BoundSphere</code> 类用于创建包围球。
*/
//class laya.d3.math.BoundSphere
var BoundSphere=(function(){
	function BoundSphere(center,radius){
		/**包围球的中心。*/
		this.center=null;
		/**包围球的半径。*/
		this.radius=NaN;
		this.center=center;
		this.radius=radius;
	}

	__class(BoundSphere,'laya.d3.math.BoundSphere');
	var __proto=BoundSphere.prototype;
	Laya.imps(__proto,{"laya.d3.core.IClone":true})
	__proto.toDefault=function(){
		this.center.toDefault();
		this.radius=0;
	}

	/**
	*判断射线是否与碰撞球交叉，并返回交叉距离。
	*@param ray 射线。
	*@return 距离交叉点的距离，-1表示不交叉。
	*/
	__proto.intersectsRayDistance=function(ray){
		return Collision.intersectsRayAndSphereRD(ray,this);
	}

	/**
	*判断射线是否与碰撞球交叉，并返回交叉点。
	*@param ray 射线。
	*@param outPoint 交叉点。
	*@return 距离交叉点的距离，-1表示不交叉。
	*/
	__proto.intersectsRayPoint=function(ray,outPoint){
		return Collision.intersectsRayAndSphereRP(ray,this,outPoint);
	}

	/**
	*克隆。
	*@param destObject 克隆源。
	*/
	__proto.cloneTo=function(destObject){
		var dest=destObject;
		this.center.cloneTo(dest.center);
		dest.radius=this.radius;
	}

	/**
	*克隆。
	*@return 克隆副本。
	*/
	__proto.clone=function(){
		var dest=/*__JS__ */new this.constructor(new Vector3(),new Vector3());
		this.cloneTo(dest);
		return dest;
	}

	BoundSphere.createFromSubPoints=function(points,start,count,out){
		if (points==null){
			throw new Error("points");
		}
		if (start < 0 || start >=points.length){
			throw new Error("start"+start+"Must be in the range [0, "+(points.length-1)+"]");
		}
		if (count < 0 || (start+count)> points.length){
			throw new Error("count"+count+"Must be in the range <= "+points.length+"}");
		};
		var upperEnd=start+count;
		var center=BoundSphere._tempVector3;
		center.elements[0]=0;
		center.elements[1]=0;
		center.elements[2]=0;
		for (var i=start;i < upperEnd;++i){
			Vector3.add(points[i],center,center);
		};
		var outCenter=out.center;
		Vector3.scale(center,1 / count,outCenter);
		var radius=0.0;
		for (i=start;i < upperEnd;++i){
			var distance=Vector3.distanceSquared(outCenter,points[i]);
			if (distance > radius)
				radius=distance;
		}
		out.radius=Math.sqrt(radius);
	}

	BoundSphere.createfromPoints=function(points,out){
		if (points==null){
			throw new Error("points");
		}
		BoundSphere.createFromSubPoints(points,0,points.length,out);
	}

	__static(BoundSphere,
	['_tempVector3',function(){return this._tempVector3=new Vector3();}
	]);
	return BoundSphere;
})()


/**
*<code>Collision</code> 类用于检测碰撞。
*/
//class laya.d3.math.Collision
var Collision=(function(){
	/**
	*创建一个 <code>Collision</code> 实例。
	*/
	function Collision(){}
	__class(Collision,'laya.d3.math.Collision');
	Collision.distancePlaneToPoint=function(plane,point){
		var dot=Vector3.dot(plane.normal,point);
		return dot-plane.distance;
	}

	Collision.distanceBoxToPoint=function(box,point){
		var boxMine=box.min.elements;
		var boxMineX=boxMine[0];
		var boxMineY=boxMine[1];
		var boxMineZ=boxMine[2];
		var boxMaxe=box.max.elements;
		var boxMaxeX=boxMaxe[0];
		var boxMaxeY=boxMaxe[1];
		var boxMaxeZ=boxMaxe[2];
		var pointe=point.elements;
		var pointeX=pointe[0];
		var pointeY=pointe[1];
		var pointeZ=pointe[2];
		var distance=0;
		if (pointeX < boxMineX)
			distance+=(boxMineX-pointeX)*(boxMineX-pointeX);
		if (pointeX > boxMaxeX)
			distance+=(boxMaxeX-pointeX)*(boxMaxeX-pointeX);
		if (pointeY < boxMineY)
			distance+=(boxMineY-pointeY)*(boxMineY-pointeY);
		if (pointeY > boxMaxeY)
			distance+=(boxMaxeY-pointeY)*(boxMaxeY-pointeY);
		if (pointeZ < boxMineZ)
			distance+=(boxMineZ-pointeZ)*(boxMineZ-pointeZ);
		if (pointeZ > boxMaxeZ)
			distance+=(boxMaxeZ-pointeZ)*(boxMaxeZ-pointeZ);
		return Math.sqrt(distance);
	}

	Collision.distanceBoxToBox=function(box1,box2){
		var box1Mine=box1.min.elements;
		var box1MineX=box1Mine[0];
		var box1MineY=box1Mine[1];
		var box1MineZ=box1Mine[2];
		var box1Maxe=box1.max.elements;
		var box1MaxeX=box1Maxe[0];
		var box1MaxeY=box1Maxe[1];
		var box1MaxeZ=box1Maxe[2];
		var box2Mine=box2.min.elements;
		var box2MineX=box2Mine[0];
		var box2MineY=box2Mine[1];
		var box2MineZ=box2Mine[2];
		var box2Maxe=box2.max.elements;
		var box2MaxeX=box2Maxe[0];
		var box2MaxeY=box2Maxe[1];
		var box2MaxeZ=box2Maxe[2];
		var distance=0;
		var delta=NaN;
		if (box1MineX > box2MaxeX){
			delta=box1MineX-box2MaxeX;
			distance+=delta *delta;
			}else if (box2MineX > box1MaxeX){
			delta=box2MineX-box1MaxeX;
			distance+=delta *delta;
		}
		if (box1MineY > box2MaxeY){
			delta=box1MineY-box2MaxeY;
			distance+=delta *delta;
			}else if (box2MineY > box1MaxeY){
			delta=box2MineY-box1MaxeY;
			distance+=delta *delta;
		}
		if (box1MineZ > box2MaxeZ){
			delta=box1MineZ-box2MaxeZ;
			distance+=delta *delta;
			}else if (box2MineZ > box1MaxeZ){
			delta=box2MineZ-box1MaxeZ;
			distance+=delta *delta;
		}
		return Math.sqrt(distance);
	}

	Collision.distanceSphereToPoint=function(sphere,point){
		var distance=Math.sqrt(Vector3.distanceSquared(sphere.center,point));
		distance-=sphere.radius;
		return Math.max(distance,0);
	}

	Collision.distanceSphereToSphere=function(sphere1,sphere2){
		var distance=Math.sqrt(Vector3.distanceSquared(sphere1.center,sphere2.center));
		distance-=sphere1.radius+sphere2.radius;
		return Math.max(distance,0);
	}

	Collision.intersectsRayAndTriangleRD=function(ray,vertex1,vertex2,vertex3,out){
		var rayO=ray.origin;
		var rayOe=rayO.elements;
		var rayOeX=rayOe[0];
		var rayOeY=rayOe[1];
		var rayOeZ=rayOe[2];
		var rayD=ray.direction;
		var rayDe=rayD.elements;
		var rayDeX=rayDe[0];
		var rayDeY=rayDe[1];
		var rayDeZ=rayDe[2];
		var v1e=vertex1.elements;
		var v1eX=v1e[0];
		var v1eY=v1e[1];
		var v1eZ=v1e[2];
		var v2e=vertex2.elements;
		var v2eX=v2e[0];
		var v2eY=v2e[1];
		var v2eZ=v2e[2];
		var v3e=vertex3.elements;
		var v3eX=v3e[0];
		var v3eY=v3e[1];
		var v3eZ=v3e[2];
		var _tempV30e=Collision._tempV30.elements;
		var _tempV30eX=_tempV30e[0];
		var _tempV30eY=_tempV30e[1];
		var _tempV30eZ=_tempV30e[2];
		_tempV30eX=v2eX-v1eX;
		_tempV30eY=v2eY-v1eY;
		_tempV30eZ=v2eZ-v1eZ;
		var _tempV31e=Collision._tempV31.elements;
		var _tempV31eX=_tempV31e[0];
		var _tempV31eY=_tempV31e[1];
		var _tempV31eZ=_tempV31e[2];
		_tempV31eX=v3eX-v1eX;
		_tempV31eY=v3eY-v1eY;
		_tempV31eZ=v3eZ-v1eZ;
		var _tempV32e=Collision._tempV32.elements;
		var _tempV32eX=_tempV32e[0];
		var _tempV32eY=_tempV32e[1];
		var _tempV32eZ=_tempV32e[2];
		_tempV32eX=(rayDeY *_tempV31eZ)-(rayDeZ *_tempV31eY);
		_tempV32eY=(rayDeZ *_tempV31eX)-(rayDeX *_tempV31eZ);
		_tempV32eZ=(rayDeX *_tempV31eY)-(rayDeY *_tempV31eX);
		var determinant=(_tempV30eX *_tempV32eX)+(_tempV30eY *_tempV32eY)+(_tempV30eZ *_tempV32eZ);
		if (MathUtils3D.isZero(determinant)){
			out=0;
			return false;
		};
		var inversedeterminant=1 / determinant;
		var _tempV33e=Collision._tempV33.elements;
		var _tempV33eX=_tempV33e[0];
		var _tempV33eY=_tempV33e[1];
		var _tempV33eZ=_tempV33e[2];
		_tempV33eX=rayOeX-v1eX;
		_tempV33eY=rayOeY-v1eY;
		_tempV33eZ=rayOeZ-v1eZ;
		var triangleU=(_tempV33eX *_tempV32eX)+(_tempV33eY *_tempV32eY)+(_tempV33eZ *_tempV32eZ);
		triangleU *=inversedeterminant;
		if (triangleU < 0 || triangleU > 1){
			out=0;
			return false;
		};
		var _tempV34e=Collision._tempV34.elements;
		var _tempV34eX=_tempV34e[0];
		var _tempV34eY=_tempV34e[1];
		var _tempV34eZ=_tempV34e[2];
		_tempV34eX=(_tempV33eY *_tempV30eZ)-(_tempV33eZ *_tempV30eY);
		_tempV34eY=(_tempV33eZ *_tempV30eX)-(_tempV33eX *_tempV30eZ);
		_tempV34eZ=(_tempV33eX *_tempV30eY)-(_tempV33eY *_tempV30eX);
		var triangleV=((rayDeX *_tempV34eX)+(rayDeY *_tempV34eY))+(rayDeZ *_tempV34eZ);
		triangleV *=inversedeterminant;
		if (triangleV < 0 || triangleU+triangleV > 1){
			out=0;
			return false;
		};
		var raydistance=(_tempV31eX *_tempV34eX)+(_tempV31eY *_tempV34eY)+(_tempV31eZ *_tempV34eZ);
		raydistance *=inversedeterminant;
		if (raydistance < 0){
			out=0;
			return false;
		}
		out=raydistance;
		return true;
	}

	Collision.intersectsRayAndTriangleRP=function(ray,vertex1,vertex2,vertex3,out){
		var distance=NaN;
		if (!Collision.intersectsRayAndTriangleRD(ray,vertex1,vertex2,vertex3,distance)){
			out=Vector3.ZERO;
			return false;
		}
		Vector3.scale(ray.direction,distance,Collision._tempV30);
		Vector3.add(ray.origin,Collision._tempV30,out);
		return true;
	}

	Collision.intersectsRayAndPoint=function(ray,point){
		Vector3.subtract(ray.origin,point,Collision._tempV30);
		var b=Vector3.dot(Collision._tempV30,ray.direction);
		var c=Vector3.dot(Collision._tempV30,Collision._tempV30)-MathUtils3D.zeroTolerance;
		if (c > 0 && b > 0)
			return false;
		var discriminant=b *b-c;
		if (discriminant < 0)
			return false;
		return true;
	}

	Collision.intersectsRayAndRay=function(ray1,ray2,out){
		var ray1o=ray1.origin;
		var ray1oe=ray1o.elements;
		var ray1oeX=ray1oe[0];
		var ray1oeY=ray1oe[1];
		var ray1oeZ=ray1oe[2];
		var ray1d=ray1.direction;
		var ray1de=ray1d.elements;
		var ray1deX=ray1de[0];
		var ray1deY=ray1de[1];
		var ray1deZ=ray1de[2];
		var ray2o=ray2.origin;
		var ray2oe=ray2o.elements;
		var ray2oeX=ray2oe[0];
		var ray2oeY=ray2oe[1];
		var ray2oeZ=ray2oe[2];
		var ray2d=ray2.direction;
		var ray2de=ray2d.elements;
		var ray2deX=ray2de[0];
		var ray2deY=ray2de[1];
		var ray2deZ=ray2de[2];
		Vector3.cross(ray1d,ray2d,Collision._tempV30);
		var tempV3e=Collision._tempV30.elements;
		var denominator=Vector3.scalarLengthSquared(Collision._tempV30);
		if (MathUtils3D.isZero(denominator)){
			if (MathUtils3D.nearEqual(ray2oeX,ray1oeX)&& MathUtils3D.nearEqual(ray2oeY,ray1oeY)&& MathUtils3D.nearEqual(ray2oeZ,ray1oeZ)){
				Vector3.ZERO.cloneTo(out);
				return true;
			}
		};
		var m11=ray2oeX-ray1oeX;
		var m12=ray2oeY-ray1oeY;
		var m13=ray2oeZ-ray1oeZ;
		var m21=ray2deX;
		var m22=ray2deY;
		var m23=ray2deZ;
		var m31=tempV3e[0];
		var m32=tempV3e[1];
		var m33=tempV3e[2];
		var dets=m11 *m22 *m33+m12 *m23 *m31+m13 *m21 *m32-m11 *m23 *m32-m12 *m21 *m33-m13 *m22 *m31;
		m21=ray1deX;
		m22=ray1deY;
		m23=ray1deZ;
		var dett=m11 *m22 *m33+m12 *m23 *m31+m13 *m21 *m32-m11 *m23 *m32-m12 *m21 *m33-m13 *m22 *m31;
		var s=dets / denominator;
		var t=dett / denominator;
		Vector3.scale(ray1d,s,Collision._tempV30);
		Vector3.scale(ray2d,t,Collision._tempV31);
		Vector3.add(ray1o,Collision._tempV30,Collision._tempV32);
		Vector3.add(ray2o,Collision._tempV31,Collision._tempV33);
		var point1e=Collision._tempV32.elements;
		var point2e=Collision._tempV33.elements;
		if (!MathUtils3D.nearEqual(point2e[0],point1e[0])|| !MathUtils3D.nearEqual(point2e[1],point1e[1])|| !MathUtils3D.nearEqual(point2e[2],point1e[2])){
			Vector3.ZERO.cloneTo(out);
			return false;
		}
		Collision._tempV32.cloneTo(out);
		return true;
	}

	Collision.intersectsPlaneAndTriangle=function(plane,vertex1,vertex2,vertex3){
		var test1=Collision.intersectsPlaneAndPoint(plane,vertex1);
		var test2=Collision.intersectsPlaneAndPoint(plane,vertex2);
		var test3=Collision.intersectsPlaneAndPoint(plane,vertex3);
		if (test1==Plane.PlaneIntersectionType_Front && test2==Plane.PlaneIntersectionType_Front && test3==Plane.PlaneIntersectionType_Front)
			return Plane.PlaneIntersectionType_Front;
		if (test1==Plane.PlaneIntersectionType_Back && test2==Plane.PlaneIntersectionType_Back && test3==Plane.PlaneIntersectionType_Back)
			return Plane.PlaneIntersectionType_Back;
		return Plane.PlaneIntersectionType_Intersecting;
	}

	Collision.intersectsRayAndPlaneRD=function(ray,plane,out){
		var planeNor=plane.normal;
		var direction=Vector3.dot(planeNor,ray.direction);
		if (MathUtils3D.isZero(direction)){
			out=0;
			return false;
		};
		var position=Vector3.dot(planeNor,ray.origin);
		out=(-plane.distance-position)/ direction;
		if (out < 0){
			out=0;
			return false;
		}
		return true;
	}

	Collision.intersectsRayAndPlaneRP=function(ray,plane,out){
		var distance=NaN;
		if (!Collision.intersectsRayAndPlaneRD(ray,plane,distance)){
			out=Vector3.ZERO;
			return false;
		}
		Vector3.scale(ray.direction,distance,Collision._tempV30);
		Vector3.add(ray.origin,Collision._tempV30,Collision._tempV31);
		out=Collision._tempV31;
		return true;
	}

	Collision.intersectsRayAndBoxRD=function(ray,box){
		var rayoe=ray.origin.elements;
		var rayoeX=rayoe[0];
		var rayoeY=rayoe[1];
		var rayoeZ=rayoe[2];
		var rayde=ray.direction.elements;
		var raydeX=rayde[0];
		var raydeY=rayde[1];
		var raydeZ=rayde[2];
		var boxMine=box.min.elements;
		var boxMineX=boxMine[0];
		var boxMineY=boxMine[1];
		var boxMineZ=boxMine[2];
		var boxMaxe=box.max.elements;
		var boxMaxeX=boxMaxe[0];
		var boxMaxeY=boxMaxe[1];
		var boxMaxeZ=boxMaxe[2];
		var out=0;
		var tmax=MathUtils3D.MaxValue;
		if (MathUtils3D.isZero(raydeX)){
			if (rayoeX < boxMineX || rayoeX > boxMaxeX){
				return-1;
			}
			}else {
			var inverse=1 / raydeX;
			var t1=(boxMineX-rayoeX)*inverse;
			var t2=(boxMaxeX-rayoeX)*inverse;
			if (t1 > t2){
				var temp=t1;
				t1=t2;
				t2=temp;
			}
			out=Math.max(t1,out);
			tmax=Math.min(t2,tmax);
			if (out > tmax){
				return-1;
			}
		}
		if (MathUtils3D.isZero(raydeY)){
			if (rayoeY < boxMineY || rayoeY > boxMaxeY){
				return-1;
			}
			}else {
			var inverse1=1 / raydeY;
			var t3=(boxMineY-rayoeY)*inverse1;
			var t4=(boxMaxeY-rayoeY)*inverse1;
			if (t3 > t4){
				var temp1=t3;
				t3=t4;
				t4=temp1;
			}
			out=Math.max(t3,out);
			tmax=Math.min(t4,tmax);
			if (out > tmax){
				return-1;
			}
		}
		if (MathUtils3D.isZero(raydeZ)){
			if (rayoeZ < boxMineZ || rayoeZ > boxMaxeZ){
				return-1;
			}
			}else {
			var inverse2=1 / raydeZ;
			var t5=(boxMineZ-rayoeZ)*inverse2;
			var t6=(boxMaxeZ-rayoeZ)*inverse2;
			if (t5 > t6){
				var temp2=t5;
				t5=t6;
				t6=temp2;
			}
			out=Math.max(t5,out);
			tmax=Math.min(t6,tmax);
			if (out > tmax){
				return-1;
			}
		}
		return out;
	}

	Collision.intersectsRayAndBoxRP=function(ray,box,out){
		var distance=Collision.intersectsRayAndBoxRD(ray,box);
		if (distance===-1){
			Vector3.ZERO.cloneTo(out);
			return distance;
		}
		Vector3.scale(ray.direction,distance,Collision._tempV30);
		Vector3.add(ray.origin,Collision._tempV30,Collision._tempV31);
		Collision._tempV31.cloneTo(out);
		return distance;
	}

	Collision.intersectsRayAndSphereRD=function(ray,sphere){
		var sphereR=sphere.radius;
		Vector3.subtract(ray.origin,sphere.center,Collision._tempV30);
		var b=Vector3.dot(Collision._tempV30,ray.direction);
		var c=Vector3.dot(Collision._tempV30,Collision._tempV30)-(sphereR *sphereR);
		if (c > 0 && b > 0){
			return-1;
		};
		var discriminant=b *b-c;
		if (discriminant < 0){
			return-1;
		};
		var distance=-b-Math.sqrt(discriminant);
		if (distance < 0)
			distance=0;
		return distance;
	}

	Collision.intersectsRayAndSphereRP=function(ray,sphere,out){
		var distance=Collision.intersectsRayAndSphereRD(ray,sphere);
		if (distance===-1){
			Vector3.ZERO.cloneTo(out);
			return distance;
		}
		Vector3.scale(ray.direction,distance,Collision._tempV30);
		Vector3.add(ray.origin,Collision._tempV30,Collision._tempV31);
		Collision._tempV31.cloneTo(out);
		return distance;
	}

	Collision.intersectsSphereAndTriangle=function(sphere,vertex1,vertex2,vertex3){
		var sphereC=sphere.center;
		var sphereR=sphere.radius;
		Collision.closestPointPointTriangle(sphereC,vertex1,vertex2,vertex3,Collision._tempV30);
		Vector3.subtract(Collision._tempV30,sphereC,Collision._tempV31);
		var dot=Vector3.dot(Collision._tempV31,Collision._tempV31);
		return dot <=sphereR *sphereR;
	}

	Collision.intersectsPlaneAndPoint=function(plane,point){
		var distance=Vector3.dot(plane.normal,point)+plane.distance;
		if (distance > 0)
			return Plane.PlaneIntersectionType_Front;
		if (distance < 0)
			return Plane.PlaneIntersectionType_Back;
		return Plane.PlaneIntersectionType_Intersecting;
	}

	Collision.intersectsPlaneAndPlane=function(plane1,plane2){
		Vector3.cross(plane1.normal,plane2.normal,Collision._tempV30);
		var denominator=Vector3.dot(Collision._tempV30,Collision._tempV30);
		if (MathUtils3D.isZero(denominator))
			return false;
		return true;
	}

	Collision.intersectsPlaneAndPlaneRL=function(plane1,plane2,line){
		var plane1nor=plane1.normal;
		var plane2nor=plane2.normal;
		Vector3.cross(plane1nor,plane2nor,Collision._tempV34);
		var denominator=Vector3.dot(Collision._tempV34,Collision._tempV34);
		if (MathUtils3D.isZero(denominator))
			return false;
		Vector3.scale(plane2nor,plane1.distance,Collision._tempV30);
		Vector3.scale(plane1nor,plane2.distance,Collision._tempV31);
		Vector3.subtract(Collision._tempV30,Collision._tempV31,Collision._tempV32);
		Vector3.cross(Collision._tempV32,Collision._tempV34,Collision._tempV33);
		Vector3.normalize(Collision._tempV34,Collision._tempV34);
		line=new Ray(Collision._tempV33,Collision._tempV34);
		return true;
	}

	Collision.intersectsPlaneAndBox=function(plane,box){
		var planeD=plane.distance;
		var planeNor=plane.normal;
		var planeNore=planeNor.elements;
		var planeNoreX=planeNore[0];
		var planeNoreY=planeNore[1];
		var planeNoreZ=planeNore[2];
		var boxMine=box.min.elements;
		var boxMineX=boxMine[0];
		var boxMineY=boxMine[1];
		var boxMineZ=boxMine[2];
		var boxMaxe=box.max.elements;
		var boxMaxeX=boxMaxe[0];
		var boxMaxeY=boxMaxe[1];
		var boxMaxeZ=boxMaxe[2];
		Collision._tempV30.elements[0]=(planeNoreX > 0)? boxMineX :boxMaxeX;
		Collision._tempV30.elements[1]=(planeNoreY > 0)? boxMineY :boxMaxeY;
		Collision._tempV30.elements[2]=(planeNoreZ > 0)? boxMineZ :boxMaxeZ;
		Collision._tempV31.elements[0]=(planeNoreX > 0)? boxMaxeX :boxMineX;
		Collision._tempV31.elements[1]=(planeNoreY > 0)? boxMaxeY :boxMineY;
		Collision._tempV31.elements[2]=(planeNoreZ > 0)? boxMaxeZ :boxMineZ;
		var distance=Vector3.dot(planeNor,Collision._tempV30);
		if (distance+planeD > 0)
			return Plane.PlaneIntersectionType_Front;
		distance=Vector3.dot(planeNor,Collision._tempV31);
		if (distance+planeD < 0)
			return Plane.PlaneIntersectionType_Back;
		return Plane.PlaneIntersectionType_Intersecting;
	}

	Collision.intersectsPlaneAndSphere=function(plane,sphere){
		var sphereR=sphere.radius;
		var distance=Vector3.dot(plane.normal,sphere.center)+plane.distance;
		if (distance > sphereR)
			return Plane.PlaneIntersectionType_Front;
		if (distance <-sphereR)
			return Plane.PlaneIntersectionType_Back;
		return Plane.PlaneIntersectionType_Intersecting;
	}

	Collision.intersectsBoxAndBox=function(box1,box2){
		var box1Mine=box1.min.elements;
		var box1Maxe=box1.max.elements;
		var box2Mine=box2.min.elements;
		var box2Maxe=box2.max.elements;
		if (box1Mine[0] > box2Maxe[0] || box2Mine[0] > box1Maxe[0])
			return false;
		if (box1Mine[1] > box2Maxe[1] || box2Mine[1] > box1Maxe[1])
			return false;
		if (box1Mine[2] > box2Maxe[2] || box2Mine[2] > box1Maxe[2])
			return false;
		return true;
	}

	Collision.intersectsBoxAndSphere=function(box,sphere){
		var sphereC=sphere.center;
		var sphereR=sphere.radius;
		Vector3.Clamp(sphereC,box.min,box.max,Collision._tempV30);
		var distance=Vector3.distanceSquared(sphereC,Collision._tempV30);
		return distance <=sphereR *sphereR;
	}

	Collision.intersectsSphereAndSphere=function(sphere1,sphere2){
		var radiisum=sphere1.radius+sphere2.radius;
		return Vector3.distanceSquared(sphere1.center,sphere2.center)<=radiisum *radiisum;
	}

	Collision.boxContainsPoint=function(box,point){
		var boxMine=box.min.elements;
		var boxMaxe=box.max.elements;
		var pointe=point.elements;
		if (boxMine[0] <=pointe[0] && boxMaxe[0] >=pointe[0] && boxMine[1] <=pointe[1] && boxMaxe[1] >=pointe[1] && boxMine[2] <=pointe[2] && boxMaxe[2] >=pointe[2])
			return /*laya.d3.math.ContainmentType.Contains*/1;
		return /*laya.d3.math.ContainmentType.Disjoint*/0;
	}

	Collision.boxContainsBox=function(box1,box2){
		var box1Mine=box1.min.elements;
		var box1MineX=box1Mine[0];
		var box1MineY=box1Mine[1];
		var box1MineZ=box1Mine[2];
		var box1Maxe=box1.max.elements;
		var box1MaxeX=box1Maxe[0];
		var box1MaxeY=box1Maxe[1];
		var box1MaxeZ=box1Maxe[2];
		var box2Mine=box2.min.elements;
		var box2MineX=box2Mine[0];
		var box2MineY=box2Mine[1];
		var box2MineZ=box2Mine[2];
		var box2Maxe=box2.max.elements;
		var box2MaxeX=box2Maxe[0];
		var box2MaxeY=box2Maxe[1];
		var box2MaxeZ=box2Maxe[2];
		if (box1MaxeX < box2MineX || box1MineX > box2MaxeX)
			return /*laya.d3.math.ContainmentType.Disjoint*/0;
		if (box1MaxeY < box2MineY || box1MineY > box2MaxeY)
			return /*laya.d3.math.ContainmentType.Disjoint*/0;
		if (box1MaxeZ < box2MineZ || box1MineZ > box2MaxeZ)
			return /*laya.d3.math.ContainmentType.Disjoint*/0;
		if (box1MineX <=box2MineX && box2MaxeX <=box2MaxeX && box1MineY <=box2MineY && box2MaxeY <=box1MaxeY && box1MineZ <=box2MineZ && box2MaxeZ <=box1MaxeZ){
			return /*laya.d3.math.ContainmentType.Contains*/1;
		}
		return /*laya.d3.math.ContainmentType.Intersects*/2;
	}

	Collision.boxContainsSphere=function(box,sphere){
		var boxMin=box.min;
		var boxMine=boxMin.elements;
		var boxMineX=boxMine[0];
		var boxMineY=boxMine[1];
		var boxMineZ=boxMine[2];
		var boxMax=box.max;
		var boxMaxe=boxMax.elements;
		var boxMaxeX=boxMaxe[0];
		var boxMaxeY=boxMaxe[1];
		var boxMaxeZ=boxMaxe[2];
		var sphereC=sphere.center;
		var sphereCe=sphereC.elements;
		var sphereCeX=sphereCe[0];
		var sphereCeY=sphereCe[1];
		var sphereCeZ=sphereCe[2];
		var sphereR=sphere.radius;
		Vector3.Clamp(sphereC,boxMin,boxMax,Collision._tempV30);
		var distance=Vector3.distanceSquared(sphereC,Collision._tempV30);
		if (distance > sphereR *sphereR)
			return /*laya.d3.math.ContainmentType.Disjoint*/0;
		if ((((boxMineX+sphereR <=sphereCeX)&& (sphereCeX <=boxMaxeX-sphereR))&& ((boxMaxeX-boxMineX > sphereR)&&
			(boxMineY+sphereR <=sphereCeY)))&& (((sphereCeY <=boxMaxeY-sphereR)&& (boxMaxeY-boxMineY > sphereR))&&
		(((boxMineZ+sphereR <=sphereCeZ)&& (sphereCeZ <=boxMaxeZ-sphereR))&& (boxMaxeZ-boxMineZ > sphereR))))
		return /*laya.d3.math.ContainmentType.Contains*/1;
		return /*laya.d3.math.ContainmentType.Intersects*/2;
	}

	Collision.sphereContainsPoint=function(sphere,point){
		if (Vector3.distanceSquared(point,sphere.center)<=sphere.radius *sphere.radius)
			return /*laya.d3.math.ContainmentType.Contains*/1;
		return /*laya.d3.math.ContainmentType.Disjoint*/0;
	}

	Collision.sphereContainsTriangle=function(sphere,vertex1,vertex2,vertex3){
		var test1=Collision.sphereContainsPoint(sphere,vertex1);
		var test2=Collision.sphereContainsPoint(sphere,vertex2);
		var test3=Collision.sphereContainsPoint(sphere,vertex3);
		if (test1==/*laya.d3.math.ContainmentType.Contains*/1 && test2==/*laya.d3.math.ContainmentType.Contains*/1 && test3==/*laya.d3.math.ContainmentType.Contains*/1)
			return /*laya.d3.math.ContainmentType.Contains*/1;
		if (Collision.intersectsSphereAndTriangle(sphere,vertex1,vertex2,vertex3))
			return /*laya.d3.math.ContainmentType.Intersects*/2;
		return /*laya.d3.math.ContainmentType.Disjoint*/0;
	}

	Collision.sphereContainsBox=function(sphere,box){
		var sphereC=sphere.center;
		var sphereCe=sphereC.elements;
		var sphereCeX=sphereCe[0];
		var sphereCeY=sphereCe[1];
		var sphereCeZ=sphereCe[2];
		var sphereR=sphere.radius;
		var boxMin=box.min;
		var boxMine=boxMin.elements;
		var boxMineX=boxMine[0];
		var boxMineY=boxMine[1];
		var boxMineZ=boxMine[2];
		var boxMax=box.max;
		var boxMaxe=boxMax.elements;
		var boxMaxeX=boxMaxe[0];
		var boxMaxeY=boxMaxe[1];
		var boxMaxeZ=boxMaxe[2];
		var _tempV30e=Collision._tempV30.elements;
		var _tempV30eX=_tempV30e[0];
		var _tempV30eY=_tempV30e[1];
		var _tempV30eZ=_tempV30e[2];
		if (!Collision.intersectsBoxAndSphere(box,sphere))
			return /*laya.d3.math.ContainmentType.Disjoint*/0;
		var radiusSquared=sphereR *sphereR;
		_tempV30eX=sphereCeX-boxMineX;
		_tempV30eY=sphereCeY-boxMaxeY;
		_tempV30eZ=sphereCeZ-boxMaxeZ;
		if (Vector3.scalarLengthSquared(Collision._tempV30)> radiusSquared)
			return /*laya.d3.math.ContainmentType.Intersects*/2;
		_tempV30eX=sphereCeX-boxMaxeX;
		_tempV30eY=sphereCeY-boxMaxeY;
		_tempV30eZ=sphereCeZ-boxMaxeZ;
		if (Vector3.scalarLengthSquared(Collision._tempV30)> radiusSquared)
			return /*laya.d3.math.ContainmentType.Intersects*/2;
		_tempV30eX=sphereCeX-boxMaxeX;
		_tempV30eY=sphereCeY-boxMineY;
		_tempV30eZ=sphereCeZ-boxMaxeZ;
		if (Vector3.scalarLengthSquared(Collision._tempV30)> radiusSquared)
			return /*laya.d3.math.ContainmentType.Intersects*/2;
		_tempV30eX=sphereCeX-boxMineX;
		_tempV30eY=sphereCeY-boxMineY;
		_tempV30eZ=sphereCeZ-boxMaxeZ;
		if (Vector3.scalarLengthSquared(Collision._tempV30)> radiusSquared)
			return /*laya.d3.math.ContainmentType.Intersects*/2;
		_tempV30eX=sphereCeX-boxMineX;
		_tempV30eY=sphereCeY-boxMaxeY;
		_tempV30eZ=sphereCeZ-boxMineZ;
		if (Vector3.scalarLengthSquared(Collision._tempV30)> radiusSquared)
			return /*laya.d3.math.ContainmentType.Intersects*/2;
		_tempV30eX=sphereCeX-boxMaxeX;
		_tempV30eY=sphereCeY-boxMaxeY;
		_tempV30eZ=sphereCeZ-boxMineZ;
		if (Vector3.scalarLengthSquared(Collision._tempV30)> radiusSquared)
			return /*laya.d3.math.ContainmentType.Intersects*/2;
		_tempV30eX=sphereCeX-boxMaxeX;
		_tempV30eY=sphereCeY-boxMineY;
		_tempV30eZ=sphereCeZ-boxMineZ;
		if (Vector3.scalarLengthSquared(Collision._tempV30)> radiusSquared)
			return /*laya.d3.math.ContainmentType.Intersects*/2;
		_tempV30eX=sphereCeX-boxMineX;
		_tempV30eY=sphereCeY-boxMineY;
		_tempV30eZ=sphereCeZ-boxMineZ;
		if (Vector3.scalarLengthSquared(Collision._tempV30)> radiusSquared)
			return /*laya.d3.math.ContainmentType.Intersects*/2;
		return /*laya.d3.math.ContainmentType.Contains*/1;
	}

	Collision.sphereContainsSphere=function(sphere1,sphere2){
		var sphere1R=sphere1.radius;
		var sphere2R=sphere2.radius;
		var distance=Vector3.distance(sphere1.center,sphere2.center);
		if (sphere1R+sphere2R < distance)
			return /*laya.d3.math.ContainmentType.Disjoint*/0;
		if (sphere1R-sphere2R < distance)
			return /*laya.d3.math.ContainmentType.Intersects*/2;
		return /*laya.d3.math.ContainmentType.Contains*/1;
	}

	Collision.closestPointPointTriangle=function(point,vertex1,vertex2,vertex3,out){
		Vector3.subtract(vertex2,vertex1,Collision._tempV30);
		Vector3.subtract(vertex3,vertex1,Collision._tempV31);
		Vector3.subtract(point,vertex1,Collision._tempV32);
		Vector3.subtract(point,vertex2,Collision._tempV33);
		Vector3.subtract(point,vertex3,Collision._tempV34);
		var d1=Vector3.dot(Collision._tempV30,Collision._tempV32);
		var d2=Vector3.dot(Collision._tempV31,Collision._tempV32);
		var d3=Vector3.dot(Collision._tempV30,Collision._tempV33);
		var d4=Vector3.dot(Collision._tempV31,Collision._tempV33);
		var d5=Vector3.dot(Collision._tempV30,Collision._tempV34);
		var d6=Vector3.dot(Collision._tempV31,Collision._tempV34);
		if (d1 <=0 && d2 <=0){
			vertex1.cloneTo(out);
			return;
		}
		if (d3 >=0 && d4 <=d3){
			vertex2.cloneTo(out);
			return;
		};
		var vc=d1 *d4-d3 *d2;
		if (vc <=0 && d1 >=0 && d3 <=0){
			var v=d1 / (d1-d3);
			Vector3.scale(Collision._tempV30,v,out);
			Vector3.add(vertex1,out,out);
			return;
		}
		if (d6 >=0 && d5 <=d6){
			vertex3.cloneTo(out);
			return;
		};
		var vb=d5 *d2-d1 *d6;
		if (vb <=0 && d2 >=0 && d6 <=0){
			var w=d2 / (d2-d6);
			Vector3.scale(Collision._tempV31,w,out);
			Vector3.add(vertex1,out,out);
			return;
		};
		var va=d3 *d6-d5 *d4;
		if (va <=0 && (d4-d3)>=0 && (d5-d6)>=0){
			var w3=(d4-d3)/ ((d4-d3)+(d5-d6));
			Vector3.subtract(vertex3,vertex2,out);
			Vector3.scale(out,w3,out);
			Vector3.add(vertex2,out,out);
			return;
		};
		var denom=1 / (va+vb+vc);
		var v2=vb *denom;
		var w2=vc *denom;
		Vector3.scale(Collision._tempV30,v2,Collision._tempV35);
		Vector3.scale(Collision._tempV31,w2,Collision._tempV36);
		Vector3.add(Collision._tempV35,Collision._tempV36,out);
		Vector3.add(vertex1,out,out);
	}

	Collision.closestPointPlanePoint=function(plane,point,out){
		var planeN=plane.normal;
		var t=Vector3.dot(planeN,point)-plane.distance;
		Vector3.scale(planeN,t,Collision._tempV30);
		Vector3.subtract(point,Collision._tempV30,out);
	}

	Collision.closestPointBoxPoint=function(box,point,out){
		Vector3.max(point,box.min,Collision._tempV30);
		Vector3.min(Collision._tempV30,box.max,out);
	}

	Collision.closestPointSpherePoint=function(sphere,point,out){
		var sphereC=sphere.center;
		Vector3.subtract(point,sphereC,out);
		Vector3.normalize(out,out);
		Vector3.scale(out,sphere.radius,out);
		Vector3.add(out,sphereC,out);
	}

	Collision.closestPointSphereSphere=function(sphere1,sphere2,out){
		var sphere1C=sphere1.center;
		Vector3.subtract(sphere2.center,sphere1C,out);
		Vector3.normalize(out,out);
		Vector3.scale(out,sphere1.radius,out);
		Vector3.add(out,sphere1C,out);
	}

	__static(Collision,
	['_tempV30',function(){return this._tempV30=new Vector3();},'_tempV31',function(){return this._tempV31=new Vector3();},'_tempV32',function(){return this._tempV32=new Vector3();},'_tempV33',function(){return this._tempV33=new Vector3();},'_tempV34',function(){return this._tempV34=new Vector3();},'_tempV35',function(){return this._tempV35=new Vector3();},'_tempV36',function(){return this._tempV36=new Vector3();}
	]);
	return Collision;
})()


/**
*<code>ContainmentType</code> 类用于定义空间物体位置关系。
*/
//class laya.d3.math.ContainmentType
var ContainmentType=(function(){
	function ContainmentType(){}
	__class(ContainmentType,'laya.d3.math.ContainmentType');
	ContainmentType.Disjoint=0;
	ContainmentType.Contains=1;
	ContainmentType.Intersects=2;
	return ContainmentType;
})()


/**
*<code>MathUtils</code> 类用于创建数学工具。
*/
//class laya.d3.math.MathUtils3D
var MathUtils3D=(function(){
	/**
	*创建一个 <code>MathUtils</code> 实例。
	*/
	function MathUtils3D(){}
	__class(MathUtils3D,'laya.d3.math.MathUtils3D');
	MathUtils3D.isZero=function(v){
		return Math.abs(v)< MathUtils3D.zeroTolerance;
	}

	MathUtils3D.nearEqual=function(n1,n2){
		if (MathUtils3D.isZero(n1-n2))
			return true;
		return false;
	}

	MathUtils3D.fastInvSqrt=function(value){
		if (MathUtils3D.isZero(value))
			return value;
		return 1.0 / Math.sqrt(value);
	}

	__static(MathUtils3D,
	['zeroTolerance',function(){return this.zeroTolerance=1e-6;},'MaxValue',function(){return this.MaxValue=3.40282347e+38;},'MinValue',function(){return this.MinValue=-3.40282347e+38;}
	]);
	return MathUtils3D;
})()


/**
*<code>Matrix3x3</code> 类用于创建3x3矩阵。
*/
//class laya.d3.math.Matrix3x3
var Matrix3x3=(function(){
	function Matrix3x3(){
		/**矩阵元素数组*/
		//this.elements=null;
		var e=this.elements=new Float32Array(9);
		e[0]=1;
		e[1]=0;
		e[2]=0;
		e[3]=0;
		e[4]=1;
		e[5]=0;
		e[6]=0;
		e[7]=0;
		e[8]=1;
	}

	__class(Matrix3x3,'laya.d3.math.Matrix3x3');
	var __proto=Matrix3x3.prototype;
	Laya.imps(__proto,{"laya.d3.core.IClone":true})
	/**
	*计算3x3矩阵的行列式
	*@return 矩阵的行列式
	*/
	__proto.determinant=function(){
		var f=this.elements;
		var a00=f[0],a01=f[1],a02=f[2];
		var a10=f[3],a11=f[4],a12=f[5];
		var a20=f[6],a21=f[7],a22=f[8];
		return a00 *(a22 *a11-a12 *a21)+a01 *(-a22 *a10+a12 *a20)+a02 *(a21 *a10-a11 *a20);
	}

	/**
	*通过一个二维向量转换3x3矩阵
	*@param tra 转换向量
	*@param out 输出矩阵
	*/
	__proto.translate=function(trans,out){
		var e=out.elements;
		var f=this.elements;
		var g=trans.elements;
		var a00=f[0],a01=f[1],a02=f[2];
		var a10=f[3],a11=f[4],a12=f[5];
		var a20=f[6],a21=f[7],a22=f[8];
		var x=g[0],y=g[1];
		e[0]=a00;
		e[1]=a01;
		e[2]=a02;
		e[3]=a10;
		e[4]=a11;
		e[5]=a12;
		e[6]=x *a00+y *a10+a20;
		e[7]=x *a01+y *a11+a21;
		e[8]=x *a02+y *a12+a22;
	}

	/**
	*根据指定角度旋转3x3矩阵
	*@param rad 旋转角度
	*@param out 输出矩阵
	*/
	__proto.rotate=function(rad,out){
		var e=out.elements;
		var f=this.elements;
		var a00=f[0],a01=f[1],a02=f[2];
		var a10=f[3],a11=f[4],a12=f[5];
		var a20=f[6],a21=f[7],a22=f[8];
		var s=Math.sin(rad);
		var c=Math.cos(rad);
		e[0]=c *a00+s *a10;
		e[1]=c *a01+s *a11;
		e[2]=c *a02+s *a12;
		e[3]=c *a10-s *a00;
		e[4]=c *a11-s *a01;
		e[5]=c *a12-s *a02;
		e[6]=a20;
		e[7]=a21;
		e[8]=a22;
	}

	/**
	*根据制定缩放3x3矩阵
	*@param scale 缩放值
	*@param out 输出矩阵
	*/
	__proto.scale=function(scale,out){
		var e=out.elements;
		var f=this.elements;
		var g=scale.elements;
		var x=g[0],y=g[1];
		e[0]=x *f[0];
		e[1]=x *f[1];
		e[2]=x *f[2];
		e[3]=y *f[3];
		e[4]=y *f[4];
		e[5]=y *f[5];
		e[6]=f[6];
		e[7]=f[7];
		e[8]=f[8];
	}

	/**
	*计算3x3矩阵的逆矩阵
	*@param out 输出的逆矩阵
	*/
	__proto.invert=function(out){
		var e=out.elements;
		var f=this.elements;
		var a00=f[0],a01=f[1],a02=f[2];
		var a10=f[3],a11=f[4],a12=f[5];
		var a20=f[6],a21=f[7],a22=f[8];
		var b01=a22 *a11-a12 *a21;
		var b11=-a22 *a10+a12 *a20;
		var b21=a21 *a10-a11 *a20;
		var det=a00 *b01+a01 *b11+a02 *b21;
		if (!det){
			out=null;
		}
		det=1.0 / det;
		e[0]=b01 *det;
		e[1]=(-a22 *a01+a02 *a21)*det;
		e[2]=(a12 *a01-a02 *a11)*det;
		e[3]=b11 *det;
		e[4]=(a22 *a00-a02 *a20)*det;
		e[5]=(-a12 *a00+a02 *a10)*det;
		e[6]=b21 *det;
		e[7]=(-a21 *a00+a01 *a20)*det;
		e[8]=(a11 *a00-a01 *a10)*det;
	}

	/**
	*计算3x3矩阵的转置矩阵
	*@param out 输出矩阵
	*/
	__proto.transpose=function(out){
		var e=out.elements;
		var f=this.elements;
		if (out===this){
			var a01=f[1],a02=f[2],a12=f[5];
			e[1]=f[3];
			e[2]=f[6];
			e[3]=a01;
			e[5]=f[7];
			e[6]=a02;
			e[7]=a12;
			}else {
			e[0]=f[0];
			e[1]=f[3];
			e[2]=f[6];
			e[3]=f[1];
			e[4]=f[4];
			e[5]=f[7];
			e[6]=f[2];
			e[7]=f[5];
			e[8]=f[8];
		}
	}

	/**设置已有的矩阵为单位矩阵*/
	__proto.identity=function(){
		var e=this.elements;
		e[0]=1;
		e[1]=0;
		e[2]=0;
		e[3]=0;
		e[4]=1;
		e[5]=0;
		e[6]=0;
		e[7]=0;
		e[8]=1;
	}

	/**
	*克隆。
	*@param destObject 克隆源。
	*/
	__proto.cloneTo=function(destObject){
		var i,s,d;
		s=this.elements;
		d=destObject.elements;
		if (s===d){
			return;
		}
		for (i=0;i < 9;++i){
			d[i]=s[i];
		}
	}

	/**
	*克隆。
	*@return 克隆副本。
	*/
	__proto.clone=function(){
		var dest=/*__JS__ */new this.constructor();
		this.cloneTo(dest);
		return dest;
	}

	Matrix3x3.createFromTranslation=function(trans,out){
		var e=out.elements;
		var g=trans.elements;
		out[0]=1;
		out[1]=0;
		out[2]=0;
		out[3]=0;
		out[4]=1;
		out[5]=0;
		out[6]=g[0];
		out[7]=g[1];
		out[8]=1;
	}

	Matrix3x3.createFromRotation=function(rad,out){
		var e=out.elements;
		var s=Math.sin(rad),c=Math.cos(rad);
		e[0]=c;
		e[1]=s;
		e[2]=0;
		e[3]=-s;
		e[4]=c;
		e[5]=0;
		e[6]=0;
		e[7]=0;
		e[8]=1;
	}

	Matrix3x3.createFromScaling=function(scale,out){
		var e=out.elements;
		var g=scale.elements;
		e[0]=g[0];
		e[1]=0;
		e[2]=0;
		e[3]=0;
		e[4]=g[1];
		e[5]=0;
		e[6]=0;
		e[7]=0;
		e[8]=1;
	}

	Matrix3x3.createFromMatrix4x4=function(sou,out){
		out[0]=sou[0];
		out[1]=sou[1];
		out[2]=sou[2];
		out[3]=sou[4];
		out[4]=sou[5];
		out[5]=sou[6];
		out[6]=sou[8];
		out[7]=sou[9];
		out[8]=sou[10];
	}

	Matrix3x3.multiply=function(left,right,out){
		var e=out.elements;
		var f=left.elements;
		var g=right.elements;
		var a00=f[0],a01=f[1],a02=f[2];
		var a10=f[3],a11=f[4],a12=f[5];
		var a20=f[6],a21=f[7],a22=f[8];
		var b00=g[0],b01=g[1],b02=g[2];
		var b10=g[3],b11=g[4],b12=g[5];
		var b20=g[6],b21=g[7],b22=g[8];
		e[0]=b00 *a00+b01 *a10+b02 *a20;
		e[1]=b00 *a01+b01 *a11+b02 *a21;
		e[2]=b00 *a02+b01 *a12+b02 *a22;
		e[3]=b10 *a00+b11 *a10+b12 *a20;
		e[4]=b10 *a01+b11 *a11+b12 *a21;
		e[5]=b10 *a02+b11 *a12+b12 *a22;
		e[6]=b20 *a00+b21 *a10+b22 *a20;
		e[7]=b20 *a01+b21 *a11+b22 *a21;
		e[8]=b20 *a02+b21 *a12+b22 *a22;
	}

	Matrix3x3.lookAt=function(eye,target,up,out){
		Vector3.subtract(eye,target,Matrix3x3._tempV30);
		Vector3.normalize(Matrix3x3._tempV30,Matrix3x3._tempV30);
		Vector3.cross(up,Matrix3x3._tempV30,Matrix3x3._tempV31);
		Vector3.normalize(Matrix3x3._tempV31,Matrix3x3._tempV31);
		Vector3.cross(Matrix3x3._tempV30,Matrix3x3._tempV31,Matrix3x3._tempV32);
		var v0e=Matrix3x3._tempV30.elements;
		var v1e=Matrix3x3._tempV31.elements;
		var v2e=Matrix3x3._tempV32.elements;
		var me=out.elements;
		me[0]=v1e[0];
		me[3]=v1e[1];
		me[6]=v1e[2];
		me[1]=v2e[0];
		me[4]=v2e[1];
		me[7]=v2e[2];
		me[2]=v0e[0];
		me[5]=v0e[1];
		me[8]=v0e[2];
	}

	Matrix3x3.DEFAULT=new Matrix3x3();
	__static(Matrix3x3,
	['_tempV30',function(){return this._tempV30=new Vector3();},'_tempV31',function(){return this._tempV31=new Vector3();},'_tempV32',function(){return this._tempV32=new Vector3();}
	]);
	return Matrix3x3;
})()


/**
*<code>Matrix4x4</code> 类用于创建4x4矩阵。
*/
//class laya.d3.math.Matrix4x4
var Matrix4x4=(function(){
	function Matrix4x4(m11,m12,m13,m14,m21,m22,m23,m24,m31,m32,m33,m34,m41,m42,m43,m44){
		/**矩阵元素数组*/
		//this.elements=null;
		(m11===void 0)&& (m11=1);
		(m12===void 0)&& (m12=0);
		(m13===void 0)&& (m13=0);
		(m14===void 0)&& (m14=0);
		(m21===void 0)&& (m21=0);
		(m22===void 0)&& (m22=1);
		(m23===void 0)&& (m23=0);
		(m24===void 0)&& (m24=0);
		(m31===void 0)&& (m31=0);
		(m32===void 0)&& (m32=0);
		(m33===void 0)&& (m33=1);
		(m34===void 0)&& (m34=0);
		(m41===void 0)&& (m41=0);
		(m42===void 0)&& (m42=0);
		(m43===void 0)&& (m43=0);
		(m44===void 0)&& (m44=1);
		var e=this.elements=new Float32Array(16);
		e[0]=m11;
		e[1]=m12;
		e[2]=m13;
		e[3]=m14;
		e[4]=m21;
		e[5]=m22;
		e[6]=m23;
		e[7]=m24;
		e[8]=m31;
		e[9]=m32;
		e[10]=m33;
		e[11]=m34;
		e[12]=m41;
		e[13]=m42;
		e[14]=m43;
		e[15]=m44;
	}

	__class(Matrix4x4,'laya.d3.math.Matrix4x4');
	var __proto=Matrix4x4.prototype;
	Laya.imps(__proto,{"laya.d3.core.IClone":true})
	__proto.getElementByRowColumn=function(row,column){
		if (row < 0 || row > 3)
			throw new Error("row","Rows and columns for matrices run from 0 to 3, inclusive.");
		if (column < 0 || column > 3)
			throw new Error("column","Rows and columns for matrices run from 0 to 3, inclusive.");
		return this.elements[(row *4)+column];
	}

	__proto.setElementByRowColumn=function(row,column,value){
		if (row < 0 || row > 3)
			throw new Error("row","Rows and columns for matrices run from 0 to 3, inclusive.");
		if (column < 0 || column > 3)
			throw new Error("column","Rows and columns for matrices run from 0 to 3, inclusive.");
		this.elements[(row *4)+column]=value;
	}

	/**
	*判断两个4x4矩阵的值是否相等。
	*@param other 4x4矩阵
	*/
	__proto.equalsOtherMatrix=function(other){
		var e=this.elements;
		var oe=other.elements;
		return (MathUtils3D.nearEqual(e[0],oe[0])&& MathUtils3D.nearEqual(e[1],oe[1])&& MathUtils3D.nearEqual(e[2],oe[2])&& MathUtils3D.nearEqual(e[3],oe[3])&& MathUtils3D.nearEqual(e[4],oe[4])&& MathUtils3D.nearEqual(e[5],oe[5])&& MathUtils3D.nearEqual(e[6],oe[6])&& MathUtils3D.nearEqual(e[7],oe[7])&& MathUtils3D.nearEqual(e[8],oe[8])&& MathUtils3D.nearEqual(e[9],oe[9])&& MathUtils3D.nearEqual(e[10],oe[10])&& MathUtils3D.nearEqual(e[11],oe[11])&& MathUtils3D.nearEqual(e[12],oe[12])&& MathUtils3D.nearEqual(e[13],oe[13])&& MathUtils3D.nearEqual(e[14],oe[14])&& MathUtils3D.nearEqual(e[15],oe[15]));
	}

	/**
	*分解矩阵为平移向量、旋转四元数、缩放向量。
	*@param translation 平移向量。
	*@param rotation 旋转四元数。
	*@param scale 缩放向量。
	*@return 是否分解成功。
	*/
	__proto.decomposeTransRotScale=function(translation,rotation,scale){
		var rotationMatrix=Matrix4x4._tempMatrix4x4;
		if (this.decomposeTransRotMatScale(translation,rotationMatrix,scale)){
			Quaternion.createFromMatrix4x4(rotationMatrix,rotation);
			return true;
			}else {
			rotation.identity();
			return false;
		}
	}

	/**
	*分解矩阵为平移向量、旋转矩阵、缩放向量。
	*@param translation 平移向量。
	*@param rotationMatrix 旋转矩阵。
	*@param scale 缩放向量。
	*@return 是否分解成功。
	*/
	__proto.decomposeTransRotMatScale=function(translation,rotationMatrix,scale){
		var e=this.elements;
		var te=translation.elements;
		var re=rotationMatrix.elements;
		var se=scale.elements;
		te[0]=e[12];
		te[1]=e[13];
		te[2]=e[14];
		var m11=e[0],m12=e[1],m13=e[2];
		var m21=e[4],m22=e[5],m23=e[6];
		var m31=e[8],m32=e[9],m33=e[10];
		var sX=se[0]=Math.sqrt((m11 *m11)+(m12 *m12)+(m13 *m13));
		var sY=se[1]=Math.sqrt((m21 *m21)+(m22 *m22)+(m23 *m23));
		var sZ=se[2]=Math.sqrt((m31 *m31)+(m32 *m32)+(m33 *m33));
		if (MathUtils3D.isZero(sX)|| MathUtils3D.isZero(sY)|| MathUtils3D.isZero(sZ)){
			re[1]=re[2]=re[3]=re[4]=re[6]=re[7]=re[8]=re[9]=re[11]=re[12]=re[13]=re[14]=0;
			re[0]=re[5]=re[10]=re[15]=1;
			return false;
		};
		var at=Matrix4x4._tempVector0;
		var atE=at.elements;
		atE[0]=m31 / sZ;
		atE[1]=m32 / sZ;
		atE[2]=m33 / sZ;
		var tempRight=Matrix4x4._tempVector1;
		var tempRightE=tempRight.elements;
		tempRightE[0]=m11 / sX;
		tempRightE[1]=m12 / sX;
		tempRightE[2]=m13 / sX;
		var up=Matrix4x4._tempVector2;
		Vector3.cross(at,tempRight,up);
		var right=Matrix4x4._tempVector1;
		Vector3.cross(up,at,right);
		re[3]=re[7]=re[11]=re[12]=re[13]=re[14]=0;
		re[15]=1;
		re[0]=right.x;
		re[1]=right.y;
		re[2]=right.z;
		re[4]=up.x;
		re[5]=up.y;
		re[6]=up.z;
		re[8]=at.x;
		re[9]=at.y;
		re[10]=at.z;
		((re[0] *m11+re[1] *m12+re[2] *m13)< 0.0)&& (se[0]=-sX);
		((re[4] *m21+re[5] *m22+re[6] *m23)< 0.0)&& (se[1]=-sY);
		((re[8] *m31+re[9] *m32+re[10] *m33)< 0.0)&& (se[2]=-sZ);
		return true;
	}

	/**
	*分解旋转矩阵的旋转为YawPitchRoll欧拉角。
	*@param out float yaw
	*@param out float pitch
	*@param out float roll
	*@return
	*/
	__proto.decomposeYawPitchRoll=function(yawPitchRoll){
		var yawPitchRollE=yawPitchRoll.elements;
		var pitch=Math.asin(-this.elements[9]);
		yawPitchRollE[1]=pitch;
		var test=Math.cos(pitch);
		if (test > MathUtils3D.zeroTolerance){
			yawPitchRollE[2]=Math.atan2(this.elements[1],this.elements[5]);
			yawPitchRollE[0]=Math.atan2(this.elements[8],this.elements[10]);
			}else {
			yawPitchRollE[2]=Math.atan2(-this.elements[4],this.elements[0]);
			yawPitchRollE[0]=0.0;
		}
	}

	/**归一化矩阵 */
	__proto.normalize=function(){
		var v=this.elements;
		var c=v[0],d=v[1],e=v[2],g=Math.sqrt(c *c+d *d+e *e);
		if (g){
			if (g==1)
				return;
			}else {
			v[0]=0;
			v[1]=0;
			v[2]=0;
			return;
		}
		g=1 / g;
		v[0]=c *g;
		v[1]=d *g;
		v[2]=e *g;
	}

	/**计算矩阵的转置矩阵*/
	__proto.transpose=function(){
		var e,t;
		e=this.elements;
		t=e[1];
		e[1]=e[4];
		e[4]=t;
		t=e[2];
		e[2]=e[8];
		e[8]=t;
		t=e[3];
		e[3]=e[12];
		e[12]=t;
		t=e[6];
		e[6]=e[9];
		e[9]=t;
		t=e[7];
		e[7]=e[13];
		e[13]=t;
		t=e[11];
		e[11]=e[14];
		e[14]=t;
		return this;
	}

	/**
	*计算一个矩阵的逆矩阵
	*@param out 输出矩阵
	*/
	__proto.invert=function(out){
		var ae=this.elements;
		var oe=out.elements;
		var a00=ae[0],a01=ae[1],a02=ae[2],a03=ae[3],a10=ae[4],a11=ae[5],a12=ae[6],a13=ae[7],a20=ae[8],a21=ae[9],a22=ae[10],a23=ae[11],a30=ae[12],a31=ae[13],a32=ae[14],a33=ae[15],
		b00=a00 *a11-a01 *a10,b01=a00 *a12-a02 *a10,b02=a00 *a13-a03 *a10,b03=a01 *a12-a02 *a11,b04=a01 *a13-a03 *a11,b05=a02 *a13-a03 *a12,b06=a20 *a31-a21 *a30,b07=a20 *a32-a22 *a30,b08=a20 *a33-a23 *a30,b09=a21 *a32-a22 *a31,b10=a21 *a33-a23 *a31,b11=a22 *a33-a23 *a32,
		det=b00 *b11-b01 *b10+b02 *b09+b03 *b08-b04 *b07+b05 *b06;
		if (Math.abs(det)===0.0){
			return;
		}
		det=1.0 / det;
		oe[0]=(a11 *b11-a12 *b10+a13 *b09)*det;
		oe[1]=(a02 *b10-a01 *b11-a03 *b09)*det;
		oe[2]=(a31 *b05-a32 *b04+a33 *b03)*det;
		oe[3]=(a22 *b04-a21 *b05-a23 *b03)*det;
		oe[4]=(a12 *b08-a10 *b11-a13 *b07)*det;
		oe[5]=(a00 *b11-a02 *b08+a03 *b07)*det;
		oe[6]=(a32 *b02-a30 *b05-a33 *b01)*det;
		oe[7]=(a20 *b05-a22 *b02+a23 *b01)*det;
		oe[8]=(a10 *b10-a11 *b08+a13 *b06)*det;
		oe[9]=(a01 *b08-a00 *b10-a03 *b06)*det;
		oe[10]=(a30 *b04-a31 *b02+a33 *b00)*det;
		oe[11]=(a21 *b02-a20 *b04-a23 *b00)*det;
		oe[12]=(a11 *b07-a10 *b09-a12 *b06)*det;
		oe[13]=(a00 *b09-a01 *b07+a02 *b06)*det;
		oe[14]=(a31 *b01-a30 *b03-a32 *b00)*det;
		oe[15]=(a20 *b03-a21 *b01+a22 *b00)*det;
	}

	/**设置矩阵为单位矩阵*/
	__proto.identity=function(){
		var e=this.elements;
		e[1]=e[2]=e[3]=e[4]=e[6]=e[7]=e[8]=e[9]=e[11]=e[12]=e[13]=e[14]=0;
		e[0]=e[5]=e[10]=e[15]=1;
	}

	/**
	*克隆。
	*@param destObject 克隆源。
	*/
	__proto.cloneTo=function(destObject){
		var i,s,d;
		s=this.elements;
		d=destObject.elements;
		if (s===d){
			return;
		}
		for (i=0;i < 16;++i){
			d[i]=s[i];
		}
	}

	/**
	*克隆。
	*@return 克隆副本。
	*/
	__proto.clone=function(){
		var dest=/*__JS__ */new this.constructor();
		this.cloneTo(dest);
		return dest;
	}

	/**
	*获取平移向量。
	*@param out 平移向量。
	*/
	__proto.getTranslationVector=function(out){
		var me=this.elements;
		var te=out.elements;
		te[0]=me[12];
		te[1]=me[13];
		te[2]=me[14];
	}

	/**
	*设置平移向量。
	*@param translate 平移向量。
	*/
	__proto.setTranslationVector=function(translate){
		var me=this.elements;
		var ve=translate.elements;
		me[12]=ve[0];
		me[13]=ve[1];
		me[14]=ve[2];
	}

	/**
	*获取前向量。
	*@param out 前向量。
	*/
	__proto.getForward=function(out){
		var me=this.elements;
		var te=out.elements;
		te[0]=-me[8];
		te[1]=-me[9];
		te[2]=-me[10];
	}

	/**
	*设置前向量。
	*@param forward 前向量。
	*/
	__proto.setForward=function(forward){
		var me=this.elements;
		var ve=forward.elements;
		me[8]=-ve[0];
		me[9]=-ve[1];
		me[10]=-ve[2];
	}

	Matrix4x4.createRotationX=function(rad,out){
		var oe=out.elements;
		var s=Math.sin(rad),c=Math.cos(rad);
		oe[1]=oe[2]=oe[3]=oe[4]=oe[7]=oe[8]=oe[11]=oe[12]=oe[13]=oe[14]=0;
		oe[0]=oe[15]=1;
		oe[5]=oe[10]=c;
		oe[6]=s;
		oe[9]=-s;
	}

	Matrix4x4.createRotationY=function(rad,out){
		var oe=out.elements;
		var s=Math.sin(rad),c=Math.cos(rad);
		oe[1]=oe[3]=oe[4]=oe[6]=oe[7]=oe[9]=oe[11]=oe[12]=oe[13]=oe[14]=0;
		oe[5]=oe[15]=1;
		oe[0]=oe[10]=c;
		oe[2]=-s;
		oe[8]=s;
	}

	Matrix4x4.createRotationZ=function(rad,out){
		var oe=out.elements;
		var s=Math.sin(rad),c=Math.cos(rad);
		oe[2]=oe[3]=oe[6]=oe[7]=oe[8]=oe[9]=oe[11]=oe[12]=oe[13]=oe[14]=0;
		oe[10]=oe[15]=1;
		oe[0]=oe[5]=c;
		oe[1]=s;
		oe[4]=-s;
	}

	Matrix4x4.createRotationYawPitchRoll=function(yaw,pitch,roll,result){
		Quaternion.createFromYawPitchRoll(yaw,pitch,roll,Matrix4x4._tempQuaternion);
		Matrix4x4.createRotationQuaternion(Matrix4x4._tempQuaternion,result);
	}

	Matrix4x4.createRotationAxis=function(axis,angle,result){
		var axisE=axis.elements;
		var x=axisE[0];
		var y=axisE[1];
		var z=axisE[2];
		var cos=Math.cos(angle);
		var sin=Math.sin(angle);
		var xx=x *x;
		var yy=y *y;
		var zz=z *z;
		var xy=x *y;
		var xz=x *z;
		var yz=y *z;
		var resultE=result.elements;
		resultE[3]=resultE[7]=resultE[11]=resultE[12]=resultE[13]=resultE[14]=0;
		resultE[15]=1.0;
		resultE[0]=xx+(cos *(1.0-xx));
		resultE[1]=(xy-(cos *xy))+(sin *z);
		resultE[2]=(xz-(cos *xz))-(sin *y);
		resultE[4]=(xy-(cos *xy))-(sin *z);
		resultE[5]=yy+(cos *(1.0-yy));
		resultE[6]=(yz-(cos *yz))+(sin *x);
		resultE[8]=(xz-(cos *xz))+(sin *y);
		resultE[9]=(yz-(cos *yz))-(sin *x);
		resultE[10]=zz+(cos *(1.0-zz));
	}

	Matrix4x4.createRotationQuaternion=function(rotation,result){
		var rotationE=rotation.elements;
		var resultE=result.elements;
		var rotationX=rotationE[0];
		var rotationY=rotationE[1];
		var rotationZ=rotationE[2];
		var rotationW=rotationE[3];
		var xx=rotationX *rotationX;
		var yy=rotationY *rotationY;
		var zz=rotationZ *rotationZ;
		var xy=rotationX *rotationY;
		var zw=rotationZ *rotationW;
		var zx=rotationZ *rotationX;
		var yw=rotationY *rotationW;
		var yz=rotationY *rotationZ;
		var xw=rotationX *rotationW;
		resultE[3]=resultE[7]=resultE[11]=resultE[12]=resultE[13]=resultE[14]=0;
		resultE[15]=1.0;
		resultE[0]=1.0-(2.0 *(yy+zz));
		resultE[1]=2.0 *(xy+zw);
		resultE[2]=2.0 *(zx-yw);
		resultE[4]=2.0 *(xy-zw);
		resultE[5]=1.0-(2.0 *(zz+xx));
		resultE[6]=2.0 *(yz+xw);
		resultE[8]=2.0 *(zx+yw);
		resultE[9]=2.0 *(yz-xw);
		resultE[10]=1.0-(2.0 *(yy+xx));
	}

	Matrix4x4.createTranslate=function(trans,out){
		var te=trans.elements;
		var oe=out.elements;
		oe[4]=oe[8]=oe[1]=oe[9]=oe[2]=oe[6]=oe[3]=oe[7]=oe[11]=0;
		oe[0]=oe[5]=oe[10]=oe[15]=1;
		oe[12]=te[0];
		oe[13]=te[1];
		oe[14]=te[2];
	}

	Matrix4x4.createScaling=function(scale,out){
		var se=scale.elements;
		var oe=out.elements;
		oe[0]=se[0];
		oe[5]=se[1];
		oe[10]=se[2];
		oe[1]=oe[4]=oe[8]=oe[12]=oe[9]=oe[13]=oe[2]=oe[6]=oe[14]=oe[3]=oe[7]=oe[11]=0;
		oe[15]=1;
	}

	Matrix4x4.multiply=function(left,right,out){
		var i,e,a,b,ai0,ai1,ai2,ai3;
		e=out.elements;
		a=left.elements;
		b=right.elements;
		if (e===b){
			b=new Float32Array(16);
			for (i=0;i < 16;++i){
				b[i]=e[i];
			}
		}
		for (i=0;i < 4;i++){
			ai0=a[i];
			ai1=a[i+4];
			ai2=a[i+8];
			ai3=a[i+12];
			e[i]=ai0 *b[0]+ai1 *b[1]+ai2 *b[2]+ai3 *b[3];
			e[i+4]=ai0 *b[4]+ai1 *b[5]+ai2 *b[6]+ai3 *b[7];
			e[i+8]=ai0 *b[8]+ai1 *b[9]+ai2 *b[10]+ai3 *b[11];
			e[i+12]=ai0 *b[12]+ai1 *b[13]+ai2 *b[14]+ai3 *b[15];
		}
	}

	Matrix4x4.createFromQuaternion=function(rotation,out){
		var e=out.elements;
		var q=rotation.elements;
		var x=q[0],y=q[1],z=q[2],w=q[3];
		var x2=x+x;
		var y2=y+y;
		var z2=z+z;
		var xx=x *x2;
		var yx=y *x2;
		var yy=y *y2;
		var zx=z *x2;
		var zy=z *y2;
		var zz=z *z2;
		var wx=w *x2;
		var wy=w *y2;
		var wz=w *z2;
		e[0]=1-yy-zz;
		e[1]=yx+wz;
		e[2]=zx-wy;
		e[3]=0;
		e[4]=yx-wz;
		e[5]=1-xx-zz;
		e[6]=zy+wx;
		e[7]=0;
		e[8]=zx+wy;
		e[9]=zy-wx;
		e[10]=1-xx-yy;
		e[11]=0;
		e[12]=0;
		e[13]=0;
		e[14]=0;
		e[15]=1;
	}

	Matrix4x4.createAffineTransformation=function(trans,rot,scale,out){
		var te=trans.elements;
		var re=rot.elements;
		var se=scale.elements;
		var oe=out.elements;
		var x=re[0],y=re[1],z=re[2],w=re[3],x2=x+x,y2=y+y,z2=z+z;
		var xx=x *x2,xy=x *y2,xz=x *z2,yy=y *y2,yz=y *z2,zz=z *z2;
		var wx=w *x2,wy=w *y2,wz=w *z2,sx=se[0],sy=se[1],sz=se[2];
		oe[0]=(1-(yy+zz))*sx;
		oe[1]=(xy+wz)*sx;
		oe[2]=(xz-wy)*sx;
		oe[3]=0;
		oe[4]=(xy-wz)*sy;
		oe[5]=(1-(xx+zz))*sy;
		oe[6]=(yz+wx)*sy;
		oe[7]=0;
		oe[8]=(xz+wy)*sz;
		oe[9]=(yz-wx)*sz;
		oe[10]=(1-(xx+yy))*sz;
		oe[11]=0;
		oe[12]=te[0];
		oe[13]=te[1];
		oe[14]=te[2];
		oe[15]=1;
	}

	Matrix4x4.createLookAt=function(eye,target,up,out){
		var oE=out.elements;
		var xaxis=Matrix4x4._tempVector0;
		var yaxis=Matrix4x4._tempVector1;
		var zaxis=Matrix4x4._tempVector2;
		Vector3.subtract(eye,target,zaxis);
		Vector3.normalize(zaxis,zaxis);
		Vector3.cross(up,zaxis,xaxis);
		Vector3.normalize(xaxis,xaxis);
		Vector3.cross(zaxis,xaxis,yaxis);
		out.identity();
		oE[0]=xaxis.x;
		oE[4]=xaxis.y;
		oE[8]=xaxis.z;
		oE[1]=yaxis.x;
		oE[5]=yaxis.y;
		oE[9]=yaxis.z;
		oE[2]=zaxis.x;
		oE[6]=zaxis.y;
		oE[10]=zaxis.z;
		oE[12]=-Vector3.dot(xaxis,eye);
		oE[13]=-Vector3.dot(yaxis,eye);
		oE[14]=-Vector3.dot(zaxis,eye);
	}

	Matrix4x4.createPerspective=function(fov,aspect,near,far,out){
		var oe=out.elements;
		var f=1.0 / Math.tan(fov / 2),nf=1 / (near-far);
		oe[0]=f / aspect;
		oe[5]=f;
		oe[10]=(far+near)*nf;
		oe[11]=-1;
		oe[14]=(2 *far *near)*nf;
		oe[1]=oe[2]=oe[3]=oe[4]=oe[6]=oe[7]=oe[8]=oe[9]=oe[12]=oe[13]=oe[15]=0;
	}

	Matrix4x4.createOrthoOffCenterRH=function(left,right,bottom,top,near,far,out){
		var oe=out.elements;
		var lr=1 / (left-right);
		var bt=1 / (bottom-top);
		var nf=1 / (near-far);
		oe[1]=oe[2]=oe[3]=oe[4]=oe[6]=oe[7]=oe[8]=oe[9]=oe[11]=0;
		oe[15]=1;
		oe[0]=-2 *lr;
		oe[5]=-2 *bt;
		oe[10]=2 *nf;
		oe[12]=(left+right)*lr;
		oe[13]=(top+bottom)*bt;
		oe[14]=(far+near)*nf;
	}

	Matrix4x4.translation=function(v3,out){
		var ve=v3.elements;
		var oe=out.elements;
		oe[0]=oe[5]=oe[10]=oe[15]=1;
		oe[12]=ve[0];
		oe[13]=ve[1];
		oe[14]=ve[2];
	}

	__static(Matrix4x4,
	['_tempMatrix4x4',function(){return this._tempMatrix4x4=new Matrix4x4();},'_tempVector0',function(){return this._tempVector0=new Vector3();},'_tempVector1',function(){return this._tempVector1=new Vector3();},'_tempVector2',function(){return this._tempVector2=new Vector3();},'_tempQuaternion',function(){return this._tempQuaternion=new Quaternion();},'DEFAULT',function(){return this.DEFAULT=new Matrix4x4();},'ZERO',function(){return this.ZERO=new Matrix4x4(
		0,0,0,0,
		0,0,0,0,
		0,0,0,0,
		0,0,0,0);}
	]);
	return Matrix4x4;
})()


/**
*<code>OrientedBoundBox</code> 类用于创建OBB包围盒。
*/
//class laya.d3.math.OrientedBoundBox
var OrientedBoundBox=(function(){
	function OrientedBoundBox(extents,transformation){
		/**每个轴长度的一半*/
		this.extents=null;
		/**这个矩阵表示包围盒的位置和缩放,它的平移向量表示该包围盒的中心*/
		this.transformation=null;
		this.extents=extents;
		this.transformation=transformation;
	}

	__class(OrientedBoundBox,'laya.d3.math.OrientedBoundBox');
	var __proto=OrientedBoundBox.prototype;
	/**
	*获取OBB包围盒的8个顶点。
	*@param corners 返回顶点的输出队列。
	*/
	__proto.getCorners=function(corners){
		var xve=OrientedBoundBox._tempV30.elements;
		var yve=OrientedBoundBox._tempV31.elements;
		var zve=OrientedBoundBox._tempV32.elements;
		var extentsE=this.extents.elements;
		xve[0]=extentsE[0];
		xve[1]=xve[2]=0;
		yve[1]=extentsE[1];
		yve[0]=yve[2]=0;
		zve[2]=extentsE[2];
		zve[0]=zve[1]=0;
		Vector3.TransformNormal(OrientedBoundBox._tempV30,this.transformation,OrientedBoundBox._tempV30);
		Vector3.TransformNormal(OrientedBoundBox._tempV31,this.transformation,OrientedBoundBox._tempV31);
		Vector3.TransformNormal(OrientedBoundBox._tempV32,this.transformation,OrientedBoundBox._tempV32);
		var center=OrientedBoundBox._tempV33;
		this.transformation.getTranslationVector(center);
		corners.length=8;
		Vector3.add(center,OrientedBoundBox._tempV30,OrientedBoundBox._tempV34);
		Vector3.add(OrientedBoundBox._tempV34,OrientedBoundBox._tempV31,OrientedBoundBox._tempV34);
		Vector3.add(OrientedBoundBox._tempV34,OrientedBoundBox._tempV32,corners[0]);
		Vector3.add(center,OrientedBoundBox._tempV30,OrientedBoundBox._tempV34);
		Vector3.add(OrientedBoundBox._tempV34,OrientedBoundBox._tempV31,OrientedBoundBox._tempV34);
		Vector3.subtract(OrientedBoundBox._tempV34,OrientedBoundBox._tempV32,corners[1]);
		Vector3.subtract(center,OrientedBoundBox._tempV30,OrientedBoundBox._tempV34);
		Vector3.add(OrientedBoundBox._tempV34,OrientedBoundBox._tempV31,OrientedBoundBox._tempV34);
		Vector3.subtract(OrientedBoundBox._tempV34,OrientedBoundBox._tempV32,corners[2]);
		Vector3.subtract(center,OrientedBoundBox._tempV30,OrientedBoundBox._tempV34);
		Vector3.add(OrientedBoundBox._tempV34,OrientedBoundBox._tempV31,OrientedBoundBox._tempV34);
		Vector3.add(OrientedBoundBox._tempV34,OrientedBoundBox._tempV32,corners[3]);
		Vector3.add(center,OrientedBoundBox._tempV30,OrientedBoundBox._tempV34);
		Vector3.subtract(OrientedBoundBox._tempV34,OrientedBoundBox._tempV31,OrientedBoundBox._tempV34);
		Vector3.add(OrientedBoundBox._tempV34,OrientedBoundBox._tempV32,corners[4]);
		Vector3.add(center,OrientedBoundBox._tempV30,OrientedBoundBox._tempV34);
		Vector3.subtract(OrientedBoundBox._tempV34,OrientedBoundBox._tempV31,OrientedBoundBox._tempV34);
		Vector3.subtract(OrientedBoundBox._tempV34,OrientedBoundBox._tempV32,corners[5]);
		Vector3.subtract(center,OrientedBoundBox._tempV30,OrientedBoundBox._tempV34);
		Vector3.subtract(OrientedBoundBox._tempV34,OrientedBoundBox._tempV31,OrientedBoundBox._tempV34);
		Vector3.subtract(OrientedBoundBox._tempV34,OrientedBoundBox._tempV32,corners[6]);
		Vector3.subtract(center,OrientedBoundBox._tempV30,OrientedBoundBox._tempV34);
		Vector3.subtract(OrientedBoundBox._tempV34,OrientedBoundBox._tempV31,OrientedBoundBox._tempV34);
		Vector3.add(OrientedBoundBox._tempV34,OrientedBoundBox._tempV32,corners[7]);
	}

	/**
	*变换该包围盒的矩阵信息。
	*@param mat 矩阵
	*/
	__proto.transform=function(mat){
		Matrix4x4.multiply(this.transformation,mat,this.transformation);
	}

	/**
	*缩放该包围盒
	*@param scaling 各轴的缩放比。
	*/
	__proto.scale=function(scaling){
		Vector3.multiply(this.extents,scaling,this.extents);
	}

	/**
	*平移该包围盒。
	*@param translation 平移参数
	*/
	__proto.translate=function(translation){
		this.transformation.getTranslationVector(OrientedBoundBox._tempV30);
		Vector3.add(OrientedBoundBox._tempV30,translation,OrientedBoundBox._tempV31);
		this.transformation.setTranslationVector(OrientedBoundBox._tempV31);
	}

	/**
	*该包围盒的尺寸。
	*@param out 输出
	*/
	__proto.Size=function(out){
		Vector3.scale(this.extents,2,out);
	}

	/**
	*该包围盒需要考虑的尺寸
	*@param out 输出
	*/
	__proto.getSize=function(out){
		var extentsE=this.extents.elements;
		OrientedBoundBox._tempV30.x=extentsE[0];
		OrientedBoundBox._tempV31.y=extentsE[1];
		OrientedBoundBox._tempV32.z=extentsE[2];
		Vector3.TransformNormal(OrientedBoundBox._tempV30,this.transformation,OrientedBoundBox._tempV30);
		Vector3.TransformNormal(OrientedBoundBox._tempV31,this.transformation,OrientedBoundBox._tempV31);
		Vector3.TransformNormal(OrientedBoundBox._tempV31,this.transformation,OrientedBoundBox._tempV32);
		var oe=out.elements;
		oe[0]=Vector3.scalarLength(OrientedBoundBox._tempV30);
		oe[1]=Vector3.scalarLength(OrientedBoundBox._tempV31);
		oe[2]=Vector3.scalarLength(OrientedBoundBox._tempV32);
	}

	/**
	*该包围盒需要考虑尺寸的平方
	*@param out 输出
	*/
	__proto.getSizeSquared=function(out){
		var extentsE=this.extents.elements;
		OrientedBoundBox._tempV30.x=extentsE[0];
		OrientedBoundBox._tempV31.y=extentsE[1];
		OrientedBoundBox._tempV32.z=extentsE[2];
		Vector3.TransformNormal(OrientedBoundBox._tempV30,this.transformation,OrientedBoundBox._tempV30);
		Vector3.TransformNormal(OrientedBoundBox._tempV31,this.transformation,OrientedBoundBox._tempV31);
		Vector3.TransformNormal(OrientedBoundBox._tempV31,this.transformation,OrientedBoundBox._tempV32);
		var oe=out.elements;
		oe[0]=Vector3.scalarLengthSquared(OrientedBoundBox._tempV30);
		oe[1]=Vector3.scalarLengthSquared(OrientedBoundBox._tempV31);
		oe[2]=Vector3.scalarLengthSquared(OrientedBoundBox._tempV32);
	}

	/**
	*该包围盒的几何中心
	*/
	__proto.getCenter=function(center){
		this.transformation.getTranslationVector(center);
	}

	/**
	*该包围盒是否包含空间中一点
	*@param point 点
	*@return 返回位置关系
	*/
	__proto.containsPoint=function(point){
		var extentsE=this.extents.elements;
		var extentsEX=extentsE[0];
		var extentsEY=extentsE[1];
		var extentsEZ=extentsE[2];
		this.transformation.invert(OrientedBoundBox._tempM0);
		Vector3.transformCoordinate(point,OrientedBoundBox._tempM0,OrientedBoundBox._tempV30);
		var _tempV30e=OrientedBoundBox._tempV30.elements;
		var _tempV30ex=Math.abs(_tempV30e[0]);
		var _tempV30ey=Math.abs(_tempV30e[1]);
		var _tempV30ez=Math.abs(_tempV30e[2]);
		if (MathUtils3D.nearEqual(_tempV30ex,extentsEX)&& MathUtils3D.nearEqual(_tempV30ey,extentsEY)&& MathUtils3D.nearEqual(_tempV30ez,extentsEZ))
			return /*laya.d3.math.ContainmentType.Intersects*/2;
		if (_tempV30ex < extentsEX && _tempV30ey < extentsEY && _tempV30ez < extentsEZ)
			return /*laya.d3.math.ContainmentType.Contains*/1;
		else
		return /*laya.d3.math.ContainmentType.Disjoint*/0;
	}

	/**
	*该包围盒是否包含空间中多点
	*@param point 点
	*@return 返回位置关系
	*/
	__proto.containsPoints=function(points){
		var extentse=this.extents.elements;
		var extentsex=extentse[0];
		var extentsey=extentse[1];
		var extentsez=extentse[2];
		this.transformation.invert(OrientedBoundBox._tempM0);
		var containsAll=true;
		var containsAny=false;
		for (var i=0;i < points.length;i++){
			Vector3.transformCoordinate(points[i],OrientedBoundBox._tempM0,OrientedBoundBox._tempV30);
			var _tempV30e=OrientedBoundBox._tempV30.elements;
			var _tempV30ex=Math.abs(_tempV30e[0]);
			var _tempV30ey=Math.abs(_tempV30e[1]);
			var _tempV30ez=Math.abs(_tempV30e[2]);
			if (MathUtils3D.nearEqual(_tempV30ex,extentsex)&& MathUtils3D.nearEqual(_tempV30ey,extentsey)&& MathUtils3D.nearEqual(_tempV30ez,extentsez))
				containsAny=true;
			if (_tempV30ex < extentsex && _tempV30ey < extentsey && _tempV30ez < extentsez)
				containsAny=true;
			else
			containsAll=false;
		}
		if (containsAll)
			return /*laya.d3.math.ContainmentType.Contains*/1;
		else if (containsAny)
		return /*laya.d3.math.ContainmentType.Intersects*/2;
		else
		return /*laya.d3.math.ContainmentType.Disjoint*/0;
	}

	/**
	*该包围盒是否包含空间中一包围球
	*@param sphere 包围球
	*@param ignoreScale 是否考虑该包围盒的缩放
	*@return 返回位置关系
	*/
	__proto.containsSphere=function(sphere,ignoreScale){
		(ignoreScale===void 0)&& (ignoreScale=false);
		var extentsE=this.extents.elements;
		var extentsEX=extentsE[0];
		var extentsEY=extentsE[1];
		var extentsEZ=extentsE[2];
		var sphereR=sphere.radius;
		this.transformation.invert(OrientedBoundBox._tempM0);
		Vector3.transformCoordinate(sphere.center,OrientedBoundBox._tempM0,OrientedBoundBox._tempV30);
		var locRadius=NaN;
		if (ignoreScale){
			locRadius=sphereR;
			}else {
			Vector3.scale(Vector3.UnitX,sphereR,OrientedBoundBox._tempV31);
			Vector3.TransformNormal(OrientedBoundBox._tempV31,OrientedBoundBox._tempM0,OrientedBoundBox._tempV31);
			locRadius=Vector3.scalarLength(OrientedBoundBox._tempV31);
		}
		Vector3.scale(this.extents,-1,OrientedBoundBox._tempV32);
		Vector3.Clamp(OrientedBoundBox._tempV30,OrientedBoundBox._tempV32,this.extents,OrientedBoundBox._tempV33);
		var distance=Vector3.distanceSquared(OrientedBoundBox._tempV30,OrientedBoundBox._tempV33);
		if (distance > locRadius *locRadius)
			return /*laya.d3.math.ContainmentType.Disjoint*/0;
		var tempV30e=OrientedBoundBox._tempV30.elements;
		var tempV30ex=tempV30e[0];
		var tempV30ey=tempV30e[1];
		var tempV30ez=tempV30e[2];
		var tempV32e=OrientedBoundBox._tempV32.elements;
		var tempV32ex=tempV32e[0];
		var tempV32ey=tempV32e[1];
		var tempV32ez=tempV32e[2];
		if ((((tempV32ex+locRadius <=tempV30ex)&& (tempV30ex <=extentsEX-locRadius))&& ((extentsEX-tempV32ex > locRadius)&& (tempV32ey+locRadius <=tempV30ey)))&& (((tempV30ey <=extentsEY-locRadius)&& (extentsEY-tempV32ey > locRadius))&& (((tempV32ez+locRadius <=tempV30ez)&& (tempV30ez <=extentsEZ-locRadius))&& (extentsEZ-tempV32ez > locRadius)))){
			return /*laya.d3.math.ContainmentType.Contains*/1;
		}
		return /*laya.d3.math.ContainmentType.Intersects*/2;
	}

	/**
	*For accuracy,The transformation matrix for both <see cref="OrientedBoundingBox"/> must not have any scaling applied to it.
	*Anyway,scaling using Scale method will keep this method accurate.
	*该包围盒是否包含空间中另一OBB包围盒
	*@param obb OBB包围盒
	*@return 返回位置关系
	*/
	__proto.containsOrientedBoundBox=function(obb){
		var i=0,k=0;
		obb.getCorners(OrientedBoundBox._corners);
		var cornersCheck=this.containsPoints(OrientedBoundBox._corners);
		if (cornersCheck !=/*laya.d3.math.ContainmentType.Disjoint*/0)
			return cornersCheck;
		var sizeAe=this.extents.elements;
		obb.extents.cloneTo(OrientedBoundBox._tempV35);
		var sizeBe=OrientedBoundBox._tempV35.elements;
		OrientedBoundBox._getRows(this.transformation,OrientedBoundBox._rows1);
		OrientedBoundBox._getRows(obb.transformation,OrientedBoundBox._rows2);
		var extentA=NaN,extentB=NaN,separation=NaN,dotNumber=NaN;
		for (i=0;i < 4;i++){
			for (k=0;k < 4;k++){
				if (i==3 || k==3){
					OrientedBoundBox._tempM0.setElementByRowColumn(i,k,0);
					OrientedBoundBox._tempM1.setElementByRowColumn(i,k,0);
					}else {
					dotNumber=Vector3.dot(OrientedBoundBox._rows1[i],OrientedBoundBox._rows2[k]);
					OrientedBoundBox._tempM0.setElementByRowColumn(i,k,dotNumber);
					OrientedBoundBox._tempM1.setElementByRowColumn(i,k,Math.abs(dotNumber));
				}
			}
		}
		obb.getCenter(OrientedBoundBox._tempV34);
		this.getCenter(OrientedBoundBox._tempV36);
		Vector3.subtract(OrientedBoundBox._tempV34,OrientedBoundBox._tempV36,OrientedBoundBox._tempV30);
		var vsepAe=OrientedBoundBox._tempV31.elements;
		vsepAe[0]=Vector3.dot(OrientedBoundBox._tempV30,OrientedBoundBox._rows1[0]);
		vsepAe[1]=Vector3.dot(OrientedBoundBox._tempV30,OrientedBoundBox._rows1[1]);
		vsepAe[2]=Vector3.dot(OrientedBoundBox._tempV30,OrientedBoundBox._rows1[2]);
		var _tempV32e=OrientedBoundBox._tempV32.elements;
		var _tempV33e=OrientedBoundBox._tempV33.elements;
		for (i=0;i < 3;i++){
			_tempV32e[0]=OrientedBoundBox._tempM1.getElementByRowColumn(i,0);
			_tempV32e[1]=OrientedBoundBox._tempM1.getElementByRowColumn(i,1);
			_tempV32e[2]=OrientedBoundBox._tempM1.getElementByRowColumn(i,2);
			extentA=sizeAe[i];
			extentB=Vector3.dot(OrientedBoundBox._tempV35,OrientedBoundBox._tempV32);
			separation=Math.abs(vsepAe[i]);
			if (separation > extentA+extentB)
				return /*laya.d3.math.ContainmentType.Disjoint*/0;
		}
		for (k=0;k < 3;k++){
			_tempV32e[0]=OrientedBoundBox._tempM1.getElementByRowColumn(0,k);
			_tempV32e[1]=OrientedBoundBox._tempM1.getElementByRowColumn(1,k);
			_tempV32e[2]=OrientedBoundBox._tempM1.getElementByRowColumn(2,k);
			_tempV33e[0]=OrientedBoundBox._tempM0.getElementByRowColumn(0,k);
			_tempV33e[1]=OrientedBoundBox._tempM0.getElementByRowColumn(1,k);
			_tempV33e[2]=OrientedBoundBox._tempM0.getElementByRowColumn(2,k);
			extentA=Vector3.dot(this.extents,OrientedBoundBox._tempV32);
			extentB=sizeBe[k];
			separation=Math.abs(Vector3.dot(OrientedBoundBox._tempV31,OrientedBoundBox._tempV33));
			if (separation > extentA+extentB)
				return /*laya.d3.math.ContainmentType.Disjoint*/0;
		}
		for (i=0;i < 3;i++){
			for (k=0;k < 3;k++){
				var i1=(i+1)% 3,i2=(i+2)% 3;
				var k1=(k+1)% 3,k2=(k+2)% 3;
				extentA=sizeAe[i1] *OrientedBoundBox._tempM1.getElementByRowColumn(i2,k)+sizeAe[i2] *OrientedBoundBox._tempM1.getElementByRowColumn(i1,k);
				extentB=sizeBe[k1] *OrientedBoundBox._tempM1.getElementByRowColumn(i,k2)+sizeBe[k2] *OrientedBoundBox._tempM1.getElementByRowColumn(i,k1);
				separation=Math.abs(vsepAe[i2] *OrientedBoundBox._tempM0.getElementByRowColumn(i1,k)-vsepAe[i1] *OrientedBoundBox._tempM0.getElementByRowColumn(i2,k));
				if (separation > extentA+extentB)
					return /*laya.d3.math.ContainmentType.Disjoint*/0;
			}
		}
		return /*laya.d3.math.ContainmentType.Intersects*/2;
	}

	/**
	*该包围盒是否包含空间中一条线
	*@param point1 点1
	*@param point2 点2
	*@return 返回位置关系
	*/
	__proto.containsLine=function(point1,point2){
		OrientedBoundBox._corners[0]=point1;
		OrientedBoundBox._corners[1]=point2;
		var cornersCheck=this.containsPoints(OrientedBoundBox._corners);
		if (cornersCheck !=/*laya.d3.math.ContainmentType.Disjoint*/0)
			return cornersCheck;
		var extentsE=this.extents.elements;
		var extentsX=extentsE[0];
		var extentsY=extentsE[1];
		var extentsZ=extentsE[2];
		this.transformation.invert(OrientedBoundBox._tempM0);
		Vector3.transformCoordinate(point1,OrientedBoundBox._tempM0,OrientedBoundBox._tempV30);
		Vector3.transformCoordinate(point2,OrientedBoundBox._tempM0,OrientedBoundBox._tempV31);
		Vector3.add(OrientedBoundBox._tempV30,OrientedBoundBox._tempV31,OrientedBoundBox._tempV32);
		Vector3.scale(OrientedBoundBox._tempV32,0.5,OrientedBoundBox._tempV32);
		Vector3.subtract(OrientedBoundBox._tempV30,OrientedBoundBox._tempV32,OrientedBoundBox._tempV33);
		var _tempV33e=OrientedBoundBox._tempV33.elements;
		var _tempV33X=_tempV33e[0];
		var _tempV33Y=_tempV33e[1];
		var _tempV33Z=_tempV33e[2];
		var _tempV34e=OrientedBoundBox._tempV34.elements;
		var _tempV34X=_tempV34e[0]=Math.abs(_tempV33e[0]);
		var _tempV34Y=_tempV34e[1]=Math.abs(_tempV33e[1]);
		var _tempV34Z=_tempV34e[2]=Math.abs(_tempV33e[2]);
		var _tempV32e=OrientedBoundBox._tempV32.elements;
		var _tempV32X=_tempV32e[0];
		var _tempV32Y=_tempV32e[1];
		var _tempV32Z=_tempV32e[2];
		if (Math.abs(_tempV32X)> extentsX+_tempV34X)
			return /*laya.d3.math.ContainmentType.Disjoint*/0;
		if (Math.abs(_tempV32Y)> extentsY+_tempV34Y)
			return /*laya.d3.math.ContainmentType.Disjoint*/0;
		if (Math.abs(_tempV32Z)> extentsZ+_tempV34Z)
			return /*laya.d3.math.ContainmentType.Disjoint*/0;
		if (Math.abs(_tempV32Y *_tempV33Z-_tempV32Z *_tempV33Y)> (extentsY *_tempV34Z+extentsZ *_tempV34Y))
			return /*laya.d3.math.ContainmentType.Disjoint*/0;
		if (Math.abs(_tempV32X *_tempV33Z-_tempV32Z *_tempV33X)> (extentsX *_tempV34Z+extentsZ *_tempV34X))
			return /*laya.d3.math.ContainmentType.Disjoint*/0;
		if (Math.abs(_tempV32X *_tempV33Y-_tempV32Y *_tempV33X)> (extentsX *_tempV34Y+extentsY *_tempV34X))
			return /*laya.d3.math.ContainmentType.Disjoint*/0;
		return /*laya.d3.math.ContainmentType.Intersects*/2;
	}

	/**
	*该包围盒是否包含空间中另一OBB包围盒
	*@param box 包围盒
	*@return 返回位置关系
	*/
	__proto.containsBoundBox=function(box){
		var i=0,k=0;
		var min=box.min;
		var max=box.max;
		box.getCorners(OrientedBoundBox._corners);
		var cornersCheck=this.containsPoints(OrientedBoundBox._corners);
		if (cornersCheck !=/*laya.d3.math.ContainmentType.Disjoint*/0)
			return cornersCheck;
		Vector3.subtract(max,min,OrientedBoundBox._tempV30);
		Vector3.scale(OrientedBoundBox._tempV30,0.5,OrientedBoundBox._tempV30);
		Vector3.add(min,OrientedBoundBox._tempV30,OrientedBoundBox._tempV30);
		Vector3.subtract(max,OrientedBoundBox._tempV30,OrientedBoundBox._tempV31);
		var sizeAe=this.extents.elements;
		var sizeBe=OrientedBoundBox._tempV31.elements;
		OrientedBoundBox._getRows(this.transformation,OrientedBoundBox._rows1);
		this.transformation.invert(OrientedBoundBox._tempM0);
		var extentA=NaN,extentB=NaN,separation=NaN,dotNumber=NaN;
		for (i=0;i < 3;i++){
			for (k=0;k < 3;k++){
				OrientedBoundBox._tempM1.setElementByRowColumn(i,k,Math.abs(OrientedBoundBox._tempM0.getElementByRowColumn(i,k)));
			}
		}
		this.getCenter(OrientedBoundBox._tempV35);
		Vector3.subtract(OrientedBoundBox._tempV30,OrientedBoundBox._tempV35,OrientedBoundBox._tempV32);
		var vsepAe=OrientedBoundBox._tempV31.elements;
		vsepAe[0]=Vector3.dot(OrientedBoundBox._tempV32,OrientedBoundBox._rows1[0]);
		vsepAe[1]=Vector3.dot(OrientedBoundBox._tempV32,OrientedBoundBox._rows1[1]);
		vsepAe[2]=Vector3.dot(OrientedBoundBox._tempV32,OrientedBoundBox._rows1[2]);
		var _tempV33e=OrientedBoundBox._tempV33.elements;
		var _tempV34e=OrientedBoundBox._tempV34.elements;
		for (i=0;i < 3;i++){
			_tempV33e[0]=OrientedBoundBox._tempM1.getElementByRowColumn(i,0);
			_tempV33e[1]=OrientedBoundBox._tempM1.getElementByRowColumn(i,1);
			_tempV33e[2]=OrientedBoundBox._tempM1.getElementByRowColumn(i,2);
			extentA=sizeAe[i];
			extentB=Vector3.dot(OrientedBoundBox._tempV31,OrientedBoundBox._tempV33);
			separation=Math.abs(vsepAe[i]);
			if (separation > extentA+extentB)
				return /*laya.d3.math.ContainmentType.Disjoint*/0;
		}
		for (k=0;k < 3;k++){
			_tempV33e[0]=OrientedBoundBox._tempM1.getElementByRowColumn(0,k);
			_tempV33e[1]=OrientedBoundBox._tempM1.getElementByRowColumn(1,k);
			_tempV33e[2]=OrientedBoundBox._tempM1.getElementByRowColumn(2,k);
			_tempV34e[0]=OrientedBoundBox._tempM0.getElementByRowColumn(0,k);
			_tempV34e[1]=OrientedBoundBox._tempM0.getElementByRowColumn(1,k);
			_tempV34e[2]=OrientedBoundBox._tempM0.getElementByRowColumn(2,k);
			extentA=Vector3.dot(this.extents,OrientedBoundBox._tempV33);
			extentB=sizeBe[k];
			separation=Math.abs(Vector3.dot(OrientedBoundBox._tempV31,OrientedBoundBox._tempV34));
			if (separation > extentA+extentB)
				return /*laya.d3.math.ContainmentType.Disjoint*/0;
		}
		for (i=0;i < 3;i++){
			for (k=0;k < 3;k++){
				var i1=(i+1)% 3,i2=(i+2)% 3;
				var k1=(k+1)% 3,k2=(k+2)% 3;
				extentA=sizeAe[i1] *OrientedBoundBox._tempM1.getElementByRowColumn(i2,k)+sizeAe[i2] *OrientedBoundBox._tempM1.getElementByRowColumn(i1,k);
				extentB=sizeBe[k1] *OrientedBoundBox._tempM1.getElementByRowColumn(i,k2)+sizeBe[k2] *OrientedBoundBox._tempM1.getElementByRowColumn(i,k1);
				separation=Math.abs(vsepAe[i2] *OrientedBoundBox._tempM0.getElementByRowColumn(i1,k)-vsepAe[i1] *OrientedBoundBox._tempM0.getElementByRowColumn(i2,k));
				if (separation > extentA+extentB)
					return /*laya.d3.math.ContainmentType.Disjoint*/0;
			}
		}
		return /*laya.d3.math.ContainmentType.Intersects*/2;
	}

	/**
	*该包围盒是否与空间中另一射线相交
	*@param ray
	*@param out
	*@return
	*/
	__proto.intersectsRay=function(ray,out){
		Vector3.scale(this.extents,-1,OrientedBoundBox._tempV30);
		this.transformation.invert(OrientedBoundBox._tempM0);
		Vector3.TransformNormal(ray.direction,OrientedBoundBox._tempM0,OrientedBoundBox._ray.direction);
		Vector3.transformCoordinate(ray.origin,OrientedBoundBox._tempM0,OrientedBoundBox._ray.origin);
		OrientedBoundBox._boxBound1.min=OrientedBoundBox._tempV30;
		OrientedBoundBox._boxBound1.max=this.extents;
		var intersects=Collision.intersectsRayAndBoxRP(OrientedBoundBox._ray,OrientedBoundBox._boxBound1,out);
		if (intersects!==-1)
			Vector3.transformCoordinate(out,this.transformation,out);
		return intersects;
	}

	__proto._getLocalCorners=function(corners){
		corners.length=8;
		var extentsE=this.extents.elements;
		OrientedBoundBox._tempV30.x=extentsE[0];
		OrientedBoundBox._tempV31.y=extentsE[1];
		OrientedBoundBox._tempV32.z=extentsE[2];
		Vector3.add(OrientedBoundBox._tempV30,OrientedBoundBox._tempV31,OrientedBoundBox._tempV33);
		Vector3.add(OrientedBoundBox._tempV33,OrientedBoundBox._tempV32,corners[0]);
		Vector3.add(OrientedBoundBox._tempV30,OrientedBoundBox._tempV31,OrientedBoundBox._tempV33);
		Vector3.subtract(OrientedBoundBox._tempV33,OrientedBoundBox._tempV32,corners[1]);
		Vector3.subtract(OrientedBoundBox._tempV31,OrientedBoundBox._tempV30,OrientedBoundBox._tempV33);
		Vector3.subtract(OrientedBoundBox._tempV33,OrientedBoundBox._tempV30,corners[2]);
		Vector3.subtract(OrientedBoundBox._tempV31,OrientedBoundBox._tempV30,OrientedBoundBox._tempV33);
		Vector3.add(OrientedBoundBox._tempV33,OrientedBoundBox._tempV32,corners[3]);
		Vector3.subtract(OrientedBoundBox._tempV30,OrientedBoundBox._tempV31,OrientedBoundBox._tempV33);
		Vector3.add(OrientedBoundBox._tempV33,OrientedBoundBox._tempV32,corners[4]);
		Vector3.subtract(OrientedBoundBox._tempV30,OrientedBoundBox._tempV31,OrientedBoundBox._tempV33);
		Vector3.subtract(OrientedBoundBox._tempV33,OrientedBoundBox._tempV32,corners[5]);
		Vector3.scale(corners[0],-1,corners[6]);
		Vector3.subtract(OrientedBoundBox._tempV32,OrientedBoundBox._tempV30,OrientedBoundBox._tempV33);
		Vector3.subtract(OrientedBoundBox._tempV33,OrientedBoundBox._tempV31,corners[7]);
	}

	/**
	*判断两个包围盒是否相等
	*@param obb obb包围盒
	*@return Boolean
	*/
	__proto.equals=function(obb){
		return this.extents==obb.extents && this.transformation==obb.transformation;
	}

	/**
	*克隆。
	*@param destObject 克隆源。
	*/
	__proto.cloneTo=function(destObject){
		var dest=destObject;
		this.extents.cloneTo(dest.extents);
		this.transformation.cloneTo(dest.transformation);
	}

	OrientedBoundBox.createByBoundBox=function(box,out){
		var min=box.min;
		var max=box.max;
		Vector3.subtract(max,min,OrientedBoundBox._tempV30);
		Vector3.scale(OrientedBoundBox._tempV30,0.5,OrientedBoundBox._tempV30);
		Vector3.add(min,OrientedBoundBox._tempV30,OrientedBoundBox._tempV31);
		Vector3.subtract(max,OrientedBoundBox._tempV31,OrientedBoundBox._tempV32);
		Matrix4x4.translation(OrientedBoundBox._tempV31,OrientedBoundBox._tempM0);
		var extents=OrientedBoundBox._tempV32.clone();
		var transformation=OrientedBoundBox._tempM0.clone();
		out.extents=extents;
		out.transformation=transformation;
	}

	OrientedBoundBox.createByMinAndMaxVertex=function(min,max){
		Vector3.subtract(max,min,OrientedBoundBox._tempV30);
		Vector3.scale(OrientedBoundBox._tempV30,0.5,OrientedBoundBox._tempV30);
		Vector3.add(min,OrientedBoundBox._tempV30,OrientedBoundBox._tempV31);
		Vector3.subtract(max,OrientedBoundBox._tempV31,OrientedBoundBox._tempV32);
		Matrix4x4.translation(OrientedBoundBox._tempV31,OrientedBoundBox._tempM0);
		var obb=new OrientedBoundBox(OrientedBoundBox._tempV32,OrientedBoundBox._tempM0);
		return obb;
	}

	OrientedBoundBox._getRows=function(mat,out){
		out.length=3;
		var mate=mat.elements;
		var row0e=out[0].elements;
		row0e[0]=mate[0];
		row0e[1]=mate[1];
		row0e[2]=mate[2];
		var row1e=out[1].elements;
		row1e[0]=mate[4];
		row1e[1]=mate[5];
		row1e[2]=mate[6];
		var row2e=out[2].elements;
		row2e[0]=mate[8];
		row2e[1]=mate[9];
		row2e[2]=mate[10];
	}

	OrientedBoundBox.getObbtoObbMatrix4x4=function(a,b,noMatrixScaleApplied,out){
		var at=a.transformation;
		var bt=b.transformation;
		if (noMatrixScaleApplied){
			OrientedBoundBox._getRows(at,OrientedBoundBox._rows1);
			OrientedBoundBox._getRows(bt,OrientedBoundBox._rows2);
			for (var i=0;i < 3;i++){
				for (var k=0;k < 3;k++){
					out.setElementByRowColumn(i,k,Vector3.dot(OrientedBoundBox._rows2[i],OrientedBoundBox._rows1[k]));
				}
			}
			b.getCenter(OrientedBoundBox._tempV30);
			a.getCenter(OrientedBoundBox._tempV31);
			Vector3.subtract(OrientedBoundBox._tempV30,OrientedBoundBox._tempV31,OrientedBoundBox._tempV32);
			var AtoBMe=out.elements;
			AtoBMe[12]=Vector3.dot(OrientedBoundBox._tempV32,OrientedBoundBox._rows1[0]);
			AtoBMe[13]=Vector3.dot(OrientedBoundBox._tempV32,OrientedBoundBox._rows1[1]);
			AtoBMe[14]=Vector3.dot(OrientedBoundBox._tempV32,OrientedBoundBox._rows1[2]);
			AtoBMe[15]=1;
			}else {
			at.invert(OrientedBoundBox._tempM0);
			Matrix4x4.multiply(bt,OrientedBoundBox._tempM0,out);
		}
	}

	OrientedBoundBox.merge=function(a,b,noMatrixScaleApplied){
		var ae=a.extents;
		var at=a.transformation;
		OrientedBoundBox.getObbtoObbMatrix4x4(a,b,noMatrixScaleApplied,OrientedBoundBox._tempM0);
		b._getLocalCorners(OrientedBoundBox._corners);
		Vector3.transformCoordinate(OrientedBoundBox._corners[0],OrientedBoundBox._tempM0,OrientedBoundBox._corners[0]);
		Vector3.transformCoordinate(OrientedBoundBox._corners[1],OrientedBoundBox._tempM0,OrientedBoundBox._corners[1]);
		Vector3.transformCoordinate(OrientedBoundBox._corners[2],OrientedBoundBox._tempM0,OrientedBoundBox._corners[2]);
		Vector3.transformCoordinate(OrientedBoundBox._corners[3],OrientedBoundBox._tempM0,OrientedBoundBox._corners[3]);
		Vector3.transformCoordinate(OrientedBoundBox._corners[4],OrientedBoundBox._tempM0,OrientedBoundBox._corners[4]);
		Vector3.transformCoordinate(OrientedBoundBox._corners[5],OrientedBoundBox._tempM0,OrientedBoundBox._corners[5]);
		Vector3.transformCoordinate(OrientedBoundBox._corners[6],OrientedBoundBox._tempM0,OrientedBoundBox._corners[6]);
		Vector3.transformCoordinate(OrientedBoundBox._corners[7],OrientedBoundBox._tempM0,OrientedBoundBox._corners[7]);
		Vector3.scale(ae,-1,OrientedBoundBox._boxBound1.min);
		ae.cloneTo(OrientedBoundBox._boxBound1.max);
		BoundBox.createfromPoints(OrientedBoundBox._corners,OrientedBoundBox._boxBound2);
		BoundBox.merge(OrientedBoundBox._boxBound2,OrientedBoundBox._boxBound1,OrientedBoundBox._boxBound3);
		var box3Min=OrientedBoundBox._boxBound3.min;
		var box3Max=OrientedBoundBox._boxBound3.max;
		Vector3.subtract(box3Max,box3Min,OrientedBoundBox._tempV30);
		Vector3.scale(OrientedBoundBox._tempV30,0.5,OrientedBoundBox._tempV30);
		Vector3.add(box3Min,OrientedBoundBox._tempV30,OrientedBoundBox._tempV32);
		Vector3.subtract(box3Max,OrientedBoundBox._tempV32,ae);
		Vector3.transformCoordinate(OrientedBoundBox._tempV32,at,OrientedBoundBox._tempV33);
	}

	__static(OrientedBoundBox,
	['_tempV30',function(){return this._tempV30=new Vector3();},'_tempV31',function(){return this._tempV31=new Vector3();},'_tempV32',function(){return this._tempV32=new Vector3();},'_tempV33',function(){return this._tempV33=new Vector3();},'_tempV34',function(){return this._tempV34=new Vector3();},'_tempV35',function(){return this._tempV35=new Vector3();},'_tempV36',function(){return this._tempV36=new Vector3();},'_tempM0',function(){return this._tempM0=new Matrix4x4();},'_tempM1',function(){return this._tempM1=new Matrix4x4();},'_corners',function(){return this._corners=/*new vector.<>*/[new Vector3(),new Vector3(),new Vector3(),new Vector3(),new Vector3(),new Vector3(),new Vector3(),new Vector3()];},'_rows1',function(){return this._rows1=/*new vector.<>*/[new Vector3(),new Vector3(),new Vector3()];},'_rows2',function(){return this._rows2=/*new vector.<>*/[new Vector3(),new Vector3(),new Vector3()];},'_ray',function(){return this._ray=new Ray(new Vector3(),new Vector3());},'_boxBound1',function(){return this._boxBound1=new BoundBox(new Vector3(),new Vector3());},'_boxBound2',function(){return this._boxBound2=new BoundBox(new Vector3(),new Vector3());},'_boxBound3',function(){return this._boxBound3=new BoundBox(new Vector3(),new Vector3());}
	]);
	return OrientedBoundBox;
})()


/**
*<code>Plane</code> 类用于创建平面。
*/
//class laya.d3.math.Plane
var Plane=(function(){
	function Plane(normal,d){
		/**平面的向量*/
		this.normal=null;
		/**平面到坐标系原点的距离*/
		this.distance=NaN;
		(d===void 0)&& (d=0);
		this.normal=normal;
		this.distance=d;
	}

	__class(Plane,'laya.d3.math.Plane');
	var __proto=Plane.prototype;
	/**
	*更改平面法线向量的系数，使之成单位长度。
	*/
	__proto.normalize=function(){
		var normalE=this.normal.elements;
		var normalEX=normalE[0];
		var normalEY=normalE[1];
		var normalEZ=normalE[2];
		var magnitude=1 / Math.sqrt(normalEX *normalEX+normalEY *normalEY+normalEZ *normalEZ);
		normalE[0]=normalEX *magnitude;
		normalE[1]=normalEY *magnitude;
		normalE[2]=normalEZ *magnitude;
		this.distance *=magnitude;
	}

	Plane.createPlaneBy3P=function(point1,point2,point3){
		var point1e=point1.elements;
		var point2e=point2.elements;
		var point3e=point3.elements;
		var x1=point2e[0]-point1e[0];
		var y1=point2e[1]-point1e[1];
		var z1=point2e[2]-point1e[2];
		var x2=point3e[0]-point1e[0];
		var y2=point3e[1]-point1e[1];
		var z2=point3e[2]-point1e[2];
		var yz=(y1 *z2)-(z1 *y2);
		var xz=(z1 *x2)-(x1 *z2);
		var xy=(x1 *y2)-(y1 *x2);
		var invPyth=1 / (Math.sqrt((yz *yz)+(xz *xz)+(xy *xy)));
		var x=yz *invPyth;
		var y=xz *invPyth;
		var z=xy *invPyth;
		var TEMPVec3e=Plane._TEMPVec3.elements;
		TEMPVec3e[0]=x;
		TEMPVec3e[1]=y;
		TEMPVec3e[2]=z;
		var d=-((x *point1e[0])+(y *point1e[1])+(z *point1e[2]));
		var plane=new Plane(Plane._TEMPVec3,d);
		return plane;
	}

	Plane.PlaneIntersectionType_Back=0;
	Plane.PlaneIntersectionType_Front=1;
	Plane.PlaneIntersectionType_Intersecting=2;
	__static(Plane,
	['_TEMPVec3',function(){return this._TEMPVec3=new Vector3();}
	]);
	return Plane;
})()


/**
*<code>Quaternion</code> 类用于创建四元数。
*/
//class laya.d3.math.Quaternion
var Quaternion=(function(){
	function Quaternion(x,y,z,w){
		this.elements=new Float32Array(4);
		(x===void 0)&& (x=0);
		(y===void 0)&& (y=0);
		(z===void 0)&& (z=0);
		(w===void 0)&& (w=1);
		this.elements[0]=x;
		this.elements[1]=y;
		this.elements[2]=z;
		this.elements[3]=w;
	}

	__class(Quaternion,'laya.d3.math.Quaternion');
	var __proto=Quaternion.prototype;
	Laya.imps(__proto,{"laya.d3.core.IClone":true})
	/**
	*根据缩放值缩放四元数
	*@param scale 缩放值
	*@param out 输出四元数
	*/
	__proto.scaling=function(scaling,out){
		var e=out.elements;
		var f=this.elements;
		e[0]=f[0] *scaling;
		e[1]=f[1] *scaling;
		e[2]=f[2] *scaling;
		e[3]=f[3] *scaling;
	}

	/**
	*归一化四元数
	*@param out 输出四元数
	*/
	__proto.normalize=function(out){
		var e=out.elements;
		var f=this.elements;
		var x=f[0],y=f[1],z=f[2],w=f[3];
		var len=x *x+y *y+z *z+w *w;
		if (len > 0){
			len=1 / Math.sqrt(len);
			e[0]=x *len;
			e[1]=y *len;
			e[2]=z *len;
			e[3]=w *len;
		}
	}

	/**
	*计算四元数的长度
	*@return 长度
	*/
	__proto.length=function(){
		var f=this.elements;
		var x=f[0],y=f[1],z=f[2],w=f[3];
		return Math.sqrt(x *x+y *y+z *z+w *w);
	}

	/**
	*根据绕X轴的角度旋转四元数
	*@param rad 角度
	*@param out 输出四元数
	*/
	__proto.rotateX=function(rad,out){
		var e=out.elements;
		var f=this.elements;
		rad *=0.5;
		var ax=f[0],ay=f[1],az=f[2],aw=f[3];
		var bx=Math.sin(rad),bw=Math.cos(rad);
		e[0]=ax *bw+aw *bx;
		e[1]=ay *bw+az *bx;
		e[2]=az *bw-ay *bx;
		e[3]=aw *bw-ax *bx;
	}

	/**
	*根据绕Y轴的制定角度旋转四元数
	*@param rad 角度
	*@param out 输出四元数
	*/
	__proto.rotateY=function(rad,out){
		var e=out.elements;
		var f=this.elements;
		rad *=0.5;
		var ax=f[0],ay=f[1],az=f[2],aw=f[3],by=Math.sin(rad),bw=Math.cos(rad);
		e[0]=ax *bw-az *by;
		e[1]=ay *bw+aw *by;
		e[2]=az *bw+ax *by;
		e[3]=aw *bw-ay *by;
	}

	/**
	*根据绕Z轴的制定角度旋转四元数
	*@param rad 角度
	*@param out 输出四元数
	*/
	__proto.rotateZ=function(rad,out){
		var e=out.elements;
		var f=this.elements;
		rad *=0.5;
		var ax=f[0],ay=f[1],az=f[2],aw=f[3],bz=Math.sin(rad),bw=Math.cos(rad);
		e[0]=ax *bw+ay *bz;
		e[1]=ay *bw-ax *bz;
		e[2]=az *bw+aw *bz;
		e[3]=aw *bw-az *bz;
	}

	/**
	*分解四元数到欧拉角（顺序为Yaw、Pitch、Roll），参考自http://xboxforums.create.msdn.com/forums/p/4574/23988.aspx#23988,问题绕X轴翻转超过±90度时有，会产生瞬间反转
	*@param quaternion 源四元数
	*@param out 欧拉角值
	*/
	__proto.getYawPitchRoll=function(out){
		Vector3.transformQuat(Vector3.ForwardRH,this,Quaternion.TEMPVector31);
		Vector3.transformQuat(Vector3.Up,this,Quaternion.TEMPVector32);
		var upe=Quaternion.TEMPVector32.elements;
		Quaternion.angleTo(Vector3.ZERO,Quaternion.TEMPVector31,Quaternion.TEMPVector33);
		var anglee=Quaternion.TEMPVector33.elements;
		if (anglee[0]==Math.PI / 2){
			anglee[1]=Quaternion.arcTanAngle(upe[2],upe[0]);
			anglee[2]=0;
			}else if (anglee[0]==-Math.PI / 2){
			anglee[1]=Quaternion.arcTanAngle(-upe[2],-upe[0]);
			anglee[2]=0;
			}else {
			Matrix4x4.createRotationY(-anglee[1],Quaternion.TEMPMatrix0);
			Matrix4x4.createRotationX(-anglee[0],Quaternion.TEMPMatrix1);
			Vector3.transformCoordinate(Quaternion.TEMPVector32,Quaternion.TEMPMatrix0,Quaternion.TEMPVector32);
			Vector3.transformCoordinate(Quaternion.TEMPVector32,Quaternion.TEMPMatrix1,Quaternion.TEMPVector32);
			anglee[2]=Quaternion.arcTanAngle(upe[1],-upe[0]);
		}
		if (anglee[1] <=-Math.PI)
			anglee[1]=Math.PI;
		if (anglee[2] <=-Math.PI)
			anglee[2]=Math.PI;
		if (anglee[1] >=Math.PI && anglee[2] >=Math.PI){
			anglee[1]=0;
			anglee[2]=0;
			anglee[0]=Math.PI-anglee[0];
		};
		var oe=out.elements;
		oe[0]=anglee[1];
		oe[1]=anglee[0];
		oe[2]=anglee[2];
	}

	/**
	*求四元数的逆
	*@param out 输出四元数
	*/
	__proto.invert=function(out){
		var e=out.elements;
		var f=this.elements;
		var a0=f[0],a1=f[1],a2=f[2],a3=f[3];
		var dot=a0 *a0+a1 *a1+a2 *a2+a3 *a3;
		var invDot=dot ? 1.0 / dot :0;
		e[0]=-a0 *invDot;
		e[1]=-a1 *invDot;
		e[2]=-a2 *invDot;
		e[3]=a3 *invDot;
	}

	/**
	*设置四元数为单位算数
	*@param out 输出四元数
	*/
	__proto.identity=function(){
		var e=this.elements;
		e[0]=0;
		e[1]=0;
		e[2]=0;
		e[3]=1;
	}

	/**
	*从Array数组拷贝值。
	*@param array 数组。
	*@param offset 数组偏移。
	*/
	__proto.fromArray=function(array,offset){
		(offset===void 0)&& (offset=0);
		this.elements[0]=array[offset+0];
		this.elements[1]=array[offset+1];
		this.elements[2]=array[offset+2];
		this.elements[3]=array[offset+3];
	}

	/**
	*克隆。
	*@param destObject 克隆源。
	*/
	__proto.cloneTo=function(destObject){
		var i,s,d;
		s=this.elements;
		d=destObject.elements;
		if (s===d){
			return;
		}
		for (i=0;i < 4;++i){
			d[i]=s[i];
		}
	}

	/**
	*克隆。
	*@return 克隆副本。
	*/
	__proto.clone=function(){
		var dest=/*__JS__ */new this.constructor();
		this.cloneTo(dest);
		return dest;
	}

	__proto.equals=function(b){
		var ae=this.elements;
		var be=b.elements;
		return MathUtils3D.nearEqual(ae[0],be[0])&& MathUtils3D.nearEqual(ae[1],be[1])&& MathUtils3D.nearEqual(ae[2],be[2])&& MathUtils3D.nearEqual(ae[3],be[3]);
	}

	/**
	*计算长度的平方。
	*@return 长度的平方。
	*/
	__proto.lengthSquared=function(){
		var x=this.elements[0];
		var y=this.elements[1];
		var z=this.elements[2];
		var w=this.elements[3];
		return (x *x)+(y *y)+(z *z)+(w *w);
	}

	/**
	*获取四元数的x值
	*/
	__getset(0,__proto,'x',function(){
		return this.elements[0];
	});

	/**
	*获取四元数的y值
	*/
	__getset(0,__proto,'y',function(){
		return this.elements[1];
	});

	/**
	*获取四元数的z值
	*/
	__getset(0,__proto,'z',function(){
		return this.elements[2];
	});

	/**
	*获取四元数的w值
	*/
	__getset(0,__proto,'w',function(){
		return this.elements[3];
	});

	Quaternion.createFromYawPitchRoll=function(yaw,pitch,roll,out){
		var halfRoll=roll *0.5;
		var halfPitch=pitch *0.5;
		var halfYaw=yaw *0.5;
		var sinRoll=Math.sin(halfRoll);
		var cosRoll=Math.cos(halfRoll);
		var sinPitch=Math.sin(halfPitch);
		var cosPitch=Math.cos(halfPitch);
		var sinYaw=Math.sin(halfYaw);
		var cosYaw=Math.cos(halfYaw);
		var oe=out.elements;
		oe[0]=(cosYaw *sinPitch *cosRoll)+(sinYaw *cosPitch *sinRoll);
		oe[1]=(sinYaw *cosPitch *cosRoll)-(cosYaw *sinPitch *sinRoll);
		oe[2]=(cosYaw *cosPitch *sinRoll)-(sinYaw *sinPitch *cosRoll);
		oe[3]=(cosYaw *cosPitch *cosRoll)+(sinYaw *sinPitch *sinRoll);
	}

	Quaternion.multiply=function(left,right,out){
		var le=left.elements;
		var re=right.elements;
		var oe=out.elements;
		var lx=le[0];
		var ly=le[1];
		var lz=le[2];
		var lw=le[3];
		var rx=re[0];
		var ry=re[1];
		var rz=re[2];
		var rw=re[3];
		var a=(ly *rz-lz *ry);
		var b=(lz *rx-lx *rz);
		var c=(lx *ry-ly *rx);
		var d=(lx *rx+ly *ry+lz *rz);
		oe[0]=(lx *rw+rx *lw)+a;
		oe[1]=(ly *rw+ry *lw)+b;
		oe[2]=(lz *rw+rz *lw)+c;
		oe[3]=lw *rw-d;
	}

	Quaternion.arcTanAngle=function(x,y){
		if (x==0){
			if (y==1)
				return Math.PI / 2;
			return-Math.PI / 2;
		}
		if (x > 0)
			return Math.atan(y / x);
		if (x < 0){
			if (y > 0)
				return Math.atan(y / x)+Math.PI;
			return Math.atan(y / x)-Math.PI;
		}
		return 0;
	}

	Quaternion.angleTo=function(from,location,angle){
		Vector3.subtract(location,from,Quaternion.TEMPVector30);
		Vector3.normalize(Quaternion.TEMPVector30,Quaternion.TEMPVector30);
		angle.elements[0]=Math.asin(Quaternion.TEMPVector30.y);
		angle.elements[1]=Quaternion.arcTanAngle(-Quaternion.TEMPVector30.z,-Quaternion.TEMPVector30.x);
	}

	Quaternion.createFromAxisAngle=function(axis,rad,out){
		var e=out.elements;
		var f=axis.elements;
		rad=rad *0.5;
		var s=Math.sin(rad);
		e[0]=s *f[0];
		e[1]=s *f[1];
		e[2]=s *f[2];
		e[3]=Math.cos(rad);
	}

	Quaternion.createFromMatrix3x3=function(sou,out){
		var e=out.elements;
		var f=sou.elements;
		var fTrace=f[0]+f[4]+f[8];
		var fRoot;
		if (fTrace > 0.0){
			fRoot=Math.sqrt(fTrace+1.0);
			e[3]=0.5 *fRoot;
			fRoot=0.5 / fRoot;
			e[0]=(f[5]-f[7])*fRoot;
			e[1]=(f[6]-f[2])*fRoot;
			e[2]=(f[1]-f[3])*fRoot;
			}else {
			var i=0;
			if (f[4] > f[0])
				i=1;
			if (f[8] > f[i *3+i])
				i=2;
			var j=(i+1)% 3;
			var k=(i+2)% 3;
			fRoot=Math.sqrt(f[i *3+i]-f[j *3+j]-f[k *3+k]+1.0);
			e[i]=0.5 *fRoot;
			fRoot=0.5 / fRoot;
			e[3]=(f[j *3+k]-f[k *3+j])*fRoot;
			e[j]=(f[j *3+i]+f[i *3+j])*fRoot;
			e[k]=(f[k *3+i]+f[i *3+k])*fRoot;
		}
		return;
	}

	Quaternion.createFromMatrix4x4=function(mat,out){
		var me=mat.elements;
		var oe=out.elements;
		var sqrt;
		var half;
		var scale=me[0]+me[5]+me[10];
		if (scale > 0.0){
			sqrt=Math.sqrt(scale+1.0);
			oe[3]=sqrt *0.5;
			sqrt=0.5 / sqrt;
			oe[0]=(me[6]-me[9])*sqrt;
			oe[1]=(me[8]-me[2])*sqrt;
			oe[2]=(me[1]-me[4])*sqrt;
			}else if ((me[0] >=me[5])&& (me[0] >=me[10])){
			sqrt=Math.sqrt(1.0+me[0]-me[5]-me[10]);
			half=0.5 / sqrt;
			oe[0]=0.5 *sqrt;
			oe[1]=(me[1]+me[4])*half;
			oe[2]=(me[2]+me[8])*half;
			oe[3]=(me[6]-me[9])*half;
			}else if (me[5] > me[10]){
			sqrt=Math.sqrt(1.0+me[5]-me[0]-me[10]);
			half=0.5 / sqrt;
			oe[0]=(me[4]+me[1])*half;
			oe[1]=0.5 *sqrt;
			oe[2]=(me[9]+me[6])*half;
			oe[3]=(me[8]-me[2])*half;
			}else {
			sqrt=Math.sqrt(1.0+me[10]-me[0]-me[5]);
			half=0.5 / sqrt;
			oe[0]=(me[8]+me[2])*half;
			oe[1]=(me[9]+me[6])*half;
			oe[2]=0.5 *sqrt;
			oe[3]=(me[1]-me[4])*half;
		}
	}

	Quaternion.slerp=function(left,right,t,out){
		var a=left.elements;
		var b=right.elements;
		var oe=out.elements;
		var ax=a[0],ay=a[1],az=a[2],aw=a[3],bx=b[0],by=b[1],bz=b[2],bw=b[3];
		var omega,cosom,sinom,scale0,scale1;
		cosom=ax *bx+ay *by+az *bz+aw *bw;
		if (cosom < 0.0){
			cosom=-cosom;
			bx=-bx;
			by=-by;
			bz=-bz;
			bw=-bw;
		}
		if ((1.0-cosom)> 0.000001){
			omega=Math.acos(cosom);
			sinom=Math.sin(omega);
			scale0=Math.sin((1.0-t)*omega)/ sinom;
			scale1=Math.sin(t *omega)/ sinom;
			}else {
			scale0=1.0-t;
			scale1=t;
		}
		oe[0]=scale0 *ax+scale1 *bx;
		oe[1]=scale0 *ay+scale1 *by;
		oe[2]=scale0 *az+scale1 *bz;
		oe[3]=scale0 *aw+scale1 *bw;
		return oe;
	}

	Quaternion.lerp=function(left,right,t,out){
		var e=out.elements;
		var f=left.elements;
		var g=right.elements;
		var ax=f[0],ay=f[1],az=f[2],aw=f[3];
		e[0]=ax+t *(g[0]-ax);
		e[1]=ay+t *(g[1]-ay);
		e[2]=az+t *(g[2]-az);
		e[3]=aw+t *(g[3]-aw);
	}

	Quaternion.add=function(left,right,out){
		var e=out.elements;
		var f=left.elements;
		var g=right.elements;
		e[0]=f[0]+g[0];
		e[1]=f[1]+g[1];
		e[2]=f[2]+g[2];
		e[3]=f[3]+g[3];
	}

	Quaternion.dot=function(left,right){
		var f=left.elements;
		var g=right.elements;
		return f[0] *g[0]+f[1] *g[1]+f[2] *g[2]+f[3] *g[3];
	}

	Quaternion.rotationLookAt=function(forward,up,out){
		Quaternion.lookAt(Vector3.ZERO,forward,up,out);
	}

	Quaternion.lookAt=function(eye,target,up,out){
		Matrix3x3.lookAt(eye,target,up,Quaternion._tempMatrix3x3);
		Quaternion.rotationMatrix(Quaternion._tempMatrix3x3,out);
	}

	Quaternion.invert=function(value,out){
		var vE=value.elements;
		var oE=out.elements;
		var lengthSq=value.lengthSquared();
		if (!MathUtils3D.isZero(lengthSq)){
			lengthSq=1.0 / lengthSq;
			oE[0]=-vE[0] *lengthSq;
			oE[1]=-vE[1] *lengthSq;
			oE[2]=-vE[2] *lengthSq;
			oE[3]=vE[3] *lengthSq;
		}
	}

	Quaternion.rotationMatrix=function(matrix3x3,out){
		var me=matrix3x3.elements;
		var m11=me[0];
		var m12=me[1];
		var m13=me[2];
		var m21=me[3];
		var m22=me[4];
		var m23=me[5];
		var m31=me[6];
		var m32=me[7];
		var m33=me[8];
		var oe=out.elements;
		var sqrt=NaN,half=NaN;
		var scale=m11+m22+m33;
		if (scale > 0){
			sqrt=Math.sqrt(scale+1);
			oe[3]=sqrt *0.5;
			sqrt=0.5 / sqrt;
			oe[0]=(m23-m32)*sqrt;
			oe[1]=(m31-m13)*sqrt;
			oe[2]=(m12-m21)*sqrt;
			}else if ((m11 >=m22)&& (m11 >=m33)){
			sqrt=Math.sqrt(1+m11-m22-m33);
			half=0.5 / sqrt;
			oe[0]=0.5 *sqrt;
			oe[1]=(m12+m21)*half;
			oe[2]=(m13+m31)*half;
			oe[3]=(m23-m32)*half;
			}else if (m22 > m33){
			sqrt=Math.sqrt(1+m22-m11-m33);
			half=0.5 / sqrt;
			oe[0]=(m21+m12)*half;
			oe[1]=0.5 *sqrt;
			oe[2]=(m32+m23)*half;
			oe[3]=(m31-m13)*half;
			}else {
			sqrt=Math.sqrt(1+m33-m11-m22);
			half=0.5 / sqrt;
			oe[0]=(m31+m13)*half;
			oe[1]=(m32+m23)*half;
			oe[2]=0.5 *sqrt;
			oe[3]=(m12-m21)*half;
		}
	}

	Quaternion.DEFAULT=new Quaternion();
	__static(Quaternion,
	['TEMPVector30',function(){return this.TEMPVector30=new Vector3();},'TEMPVector31',function(){return this.TEMPVector31=new Vector3();},'TEMPVector32',function(){return this.TEMPVector32=new Vector3();},'TEMPVector33',function(){return this.TEMPVector33=new Vector3();},'TEMPMatrix0',function(){return this.TEMPMatrix0=new Matrix4x4();},'TEMPMatrix1',function(){return this.TEMPMatrix1=new Matrix4x4();},'_tempMatrix3x3',function(){return this._tempMatrix3x3=new Matrix3x3();},'NAN',function(){return this.NAN=new Quaternion(NaN,NaN,NaN,NaN);}
	]);
	return Quaternion;
})()


/**
*<code>Rand</code> 类用于通过32位无符号整型随机种子创建随机数。
*/
//class laya.d3.math.Rand
var Rand=(function(){
	function Rand(seed){
		this._temp=new Uint32Array(1);
		this.seeds=new Uint32Array(4);
		this.seeds[0]=seed;
		this.seeds[1]=this.seeds[0] *0x6C078965+1;
		this.seeds[2]=this.seeds[1] *0x6C078965+1;
		this.seeds[3]=this.seeds[2] *0x6C078965+1;
	}

	__class(Rand,'laya.d3.math.Rand');
	var __proto=Rand.prototype;
	/**
	*获取无符号32位整形随机数。
	*@return 无符号32位整形随机数。
	*/
	__proto.getUint=function(){
		this._temp[0]=this.seeds[0] ^ (this.seeds[0] << 11);
		this.seeds[0]=this.seeds[1];
		this.seeds[1]=this.seeds[2];
		this.seeds[2]=this.seeds[3];
		this.seeds[3]=(this.seeds[3] ^ (this.seeds[3] >>> 19))^ (this._temp[0] ^ (this._temp[0] >>> 8));
		return this.seeds[3];
	}

	/**
	*获取0到1之间的浮点随机数。
	*@return 0到1之间的浮点随机数。
	*/
	__proto.getFloat=function(){
		this.getUint();
		return (this.seeds[3] & 0x007FFFFF)*(1.0 / 8388607.0);
	}

	/**
	*获取-1到1之间的浮点随机数。
	*@return-1到1之间的浮点随机数。
	*/
	__proto.getSignedFloat=function(){
		return this.getFloat()*2.0-1.0;
	}

	/**
	*设置随机种子。
	*@param seed 随机种子。
	*/
	/**
	*获取随机种子。
	*@return 随机种子。
	*/
	__getset(0,__proto,'seed',function(){
		return this.seeds[0];
		},function(seed){
		this.seeds[0]=seed;
		this.seeds[1]=this.seeds[0] *0x6C078965+1;
		this.seeds[2]=this.seeds[1] *0x6C078965+1;
		this.seeds[3]=this.seeds[2] *0x6C078965+1;
	});

	Rand.getFloatFromInt=function(v){
		return (v & 0x007FFFFF)*(1.0 / 8388607.0)
	}

	Rand.getByteFromInt=function(v){
		return (v & 0x007FFFFF)>>> 15;
	}

	return Rand;
})()


/**
*<code>Rand</code> 类用于通过128位整型种子创建随机数,算法来自:https://github.com/AndreasMadsen/xorshift。
*/
//class laya.d3.math.RandX
var RandX=(function(){
	function RandX(seed){
		/**@private */
		this._state0U=NaN;
		/**@private */
		this._state0L=NaN;
		/**@private */
		this._state1U=NaN;
		/**@private */
		this._state1L=NaN;
		if (!((seed instanceof Array))|| seed.length!==4)
			throw new Error('Rand:Seed must be an array with 4 numbers');
		this._state0U=seed[0] | 0;
		this._state0L=seed[1] | 0;
		this._state1U=seed[2] | 0;
		this._state1L=seed[3] | 0;
	}

	__class(RandX,'laya.d3.math.RandX');
	var __proto=RandX.prototype;
	/**
	*通过2x32位的数组，返回64位的随机数。
	*@return 64位的随机数。
	*/
	__proto.randomint=function(){
		var s1U=this._state0U,s1L=this._state0L;
		var s0U=this._state1U,s0L=this._state1L;
		var sumL=(s0L >>> 0)+(s1L >>> 0);
		var resU=(s0U+s1U+(sumL / 2 >>> 31))>>> 0;
		var resL=sumL >>> 0;
		this._state0U=s0U;
		this._state0L=s0L;
		var t1U=0,t1L=0;
		var t2U=0,t2L=0;
		var a1=23;
		var m1=0xFFFFFFFF << (32-a1);
		t1U=(s1U << a1)| ((s1L & m1)>>> (32-a1));
		t1L=s1L << a1;
		s1U=s1U ^ t1U;
		s1L=s1L ^ t1L;
		t1U=s1U ^ s0U;
		t1L=s1L ^ s0L;
		var a2=18;
		var m2=0xFFFFFFFF >>> (32-a2);
		t2U=s1U >>> a2;
		t2L=(s1L >>> a2)| ((s1U & m2)<< (32-a2));
		t1U=t1U ^ t2U;
		t1L=t1L ^ t2L;
		var a3=5;
		var m3=0xFFFFFFFF >>> (32-a3);
		t2U=s0U >>> a3;
		t2L=(s0L >>> a3)| ((s0U & m3)<< (32-a3));
		t1U=t1U ^ t2U;
		t1L=t1L ^ t2L;
		this._state1U=t1U;
		this._state1L=t1L;
		return [resU,resL];
	}

	/**
	*返回[0,1)之间的随机数。
	*@return
	*/
	__proto.random=function(){
		var t2=this.randomint();
		var t2U=t2[0];
		var t2L=t2[1];
		var eU=0x3FF << (52-32);
		var eL=0;
		var a1=12;
		var m1=0xFFFFFFFF >>> (32-a1);
		var sU=t2U >>> a1;
		var sL=(t2L >>> a1)| ((t2U & m1)<< (32-a1));
		var xU=eU | sU;
		var xL=eL | sL;
		RandX._CONVERTION_BUFFER.setUint32(0,xU,false);
		RandX._CONVERTION_BUFFER.setUint32(4,xL,false);
		var d=/*__JS__ */Rand._CONVERTION_BUFFER.getFloat64(0,false);
		return d-1;
	}

	__static(RandX,
	['_CONVERTION_BUFFER',function(){return this._CONVERTION_BUFFER=new DataView(new ArrayBuffer(8));},'defaultRand',function(){return this.defaultRand=/*__JS__ */new Rand([0,Date.now()/ 65536,0,Date.now()% 65536]);}
	]);
	return RandX;
})()


/**
*<code>Ray</code> 类用于创建射线。
*/
//class laya.d3.math.Ray
var Ray=(function(){
	function Ray(origin,direction){
		/**原点*/
		this.origin=null;
		/**方向*/
		this.direction=null;
		this.origin=origin;
		this.direction=direction;
	}

	__class(Ray,'laya.d3.math.Ray');
	return Ray;
})()


/**
*<code>Vector2</code> 类用于创建二维向量。
*/
//class laya.d3.math.Vector2
var Vector2=(function(){
	function Vector2(x,y){
		this.elements=new Float32Array(2);
		(x===void 0)&& (x=0);
		(y===void 0)&& (y=0);
		var v=this.elements;
		v[0]=x;
		v[1]=y;
	}

	__class(Vector2,'laya.d3.math.Vector2');
	var __proto=Vector2.prototype;
	Laya.imps(__proto,{"laya.d3.core.IClone":true})
	/**
	*从Array数组拷贝值。
	*@param array 数组。
	*@param offset 数组偏移。
	*/
	__proto.fromArray=function(array,offset){
		(offset===void 0)&& (offset=0);
		this.elements[0]=array[offset+0];
		this.elements[1]=array[offset+1];
	}

	/**
	*克隆。
	*@param destObject 克隆源。
	*/
	__proto.cloneTo=function(destObject){
		var destVector2=destObject;
		var destE=destVector2.elements;
		var s=this.elements;
		destE[0]=s[0];
		destE[1]=s[1];
	}

	/**
	*克隆。
	*@return 克隆副本。
	*/
	__proto.clone=function(){
		var destVector2=/*__JS__ */new this.constructor();
		this.cloneTo(destVector2);
		return destVector2;
	}

	/**
	*设置X轴坐标。
	*@param value X轴坐标。
	*/
	/**
	*获取X轴坐标。
	*@return X轴坐标。
	*/
	__getset(0,__proto,'x',function(){
		return this.elements[0];
		},function(value){
		this.elements[0]=value;
	});

	/**
	*设置Y轴坐标。
	*@param value Y轴坐标。
	*/
	/**
	*获取Y轴坐标。
	*@return Y轴坐标。
	*/
	__getset(0,__proto,'y',function(){
		return this.elements[1];
		},function(value){
		this.elements[1]=value;
	});

	Vector2.scale=function(a,b,out){
		var e=out.elements;
		var f=a.elements;
		e[0]=f[0] *b;
		e[1]=f[1] *b;
	}

	__static(Vector2,
	['ZERO',function(){return this.ZERO=new Vector2(0.0,0.0);},'ONE',function(){return this.ONE=new Vector2(1.0,1.0);}
	]);
	return Vector2;
})()


/**
*<code>Vector3</code> 类用于创建三维向量。
*/
//class laya.d3.math.Vector3
var Vector3=(function(){
	function Vector3(x,y,z){
		this.elements=new Float32Array(3);
		(x===void 0)&& (x=0);
		(y===void 0)&& (y=0);
		(z===void 0)&& (z=0);
		var v=this.elements;
		v[0]=x;
		v[1]=y;
		v[2]=z;
	}

	__class(Vector3,'laya.d3.math.Vector3');
	var __proto=Vector3.prototype;
	Laya.imps(__proto,{"laya.d3.core.IClone":true})
	/**
	*从Array数组拷贝值。
	*@param array 数组。
	*@param offset 数组偏移。
	*/
	__proto.fromArray=function(array,offset){
		(offset===void 0)&& (offset=0);
		this.elements[0]=array[offset+0];
		this.elements[1]=array[offset+1];
		this.elements[2]=array[offset+2];
	}

	/**
	*克隆。
	*@param destObject 克隆源。
	*/
	__proto.cloneTo=function(destObject){
		var destVector3=destObject;
		var destE=destVector3.elements;
		var s=this.elements;
		destE[0]=s[0];
		destE[1]=s[1];
		destE[2]=s[2];
	}

	/**
	*克隆。
	*@return 克隆副本。
	*/
	__proto.clone=function(){
		var destVector3=/*__JS__ */new this.constructor();
		this.cloneTo(destVector3);
		return destVector3;
	}

	__proto.toDefault=function(){
		this.elements[0]=0;
		this.elements[1]=0;
		this.elements[2]=0;
	}

	/**
	*设置X轴坐标。
	*@param value X轴坐标。
	*/
	/**
	*获取X轴坐标。
	*@return X轴坐标。
	*/
	__getset(0,__proto,'x',function(){
		return this.elements[0];
		},function(value){
		this.elements[0]=value;
	});

	/**
	*设置Y轴坐标。
	*@param value Y轴坐标。
	*/
	/**
	*获取Y轴坐标。
	*@return Y轴坐标。
	*/
	__getset(0,__proto,'y',function(){
		return this.elements[1];
		},function(value){
		this.elements[1]=value;
	});

	/**
	*设置Z轴坐标。
	*@param value Z轴坐标。
	*/
	/**
	*获取Z轴坐标。
	*@return Z轴坐标。
	*/
	__getset(0,__proto,'z',function(){
		return this.elements[2];
		},function(value){
		this.elements[2]=value;
	});

	Vector3.distanceSquared=function(value1,value2){
		var value1e=value1.elements;
		var value2e=value2.elements;
		var x=value1e[0]-value2e[0];
		var y=value1e[1]-value2e[1];
		var z=value1e[2]-value2e[2];
		return (x *x)+(y *y)+(z *z);
	}

	Vector3.distance=function(value1,value2){
		var value1e=value1.elements;
		var value2e=value2.elements;
		var x=value1e[0]-value2e[0];
		var y=value1e[1]-value2e[1];
		var z=value1e[2]-value2e[2];
		return Math.sqrt((x *x)+(y *y)+(z *z));
	}

	Vector3.min=function(a,b,out){
		var e=out.elements;
		var f=a.elements;
		var g=b.elements
		e[0]=Math.min(f[0],g[0]);
		e[1]=Math.min(f[1],g[1]);
		e[2]=Math.min(f[2],g[2]);
	}

	Vector3.max=function(a,b,out){
		var e=out.elements;
		var f=a.elements;
		var g=b.elements
		e[0]=Math.max(f[0],g[0]);
		e[1]=Math.max(f[1],g[1]);
		e[2]=Math.max(f[2],g[2]);
	}

	Vector3.transformQuat=function(source,rotation,out){
		var destination=out.elements;
		var se=source.elements;
		var re=rotation.elements;
		var x=se[0],y=se[1],z=se[2],qx=re[0],qy=re[1],qz=re[2],qw=re[3],
		ix=qw *x+qy *z-qz *y,iy=qw *y+qz *x-qx *z,iz=qw *z+qx *y-qy *x,iw=-qx *x-qy *y-qz *z;
		destination[0]=ix *qw+iw *-qx+iy *-qz-iz *-qy;
		destination[1]=iy *qw+iw *-qy+iz *-qx-ix *-qz;
		destination[2]=iz *qw+iw *-qz+ix *-qy-iy *-qx;
	}

	Vector3.scalarLength=function(a){
		var f=a.elements;
		var x=f[0],y=f[1],z=f[2];
		return Math.sqrt(x *x+y *y+z *z);
	}

	Vector3.scalarLengthSquared=function(a){
		var f=a.elements;
		var x=f[0],y=f[1],z=f[2];
		return x *x+y *y+z *z;
	}

	Vector3.normalize=function(s,out){
		var se=s.elements;
		var oe=out.elements;
		var x=se[0],y=se[1],z=se[2];
		var len=x *x+y *y+z *z;
		if (len > 0){
			len=1 / Math.sqrt(len);
			oe[0]=se[0] *len;
			oe[1]=se[1] *len;
			oe[2]=se[2] *len;
		}
	}

	Vector3.multiply=function(a,b,out){
		var e=out.elements;
		var f=a.elements;
		var g=b.elements
		e[0]=f[0] *g[0];
		e[1]=f[1] *g[1];
		e[2]=f[2] *g[2];
	}

	Vector3.scale=function(a,b,out){
		var e=out.elements;
		var f=a.elements;
		e[0]=f[0] *b;
		e[1]=f[1] *b;
		e[2]=f[2] *b;
	}

	Vector3.lerp=function(a,b,t,out){
		var e=out.elements;
		var f=a.elements;
		var g=b.elements;
		var ax=f[0],ay=f[1],az=f[2];
		e[0]=ax+t *(g[0]-ax);
		e[1]=ay+t *(g[1]-ay);
		e[2]=az+t *(g[2]-az);
	}

	Vector3.transformV3ToV3=function(vector,transform,result){
		var intermediate=Vector3._tempVector4;
		Vector3.transformV3ToV4(vector,transform,intermediate);
		var intermediateElem=intermediate.elements;
		var resultElem=result.elements;
		resultElem[0]=intermediateElem[0];
		resultElem[1]=intermediateElem[1];
		resultElem[2]=intermediateElem[2];
	}

	Vector3.transformV3ToV4=function(vector,transform,result){
		var vectorElem=vector.elements;
		var vectorX=vectorElem[0];
		var vectorY=vectorElem[1];
		var vectorZ=vectorElem[2];
		var transformElem=transform.elements;
		var resultElem=result.elements;
		resultElem[0]=(vectorX *transformElem[0])+(vectorY *transformElem[4])+(vectorZ *transformElem[8])+transformElem[12];
		resultElem[1]=(vectorX *transformElem[1])+(vectorY *transformElem[5])+(vectorZ *transformElem[9])+transformElem[13];
		resultElem[2]=(vectorX *transformElem[2])+(vectorY *transformElem[6])+(vectorZ *transformElem[10])+transformElem[14];
		resultElem[3]=(vectorX *transformElem[3])+(vectorY *transformElem[7])+(vectorZ *transformElem[11])+transformElem[15];
	}

	Vector3.TransformNormal=function(normal,transform,result){
		var normalElem=normal.elements;
		var normalX=normalElem[0];
		var normalY=normalElem[1];
		var normalZ=normalElem[2];
		var transformElem=transform.elements;
		var resultElem=result.elements;
		resultElem[0]=(normalX *transformElem[0])+(normalY *transformElem[4])+(normalZ *transformElem[8]);
		resultElem[1]=(normalX *transformElem[1])+(normalY *transformElem[5])+(normalZ *transformElem[9]);
		resultElem[2]=(normalX *transformElem[2])+(normalY *transformElem[6])+(normalZ *transformElem[10]);
	}

	Vector3.transformCoordinate=function(coordinate,transform,result){
		var vectorElem=Vector3._tempVector4.elements;
		var coordinateElem=coordinate.elements;
		var coordinateX=coordinateElem[0];
		var coordinateY=coordinateElem[1];
		var coordinateZ=coordinateElem[2];
		var transformElem=transform.elements;
		vectorElem[0]=(coordinateX *transformElem[0])+(coordinateY *transformElem[4])+(coordinateZ *transformElem[8])+transformElem[12];
		vectorElem[1]=(coordinateX *transformElem[1])+(coordinateY *transformElem[5])+(coordinateZ *transformElem[9])+transformElem[13];
		vectorElem[2]=(coordinateX *transformElem[2])+(coordinateY *transformElem[6])+(coordinateZ *transformElem[10])+transformElem[14];
		vectorElem[3]=1.0 / ((coordinateX *transformElem[3])+(coordinateY *transformElem[7])+(coordinateZ *transformElem[11])+transformElem[15]);
		var resultElem=result.elements;
		resultElem[0]=vectorElem[0] *vectorElem[3];
		resultElem[1]=vectorElem[1] *vectorElem[3];
		resultElem[2]=vectorElem[2] *vectorElem[3];
	}

	Vector3.Clamp=function(value,min,max,out){
		var valuee=value.elements;
		var x=valuee[0];
		var y=valuee[1];
		var z=valuee[2];
		var mine=min.elements;
		var mineX=mine[0];
		var mineY=mine[1];
		var mineZ=mine[2];
		var maxe=max.elements;
		var maxeX=maxe[0];
		var maxeY=maxe[1];
		var maxeZ=maxe[2];
		var oute=out.elements;
		x=(x > maxeX)? maxeX :x;
		x=(x < mineX)? mineX :x;
		y=(y > maxeY)? maxeY :y;
		y=(y < mineY)? mineY :y;
		z=(z > maxeZ)? maxeZ :z;
		z=(z < mineZ)? mineZ :z;
		oute[0]=x;
		oute[1]=y;
		oute[2]=z;
	}

	Vector3.add=function(a,b,out){
		var e=out.elements;
		var f=a.elements;
		var g=b.elements
		e[0]=f[0]+g[0];
		e[1]=f[1]+g[1];
		e[2]=f[2]+g[2];
	}

	Vector3.subtract=function(a,b,o){
		var oe=o.elements;
		var ae=a.elements;
		var be=b.elements;
		oe[0]=ae[0]-be[0];
		oe[1]=ae[1]-be[1];
		oe[2]=ae[2]-be[2];
	}

	Vector3.cross=function(a,b,o){
		var ae=a.elements;
		var be=b.elements;
		var oe=o.elements;
		var ax=ae[0],ay=ae[1],az=ae[2],bx=be[0],by=be[1],bz=be[2];
		oe[0]=ay *bz-az *by;
		oe[1]=az *bx-ax *bz;
		oe[2]=ax *by-ay *bx;
	}

	Vector3.dot=function(a,b){
		var ae=a.elements;
		var be=b.elements;
		var r=(ae[0] *be[0])+(ae[1] *be[1])+(ae[2] *be[2]);
		return r;
	}

	Vector3.equals=function(a,b){
		var ae=a.elements;
		var be=b.elements;
		return MathUtils3D.nearEqual(Math.abs(ae[0]),Math.abs(be[0]))&& MathUtils3D.nearEqual(Math.abs(ae[1]),Math.abs(be[1]))&& MathUtils3D.nearEqual(Math.abs(ae[2]),Math.abs(be[2]));
	}

	Vector3.ZERO=new Vector3(0.0,0.0,0.0);
	Vector3.ONE=new Vector3(1.0,1.0,1.0);
	Vector3.NegativeUnitX=new Vector3(-1,0,0);
	Vector3.UnitX=new Vector3(1,0,0);
	Vector3.UnitY=new Vector3(0,1,0);
	Vector3.UnitZ=new Vector3(0,0,1);
	Vector3.ForwardRH=new Vector3(0,0,-1);
	Vector3.ForwardLH=new Vector3(0,0,1);
	Vector3.Up=new Vector3(0,1,0);
	Vector3.NAN=new Vector3(NaN,NaN,NaN);
	__static(Vector3,
	['_tempVector4',function(){return this._tempVector4=new Vector4();}
	]);
	return Vector3;
})()


/**
*<code>Vector4</code> 类用于创建四维向量。
*/
//class laya.d3.math.Vector4
var Vector4=(function(){
	function Vector4(x,y,z,w){
		this.elements=new Float32Array(4);
		(x===void 0)&& (x=0);
		(y===void 0)&& (y=0);
		(z===void 0)&& (z=0);
		(w===void 0)&& (w=0);
		var v=this.elements;
		v[0]=x;
		v[1]=y;
		v[2]=z;
		v[3]=w;
	}

	__class(Vector4,'laya.d3.math.Vector4');
	var __proto=Vector4.prototype;
	Laya.imps(__proto,{"laya.d3.core.IClone":true})
	/**
	*从Array数组拷贝值。
	*@param array 数组。
	*@param offset 数组偏移。
	*/
	__proto.fromArray=function(array,offset){
		(offset===void 0)&& (offset=0);
		this.elements[0]=array[offset+0];
		this.elements[1]=array[offset+1];
		this.elements[2]=array[offset+2];
		this.elements[3]=array[offset+3];
	}

	/**
	*克隆。
	*@param destObject 克隆源。
	*/
	__proto.cloneTo=function(destObject){
		var destVector4=destObject;
		var destE=destVector4.elements;
		var s=this.elements;
		destE[0]=s[0];
		destE[1]=s[1];
		destE[2]=s[2];
		destE[3]=s[3];
	}

	/**
	*克隆。
	*@return 克隆副本。
	*/
	__proto.clone=function(){
		var destVector4=/*__JS__ */new this.constructor();
		this.cloneTo(destVector4);
		return destVector4;
	}

	/**
	*求四维向量的长度。
	*@return 长度。
	*/
	__proto.length=function(){
		return Math.sqrt(this.x *this.x+this.y *this.y+this.z *this.z+this.w *this.w);
	}

	/**
	*求四维向量长度的平方。
	*@return 长度的平方。
	*/
	__proto.lengthSquared=function(){
		return this.x *this.x+this.y *this.y+this.z *this.z+this.w *this.w;
	}

	/**
	*设置X轴坐标。
	*@param value X轴坐标。
	*/
	/**
	*获取X轴坐标。
	*@return X轴坐标。
	*/
	__getset(0,__proto,'x',function(){
		return this.elements[0];
		},function(value){
		this.elements[0]=value;
	});

	/**
	*设置Y轴坐标。
	*@param value Y轴坐标。
	*/
	/**
	*获取Y轴坐标。
	*@return Y轴坐标。
	*/
	__getset(0,__proto,'y',function(){
		return this.elements[1];
		},function(value){
		this.elements[1]=value;
	});

	/**
	*设置Z轴坐标。
	*@param value Z轴坐标。
	*/
	/**
	*获取Z轴坐标。
	*@return Z轴坐标。
	*/
	__getset(0,__proto,'z',function(){
		return this.elements[2];
		},function(value){
		this.elements[2]=value;
	});

	/**
	*设置W轴坐标。
	*@param value W轴坐标。
	*/
	/**
	*获取W轴坐标。
	*@return W轴坐标。
	*/
	__getset(0,__proto,'w',function(){
		return this.elements[3];
		},function(value){
		this.elements[3]=value;
	});

	Vector4.lerp=function(a,b,t,out){
		var e=out.elements;
		var f=a.elements;
		var g=b.elements;
		var ax=f[0],ay=f[1],az=f[2],aw=f[3];
		e[0]=ax+t *(g[0]-ax);
		e[1]=ay+t *(g[1]-ay);
		e[2]=az+t *(g[2]-az);
		e[3]=aw+t *(g[3]-aw);
	}

	Vector4.transformByM4x4=function(vector4,m4x4,out){
		var ve=vector4.elements;
		var vx=ve[0];
		var vy=ve[1];
		var vz=ve[2];
		var vw=ve[3];
		var me=m4x4.elements;
		var oe=out.elements;
		oe[0]=vx *me[0]+vy *me[4]+vz *me[8]+vw *me[12];
		oe[1]=vx *me[1]+vy *me[5]+vz *me[9]+vw *me[13];
		oe[2]=vx *me[2]+vy *me[6]+vz *me[10]+vw *me[14];
		oe[3]=vx *me[3]+vy *me[7]+vz *me[11]+vw *me[15];
	}

	Vector4.equals=function(a,b){
		var ae=a.elements;
		var be=b.elements;
		return MathUtils3D.nearEqual(Math.abs(ae[0]),Math.abs(be[0]))&& MathUtils3D.nearEqual(Math.abs(ae[1]),Math.abs(be[1]))&& MathUtils3D.nearEqual(Math.abs(ae[2]),Math.abs(be[2]))&& MathUtils3D.nearEqual(Math.abs(ae[3]),Math.abs(be[3]));
	}

	Vector4.normalize=function(s,out){
		var se=s.elements;
		var oe=out.elements;
		var len=/*if err,please use iflash.method.xmlLength()*/s.length();
		if (len > 0){
			oe[0]=se[0] *len;
			oe[1]=se[1] *len;
			oe[2]=se[2] *len;
			oe[3]=se[3] *len;
		}
	}

	Vector4.add=function(a,b,out){
		var oe=out.elements;
		var ae=a.elements;
		var be=b.elements;
		oe[0]=ae[0]+be[0];
		oe[1]=ae[1]+be[1];
		oe[2]=ae[2]+be[2];
		oe[3]=ae[3]+be[3];
	}

	Vector4.subtract=function(a,b,out){
		var oe=out.elements;
		var ae=a.elements;
		var be=b.elements;
		oe[0]=ae[0]-be[0];
		oe[1]=ae[1]-be[1];
		oe[2]=ae[2]-be[2];
		oe[3]=ae[3]-be[3];
	}

	Vector4.multiply=function(a,b,out){
		var oe=out.elements;
		var ae=a.elements;
		var be=b.elements;
		oe[0]=ae[0] *be[0];
		oe[1]=ae[1] *be[1];
		oe[2]=ae[2] *be[2];
		oe[3]=ae[3] *be[3];
	}

	Vector4.scale=function(a,b,out){
		var oe=out.elements;
		var ae=a.elements;
		oe[0]=ae[0] *b;
		oe[1]=ae[1] *b;
		oe[2]=ae[2] *b;
		oe[3]=ae[3] *b;
	}

	Vector4.Clamp=function(value,min,max,out){
		var valuee=value.elements;
		var x=valuee[0];
		var y=valuee[1];
		var z=valuee[2];
		var w=valuee[3];
		var mine=min.elements;
		var mineX=mine[0];
		var mineY=mine[1];
		var mineZ=mine[2];
		var mineW=mine[3];
		var maxe=max.elements;
		var maxeX=maxe[0];
		var maxeY=maxe[1];
		var maxeZ=maxe[2];
		var maxeW=maxe[3];
		var oute=out.elements;
		x=(x > maxeX)? maxeX :x;
		x=(x < mineX)? mineX :x;
		y=(y > maxeY)? maxeY :y;
		y=(y < mineY)? mineY :y;
		z=(z > maxeZ)? maxeZ :z;
		z=(z < mineZ)? mineZ :z;
		w=(w > maxeW)? maxeW :w;
		w=(w < mineW)? mineW :w;
		oute[0]=x;
		oute[1]=y;
		oute[2]=z;
		oute[3]=w;
	}

	Vector4.distanceSquared=function(value1,value2){
		var value1e=value1.elements;
		var value2e=value2.elements;
		var x=value1e[0]-value2e[0];
		var y=value1e[1]-value2e[1];
		var z=value1e[2]-value2e[2];
		var w=value1e[3]-value2e[3];
		return (x *x)+(y *y)+(z *z)+(w *w);
	}

	Vector4.distance=function(value1,value2){
		var value1e=value1.elements;
		var value2e=value2.elements;
		var x=value1e[0]-value2e[0];
		var y=value1e[1]-value2e[1];
		var z=value1e[2]-value2e[2];
		var w=value1e[3]-value2e[3];
		return Math.sqrt((x *x)+(y *y)+(z *z)+(w *w));
	}

	Vector4.dot=function(a,b){
		var ae=a.elements;
		var be=b.elements;
		var r=(ae[0] *be[0])+(ae[1] *be[1])+(ae[2] *be[2])+(ae[3] *be[3]);
		return r;
	}

	Vector4.min=function(a,b,out){
		var e=out.elements;
		var f=a.elements;
		var g=b.elements
		e[0]=Math.min(f[0],g[0]);
		e[1]=Math.min(f[1],g[1]);
		e[2]=Math.min(f[2],g[2]);
		e[3]=Math.min(f[3],g[3]);
	}

	Vector4.max=function(a,b,out){
		var e=out.elements;
		var f=a.elements;
		var g=b.elements
		e[0]=Math.max(f[0],g[0]);
		e[1]=Math.max(f[1],g[1]);
		e[2]=Math.max(f[2],g[2]);
		e[3]=Math.max(f[3],g[3]);
	}

	__static(Vector4,
	['ZERO',function(){return this.ZERO=new Vector4();},'ONE',function(){return this.ONE=new Vector4(1.0,1.0,1.0,1.0);},'UnitX',function(){return this.UnitX=new Vector4(1.0,0.0,0.0,0.0);},'UnitY',function(){return this.UnitY=new Vector4(0.0,1.0,0.0,0.0);},'UnitZ',function(){return this.UnitZ=new Vector4(0.0,0.0,1.0,0.0);},'UnitW',function(){return this.UnitW=new Vector4(0.0,0.0,0.0,1.0);}
	]);
	return Vector4;
})()


/**
*<code>Viewport</code> 类用于创建视口。
*/
//class laya.d3.math.Viewport
var Viewport=(function(){
	function Viewport(x,y,width,height){
		/**X轴坐标*/
		//this.x=NaN;
		/**Y轴坐标*/
		//this.y=NaN;
		/**宽度*/
		//this.width=NaN;
		/**高度*/
		//this.height=NaN;
		/**最小深度*/
		//this.minDepth=NaN;
		/**最大深度*/
		//this.maxDepth=NaN;
		this.minDepth=0.0;
		this.maxDepth=1.0;
		this.x=x;
		this.y=y;
		this.width=width;
		this.height=height;
	}

	__class(Viewport,'laya.d3.math.Viewport');
	var __proto=Viewport.prototype;
	/**
	*变换一个三维向量。
	*@param source 源三维向量。
	*@param matrix 变换矩阵。
	*@param vector 输出三维向量。
	*/
	__proto.project=function(source,matrix,out){
		Vector3.transformV3ToV3(source,matrix,out);
		var sourceEleme=source.elements;
		var matrixEleme=matrix.elements;
		var outEleme=out.elements;
		var a=(((sourceEleme[0] *matrixEleme[3])+(sourceEleme[1] *matrixEleme[7]))+(sourceEleme[2] *matrixEleme[11]))+matrixEleme[15];
		if (a!==1.0){
			outEleme[0]=outEleme[0] / a;
			outEleme[1]=outEleme[1] / a;
			outEleme[2]=outEleme[2] / a;
		}
		outEleme[0]=(((outEleme[0]+1.0)*0.5)*this.width)+this.x;
		outEleme[1]=(((-outEleme[1]+1.0)*0.5)*this.height)+this.y;
		outEleme[2]=(outEleme[2] *(this.maxDepth-this.minDepth))+this.minDepth;
	}

	/**
	*反变换一个三维向量。
	*@param source 源三维向量。
	*@param matrix 变换矩阵。
	*@param vector 输出三维向量。
	*/
	__proto.unprojectFromMat=function(source,matrix,out){
		var sourceEleme=source.elements;
		var matrixEleme=matrix.elements;
		var outEleme=out.elements;
		outEleme[0]=(((sourceEleme[0]-this.x)/ (this.width))*2.0)-1.0;
		outEleme[1]=-((((sourceEleme[1]-this.y)/ (this.height))*2.0)-1.0);
		var halfDepth=(this.maxDepth-this.minDepth)/ 2;
		outEleme[2]=(sourceEleme[2]-this.minDepth-halfDepth)/ halfDepth;
		var a=(((outEleme[0] *matrixEleme[3])+(outEleme[1] *matrixEleme[7]))+(outEleme[2] *matrixEleme[11]))+matrixEleme[15];
		Vector3.transformV3ToV3(out,matrix,out);
		if (a!==1.0){
			outEleme[0]=outEleme[0] / a;
			outEleme[1]=outEleme[1] / a;
			outEleme[2]=outEleme[2] / a;
		}
	}

	/**
	*反变换一个三维向量。
	*@param source 源三维向量。
	*@param projection 透视投影矩阵。
	*@param view 视图矩阵。
	*@param world 世界矩阵,可设置为null。
	*@param out 输出向量。
	*/
	__proto.unprojectFromWVP=function(source,projection,view,world,out){
		Matrix4x4.multiply(projection,view,Viewport._tempMatrix4x4);
		(world)&& (Matrix4x4.multiply(Viewport._tempMatrix4x4,world,Viewport._tempMatrix4x4));
		Viewport._tempMatrix4x4.invert(Viewport._tempMatrix4x4);
		this.unprojectFromMat(source,Viewport._tempMatrix4x4,out);
	}

	__static(Viewport,
	['_tempMatrix4x4',function(){return this._tempMatrix4x4=new Matrix4x4();}
	]);
	return Viewport;
})()


/**
*<code>Sky</code> 类用于创建天空的父类，抽象类不允许实例。
*/
//class laya.d3.resource.models.Sky
var Sky=(function(){
	function Sky(){
		/**@private */
		//this.__ownerCamera=null;
		/**@private 透明混合度。 */
		this._alphaBlending=1.0;
		/**@private 颜色强度。 */
		this._colorIntensity=1.0;
		/**@private */
		//this._vertexBuffer=null;
		/**@private */
		//this._indexBuffer=null;
		/**@private */
		//this._sharderNameID=0;
		/**@private */
		//this._shader=null;
		/**@private */
		//this._shaderValue=null;
		/**@private */
		//this._shaderCompile=null;
		/**@private */
		//this._environmentDiffuse=null;
		/**@private */
		//this._environmentSpecular=null;
		;
		this._shaderValue=new ValusArray();
	}

	__class(Sky,'laya.d3.resource.models.Sky');
	var __proto=Sky.prototype;
	/**
	*@private
	*/
	__proto._setEnvironmentDiffuse=function(){
		if (this._environmentDiffuse.loaded){
			this.__ownerCamera._shaderValues.setValue(/*laya.d3.core.BaseCamera.ENVIRONMENTDIFFUSE*/7,this._environmentDiffuse);
			}else {
			this._environmentDiffuse.on(/*laya.events.Event.LOADED*/"loaded",this,this._environmentDiffuseLoaded);
		}
	}

	/**
	*@private
	*/
	__proto._setEnvironmentSpecular=function(){
		if (this._environmentSpecular.loaded){
			var si=this._environmentSpecular['simLodInfo'];
			if (si && (si instanceof Float32Array))
				this.__ownerCamera._shaderValues.setValue(/*laya.d3.core.BaseCamera.SIMLODINFO*/9,si);
			this.__ownerCamera._shaderValues.setValue(/*laya.d3.core.BaseCamera.ENVIRONMENTSPECULAR*/8,this._environmentSpecular);
			}else {
			this._environmentSpecular.on(/*laya.events.Event.LOADED*/"loaded",this,this._environmentSpecularLoaded);
		}
	}

	/**
	*@private
	*/
	__proto._environmentDiffuseLoaded=function(){
		this.__ownerCamera._shaderValues.setValue(/*laya.d3.core.BaseCamera.ENVIRONMENTDIFFUSE*/7,this._environmentDiffuse);
	}

	/**
	*@private
	*/
	__proto._environmentSpecularLoaded=function(){
		var si=this._environmentSpecular['simLodInfo'];
		if (si && (si instanceof Float32Array))
			this.__ownerCamera._shaderValues.setValue(/*laya.d3.core.BaseCamera.SIMLODINFO*/9,si);
		this.__ownerCamera._shaderValues.setValue(/*laya.d3.core.BaseCamera.ENVIRONMENTSPECULAR*/8,this._environmentSpecular);
	}

	/**
	*@private
	*/
	__proto._render=function(state){}
	/**
	*销毁天空。
	*/
	__proto.destroy=function(){
		this.__ownerCamera=null;
	}

	/**
	*@private
	*/
	__getset(0,__proto,'_ownerCamera',null,function(value){
		this.__ownerCamera=value;
		(this._environmentDiffuse)&& (this._setEnvironmentDiffuse());
		(this._environmentSpecular)&& (this._setEnvironmentSpecular());
	});

	/**
	*设置透明混合度。
	*@param value 透明混合度。
	*/
	/**
	*获取透明混合度。
	*@return 透明混合度。
	*/
	__getset(0,__proto,'alphaBlending',function(){
		return this._alphaBlending;
		},function(value){
		this._alphaBlending=value;
		if (this._alphaBlending < 0)
			this._alphaBlending=0;
		if (this._alphaBlending > 1)
			this._alphaBlending=1;
	});

	__getset(0,__proto,'envDiffuseSHBlue',null,function(value){
		this.__ownerCamera._shaderValues.setValue(/*laya.d3.core.BaseCamera.DIFFUSEIRRADMATB*/12,value);
	});

	/**
	*设置颜色强度。
	*@param value 颜色强度。
	*/
	/**
	*获取颜色强度。
	*@return 颜色强度。
	*/
	__getset(0,__proto,'colorIntensity',function(){
		return this._colorIntensity;
		},function(value){
		this._colorIntensity=value;
		if (this._colorIntensity < 0)
			this._colorIntensity=0;
	});

	__getset(0,__proto,'envDiffuseSHGreen',null,function(value){
		this.__ownerCamera._shaderValues.setValue(/*laya.d3.core.BaseCamera.DIFFUSEIRRADMATG*/11,value);
	});

	__getset(0,__proto,'envDiffuseSHRed',null,function(value){
		this.__ownerCamera._shaderValues.setValue(/*laya.d3.core.BaseCamera.DIFFUSEIRRADMATR*/10,value);
	});

	/**
	*设置环境漫反射贴图。
	*@param value 环境漫反射贴图。
	*/
	/**
	*获取环境漫反射贴图。
	*@return 环境漫反射贴图。
	*/
	__getset(0,__proto,'environmentDiffuse',function(){
		return this._environmentDiffuse;
		},function(value){
		value.minFifter=/*laya.webgl.WebGLContext.NEAREST*/0x2600;
		this._environmentDiffuse=value;
		(this.__ownerCamera)&& (this._setEnvironmentDiffuse());
	});

	/**
	*设置环境高光贴图。
	*@param value 环境高光贴图。
	*/
	/**
	*获取环境高光贴图。
	*@return 环境高光贴图。
	*/
	__getset(0,__proto,'environmentSpecular',function(){
		return this._environmentSpecular;
		},function(value){
		this._environmentSpecular=value;
		(this.__ownerCamera)&& (this._setEnvironmentSpecular());
	});

	Sky.MVPMATRIX=0;
	Sky.INTENSITY=1;
	Sky.ALPHABLENDING=2;
	Sky.DIFFUSETEXTURE=3;
	return Sky;
})()


/**
*<code>SubMesh</code> 类用于创建子网格数据模板。
*/
//class laya.d3.resource.models.SubMesh
var SubMesh=(function(){
	function SubMesh(mesh){
		/**@private */
		this._mesh=null;
		/**@private */
		this._boneIndicesList=null;
		/**@private */
		this._subIndexBufferStart=null;
		/**@private */
		this._subIndexBufferCount=null;
		/**@private */
		this._skinAnimationDatas=null;
		/**@private */
		this._bufferUsage=null;
		/**@private */
		this._indexInMesh=0;
		/**@private */
		this._vertexBuffer=null;
		/**@private */
		this._vertexStart=0;
		/**@private */
		this._vertexCount=0;
		/**@private */
		this._indexBuffer=null;
		/**@private */
		this._indexStart=0;
		/**@private */
		this._indexCount=0;
		/**@private */
		this._indices=null;
		this._bufferUsage={};
		this._mesh=mesh;
		this._boneIndicesList=[];
		this._subIndexBufferStart=[];
		this._subIndexBufferCount=[];
	}

	__class(SubMesh,'laya.d3.resource.models.SubMesh');
	var __proto=SubMesh.prototype;
	Laya.imps(__proto,{"laya.d3.core.render.IRenderable":true,"laya.resource.IDispose":true})
	/**
	*@private
	*/
	__proto._getVertexBuffer=function(index){
		(index===void 0)&& (index=0);
		if (index===0)
			return this._vertexBuffer;
		else
		return null;
	}

	/**
	*@private
	*/
	__proto._getIndexBuffer=function(){
		return this._indexBuffer;
	}

	/**
	*@private
	*/
	__proto._getStaticBatchBakedVertexs=function(batchOwnerTransform,owner){
		var byteSizeInFloat=4;
		var vertexBuffer=this._vertexBuffer;
		var vertexDeclaration=vertexBuffer.vertexDeclaration;
		var positionOffset=vertexDeclaration.getVertexElementByUsage(/*laya.d3.graphics.VertexElementUsage.POSITION0*/0).offset / byteSizeInFloat;
		var normalOffset=vertexDeclaration.getVertexElementByUsage(/*laya.d3.graphics.VertexElementUsage.NORMAL0*/3).offset / byteSizeInFloat;
		var lightmapScaleOffset=owner.meshRender.lightmapScaleOffset;
		var i=0,n=0,bakedVertexes,bakedVertexFloatCount=0,lightingMapTexcoordOffset=0,uv1Element;
		var uv0Offset=0,oriVertexFloatCount=0;
		if (lightmapScaleOffset){
			uv1Element=vertexDeclaration.getVertexElementByUsage(/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE1*/15);
			if (uv1Element){
				bakedVertexFloatCount=vertexDeclaration.vertexStride / byteSizeInFloat;
				if (this._vertexCount > 0)
					bakedVertexes=vertexBuffer.getData().slice(this._vertexStart *bakedVertexFloatCount,(this._vertexStart+this._vertexCount)*bakedVertexFloatCount);
				else
				bakedVertexes=vertexBuffer.getData().slice();
				lightingMapTexcoordOffset=uv1Element.offset / byteSizeInFloat;
				}else {
				oriVertexFloatCount=vertexDeclaration.vertexStride / byteSizeInFloat;
				bakedVertexFloatCount=oriVertexFloatCount+2;
				if (this._vertexCount)
					bakedVertexes=new Float32Array(this._vertexCount *(vertexBuffer.vertexDeclaration.vertexStride / byteSizeInFloat+2));
				else
				bakedVertexes=new Float32Array(vertexBuffer.vertexCount *(vertexBuffer.vertexDeclaration.vertexStride / byteSizeInFloat+2));
				uv0Offset=vertexDeclaration.getVertexElementByUsage(/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE0*/2).offset / byteSizeInFloat;
				lightingMapTexcoordOffset=uv0Offset+2;
				var oriVertexes=vertexBuffer.getData();
				for (i=0,n=oriVertexes.length / oriVertexFloatCount;i < n;i++){
					var oriVertexOffset=0;
					if (this._vertexCount > 0)
						oriVertexOffset=(this._vertexStart+i)*oriVertexFloatCount;
					else
					oriVertexOffset=i *oriVertexFloatCount;
					var bakedVertexOffset=i *bakedVertexFloatCount;
					var j=0;
					for (j=0;j < lightingMapTexcoordOffset;j++)
					bakedVertexes[bakedVertexOffset+j]=oriVertexes[oriVertexOffset+j];
					for (j=lightingMapTexcoordOffset;j < oriVertexFloatCount;j++)
					bakedVertexes[bakedVertexOffset+j+2]=oriVertexes[oriVertexOffset+j];
				}
			}
			}else {
			bakedVertexFloatCount=vertexDeclaration.vertexStride / byteSizeInFloat;
			if (this._vertexCount)
				bakedVertexes=vertexBuffer.getData().slice(this._vertexStart *bakedVertexFloatCount,(this._vertexStart+this._vertexCount)*bakedVertexFloatCount);
			else
			bakedVertexes=vertexBuffer.getData().slice();
		}
		if (batchOwnerTransform){
			var rootMat=batchOwnerTransform.worldMatrix;
			var rootInvertMat=SubMesh._tempMatrix4x40;
			rootMat.invert(rootInvertMat);
			var result=SubMesh._tempMatrix4x41;
			var transform=owner.transform.worldMatrix;
			Matrix4x4.multiply(rootInvertMat,transform,result);
			}else {
			result=owner.transform.worldMatrix;
		};
		var rotation=SubMesh._tempQuaternion0;
		result.decomposeTransRotScale(SubMesh._tempVector30,rotation,SubMesh._tempVector31);
		for (i=0,n=bakedVertexes.length / bakedVertexFloatCount;i < n;i++){
			var posOffset=i *bakedVertexFloatCount+positionOffset;
			var norOffset=i *bakedVertexFloatCount+normalOffset;
			Utils3D.transformVector3ArrayToVector3ArrayCoordinate(bakedVertexes,posOffset,result,bakedVertexes,posOffset);
			Utils3D.transformVector3ArrayByQuat(bakedVertexes,norOffset,rotation,bakedVertexes,norOffset);
			if (lightmapScaleOffset){
				var lightingMapTexOffset=i *bakedVertexFloatCount+lightingMapTexcoordOffset;
				if (uv1Element){
					Utils3D.transformLightingMapTexcoordByUV1Array(bakedVertexes,lightingMapTexOffset,lightmapScaleOffset,bakedVertexes,lightingMapTexOffset);
					}else {
					var tex0Offset=i *oriVertexFloatCount+uv0Offset;
					Utils3D.transformLightingMapTexcoordByUV0Array(oriVertexes,tex0Offset,lightmapScaleOffset,bakedVertexes,lightingMapTexOffset);
				}
			}
		}
		return bakedVertexes;
	}

	/**
	*@private
	*/
	__proto._getVertexBuffers=function(){
		return null;
	}

	/**
	*@private
	*/
	__proto._beforeRender=function(state){
		this._vertexBuffer._bind();
		this._indexBuffer._bind();
		return true;
	}

	/**
	*@private
	*渲染。
	*@param state 渲染状态。
	*/
	__proto._render=function(state){
		var skinAnimationDatas;
		var indexCount=0;
		var renderElement=state.renderElement;
		if (this._indexCount > 1){
			var boneIndicesListCount=this._boneIndicesList.length;
			if (boneIndicesListCount > 1){
				for (var i=0;i < boneIndicesListCount;i++){
					skinAnimationDatas=renderElement._skinAnimationDatas || this._skinAnimationDatas;
					if (skinAnimationDatas){
						renderElement._shaderValue.setValue(/*laya.d3.core.SkinnedMeshSprite3D.BONES*/0,skinAnimationDatas[i]);
						state._shader.uploadRenderElementUniforms(renderElement._shaderValue.data);
					}
					WebGL.mainContext.drawElements(/*laya.webgl.WebGLContext.TRIANGLES*/0x0004,this._subIndexBufferCount[i],/*laya.webgl.WebGLContext.UNSIGNED_SHORT*/0x1403,this._subIndexBufferStart[i] *2);
				}
				Stat.drawCall+=boneIndicesListCount;
				}else {
				skinAnimationDatas=renderElement._skinAnimationDatas || this._skinAnimationDatas;
				if (skinAnimationDatas){
					renderElement._shaderValue.setValue(/*laya.d3.core.SkinnedMeshSprite3D.BONES*/0,skinAnimationDatas[0]);
					state._shader.uploadRenderElementUniforms(renderElement._shaderValue.data);
				}
				WebGL.mainContext.drawElements(/*laya.webgl.WebGLContext.TRIANGLES*/0x0004,this._indexCount,/*laya.webgl.WebGLContext.UNSIGNED_SHORT*/0x1403,this._indexStart *2);
				Stat.drawCall++;
			}
			indexCount=this._indexCount;
			}else {
			indexCount=this._indexBuffer.indexCount;
			skinAnimationDatas=renderElement._skinAnimationDatas || this._skinAnimationDatas;
			if (skinAnimationDatas){
				renderElement._shaderValue.setValue(/*laya.d3.core.SkinnedMeshSprite3D.BONES*/0,skinAnimationDatas[0]);
				state._shader.uploadRenderElementUniforms(renderElement._shaderValue.data);
			}
			WebGL.mainContext.drawElements(/*laya.webgl.WebGLContext.TRIANGLES*/0x0004,indexCount,/*laya.webgl.WebGLContext.UNSIGNED_SHORT*/0x1403,0);
			Stat.drawCall++;
		}
		Stat.trianglesFaces+=indexCount / 3;
	}

	/**
	*@private
	*/
	__proto.getIndices=function(){
		if (this._indexCount > 0)
			return this._indices;
		else
		return this._indexBuffer.getData();
	}

	/**
	*<p>彻底清理资源。</p>
	*<p><b>注意：</b>会强制解锁清理。</p>
	*/
	__proto.dispose=function(){
		this._indexBuffer.destroy();
		this._vertexBuffer.destroy();
		this._mesh=null;
		this._boneIndicesList=null;
		this._subIndexBufferStart=null;
		this._subIndexBufferCount=null;
		this._skinAnimationDatas=null;
		this._bufferUsage=null;
		this._vertexBuffer=null;
		this._indexBuffer=null;
	}

	/**
	*@private
	*/
	__getset(0,__proto,'_vertexBufferCount',function(){
		return 1;
	});

	/**
	*@private
	*/
	__getset(0,__proto,'triangleCount',function(){
		return this._indexBuffer.indexCount / 3;
	});

	__static(SubMesh,
	['_tempVector30',function(){return this._tempVector30=new Vector3();},'_tempVector31',function(){return this._tempVector31=new Vector3();},'_tempQuaternion0',function(){return this._tempQuaternion0=new Quaternion();},'_tempMatrix4x40',function(){return this._tempMatrix4x40=new Matrix4x4();},'_tempMatrix4x41',function(){return this._tempMatrix4x41=new Matrix4x4();}
	]);
	return SubMesh;
})()


/**
*@private
*/
//class laya.d3.shader.ShaderDefines
var ShaderDefines$1=(function(){
	function ShaderDefines(shaderdefines){
		/**@private [只读]*/
		this.defineCounter=0;
		/**@private [只读]*/
		this.defines=null;
		if (shaderdefines){
			this.defineCounter=shaderdefines.defineCounter;
			this.defines=shaderdefines.defines.slice();
			}else {
			this.defineCounter=0;
			this.defines=[];
		}
	}

	__class(ShaderDefines,'laya.d3.shader.ShaderDefines',null,'ShaderDefines$1');
	var __proto=ShaderDefines.prototype;
	/**
	*@private
	*/
	__proto.registerDefine=function(name){
		var value=Math.pow(2,this.defineCounter++);
		this.defines[value]=name;
		return value;
	}

	return ShaderDefines;
})()


/**
*@private
*<code>ShaderInit</code> 类用于初始化内置Shader。
*/
//class laya.d3.shader.ShaderInit3D
var ShaderInit3D=(function(){
	/**
	*创建一个 <code>ShaderInit</code> 实例。
	*/
	function ShaderInit3D(){}
	__class(ShaderInit3D,'laya.d3.shader.ShaderInit3D');
	ShaderInit3D.__init__=function(){
		ShaderCompile3D._globalRegDefine("HIGHPRECISION",ShaderCompile3D.SHADERDEFINE_HIGHPRECISION);
		ShaderCompile3D._globalRegDefine("FOG",ShaderCompile3D.SHADERDEFINE_FOG);
		ShaderCompile3D._globalRegDefine("DIRECTIONLIGHT",ShaderCompile3D.SHADERDEFINE_DIRECTIONLIGHT);
		ShaderCompile3D._globalRegDefine("POINTLIGHT",ShaderCompile3D.SHADERDEFINE_POINTLIGHT);
		ShaderCompile3D._globalRegDefine("SPOTLIGHT",ShaderCompile3D.SHADERDEFINE_SPOTLIGHT);
		ShaderCompile3D._globalRegDefine("UV",ShaderCompile3D.SHADERDEFINE_UV0);
		ShaderCompile3D._globalRegDefine("COLOR",ShaderCompile3D.SHADERDEFINE_COLOR);
		ShaderCompile3D._globalRegDefine("UV1",ShaderCompile3D.SHADERDEFINE_UV1);
		ShaderCompile3D._globalRegDefine("CASTSHADOW",ParallelSplitShadowMap.SHADERDEFINE_CAST_SHADOW);
		ShaderCompile3D._globalRegDefine("SHADOWMAP_PSSM1",ParallelSplitShadowMap.SHADERDEFINE_SHADOW_PSSM1);
		ShaderCompile3D._globalRegDefine("SHADOWMAP_PSSM2",ParallelSplitShadowMap.SHADERDEFINE_SHADOW_PSSM2);
		ShaderCompile3D._globalRegDefine("SHADOWMAP_PSSM3",ParallelSplitShadowMap.SHADERDEFINE_SHADOW_PSSM3);
		ShaderCompile3D._globalRegDefine("SHADOWMAP_PCF_NO",ParallelSplitShadowMap.SHADERDEFINE_SHADOW_PCF_NO);
		ShaderCompile3D._globalRegDefine("SHADOWMAP_PCF1",ParallelSplitShadowMap.SHADERDEFINE_SHADOW_PCF1);
		ShaderCompile3D._globalRegDefine("SHADOWMAP_PCF2",ParallelSplitShadowMap.SHADERDEFINE_SHADOW_PCF2);
		ShaderCompile3D._globalRegDefine("SHADOWMAP_PCF3",ParallelSplitShadowMap.SHADERDEFINE_SHADOW_PCF3);
		ShaderCompile3D._globalRegDefine("DEPTHFOG",ShaderCompile3D.SAHDERDEFINE_DEPTHFOG);
		Shader3D.addInclude("LightHelper.glsl","\nstruct DirectionLight\n{\n vec3 Direction;\n vec3 Diffuse;\n};\n\nstruct PointLight\n{\n vec3 Diffuse;\n vec3 Attenuation;\n vec3 Position;\n float Range;\n};\n\nstruct SpotLight\n{\n vec3 Diffuse;\n vec3 Attenuation;\n vec3 Position;\n vec3 Direction;\n float Spot;\n float Range;\n};\n\n\nvec3 NormalSampleToWorldSpace(vec3 normalMapSample, vec3 unitNormal, vec3 tangent)\n{\n	vec3 normalT = 2.0*normalMapSample - 1.0;\n\n	// Build orthonormal basis.\n	vec3 N = normalize(unitNormal);\n	vec3 T = normalize(tangent- dot(tangent, N)*N);\n	vec3 B = cross(T, N);\n\n	mat3 TBN = mat3(T, B, N);\n\n	// Transform from tangent space to world space.\n	vec3 bumpedNormal = TBN*normalT;\n\n	return bumpedNormal;\n}\n\n\nvoid  computeDirectionLight(in vec3 matDif,in vec3 matAmb,in vec4 matSpe,in DirectionLight dirLight,in vec3 ambinentColor,in vec3 normal,in vec3 toEye,out vec3 dif,out vec3 amb,out vec3 spec)\n{\n	dif=vec3(0.0);//不初始化在IOS中闪烁，PC中不会闪烁\n	amb=vec3(0.0);\n	spec=vec3(0.0);\n	vec3 lightVec=-normalize(dirLight.Direction);\n	\n	amb=matAmb*ambinentColor;\n	\n	float  diffuseFactor=dot(lightVec, normal);\n	\n	if(diffuseFactor>0.0)\n	{\n	   vec3 v = reflect(-lightVec, normal);\n	   float specFactor = pow(max(dot(v, toEye), 0.0), matSpe.w);\n	   \n	   dif = diffuseFactor * matDif * dirLight.Diffuse;\n	   spec = specFactor * matSpe.rgb;\n	}\n	\n}\n\nvoid computePointLight(in vec3 matDif,in vec3 matAmb,in vec4 matSpe,in PointLight poiLight,in vec3 ambinentColor, in vec3 pos,in vec3 normal,in vec3 toEye,out vec3 dif,out vec3 amb,out vec3 spec)\n{\n	dif=vec3(0.0);\n	amb=vec3(0.0);\n	spec=vec3(0.0);\n	vec3 lightVec = poiLight.Position - pos;\n		\n	float d = length(lightVec);\n	\n	if( d > poiLight.Range )\n		return;\n		\n	lightVec /= d; \n	\n	amb = matAmb*ambinentColor;	\n\n	float diffuseFactor = dot(lightVec, normal);\n\n	if( diffuseFactor > 0.0 )\n	{\n		vec3 v= reflect(-lightVec, normal);\n		float specFactor = pow(max(dot(v, toEye), 0.0), matSpe.w);\n					\n		dif = diffuseFactor * matDif * poiLight.Diffuse;\n		spec = specFactor * matSpe.rgb;\n	}\n\n	float attenuate = 1.0 / dot(poiLight.Attenuation, vec3(1.0, d, d*d));\n\n	dif *= attenuate;\n	spec*= attenuate;\n}\n\nvoid ComputeSpotLight(in vec3 matDif,in vec3 matAmb,in vec4 matSpe,in SpotLight spoLight,in vec3 ambinentColor,in vec3 pos, in vec3 normal,in vec3 toEye,out vec3 dif,out vec3 amb,out vec3 spec)\n{\n	amb = vec3(0.0);\n	dif =vec3(0.0);\n	spec= vec3(0.0);\n	vec3 lightVec = spoLight.Position - pos;\n		\n	float d = length(lightVec);\n	\n	if( d > spoLight.Range)\n		return;\n		\n	lightVec /= d; \n	\n	amb = matAmb*ambinentColor;	\n\n	float diffuseFactor = dot(lightVec, normal);\n\n	if(diffuseFactor > 0.0)\n	{\n		vec3 v= reflect(-lightVec, normal);\n		float specFactor = pow(max(dot(v, toEye), 0.0), matSpe.w);\n					\n		dif = diffuseFactor * matDif * spoLight.Diffuse;\n		spec = specFactor * matSpe.rgb;\n	}\n	\n	float spot = pow(max(dot(-lightVec, normalize(spoLight.Direction)), 0.0), spoLight.Spot);\n\n	float attenuate = spot/dot(spoLight.Attenuation, vec3(1.0, d, d*d));\n\n	amb *= spot;\n	dif *= attenuate;\n	spec*= attenuate;\n}\n\n");
		Shader3D.addInclude("Lighting.glsl","\nstruct DirectionLight\n{\n	vec3 Color;\n	vec3 Direction;\n};\n\nstruct PointLight\n{\n	vec3 Color;\n	vec3 Position;\n	float Range;\n};\n\nstruct SpotLight\n{\n	vec3 Color;\n	vec3 Position;\n	vec3 Direction;\n	float Spot;\n	float Range;\n};\n\n// U3D中使用衰减纹理,此函数模拟并非正确\n//float U3DAttenuation(in vec3 L,in float invLightRadius)\n//{\n//	float fRatio = clamp(length(L) * invLightRadius,0.0,1.0);\n//	fRatio *= fRatio;\n//	return 1.0 / (1.0 + 25.0 * fRatio)* clamp(4.0*(1.0 - fRatio),0.0,1.0); //fade to black as if 4 pixel texture\n//} \n\n// Same as Just Cause 2 and Crysis 2 (you can read GPU Pro 1 book for more information)\nfloat BasicAttenuation(in vec3 L,in float invLightRadius)\n{\n	vec3 distance = L * invLightRadius;\n	float attenuation = clamp(1.0 - dot(distance, distance),0.0,1.0); // Equals float attenuation = saturate(1.0f - dot(L, L) / (lightRadius *  lightRadius)); 	\n	return attenuation * attenuation;\n} \n\n// Inspired on http://fools.slindev.com/viewtopic.php?f=11&t=21&view=unread#unread	\nfloat NaturalAttenuation(in vec3 L,in float invLightRadius)\n{\n	float attenuationFactor = 30.0;\n	vec3 distance = L * invLightRadius;\n	float attenuation = dot(distance, distance); // Equals float attenuation = dot(L, L) / (lightRadius *  lightRadius);\n	attenuation = 1.0 / (attenuation * attenuationFactor + 1.0);\n	// Second we move down the function therewith it reaches zero at abscissa 1:\n	attenuationFactor = 1.0 / (attenuationFactor + 1.0); //attenuationFactor contains now the value we have to subtract\n	attenuation = max(attenuation - attenuationFactor, 0.0); // The max fixes a bug.\n	// Finally we expand the equation along the y-axis so that it starts with a function value of 1 again.\n	attenuation /= 1.0 - attenuationFactor;\n	return attenuation;\n} \n\nvoid LayaAirBlinnPhongLight (in vec3 specColor,in float specColorIntensity,in vec3 normal,in vec3 gloss, in vec3 viewDir,in vec3 lightColor, in vec3 lightVec,out vec3 diffuseColor,out vec3 specularColor)\n{\n    mediump vec3 h = normalize(viewDir-lightVec);\n    lowp float ln = max (0.0, dot (-lightVec,normal));\n    float nh = max (0.0, dot (h,normal));\n	diffuseColor=lightColor * ln;\n	specularColor=lightColor *specColor*pow (nh, specColorIntensity*128.0) * gloss;\n}\n\nvoid LayaAirBlinnPhongDiectionLight (in vec3 specColor,in float specColorIntensity,in vec3 normal,in vec3 gloss, in vec3 viewDir, in DirectionLight light,out vec3 diffuseColor,out vec3 specularColor)\n{\n	vec3 lightVec=normalize(light.Direction);\n	LayaAirBlinnPhongLight(specColor,specColorIntensity,normal,gloss,viewDir,light.Color,lightVec,diffuseColor,specularColor);\n}\n\nvoid LayaAirBlinnPhongPointLight (in vec3 pos,in vec3 specColor,in float specColorIntensity,in vec3 normal,in vec3 gloss, in vec3 viewDir, in PointLight light,out vec3 diffuseColor,out vec3 specularColor)\n{\n	vec3 lightVec =  pos-light.Position;\n	//if( length(lightVec) > light.Range )\n	//	return;\n	LayaAirBlinnPhongLight(specColor,specColorIntensity,normal,gloss,viewDir,light.Color,lightVec/length(lightVec),diffuseColor,specularColor);\n	float attenuate = BasicAttenuation(lightVec, 1.0/light.Range);\n	diffuseColor *= attenuate;\n	specularColor*= attenuate;\n}\n\nvoid LayaAirBlinnPhongSpotLight (in vec3 pos,in vec3 specColor,in float specColorIntensity,in vec3 normal,in vec3 gloss, in vec3 viewDir, in SpotLight light,out vec3 diffuseColor,out vec3 specularColor)\n{\n	vec3 lightVec =  pos-light.Position;\n	//if( length(lightVec) > light.Range )\n	//	return;\n	vec3 normalLightVec=lightVec/length(lightVec);\n	LayaAirBlinnPhongLight(specColor,specColorIntensity,normal,gloss,viewDir,light.Color,normalLightVec,diffuseColor,specularColor);\n	float spot = pow(max(dot(normalLightVec, normalize(light.Direction)), 0.0), light.Spot);\n	float attenuate = spot*BasicAttenuation(lightVec, 1.0/light.Range);\n	diffuseColor *= attenuate;\n	specularColor*= attenuate;\n}\n\nvec3 NormalSampleToWorldSpace(vec3 normalMapSample, vec3 unitNormal, vec3 tangent,vec3 binormal)\n{\n	vec3 normalT =vec3(2.0*normalMapSample.x - 1.0,1.0-2.0*normalMapSample.y,2.0*normalMapSample.z - 1.0);\n	\n	// Build orthonormal basis.\n	vec3 N = normalize(unitNormal);\n	vec3 T = normalize(tangent);\n	vec3 B = normalize(binormal);\n	mat3 TBN = mat3(T, B, N);\n	\n	// Transform from tangent space to world space.\n	vec3 bumpedNormal = TBN*normalT;\n\n	return bumpedNormal;\n}\n\n\n");
		Shader3D.addInclude("ShadowHelper.glsl","uniform sampler2D u_shadowMap1;\nuniform sampler2D u_shadowMap2;\nuniform sampler2D u_shadowMap3;\nuniform vec2	  u_shadowPCFoffset;\nuniform vec4     u_shadowPSSMDistance;\nvec4 packDepth(const in float depth)\n{\n	const vec4 bitShift = vec4(256.0*256.0*256.0, 256.0*256.0, 256.0, 1.0);\n	const vec4 bitMask	= vec4(0.0, 1.0/256.0, 1.0/256.0, 1.0/256.0);\n	vec4 res = mod(depth*bitShift*vec4(255), vec4(256))/vec4(255);\n	res -= res.xxyz * bitMask;\n	return res;\n}\nfloat unpackDepth(const in vec4 rgbaDepth)\n{\n	const vec4 bitShift = vec4(1.0/(256.0*256.0*256.0), 1.0/(256.0*256.0), 1.0/256.0, 1.0);\n	float depth = dot(rgbaDepth, bitShift);\n	return depth;\n}\nfloat tex2DPCF( sampler2D shadowMap,vec2 texcoord,vec2 invsize,float zRef )\n{\n	vec2 texelpos =texcoord / invsize;\n	vec2 lerps = fract( texelpos );\n	float sourcevals[4];\n	sourcevals[0] = float( unpackDepth(texture2D(shadowMap,texcoord)) > zRef );\n	sourcevals[1] = float( unpackDepth(texture2D(shadowMap,texcoord + vec2(invsize.x,0))) > zRef );\n	sourcevals[2] = float( unpackDepth(texture2D(shadowMap,texcoord + vec2(0,invsize.y))) > zRef );\n	sourcevals[3] = float( unpackDepth(texture2D(shadowMap,texcoord + vec2(invsize.x, invsize.y) )) > zRef );\n	return mix( mix(sourcevals[0],sourcevals[2],lerps.y),mix(sourcevals[1],sourcevals[3],lerps.y),lerps.x );\n}\nfloat getShadowPSSM3( sampler2D shadowMap1,sampler2D shadowMap2,sampler2D shadowMap3,mat4 lightShadowVP[4],vec4 pssmDistance,vec2 shadowPCFOffset,vec3 worldPos,float posViewZ,float zBias )\n{\n	float value = 1.0;\n	int nPSNum = int(posViewZ>pssmDistance.x);\n	nPSNum += int(posViewZ>pssmDistance.y);\n	nPSNum += int(posViewZ>pssmDistance.z);\n	//真SB,webgl不支持在PS中直接访问数组\n	mat4 lightVP;\n	if( nPSNum == 0 )\n	{\n		lightVP = lightShadowVP[1];\n	}\n	else if( nPSNum == 1 )\n	{\n		lightVP = lightShadowVP[2];\n	}\n	else if( nPSNum == 2 )\n	{\n		lightVP = lightShadowVP[3];\n	}\n	vec4 vLightMVPPos = lightVP * vec4(worldPos,1.0);\n	//为了效率，在CPU计算/2.0 + 0.5\n	//vec3 vText = (vLightMVPPos.xyz / vLightMVPPos.w)/2.0 + 0.5;\n	vec3 vText = vLightMVPPos.xyz / vLightMVPPos.w;\n	float fMyZ = vText.z - zBias;\n	/*\n	bvec4 bInFrustumVec = bvec4 ( vText.x >= 0.0, vText.x <= 1.0, vText.y >= 0.0, vText.y <= 1.0 );\n	bool bInFrustum = all( bInFrustumVec );\n	bvec2 bFrustumTestVec = bvec2( bInFrustum, fMyZ <= 1.0 );\n	bool bFrustumTest = all( bFrustumTestVec );\n	if ( bFrustumTest ) \n	*/\n	if( fMyZ <= 1.0 )\n	{\n		float zdepth=0.0;\n#ifdef SHADOWMAP_PCF3\n		if ( nPSNum == 0 )\n		{\n			value =  tex2DPCF( shadowMap1, vText.xy,shadowPCFOffset,fMyZ );\n			value += tex2DPCF( shadowMap1, vText.xy+vec2(shadowPCFOffset.xy),shadowPCFOffset,	fMyZ );\n			value += tex2DPCF( shadowMap1, vText.xy+vec2(shadowPCFOffset.x,0),shadowPCFOffset,	fMyZ );\n			value += tex2DPCF( shadowMap1, vText.xy+vec2(0,shadowPCFOffset.y),shadowPCFOffset,	fMyZ );\n			value = value/4.0;\n		} \n		else if( nPSNum == 1 )\n		{\n			value = tex2DPCF( shadowMap2,vText.xy,shadowPCFOffset,fMyZ);\n		}\n		else if( nPSNum == 2 )\n		{\n			vec4 color = texture2D( shadowMap3,vText.xy );\n			zdepth = unpackDepth(color);\n			value = float(fMyZ < zdepth);\n		}\n#endif\n#ifdef SHADOWMAP_PCF2\n		if ( nPSNum == 0 )\n		{\n			value = tex2DPCF( shadowMap1,vText.xy,shadowPCFOffset,fMyZ);\n		}\n		else if( nPSNum == 1 )\n		{\n			value = tex2DPCF( shadowMap2,vText.xy,shadowPCFOffset,fMyZ);\n		}\n		else if( nPSNum == 2 )\n		{\n			vec4 color = texture2D( shadowMap3,vText.xy );\n			zdepth = unpackDepth(color);\n			value = float(fMyZ < zdepth);\n		}\n\n#endif\n#ifdef SHADOWMAP_PCF1\n		if ( nPSNum == 0 )\n		{\n			value = tex2DPCF( shadowMap1,vText.xy,shadowPCFOffset,fMyZ);\n		}\n		else if( nPSNum == 1 )\n		{\n			vec4 color = texture2D( shadowMap2,vText.xy );\n			zdepth = unpackDepth(color);\n			value = float(fMyZ < zdepth);\n		}\n		else if( nPSNum == 2 )\n		{\n			vec4 color = texture2D( shadowMap3,vText.xy );\n			zdepth = unpackDepth(color);\n			value = float(fMyZ < zdepth);\n		}\n#endif\n#ifdef SHADOWMAP_PCF_NO\n		vec4 color;\n		if ( nPSNum == 0 )\n		{\n			color = texture2D( shadowMap1,vText.xy );\n		}\n		else if( nPSNum == 1 )\n		{\n			color = texture2D( shadowMap2,vText.xy );\n		}\n		else if( nPSNum == 2 )\n		{\n			color = texture2D( shadowMap3,vText.xy );\n		}\n		zdepth = unpackDepth(color);\n		value = float(fMyZ < zdepth);\n#endif\n	}\n	return value;\n}\nfloat getShadowPSSM2( sampler2D shadowMap1,sampler2D shadowMap2,mat4 lightShadowVP[4],vec4 pssmDistance,vec2 shadowPCFOffset,vec3 worldPos,float posViewZ,float zBias )\n{\n	float value = 1.0;\n	int nPSNum = int(posViewZ>pssmDistance.x);\n	nPSNum += int(posViewZ>pssmDistance.y);\n	//真SB,webgl不支持在PS中直接访问数组\n	mat4 lightVP;\n	if( nPSNum == 0 )\n	{\n		lightVP = lightShadowVP[1];\n	}\n	else if( nPSNum == 1 )\n	{\n		lightVP = lightShadowVP[2];\n	}\n	vec4 vLightMVPPos = lightVP * vec4(worldPos,1.0);\n	//为了效率，在CPU计算/2.0 + 0.5\n	//vec3 vText = (vLightMVPPos.xyz / vLightMVPPos.w)/2.0 + 0.5;\n	vec3 vText = vLightMVPPos.xyz / vLightMVPPos.w;\n	float fMyZ = vText.z - zBias;\n	/*\n	bvec4 bInFrustumVec = bvec4 ( vText.x >= 0.0, vText.x <= 1.0, vText.y >= 0.0, vText.y <= 1.0 );\n	bool bInFrustum = all( bInFrustumVec );\n	bvec2 bFrustumTestVec = bvec2( bInFrustum, fMyZ <= 1.0 );\n	bool bFrustumTest = all( bFrustumTestVec );\n	if ( bFrustumTest ) \n	*/\n	if( fMyZ <= 1.0 )\n	{\n		float zdepth=0.0;\n#ifdef SHADOWMAP_PCF3\n		if ( nPSNum == 0 )\n		{\n			value =  tex2DPCF( shadowMap1, vText.xy,shadowPCFOffset,fMyZ );\n			value += tex2DPCF( shadowMap1, vText.xy+vec2(shadowPCFOffset.xy),shadowPCFOffset,	fMyZ );\n			value += tex2DPCF( shadowMap1, vText.xy+vec2(shadowPCFOffset.x,0),shadowPCFOffset,	fMyZ );\n			value += tex2DPCF( shadowMap1, vText.xy+vec2(0,shadowPCFOffset.y),shadowPCFOffset,	fMyZ );\n			value = value/4.0;\n		}\n		else if( nPSNum == 1 )\n		{\n			value = tex2DPCF( shadowMap2,vText.xy,shadowPCFOffset,fMyZ);\n		}\n#endif\n#ifdef SHADOWMAP_PCF2\n		if ( nPSNum == 0 )\n		{\n			value = tex2DPCF( shadowMap1,vText.xy,shadowPCFOffset,fMyZ);\n		}\n		else if( nPSNum == 1 )\n		{\n			value = tex2DPCF( shadowMap2,vText.xy,shadowPCFOffset,fMyZ);\n		}\n#endif\n#ifdef SHADOWMAP_PCF1\n		if ( nPSNum == 0 )\n		{\n			value = tex2DPCF( shadowMap1,vText.xy,shadowPCFOffset,fMyZ);\n		}\n		else if( nPSNum == 1 )\n		{\n			vec4 color = texture2D( shadowMap2,vText.xy );\n			zdepth = unpackDepth(color);\n			value = float(fMyZ < zdepth);\n		}\n#endif\n#ifdef SHADOWMAP_PCF_NO\n		vec4 color;\n		if ( nPSNum == 0 )\n		{\n			color = texture2D( shadowMap1,vText.xy );\n		}\n		else if( nPSNum == 1 )\n		{\n			color = texture2D( shadowMap2,vText.xy );\n		}\n		zdepth = unpackDepth(color);\n		value = float(fMyZ < zdepth);\n#endif\n	}\n	return value;\n}\nfloat getShadowPSSM1( sampler2D shadowMap1,vec4 lightMVPPos,vec4 pssmDistance,vec2 shadowPCFOffset,float posViewZ,float zBias )\n{\n	float value = 1.0;\n	if( posViewZ < pssmDistance.x )\n	{\n		vec3 vText = lightMVPPos.xyz / lightMVPPos.w;\n		float fMyZ = vText.z - zBias;\n		/*\n		bvec4 bInFrustumVec = bvec4 ( vText.x >= 0.0, vText.x <= 1.0, vText.y >= 0.0, vText.y <= 1.0 );\n		bool bInFrustum = all( bInFrustumVec );\n		bvec2 bFrustumTestVec = bvec2( bInFrustum, fMyZ <= 1.0 );\n		bool bFrustumTest = all( bFrustumTestVec );\n		*/\n		if ( fMyZ <= 1.0 ) \n		{\n			float zdepth=0.0;\n#ifdef SHADOWMAP_PCF3\n			value =  tex2DPCF( shadowMap1, vText.xy,shadowPCFOffset,fMyZ );\n			value += tex2DPCF( shadowMap1, vText.xy+vec2(shadowPCFOffset.xy),shadowPCFOffset,fMyZ );\n			value += tex2DPCF( shadowMap1, vText.xy+vec2(shadowPCFOffset.x,0),shadowPCFOffset,fMyZ );\n			value += tex2DPCF( shadowMap1, vText.xy+vec2(0,shadowPCFOffset.y),shadowPCFOffset,fMyZ );\n			value = value/4.0;\n#endif\n#ifdef SHADOWMAP_PCF2		\n			value = tex2DPCF( shadowMap1,vText.xy,shadowPCFOffset,fMyZ);\n#endif\n#ifdef SHADOWMAP_PCF1\n			value = tex2DPCF( shadowMap1,vText.xy,shadowPCFOffset,fMyZ);\n#endif\n#ifdef SHADOWMAP_PCF_NO		\n			vec4 color = texture2D( shadowMap1,vText.xy );\n			zdepth = unpackDepth(color);\n			value = float(fMyZ < zdepth);\n#endif\n		}\n	}\n	return value;\n}");
		Shader3D.addInclude("WaveFunction.glsl","\nuniform vec2 u_WaveInfoD[20];\nuniform vec4 u_WaveInfo[20];\n\nuniform float TEXWAVE_UV_SCALE ;//= 20.0; //每texwidth像素代表的实际距离\n/**\n	这里的计算都是\n*/\n\n/**\n* 计算一个波形\n*  开始计算的时候都按照z向上，最后输出的时候，颠倒一下。\n* @param tm {float} 毫秒\n*/\nvoid calcGerstnerWave(float curtm, vec3 pos, float deep, vec2 uvpos, out vec3 opos, out vec3 B, out vec3 T, out vec3 N, out float foamS){\n	float tm = curtm/1000.;\n	opos = pos;\n	vec3 wpos=vec3(0.);		//累加的位置\n	N=vec3(0.,0.,0.);	//输出的法线初始化一下\n	T=vec3(0.,0.,0.);\n	B=vec3(0.,0.,0.);\n	vec2 cD ;//= D;\n	//float deepAtt = max(0.,min(deep,1.0));\n	//A*=deepAtt; //TODO\n	\n	for( int i=0; i<4; i++){\n		cD = u_WaveInfoD[i];//vec2(wi.winfo[0],wi.winfo[1]);// wi.vDir;\n		float Q = u_WaveInfo[i].x;//wi.QorK;\n		float A = u_WaveInfo[i].y;//wi.A;\n		float W = u_WaveInfo[i].z;//wi.omega;\n		float P = u_WaveInfo[i].w;//wi.phi;\n		float dop = dot(cD,uvpos);\n		float c = cos(dop*W - tm*P);//TODO 优化\n		float s = sin(dop*W - tm*P);\n		float AWs = A*W*s;\n		float AWc = A*W*c;\n		float _QxyAWs = -Q*cD.x*cD.y*AWs;\n		\n		wpos += vec3(Q*A*cD.x*c,\n					Q*A*cD.y*c,\n					A*s);\n		N += vec3(-cD.x*AWc,\n				-cD.y*AWc,\n				Q*AWs);//记得最后1-\n		T += vec3(_QxyAWs,\n				Q*cD.y*cD.y*AWs,//记得1-\n				cD.y*AWc\n			);\n		B += vec3(Q*cD.x*cD.x*AWs,//记得1-\n				_QxyAWs,\n				cD.x*AWc\n			);\n		//float v1 = exp(-tan((dop*W - tm*P)/2.+1.07));//除2，+pi/2 这样正好能对齐\n#ifdef USE_FOAM		\n		float v1 = 0.5-sin((dop*W - tm*P)/1.+2.0)/2.;\n		foamS += pow(v1,9.)/4.;\n#endif\n	}\n	T.y=1.-T.y; B.x=1.-B.x;N.z=1.-N.z;\n	opos += vec3(wpos.x,wpos.z*min(deep/10.,1.),wpos.y);\n	//y和z交换一下。现在根据uv计算的位置，所以直接交换yz就行。其他情况下有问题么\n	T.xyz=T.xzy;\n	B.xyz=B.xzy;\n	N.xyz=N.xzy;\n}\n\n\nvoid calcWave(float curtm, vec2 uv, out vec3 B, out vec3 T, out vec3 N){\n	float tm = curtm/1000.;\n	N=vec3(0.,0.,0.);	//输出的法线初始化一下\n	vec2 uvpos = uv*TEXWAVE_UV_SCALE; //TODO 这个范围是什么 就是1？\n	uvpos.y*=-1.;\n	vec2 cD;// = D;\n	const int NumWaves = 4;\n	float scale = 1./float(NumWaves);\n	for( int i=0; i<NumWaves; i++){\n		cD = u_WaveInfoD[i];//vec2(wi.winfo[0],wi.winfo[1]);// wi.vDir;\n		float k = 1.5;//u_WaveInfo[i].x;//wi.QorK; TODO  不知道为什么，这个取u_WaveInfo[i].x，在mi3w上就会闪。测试发现实际值也传过来了，就是1.5\n		float A = u_WaveInfo[i].y;//wi.A;\n		float W = u_WaveInfo[i].z;//wi.omega;\n		float P = u_WaveInfo[i].w;//wi.phi;\n		\n		float dop = dot(cD,uvpos);\n		float c = cos(dop*W - tm*P);//TODO 优化\n		float s = sin(dop*W - tm*P);\n		/*\n		float AWs = A*W*s;\n		float AWc = A*W*c;\n		float _QxyAWs = -Q*cD.x*cD.y*AWs;\n		\n		N += vec3(-cD.x*AWc,\n				-cD.y*AWc,\n				Q*AWs);//记得最后1-\n		*/\n		float kWAc = scale*c;//k*W*A*c;  为了提高精度，这里只保留sin，cos部分，实际使用的时候再乘回来。\n		//float kWAc = k*W*A*c;  \n		N += vec3(\n			-kWAc*cD.x*pow((s+1.)/2.,k-1.),\n			-kWAc*cD.y*pow((s+1.)/2.,k-1.),\n			1.\n		);\n	}\n	//N.z=1.-N.z;\n	//y和z交换一下。现在根据uv计算的位置，所以直接交换yz就行。其他情况下有问题么\n	N.xyz=N.xzy;\n}\n");
		Shader3D.addInclude("BRDF.glsl","vec4 LayaAirBRDF(in vec3 diffuseColor, in vec3 specularColor, in float oneMinusReflectivity, in float smoothness, in vec3 normal, in vec3 viewDir, in vec3 lightDir, in vec3 lightColor, in vec3 gi)\n{\n	float perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness);\n	vec3 halfDir = SafeNormalize(viewDir - lightDir);\n	\n	float nv = abs(dot(normal, viewDir));\n	\n	float nl = clamp(dot(normal,   -lightDir),  0.0, 1.0);\n	float nh = clamp(dot(normal,     halfDir),  0.0, 1.0);\n	float lv = clamp(dot(lightDir,   viewDir),  0.0, 1.0);\n	float lh = clamp(dot(lightDir,  -halfDir),  0.0, 1.0);\n	\n	float diffuseTerm = DisneyDiffuse(nv, nl, lh, perceptualRoughness) * nl;\n	\n	float roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n	\n	//#if UNITY_BRDF_GGX\n	float V = SmithJointGGXVisibilityTerm(nl, nv, roughness);\n	float D = GGXTerm(nh, roughness);\n	\n	float specularTerm = V * D * PI;\n	\n	specularTerm = sqrt(max(0.0001, specularTerm));\n	specularTerm = max(0.0, specularTerm * nl);\n	\n	vec4 color;\n	color.rgb = diffuseColor * (gi + lightColor * diffuseTerm) + specularTerm * lightColor * FresnelTerm (specularColor, lh);\n	\n	color.a = 1.0;\n	return color;\n}");
		Shader3D.addInclude("PBRUtils.glsl","struct DirectionLight\n{\n	vec3 Color;\n	vec3 Direction;\n};\n\nvec3 UnpackScaleNormal(in vec2 uv0)\n{\n	#ifdef NORMALTEXTURE\n		vec3 normalT;\n		vec4 normalMapSample = texture2D(u_NormalTexture, uv0);\n		normalT.x = 2.0 * normalMapSample.x - 1.0;\n		normalT.y = 1.0 - 2.0 * normalMapSample.y;\n		normalT.xy *= u_normalScale;\n		normalT.z = sqrt(1.0 - clamp(dot(normalT.xy, normalT.xy), 0.0, 1.0));\n		\n		vec3 T = normalize(v_Tangent);\n		vec3 B = normalize(v_Binormal);\n		vec3 N = normalize(v_Normal);\n		mat3 TBN = mat3(T, B, N);\n		\n		vec3 bumpedNormal = TBN * normalize(normalT);\n		return bumpedNormal;\n	#else\n		return normalize(v_Normal);\n	#endif\n}\n\nvec4 DielectricSpecularColor = vec4(0.220916301, 0.220916301, 0.220916301, 1.0 - 0.220916301);\n\nfloat PI = 3.14159265359;\n\nvec3 FresnelTerm (in vec3 F0, in float cosA)\n{\n	return F0 + (vec3(1.0) - F0) * pow(1.0 - cosA, 5.0);\n}\n\nfloat PerceptualRoughnessToRoughness(in float perceptualRoughness)\n{\n	return perceptualRoughness * perceptualRoughness;\n}\n\nfloat PerceptualRoughnessToSpecularPower(in float perceptualRoughness)\n{\n	float m = PerceptualRoughnessToRoughness(perceptualRoughness);\n	float sq = max(0.0001, m * m);\n	float n = (2.0 / sq) - 2.0;\n	n = max(n, 0.0001);\n	return n;\n}\n\nfloat RoughnessToPerceptualRoughness(in float roughness)\n{\n	return sqrt(roughness);\n}\n\nfloat SmoothnessToRoughness(in float smoothness)\n{\n	return (1.0 - smoothness) * (1.0 - smoothness);\n}\n\nfloat SmoothnessToPerceptualRoughness(in float smoothness)\n{\n	return (1.0 - smoothness);\n}\n\nvec3 SafeNormalize(in vec3 inVec)\n{\n	float dp3 = max(0.001,dot(inVec,inVec));\n	return inVec * (1.0 / sqrt(dp3));\n}\n\nfloat DisneyDiffuse(in float NdotV, in float NdotL, in float LdotH, in float perceptualRoughness)\n{\n	float fd90 = 0.5 + 2.0 * LdotH * LdotH * perceptualRoughness;\n	float lightScatter	= (1.0 + (fd90 - 1.0) * pow(1.0 - NdotL,5.0));\n	float viewScatter	= (1.0 + (fd90 - 1.0) * pow(1.0 - NdotV,5.0));\n\n	return lightScatter * viewScatter;\n}\n\nfloat SmithJointGGXVisibilityTerm (float NdotL, float NdotV, float roughness)\n{\n	float a = roughness;\n	float lambdaV = NdotL * (NdotV * (1.0 - a) + a);\n	float lambdaL = NdotV * (NdotL * (1.0 - a) + a);\n\n	return 0.5 / (lambdaV + lambdaL + 0.00001);\n}\n\nfloat GGXTerm (float NdotH, float roughness)\n{\n	float a2 = roughness * roughness;\n	float d = (NdotH * a2 - NdotH) * NdotH + 1.0;\n	return 0.31830988618 * a2 / (d * d + 0.0000001);\n}\n\nfloat OneMinusReflectivityFromMetallic(in float metallic)\n{\n	float oneMinusDielectricSpec = DielectricSpecularColor.a;\n	return oneMinusDielectricSpec - metallic * oneMinusDielectricSpec;\n}\n\nfloat SpecularStrength(vec3 specular)\n{\n    //(SHADER_TARGET < 30)return specular.r; \n    return max (max (specular.r, specular.g), specular.b);\n}\n\nvec3 DiffuseAndSpecularFromMetallic(in vec3 diffuseColor, in float metallic, out vec3 specularColor, out float oneMinusReflectivity)\n{\n	specularColor = mix(DielectricSpecularColor.rgb, diffuseColor, metallic);\n	oneMinusReflectivity = OneMinusReflectivityFromMetallic(metallic);\n	return diffuseColor * oneMinusReflectivity;\n}\n\nvec3 EnergyConservationBetweenDiffuseAndSpecular(in vec3 diffuseColor, in vec3 specularColor, out float oneMinusReflectivity)\n{\n	oneMinusReflectivity = 1.0 - SpecularStrength(specularColor);\n	return diffuseColor * oneMinusReflectivity;\n}\n\nvec4 Occlusion(in vec2 uv0){\n	#ifdef OCCLUSIONTEXTURE\n		vec4 occlusionTextureColor = texture2D(u_OcclusionTexture, uv0);\n		float occ = occlusionTextureColor.g;\n		float oneMinusT = 1.0 - u_occlusionStrength;\n		float lerpOneTo = oneMinusT + occ * u_occlusionStrength;\n		return occlusionTextureColor * lerpOneTo;\n	#else\n		return vec4(1.0);\n	#endif\n}\n\nvec2 ParallaxOffset(in vec3 viewDir){\n	#ifdef PARALLAXTEXTURE\n		float h = texture2D(u_ParallaxTexture, v_Texcoord0).g;\n		h = h * u_parallaxScale - u_parallaxScale / 2.0;\n		vec3 v = viewDir;\n		v.z += 0.42;\n		vec2 offset = h * (v.xy / v.z);\n		return v_Texcoord0 + offset;\n	#else\n		return v_Texcoord0;\n	#endif\n}\n\n");
		Shader3D.addInclude("PBRStandardLighting.glsl","#include \"PBRUtils.glsl\"\n#include \"BRDF.glsl\"\n\nvec4 PBRStandardLight(in vec3 diffuseColor, in float metallic, in float smoothness, in vec3 normal, in vec3 viewDir, in vec3 lightDir, in vec3 lightColor, in vec3 gi)\n{\n	float oneMinusReflectivity;\n	vec3 specularColor;\n	diffuseColor = DiffuseAndSpecularFromMetallic (diffuseColor, metallic, specularColor, oneMinusReflectivity);\n	\n	vec4 color = LayaAirBRDF(diffuseColor, specularColor, oneMinusReflectivity, smoothness, normal, viewDir, lightDir, lightColor, gi);\n	return color;\n}\n\nvec4 PBRStandardDiectionLight (in vec3 diffuseColor, in float metallic, in float smoothness, in vec3 normal, in vec3 viewDir, in DirectionLight light, in vec3 gi)\n{\n	vec3 lightVec = normalize(light.Direction);\n	return PBRStandardLight(diffuseColor, metallic, smoothness, normal, viewDir, lightVec, light.Color, gi);\n}\n\nvec2 MetallicGloss(in float diffuseTextureAlpha, in vec2 uv0)\n{\n	vec2 mg;\n	\n	#ifdef METALLICGLOSSTEXTURE\n		vec4 metallicGlossTextureColor = texture2D(u_MetallicGlossTexture, uv0);\n		#ifdef SMOOTHNESSSOURCE_DIFFUSETEXTURE_ALPHA\n			mg.r = metallicGlossTextureColor.r;\n			mg.g = diffuseTextureAlpha;\n		#else\n		    mg = metallicGlossTextureColor.ra;\n		#endif\n		mg.g *= u_smoothnessScale;\n	#else\n		mg.r = u_metallic;\n		#ifdef SMOOTHNESSSOURCE_DIFFUSETEXTURE_ALPHA\n			mg.g = diffuseTextureAlpha * u_smoothnessScale;\n		#else\n			mg.g = u_smoothness;\n		#endif\n	#endif\n	\n	return mg;\n}\n\n");
		Shader3D.addInclude("PBRSpecularLighting.glsl","#include \"PBRUtils.glsl\"\n#include \"BRDF.glsl\"\n\nvec4 PBRSpecularLight(in vec3 diffuseColor, in vec3 specularColor, in float smoothness, in vec3 normal, in vec3 viewDir, in vec3 lightDir, in vec3 lightColor, in vec3 gi)\n{\n	float oneMinusReflectivity;\n	diffuseColor = EnergyConservationBetweenDiffuseAndSpecular (diffuseColor, specularColor, oneMinusReflectivity);\n	\n	vec4 color = LayaAirBRDF(diffuseColor, specularColor, oneMinusReflectivity, smoothness, normal, viewDir, lightDir, lightColor, gi);\n	return color;\n}\n\nvec4 PBRSpecularDiectionLight (in vec3 diffuseColor, in vec3 specularColor, in float smoothness, in vec3 normal, in vec3 viewDir, in DirectionLight light, in vec3 gi)\n{\n	vec3 lightVec = normalize(light.Direction);\n	return PBRSpecularLight(diffuseColor, specularColor, smoothness, normal, viewDir, lightVec, light.Color, gi);\n}\n\nvec4 SpecularGloss(float diffuseTextureAlpha, in vec2 uv0)\n{\n    vec4 sg;\n	\n	#ifdef SPECULARTEXTURE\n		vec4 specularTextureColor = texture2D(u_SpecularTexture, uv0);\n		#ifdef SMOOTHNESSSOURCE_DIFFUSETEXTURE_ALPHA\n			sg.rgb = specularTextureColor.rgb;\n			sg.a = diffuseTextureAlpha;\n		#else\n			sg = specularTextureColor;\n		#endif\n		sg.a *= u_smoothnessScale;\n	#else\n		sg.rgb = u_SpecularColor.rgb;\n		#ifdef SMOOTHNESSSOURCE_DIFFUSETEXTURE_ALPHA\n			sg.a = diffuseTextureAlpha * u_smoothnessScale;\n		#else\n			sg.a = u_smoothness;\n		#endif\n	#endif\n	\n    return sg;\n}\n\n");
		var vs,ps;
		var attributeMap={
			'a_Position':/*laya.d3.graphics.VertexElementUsage.POSITION0*/0,
			'a_Color':/*laya.d3.graphics.VertexElementUsage.COLOR0*/1,
			'a_Normal':/*laya.d3.graphics.VertexElementUsage.NORMAL0*/3,
			'a_Texcoord0':/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE0*/2,
			'a_Texcoord1':/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE1*/15,
			'a_BoneWeights':/*laya.d3.graphics.VertexElementUsage.BLENDWEIGHT0*/7,
			'a_BoneIndices':/*laya.d3.graphics.VertexElementUsage.BLENDINDICES0*/6,
			'a_Tangent0':/*laya.d3.graphics.VertexElementUsage.TANGENT0*/5};
		var uniformMap={
			'u_Bones':[ /*laya.d3.core.SkinnedMeshSprite3D.BONES*/0,/*laya.d3.shader.Shader3D.PERIOD_RENDERELEMENT*/0],
			'u_DiffuseTexture':[ /*laya.d3.core.material.BlinnPhongMaterial.ALBEDOTEXTURE*/1,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_SpecularTexture':[ /*laya.d3.core.material.BlinnPhongMaterial.SPECULARTEXTURE*/3,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_NormalTexture':[ /*laya.d3.core.material.BlinnPhongMaterial.NORMALTEXTURE*/2,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_ReflectTexture':[ /*laya.d3.core.material.BlinnPhongMaterial.REFLECTTEXTURE*/5,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_AlphaTestValue':[ /*laya.d3.core.material.BaseMaterial.ALPHATESTVALUE*/0,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_DiffuseColor':[ /*laya.d3.core.material.BlinnPhongMaterial.ALBEDOCOLOR*/6,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_MaterialSpecular':[ /*laya.d3.core.material.BlinnPhongMaterial.MATERIALSPECULAR*/8,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_Shininess':[ /*laya.d3.core.material.BlinnPhongMaterial.SHININESS*/9,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_MaterialReflect':[ /*laya.d3.core.material.BlinnPhongMaterial.MATERIALREFLECT*/10,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_TilingOffset':[ /*laya.d3.core.material.BlinnPhongMaterial.TILINGOFFSET*/11,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_WorldMat':[ /*laya.d3.core.Sprite3D.WORLDMATRIX*/0,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],
			'u_MvpMatrix':[ /*laya.d3.core.Sprite3D.MVPMATRIX*/1,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],
			'u_LightmapScaleOffset':[ /*laya.d3.core.RenderableSprite3D.LIGHTMAPSCALEOFFSET*/2,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],
			'u_LightMap':[ /*laya.d3.core.RenderableSprite3D.LIGHTMAP*/3,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],
			'u_CameraPos':[ /*laya.d3.core.BaseCamera.CAMERAPOS*/0,/*laya.d3.shader.Shader3D.PERIOD_CAMERA*/3],
			'u_FogStart':[ /*laya.d3.core.scene.Scene.FOGSTART*/1,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_FogRange':[ /*laya.d3.core.scene.Scene.FOGRANGE*/2,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_FogColor':[ /*laya.d3.core.scene.Scene.FOGCOLOR*/0,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_DirectionLight.Color':[ /*laya.d3.core.scene.Scene.LIGHTDIRCOLOR*/4,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_DirectionLight.Direction':[ /*laya.d3.core.scene.Scene.LIGHTDIRECTION*/3,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_PointLight.Position':[ /*laya.d3.core.scene.Scene.POINTLIGHTPOS*/5,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_PointLight.Range':[ /*laya.d3.core.scene.Scene.POINTLIGHTRANGE*/6,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_PointLight.Color':[ /*laya.d3.core.scene.Scene.POINTLIGHTCOLOR*/8,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_SpotLight.Position':[ /*laya.d3.core.scene.Scene.SPOTLIGHTPOS*/9,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_SpotLight.Direction':[ /*laya.d3.core.scene.Scene.SPOTLIGHTDIRECTION*/10,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_SpotLight.Range':[ /*laya.d3.core.scene.Scene.SPOTLIGHTRANGE*/12,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_SpotLight.Spot':[ /*laya.d3.core.scene.Scene.SPOTLIGHTSPOT*/11,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_SpotLight.Color':[ /*laya.d3.core.scene.Scene.SPOTLIGHTCOLOR*/14,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_AmbientColor':[ /*laya.d3.core.scene.Scene.AMBIENTCOLOR*/21,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_shadowMap1':[ /*laya.d3.core.scene.Scene.SHADOWMAPTEXTURE1*/18,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_shadowMap2':[ /*laya.d3.core.scene.Scene.SHADOWMAPTEXTURE2*/19,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_shadowMap3':[ /*laya.d3.core.scene.Scene.SHADOWMAPTEXTURE3*/20,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_shadowPSSMDistance':[ /*laya.d3.core.scene.Scene.SHADOWDISTANCE*/15,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_lightShadowVP':[ /*laya.d3.core.scene.Scene.SHADOWLIGHTVIEWPROJECT*/16,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_shadowPCFoffset':[ /*laya.d3.core.scene.Scene.SHADOWMAPPCFOFFSET*/17,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4]};
		var BLINNPHONG=Shader3D.nameKey.add("BLINNPHONG");
		vs="attribute vec4 a_Position;\nuniform mat4 u_MvpMatrix;\n\n#if defined(DIFFUSEMAP)||((defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&(defined(SPECULARMAP)||defined(NORMALMAP)))||(defined(LIGHTMAP)&&defined(UV))\n	attribute vec2 a_Texcoord0;\n	varying vec2 v_Texcoord0;\n#endif\n\n#if defined(LIGHTMAP)&&defined(UV1)\n	attribute vec2 a_Texcoord1;\n#endif\n\n#ifdef LIGHTMAP\n	uniform vec4 u_LightmapScaleOffset;\n	varying vec2 v_LightMapUV;\n#endif\n\n#ifdef COLOR\n	attribute vec4 a_Color;\n	varying vec4 v_Color;\n#endif\n\n#ifdef BONE\n	const int c_MaxBoneCount = 24;\n	attribute vec4 a_BoneIndices;\n	attribute vec4 a_BoneWeights;\n	uniform mat4 u_Bones[c_MaxBoneCount];\n#endif\n\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(REFLECTMAP)\n	attribute vec3 a_Normal;\n	varying vec3 v_Normal; \n#endif\n\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(REFLECTMAP)\n	uniform vec3 u_CameraPos;\n	varying vec3 v_ViewDir; \n#endif\n\n#if (defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(REFLECTMAP))&&defined(NORMALMAP)\n	attribute vec4 a_Tangent0;\n	varying vec3 v_Tangent;\n	varying vec3 v_Binormal;\n#endif\n\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(REFLECTMAP)||defined(RECEIVESHADOW)\n	uniform mat4 u_WorldMat;\n	varying vec3 v_PositionWorld;\n#endif\n\nvarying float v_posViewZ;\n#ifdef RECEIVESHADOW\n  #ifdef SHADOWMAP_PSSM1 \n  varying vec4 v_lightMVPPos;\n  uniform mat4 u_lightShadowVP[4];\n  #endif\n#endif\n\n#ifdef TILINGOFFSET\n	uniform vec4 u_TilingOffset;\n#endif\n\nvoid main_castShadow()\n{\n	#ifdef BONE\n		mat4 skinTransform=mat4(0.0);\n		skinTransform += u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\n		skinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\n		skinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\n		skinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\n		vec4 position=skinTransform*a_Position;\n		gl_Position = u_MvpMatrix * position;\n	#else\n		gl_Position = u_MvpMatrix * a_Position;\n	#endif\n	 \n	//TODO没考虑UV动画呢\n	#if defined(DIFFUSEMAP)&&defined(ALPHATEST)\n		v_Texcoord0=a_Texcoord0;\n	#endif\n		v_posViewZ = gl_Position.z;\n}\n\nvoid main_normal()\n{\n	#ifdef BONE\n		mat4 skinTransform=mat4(0.0);\n		skinTransform += u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\n		skinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\n		skinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\n		skinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\n		vec4 position=skinTransform*a_Position;\n		gl_Position = u_MvpMatrix * position;\n	#else\n		gl_Position = u_MvpMatrix * a_Position;\n	#endif\n\n	#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(REFLECTMAP)\n		mat3 worldMat;\n		#ifdef BONE\n			worldMat=mat3(u_WorldMat*skinTransform);\n		#else\n			worldMat=mat3(u_WorldMat);\n		#endif  \n		v_Normal=worldMat*a_Normal;//TODO:法线可以用\"魔法\"矩阵\n		#if (defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&defined(NORMALMAP)\n			v_Tangent=worldMat*a_Tangent0.xyz;\n			v_Binormal=cross(v_Normal,v_Tangent)*a_Tangent0.w;\n		#endif\n	#endif\n\n	#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(REFLECTMAP)||defined(RECEIVESHADOW)\n		#ifdef BONE\n			v_PositionWorld=(u_WorldMat*position).xyz;\n		#else\n			v_PositionWorld=(u_WorldMat*a_Position).xyz;\n		#endif\n	#endif\n	\n	#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(REFLECTMAP)\n		v_ViewDir=u_CameraPos-v_PositionWorld;\n	#endif\n\n	#if defined(DIFFUSEMAP)||((defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&(defined(SPECULARMAP)||defined(NORMALMAP)))\n		v_Texcoord0=a_Texcoord0;\n		#ifdef TILINGOFFSET\n			v_Texcoord0=(vec2(v_Texcoord0.x,v_Texcoord0.y-1.0)*u_TilingOffset.xy)+u_TilingOffset.zw;\n			v_Texcoord0=vec2(v_Texcoord0.x,1.0+v_Texcoord0.y);\n		#endif\n	#endif\n\n	#ifdef LIGHTMAP\n		#ifdef SCALEOFFSETLIGHTINGMAPUV\n			#ifdef UV1\n				v_LightMapUV=vec2(a_Texcoord1.x*u_LightmapScaleOffset.x+u_LightmapScaleOffset.z,1.0+a_Texcoord1.y*u_LightmapScaleOffset.y+u_LightmapScaleOffset.w);\n			#else\n				v_LightMapUV=vec2(a_Texcoord0.x,a_Texcoord0.y-1.0)*u_LightmapScaleOffset.xy+u_LightmapScaleOffset.zw;\n			#endif \n		#else\n			#ifdef UV1\n				v_LightMapUV=a_Texcoord1;\n			#else\n				v_LightMapUV=a_Texcoord0;\n			#endif \n		#endif \n	#endif\n\n	#ifdef COLOR\n		v_Color=a_Color;\n	#endif\n\n	#ifdef RECEIVESHADOW\n		v_posViewZ = gl_Position.w;\n		#ifdef SHADOWMAP_PSSM1 \n			v_lightMVPPos = u_lightShadowVP[0] * vec4(v_PositionWorld,1.0);\n		#endif\n	#endif\n}\n\nvoid main()\n{\n	#ifdef CASTSHADOW\n		main_castShadow();\n	#else\n		main_normal();\n	#endif\n}";
		ps="#ifdef HIGHPRECISION\n	precision highp float;\n#else\n	precision mediump float;\n#endif\n\n#include \"Lighting.glsl\";\n\nuniform vec4 u_DiffuseColor;\n\n#ifdef COLOR\n	varying vec4 v_Color;\n#endif\n\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(REFLECTMAP)\n	varying vec3 v_ViewDir; \n#endif\n\n#ifdef ALPHATEST\n	uniform float u_AlphaTestValue;\n#endif\n\n#ifdef DIFFUSEMAP\n	uniform sampler2D u_DiffuseTexture;\n#endif\n\n#ifdef REFLECTMAP\n	uniform samplerCube u_ReflectTexture;\n	uniform vec3 u_MaterialReflect;\n#endif\n\n#if defined(DIFFUSEMAP)||((defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&(defined(SPECULARMAP)||defined(NORMALMAP)))\n	varying vec2 v_Texcoord0;\n#endif\n\n#ifdef LIGHTMAP\n	varying vec2 v_LightMapUV;\n	uniform sampler2D u_LightMap;\n#endif\n\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\n	uniform vec3 u_MaterialSpecular;\n	uniform float u_Shininess;\n	#ifdef SPECULARMAP \n		uniform sampler2D u_SpecularTexture;\n	#endif\n#endif\n\n#ifdef FOG\n	uniform float u_FogStart;\n	uniform float u_FogRange;\n	#ifdef ADDTIVEFOG\n	#else\n		uniform vec3 u_FogColor;\n	#endif\n#endif\n\n\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(REFLECTMAP)\n	varying vec3 v_Normal;\n#endif\n\n#if (defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&defined(NORMALMAP)\n	uniform sampler2D u_NormalTexture;\n	varying vec3 v_Tangent;\n	varying vec3 v_Binormal;\n#endif\n\n#ifdef DIRECTIONLIGHT\n	uniform DirectionLight u_DirectionLight;\n#endif\n\n#ifdef POINTLIGHT\n	uniform PointLight u_PointLight;\n#endif\n\n#ifdef SPOTLIGHT\n	uniform SpotLight u_SpotLight;\n#endif\n\nuniform vec3 u_AmbientColor;\n\n\n#if defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(REFLECTMAP)||defined(RECEIVESHADOW)\n	varying vec3 v_PositionWorld;\n#endif\n\n#include \"ShadowHelper.glsl\"\nvarying float v_posViewZ;\n#ifdef RECEIVESHADOW\n	#if defined(SHADOWMAP_PSSM2)||defined(SHADOWMAP_PSSM3)\n		uniform mat4 u_lightShadowVP[4];\n	#endif\n	#ifdef SHADOWMAP_PSSM1 \n		varying vec4 v_lightMVPPos;\n	#endif\n#endif\n\nvoid main_castShadow()\n{\n	//gl_FragColor=vec4(v_posViewZ,0.0,0.0,1.0);\n	gl_FragColor=packDepth(v_posViewZ);\n	#if defined(DIFFUSEMAP)&&defined(ALPHATEST)\n		float alpha = texture2D(u_DiffuseTexture,v_Texcoord0).w;\n		if( alpha < u_AlphaTestValue )\n		{\n			discard;\n		}\n	#endif\n}\nvoid main_normal()\n{\n	vec4 mainColor=u_DiffuseColor;\n	#ifdef DIFFUSEMAP\n		vec4 difTexColor=texture2D(u_DiffuseTexture, v_Texcoord0);\n		mainColor=mainColor*difTexColor;\n	#endif \n	#ifdef COLOR\n		mainColor=mainColor*v_Color;\n	#endif \n    \n	#ifdef ALPHATEST\n		if(mainColor.a<u_AlphaTestValue)\n			discard;\n	#endif\n  \n	#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(REFLECTMAP)\n		vec3 normal;\n		#if (defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&defined(NORMALMAP)\n			vec3 normalMapSample = texture2D(u_NormalTexture, v_Texcoord0).rgb;\n			normal = normalize(NormalSampleToWorldSpace(normalMapSample, v_Normal, v_Tangent,v_Binormal));\n		#else\n			normal = normalize(v_Normal);\n		#endif\n	#endif\n	\n	#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\n		vec3 viewDir= normalize(v_ViewDir);\n		vec3 diffuse = vec3(0.0);\n		vec3 specular= vec3(0.0);\n		vec3 dif,spe;\n		#ifdef SPECULARMAP\n			vec3 gloss=texture2D(u_SpecularTexture, v_Texcoord0).rgb;\n		#else\n			#ifdef DIFFUSEMAP\n				vec3 gloss=vec3(difTexColor.a);\n			#else\n				vec3 gloss=vec3(1.0);\n			#endif\n		#endif\n	#endif\n\n	\n	#ifdef DIRECTIONLIGHT\n		LayaAirBlinnPhongDiectionLight(u_MaterialSpecular,u_Shininess,normal,gloss,viewDir,u_DirectionLight,dif,spe);\n		diffuse+=dif;\n		specular+=spe;\n	#endif\n \n	#ifdef POINTLIGHT\n		LayaAirBlinnPhongPointLight(v_PositionWorld,u_MaterialSpecular,u_Shininess,normal,gloss,viewDir,u_PointLight,dif,spe);\n		diffuse+=dif;\n		specular+=spe;\n	#endif\n\n	#ifdef SPOTLIGHT\n		LayaAirBlinnPhongSpotLight(v_PositionWorld,u_MaterialSpecular,u_Shininess,normal,gloss,viewDir,u_SpotLight,dif,spe);\n		diffuse+=dif;\n		specular+=spe;\n	#endif\n\n	\n	vec3 finalDiffuse;\n	#ifdef LIGHTMAP\n		finalDiffuse=texture2D(u_LightMap, v_LightMapUV).rgb*2.0;\n		//float exponent = texture2D(u_LightMap, v_LightMapUV).a;\n		//finalDiffuse = texture2D(u_LightMap, v_LightMapUV).rgb;\n		//float ratio = pow(2.0, exponent * 255.0 - (128.0 + 8.0));\n		//finalDiffuse = finalDiffuse * 255.0 * ratio;	\n		//finalDiffuse = sqrt(finalDiffuse);\n	#else\n		finalDiffuse=vec3(0.0);\n	#endif\n\n	#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\n		finalDiffuse+=diffuse;\n	#endif\n\n	#ifdef RECEIVESHADOW\n		float shadowValue = 1.0;\n		#ifdef SHADOWMAP_PSSM3\n			shadowValue = getShadowPSSM3( u_shadowMap1,u_shadowMap2,u_shadowMap3,u_lightShadowVP,u_shadowPSSMDistance,u_shadowPCFoffset,v_PositionWorld,v_posViewZ,0.001);\n		#endif\n		#ifdef SHADOWMAP_PSSM2\n			shadowValue = getShadowPSSM2( u_shadowMap1,u_shadowMap2,u_lightShadowVP,u_shadowPSSMDistance,u_shadowPCFoffset,v_PositionWorld,v_posViewZ,0.001);\n		#endif \n		#ifdef SHADOWMAP_PSSM1\n			shadowValue = getShadowPSSM1( u_shadowMap1,v_lightMVPPos,u_shadowPSSMDistance,u_shadowPCFoffset,v_posViewZ,0.001);\n		#endif\n		gl_FragColor =vec4(mainColor.rgb*(u_AmbientColor + finalDiffuse)*shadowValue,mainColor.a);\n	#else\n		gl_FragColor =vec4(mainColor.rgb*(u_AmbientColor + finalDiffuse),mainColor.a);\n	#endif\n	\n\n	#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\n		#ifdef RECEIVESHADOW\n			gl_FragColor.rgb+=specular*shadowValue;\n		#else\n			gl_FragColor.rgb+=specular;\n		#endif\n	#endif\n\n\n	#ifdef REFLECTMAP\n		vec3 incident = -viewDir;\n		vec3 reflectionVector = reflect(incident,normal);\n		vec3 reflectionColor  = textureCube(u_ReflectTexture,reflectionVector).rgb;\n		gl_FragColor.rgb += u_MaterialReflect*reflectionColor;\n	#endif\n	  \n	#ifdef FOG\n		float lerpFact=clamp((1.0/gl_FragCoord.w-u_FogStart)/u_FogRange,0.0,1.0);\n		#ifdef ADDTIVEFOG\n			gl_FragColor.rgb=mix(gl_FragColor.rgb,vec3(0.0,0.0,0.0),lerpFact);\n		#else\n			gl_FragColor.rgb=mix(gl_FragColor.rgb,u_FogColor,lerpFact);\n		#endif\n	#endif\n}\n\nvoid main()\n{\n	#ifdef CASTSHADOW		\n		main_castShadow();\n	#else\n	  main_normal();\n	#endif  \n}\n\n";
		var shaderCompile=ShaderCompile3D.add(BLINNPHONG,vs,ps,attributeMap,uniformMap);
		BlinnPhongMaterial.SHADERDEFINE_DIFFUSEMAP=shaderCompile.registerMaterialDefine("DIFFUSEMAP");
		BlinnPhongMaterial.SHADERDEFINE_NORMALMAP=shaderCompile.registerMaterialDefine("NORMALMAP");
		BlinnPhongMaterial.SHADERDEFINE_SPECULARMAP=shaderCompile.registerMaterialDefine("SPECULARMAP");
		BlinnPhongMaterial.SHADERDEFINE_REFLECTMAP=shaderCompile.registerMaterialDefine("REFLECTMAP");
		BlinnPhongMaterial.SHADERDEFINE_TILINGOFFSET=shaderCompile.registerMaterialDefine("TILINGOFFSET");
		BlinnPhongMaterial.SHADERDEFINE_ADDTIVEFOG=shaderCompile.registerMaterialDefine("ADDTIVEFOG");
		attributeMap={
			'a_Position':/*laya.d3.graphics.VertexElementUsage.POSITION0*/0,
			'a_Color':/*laya.d3.graphics.VertexElementUsage.COLOR0*/1,
			'a_Normal':/*laya.d3.graphics.VertexElementUsage.NORMAL0*/3,
			'a_Texcoord0':/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE0*/2,
			'a_Texcoord1':/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE1*/15,
			'a_TexcoordNext0':/*laya.d3.graphics.VertexElementUsage.NEXTTEXTURECOORDINATE0*/14,
			'a_BoneWeights':/*laya.d3.graphics.VertexElementUsage.BLENDWEIGHT0*/7,
			'a_BoneIndices':/*laya.d3.graphics.VertexElementUsage.BLENDINDICES0*/6,
			'a_Tangent0':/*laya.d3.graphics.VertexElementUsage.TANGENT0*/5};
		uniformMap={
			'u_Bones':[ /*laya.d3.core.SkinnedMeshSprite3D.BONES*/0,/*laya.d3.shader.Shader3D.PERIOD_RENDERELEMENT*/0],
			'u_DiffuseTexture':[ /*laya.d3.core.material.StandardMaterial.DIFFUSETEXTURE*/1,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_SpecularTexture':[ /*laya.d3.core.material.StandardMaterial.SPECULARTEXTURE*/3,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_NormalTexture':[ /*laya.d3.core.material.StandardMaterial.NORMALTEXTURE*/2,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_AmbientTexture':[ /*laya.d3.core.material.StandardMaterial.AMBIENTTEXTURE*/5,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_ReflectTexture':[ /*laya.d3.core.material.StandardMaterial.REFLECTTEXTURE*/6,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_AlphaTestValue':[ /*laya.d3.core.material.BaseMaterial.ALPHATESTVALUE*/0,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_Albedo':[ /*laya.d3.core.material.StandardMaterial.ALBEDO*/7,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_UVMatrix':[ /*laya.d3.core.material.StandardMaterial.UVMATRIX*/13,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_UVAge':[ /*laya.d3.core.material.StandardMaterial.UVAGE*/14,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_UVAniAge':[ /*laya.d3.core.material.StandardMaterial.UVANIAGE*/8,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_MaterialDiffuse':[ /*laya.d3.core.material.StandardMaterial.MATERIALDIFFUSE*/10,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_MaterialAmbient':[ /*laya.d3.core.material.StandardMaterial.MATERIALAMBIENT*/9,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_MaterialSpecular':[ /*laya.d3.core.material.StandardMaterial.MATERIALSPECULAR*/11,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_MaterialReflect':[ /*laya.d3.core.material.StandardMaterial.MATERIALREFLECT*/12,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_TilingOffset':[ /*laya.d3.core.material.StandardMaterial.TILINGOFFSET*/15,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_WorldMat':[ /*laya.d3.core.Sprite3D.WORLDMATRIX*/0,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],
			'u_MvpMatrix':[ /*laya.d3.core.Sprite3D.MVPMATRIX*/1,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],
			'u_LightmapScaleOffset':[ /*laya.d3.core.RenderableSprite3D.LIGHTMAPSCALEOFFSET*/2,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],
			'u_LightMap':[ /*laya.d3.core.RenderableSprite3D.LIGHTMAP*/3,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],
			'u_CameraPos':[ /*laya.d3.core.BaseCamera.CAMERAPOS*/0,/*laya.d3.shader.Shader3D.PERIOD_CAMERA*/3],
			'u_FogStart':[ /*laya.d3.core.scene.Scene.FOGSTART*/1,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_FogRange':[ /*laya.d3.core.scene.Scene.FOGRANGE*/2,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_FogColor':[ /*laya.d3.core.scene.Scene.FOGCOLOR*/0,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_DirectionLight.Direction':[ /*laya.d3.core.scene.Scene.LIGHTDIRECTION*/3,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_DirectionLight.Diffuse':[ /*laya.d3.core.scene.Scene.LIGHTDIRCOLOR*/4,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_PointLight.Position':[ /*laya.d3.core.scene.Scene.POINTLIGHTPOS*/5,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_PointLight.Range':[ /*laya.d3.core.scene.Scene.POINTLIGHTRANGE*/6,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_PointLight.Attenuation':[ /*laya.d3.core.scene.Scene.POINTLIGHTATTENUATION*/7,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_PointLight.Diffuse':[ /*laya.d3.core.scene.Scene.POINTLIGHTCOLOR*/8,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_SpotLight.Position':[ /*laya.d3.core.scene.Scene.SPOTLIGHTPOS*/9,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_SpotLight.Direction':[ /*laya.d3.core.scene.Scene.SPOTLIGHTDIRECTION*/10,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_SpotLight.Range':[ /*laya.d3.core.scene.Scene.SPOTLIGHTRANGE*/12,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_SpotLight.Spot':[ /*laya.d3.core.scene.Scene.SPOTLIGHTSPOT*/11,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_SpotLight.Attenuation':[ /*laya.d3.core.scene.Scene.SPOTLIGHTATTENUATION*/13,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_SpotLight.Diffuse':[ /*laya.d3.core.scene.Scene.SPOTLIGHTCOLOR*/14,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_AmbientColor':[ /*laya.d3.core.scene.Scene.AMBIENTCOLOR*/21,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_shadowMap1':[ /*laya.d3.core.scene.Scene.SHADOWMAPTEXTURE1*/18,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_shadowMap2':[ /*laya.d3.core.scene.Scene.SHADOWMAPTEXTURE2*/19,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_shadowMap3':[ /*laya.d3.core.scene.Scene.SHADOWMAPTEXTURE3*/20,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_shadowPSSMDistance':[ /*laya.d3.core.scene.Scene.SHADOWDISTANCE*/15,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_lightShadowVP':[ /*laya.d3.core.scene.Scene.SHADOWLIGHTVIEWPROJECT*/16,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_shadowPCFoffset':[ /*laya.d3.core.scene.Scene.SHADOWMAPPCFOFFSET*/17,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4]};
		var SIMPLE=Shader3D.nameKey.add("SIMPLE");
		vs="attribute vec4 a_Position;\nuniform mat4 u_MvpMatrix;\n\n\n\n#if defined(DIFFUSEMAP)||((defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&(defined(COLOR)&&defined(SPECULARMAP)||defined(NORMALMAP)))||(defined(LIGHTMAP)&&defined(UV))\nattribute vec2 a_Texcoord0;\nvarying vec2 v_Texcoord0;\n  #ifdef UVTRANSFORM \n  uniform mat4 u_UVMatrix;\n  #endif\n#endif\n\n#if defined(AMBIENTMAP)||(defined(LIGHTMAP)&&defined(UV1))\nattribute vec2 a_Texcoord1;\n#endif\n\n#if defined(AMBIENTMAP)||defined(LIGHTMAP)\nuniform vec4 u_LightmapScaleOffset;\nvarying vec2 v_LightMapUV;\n#endif\n\n\n#ifdef COLOR\nattribute vec4 a_Color;\nvarying vec4 v_Color;\n#endif\n\n#ifdef BONE\nattribute vec4 a_BoneIndices;\nattribute vec4 a_BoneWeights;\nconst int c_MaxBoneCount = 24;\nuniform mat4 u_Bones[c_MaxBoneCount];\n#endif\n\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(REFLECTMAP)\nattribute vec3 a_Normal;\nvarying vec3 v_Normal;\n#endif\n\n#if (defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(REFLECTMAP))&&defined(NORMALMAP)\nattribute vec3 a_Tangent0;\nvarying vec3 v_Tangent0;\n#endif\n\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(FOG)||defined(DEPTHFOG)||defined(REFLECTMAP)||defined(RECEIVESHADOW)\nuniform mat4 u_WorldMat;\nvarying vec3 v_PositionWorld;\n#endif\n\nvarying float v_posViewZ;\n#ifdef RECEIVESHADOW\n  #ifdef SHADOWMAP_PSSM1 \n  varying vec4 v_lightMVPPos;\n  uniform mat4 u_lightShadowVP[4];\n  #endif\n#endif\n\n#ifdef TILINGOFFSET\n	uniform vec4 u_TilingOffset;\n#endif\n\nvoid main_castShadow()\n{\n#ifdef BONE\n	mat4 skinTransform=mat4(0.0);\n	skinTransform += u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\n	skinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\n	skinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\n	skinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\n	vec4 position=skinTransform*a_Position;\n	gl_Position = u_MvpMatrix * position;\n#else\n	gl_Position = u_MvpMatrix * a_Position;\n#endif\n \n//TODO没考虑UV动画呢\n#if defined(DIFFUSEMAP)&&defined(ALPHATEST)\n	v_Texcoord0=a_Texcoord0;\n#endif\n	v_posViewZ = gl_Position.z;\n}\n\nvoid main_normal()\n{\n#ifdef BONE\n	mat4 skinTransform=mat4(0.0);\n	skinTransform += u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\n	skinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\n	skinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\n	skinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\n	vec4 position=skinTransform*a_Position;\n	gl_Position = u_MvpMatrix * position;\n#else\n	gl_Position = u_MvpMatrix * a_Position;\n#endif\n\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(REFLECTMAP)\n	mat3 worldMat;\n	#ifdef BONE\n		worldMat=mat3(u_WorldMat*skinTransform);\n	#else\n		worldMat=mat3(u_WorldMat);\n	#endif  \n	v_Normal=worldMat*a_Normal;\n	#if (defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&defined(NORMALMAP)\n		v_Tangent0=worldMat*a_Tangent0;\n	#endif\n#endif\n\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(FOG)||defined(DEPTHFOG)||defined(REFLECTMAP)||defined(RECEIVESHADOW)\n	#ifdef BONE\n		v_PositionWorld=(u_WorldMat*position).xyz;\n	#else\n		v_PositionWorld=(u_WorldMat*a_Position).xyz;\n	#endif\n#endif\n\n#if defined(DIFFUSEMAP)||((defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&(defined(COLOR)&&defined(SPECULARMAP)||defined(NORMALMAP)))\n	v_Texcoord0=a_Texcoord0;\n	#ifdef TILINGOFFSET\n		v_Texcoord0=(vec2(v_Texcoord0.x,v_Texcoord0.y-1.0)*u_TilingOffset.xy)+u_TilingOffset.zw;\n		v_Texcoord0=vec2(v_Texcoord0.x,v_Texcoord0.y+1.0);\n	#endif\n	#ifdef UVTRANSFORM\n		v_Texcoord0=(u_UVMatrix*vec4(v_Texcoord0,0.0,1.0)).xy;\n	#endif\n#endif\n\n#if defined(AMBIENTMAP)||defined(LIGHTMAP)\n	#ifdef SCALEOFFSETLIGHTINGMAPUV\n		#ifdef UV1\n			v_LightMapUV=vec2(a_Texcoord1.x*u_LightmapScaleOffset.x+u_LightmapScaleOffset.z,1.0+a_Texcoord1.y*u_LightmapScaleOffset.y+u_LightmapScaleOffset.w);\n		#else\n			v_LightMapUV=vec2(a_Texcoord0.x,a_Texcoord0.y-1.0)*u_LightmapScaleOffset.xy+u_LightmapScaleOffset.zw;\n		#endif \n	#else\n		#ifdef UV1\n			v_LightMapUV=a_Texcoord1;\n		#else\n			v_LightMapUV=a_Texcoord0;\n		#endif \n	#endif \n#endif\n\n#ifdef COLOR\n	v_Color=a_Color;\n#endif\n\n#ifdef RECEIVESHADOW\n	v_posViewZ = gl_Position.w;\n	#ifdef SHADOWMAP_PSSM1 \n		v_lightMVPPos = u_lightShadowVP[0] * vec4(v_PositionWorld,1.0);\n	#endif\n#endif\n}\n\nvoid main()\n{\n#ifdef CASTSHADOW\n	main_castShadow();\n#else\n	main_normal();\n#endif\n}";
		ps="#ifdef HIGHPRECISION\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\n#include \"LightHelper.glsl\";\n\nuniform vec4 u_Albedo;\n\n#ifdef ALPHATEST\nuniform float u_AlphaTestValue;\n#endif\n\n#ifdef DIFFUSEMAP\nuniform sampler2D u_DiffuseTexture;\n#endif\n\n#ifdef REFLECTMAP\nuniform samplerCube u_ReflectTexture;\nuniform vec3 u_MaterialReflect;\n#endif\n\n#if   defined(DIFFUSEMAP)||((defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&(defined(COLOR)&&defined(SPECULARMAP)||defined(NORMALMAP)))\nvarying vec2 v_Texcoord0;\n#endif\n\n#if defined(AMBIENTMAP)||defined(LIGHTMAP)\nvarying vec2 v_LightMapUV;\n#endif\n#ifdef AMBIENTMAP\nuniform sampler2D u_AmbientTexture;\n#endif\n#ifdef LIGHTMAP\nuniform sampler2D u_LightMap;\n#endif\n\n#ifdef COLOR\nvarying vec4 v_Color;\n#endif\n\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\nuniform vec3 u_MaterialDiffuse;\nuniform vec4 u_MaterialSpecular;\n  #if (defined(DIFFUSEMAP)||defined(COLOR))&&defined(SPECULARMAP) \n  uniform sampler2D u_SpecularTexture;\n  #endif\n#endif\n\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(AMBIENTMAP)||defined(LIGHTMAP)\nuniform vec3 u_MaterialAmbient;\n#endif\n\n#if defined(FOG)||defined(DEPTHFOG)\n	uniform float u_FogStart;\n	uniform float u_FogRange;\n	#ifdef ADDTIVEFOG\n	#else\n		uniform vec3 u_FogColor;\n	#endif\n#endif\n\n\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(REFLECTMAP)\nvarying vec3 v_Normal;\n#endif\n\n#if (defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&defined(NORMALMAP)\nuniform sampler2D u_NormalTexture;\nvarying vec3 v_Tangent0;\n#endif\n\n#ifdef DIRECTIONLIGHT\nuniform DirectionLight u_DirectionLight;\n#endif\n\n#ifdef POINTLIGHT\nuniform PointLight u_PointLight;\n#endif\n\n#ifdef SPOTLIGHT\nuniform SpotLight u_SpotLight;\n#endif\n\nuniform vec3 u_AmbientColor;\n\n\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(FOG)||defined(DEPTHFOG)||defined(REFLECTMAP)||(defined(RECEIVESHADOW)&&(defined(SHADOWMAP_PSM2)||defined(SHADOWMAP_PSM3)))\nuniform vec3 u_CameraPos;\n#endif\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(FOG)||defined(DEPTHFOG)||defined(REFLECTMAP)\nvarying vec3 v_PositionWorld;\n#endif\n\n#include \"ShadowHelper.glsl\"\n#ifdef RECEIVESHADOW\n	#if defined(SHADOWMAP_PSSM2)||defined(SHADOWMAP_PSSM3)\n	uniform mat4 u_lightShadowVP[4];\n	#endif\n	#ifdef SHADOWMAP_PSSM1 \n	varying vec4 v_lightMVPPos;\n	#endif\n#endif\nvarying float v_posViewZ;\n\n\n\nvoid main_castShadow()\n{\n	//gl_FragColor=vec4(v_posViewZ,0.0,0.0,1.0);\n	gl_FragColor=packDepth(v_posViewZ);\n	#if defined(DIFFUSEMAP)&&defined(ALPHATEST)\n		float alpha = texture2D(u_DiffuseTexture,v_Texcoord0).w;\n		if( alpha < u_AlphaTestValue )\n		{\n			discard;\n		}\n	#endif\n}\nvoid main_normal()\n{\n#if defined(DIFFUSEMAP)&&!defined(COLOR)\n	gl_FragColor=texture2D(u_DiffuseTexture, v_Texcoord0);\n#endif \n  \n#if defined(COLOR)&&!defined(DIFFUSEMAP)\n	gl_FragColor=v_Color;\n#endif \n  \n#if defined(DIFFUSEMAP)&&defined(COLOR)\n	vec4 texColor=texture2D(u_DiffuseTexture, v_Texcoord0);\n	gl_FragColor=texColor*v_Color;\n#endif\n  \n#if !defined(DIFFUSEMAP)&&!defined(COLOR)\n	gl_FragColor=vec4(1.0,1.0,1.0,1.0);\n#endif \n    \n#ifdef ALPHATEST\n	if(gl_FragColor.a-u_AlphaTestValue<0.0)\n		discard;\n#endif\n  \n  \n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(REFLECTMAP)\n	vec3 normal;\n    #if (defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&defined(NORMALMAP)\n		vec3 normalMapSample = texture2D(u_NormalTexture, v_Texcoord0).rgb;\n		normal = normalize(NormalSampleToWorldSpace(normalMapSample, v_Normal, v_Tangent0));\n	#else\n		normal = normalize(v_Normal);\n    #endif\n#endif\n	\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\n	vec3 diffuse = vec3(0.0);\n	vec3 ambient = vec3(0.0);\n	vec3 specular= vec3(0.0);\n	vec3 dif, amb, spe;\n#endif\n  \n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(FOG)||defined(REFLECTMAP)\n	vec3 toEye;\n	#ifdef FOG\n		toEye=u_CameraPos-v_PositionWorld;\n		float toEyeLength=length(toEye);\n		toEye/=toEyeLength;\n	#else\n		toEye=normalize(u_CameraPos-v_PositionWorld);\n	#endif\n#endif\n	\n#ifdef DIRECTIONLIGHT\n	computeDirectionLight(u_MaterialDiffuse,u_MaterialAmbient,u_MaterialSpecular,u_DirectionLight,u_AmbientColor,normal,toEye, dif, amb, spe);\n	diffuse+=dif;\n	ambient+=amb;\n	specular+=spe;\n#endif\n \n#ifdef POINTLIGHT\n	computePointLight(u_MaterialDiffuse,u_MaterialAmbient,u_MaterialSpecular,u_PointLight,u_AmbientColor,v_PositionWorld,normal,toEye, dif, amb, spe);\n	diffuse+=dif;\n	ambient+=amb;\n	specular+=spe;\n#endif\n\n#ifdef SPOTLIGHT\n	ComputeSpotLight(u_MaterialDiffuse,u_MaterialAmbient,u_MaterialSpecular,u_SpotLight,u_AmbientColor,v_PositionWorld,normal,toEye, dif, amb, spe);\n	diffuse+=dif;\n	ambient+=amb;\n	specular+=spe;\n#endif\n\n#ifdef RECEIVESHADOW\n	float shadowValue = 1.0;\n	#ifdef SHADOWMAP_PSSM3\n		shadowValue = getShadowPSSM3( u_shadowMap1,u_shadowMap2,u_shadowMap3,u_lightShadowVP,u_shadowPSSMDistance,u_shadowPCFoffset,v_PositionWorld,v_posViewZ,0.001);\n	#endif\n	#ifdef SHADOWMAP_PSSM2\n		shadowValue = getShadowPSSM2( u_shadowMap1,u_shadowMap2,u_lightShadowVP,u_shadowPSSMDistance,u_shadowPCFoffset,v_PositionWorld,v_posViewZ,0.001);\n	#endif \n	#ifdef SHADOWMAP_PSSM1\n		shadowValue = getShadowPSSM1( u_shadowMap1,v_lightMVPPos,u_shadowPSSMDistance,u_shadowPCFoffset,v_posViewZ,0.001);\n	#endif\n#endif\n\n#ifdef AMBIENTMAP\n	#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\n		gl_FragColor.rgb=gl_FragColor.rgb*(u_MaterialAmbient+texture2D(u_AmbientTexture, v_LightMapUV).rgb); \n	#else\n		#if defined(RECEIVESHADOW)\n			gl_FragColor.rgb=gl_FragColor.rgb*(u_MaterialAmbient+texture2D(u_AmbientTexture, v_LightMapUV).rgb * shadowValue);\n		#else\n			gl_FragColor.rgb=gl_FragColor.rgb*(u_MaterialAmbient+texture2D(u_AmbientTexture, v_LightMapUV).rgb); \n		#endif\n	#endif\n#endif\n\n#ifdef LIGHTMAP\n	#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\n		gl_FragColor.rgb=gl_FragColor.rgb*(u_MaterialAmbient+texture2D(u_LightMap, v_LightMapUV).rgb); \n	#else\n		#if defined(RECEIVESHADOW)\n			gl_FragColor.rgb=gl_FragColor.rgb*(u_MaterialAmbient+texture2D(u_LightMap, v_LightMapUV).rgb * shadowValue);\n		#else\n			gl_FragColor.rgb=gl_FragColor.rgb*(u_MaterialAmbient+texture2D(u_LightMap, v_LightMapUV).rgb); \n		#endif\n	#endif\n#endif\n\ngl_FragColor=gl_FragColor*u_Albedo;\n\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\n	#if (defined(DIFFUSEMAP)||defined(COLOR))&&defined(SPECULARMAP)\n		specular =specular*texture2D(u_SpecularTexture, v_Texcoord0).rgb;\n    #endif\n	#ifdef RECEIVESHADOW\n		gl_FragColor =vec4( gl_FragColor.rgb*(ambient + diffuse*shadowValue) + specular*shadowValue,gl_FragColor.a);\n	#else\n		gl_FragColor =vec4( gl_FragColor.rgb*(ambient + diffuse) + specular,gl_FragColor.a);\n	#endif\n#endif\n  \n#ifdef REFLECTMAP\n	vec3 incident = -toEye;\n	vec3 reflectionVector = reflect(incident,normal);\n	vec3 reflectionColor  = textureCube(u_ReflectTexture,reflectionVector).rgb;\n	gl_FragColor.rgb += u_MaterialReflect*reflectionColor;\n#endif\n  \n#ifdef FOG\n	float lerpFact=clamp((toEyeLength-u_FogStart)/u_FogRange,0.0,1.0);\n	#ifdef ADDTIVEFOG\n		gl_FragColor.rgb=mix(gl_FragColor.rgb,vec3(0.0,0.0,0.0),lerpFact);\n	#else\n		gl_FragColor.rgb=mix(gl_FragColor.rgb,u_FogColor,lerpFact);\n	#endif\n#endif\n#ifdef DEPTHFOG\n	float lerpFact = (-v_PositionWorld.y-u_FogStart)/u_FogRange;\n	gl_FragColor.rgb=mix(gl_FragColor.rgb,u_FogColor,lerpFact);\n#endif\n}\n\nvoid main()\n{\n#ifdef CASTSHADOW		\n	main_castShadow();\n#else\n  main_normal();\n#endif  \n}\n\n";
		shaderCompile=ShaderCompile3D.add(SIMPLE,vs,ps,attributeMap,uniformMap);
		StandardMaterial.SHADERDEFINE_DIFFUSEMAP=shaderCompile.registerMaterialDefine("DIFFUSEMAP");
		StandardMaterial.SHADERDEFINE_NORMALMAP=shaderCompile.registerMaterialDefine("NORMALMAP");
		StandardMaterial.SHADERDEFINE_SPECULARMAP=shaderCompile.registerMaterialDefine("SPECULARMAP");
		StandardMaterial.SHADERDEFINE_EMISSIVEMAP=shaderCompile.registerMaterialDefine("EMISSIVEMAP");
		StandardMaterial.SHADERDEFINE_AMBIENTMAP=shaderCompile.registerMaterialDefine("AMBIENTMAP");
		StandardMaterial.SHADERDEFINE_REFLECTMAP=shaderCompile.registerMaterialDefine("REFLECTMAP");
		StandardMaterial.SHADERDEFINE_UVTRANSFORM=shaderCompile.registerMaterialDefine("UVTRANSFORM");
		StandardMaterial.SHADERDEFINE_TILINGOFFSET=shaderCompile.registerMaterialDefine("TILINGOFFSET");
		StandardMaterial.SHADERDEFINE_ADDTIVEFOG=shaderCompile.registerMaterialDefine("ADDTIVEFOG");
		attributeMap={
			'a_Position':/*laya.d3.graphics.VertexElementUsage.POSITION0*/0,
			'a_Color':/*laya.d3.graphics.VertexElementUsage.COLOR0*/1};
		uniformMap={
			'u_MvpMatrix':[ /*laya.d3.core.Sprite3D.MVPMATRIX*/1,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2]};
		var LINE=Shader3D.nameKey.add("LINE");
		vs="attribute vec4 a_Position;\nuniform mat4 u_MvpMatrix;\nattribute vec4 a_Color;\nvarying vec4 v_Color;\n\n\nvoid main()\n{\n  gl_Position = u_MvpMatrix * a_Position;\n  v_Color=a_Color;\n}";
		ps="#ifdef HIGHPRECISION\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nvarying vec4 v_Color;\n\nvoid main()\n{\n  gl_FragColor=v_Color; \n}\n\n";
		ShaderCompile3D.add(LINE,vs,ps,attributeMap,uniformMap);
		attributeMap={
			'a_position':/*laya.d3.graphics.VertexElementUsage.POSITION0*/0,
			'a_normal':/*laya.d3.graphics.VertexElementUsage.NORMAL0*/3,
			'tangent':/*laya.d3.graphics.VertexElementUsage.TANGENT0*/5,
			'binormal':/*laya.d3.graphics.VertexElementUsage.BINORMAL0*/4,
			'uv':/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE0*/2,
			'a_BoneWeights':/*laya.d3.graphics.VertexElementUsage.BLENDWEIGHT0*/7,
			'a_BoneIndices':/*laya.d3.graphics.VertexElementUsage.BLENDINDICES0*/6,
			'a_Tangent0':/*laya.d3.graphics.VertexElementUsage.TANGENT0*/5};
		uniformMap={
			'u_Bones':[ /*laya.d3.core.SkinnedMeshSprite3D.BONES*/0,/*laya.d3.shader.Shader3D.PERIOD_RENDERELEMENT*/0],
			'u_lodRect':[ /*laya.d3.core.BaseCamera.SIMLODINFO*/9,/*laya.d3.shader.Shader3D.PERIOD_CAMERA*/3],
			'irrad_mat_red':[ /*laya.d3.core.BaseCamera.DIFFUSEIRRADMATR*/10,/*laya.d3.shader.Shader3D.PERIOD_CAMERA*/3],
			'irrad_mat_green':[ /*laya.d3.core.BaseCamera.DIFFUSEIRRADMATG*/11,/*laya.d3.shader.Shader3D.PERIOD_CAMERA*/3],
			'irrad_mat_blue':[ /*laya.d3.core.BaseCamera.DIFFUSEIRRADMATB*/12,/*laya.d3.shader.Shader3D.PERIOD_CAMERA*/3],
			'u_hdrexposure':[ /*laya.d3.core.BaseCamera.HDREXPOSURE*/13,/*laya.d3.shader.Shader3D.PERIOD_CAMERA*/3],
			'u_aoObjPos':[ /*laya.d3.core.material.PBRMaterial.AOOBJPOS*/14,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'texBaseColor':[ /*laya.d3.core.material.PBRMaterial.DIFFUSETEXTURE*/1,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'texNormal':[ /*laya.d3.core.material.PBRMaterial.NORMALTEXTURE*/2,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'texPbrInfo':[ /*laya.d3.core.material.PBRMaterial.PBRINFOTEXTURE*/3,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'texPrefilterdEnv':[ /*laya.d3.core.BaseCamera.ENVIRONMENTSPECULAR*/8,/*laya.d3.shader.Shader3D.PERIOD_CAMERA*/3],
			'texHSNoise':[ /*laya.d3.core.material.PBRMaterial.HSNOISETEXTURE*/15,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'texPrefilterDiff':[ /*laya.d3.core.BaseCamera.ENVIRONMENTDIFFUSE*/7,/*laya.d3.shader.Shader3D.PERIOD_CAMERA*/3],
			'u_AlphaTestValue':[ /*laya.d3.core.material.BaseMaterial.ALPHATESTVALUE*/0,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'texBRDFLUT':[ /*laya.d3.core.material.PBRMaterial.PBRLUTTEXTURE*/4,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_UVAniAge':[ /*laya.d3.core.material.PBRMaterial.UVANIAGE*/5,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_roughness':[ /*laya.d3.core.material.PBRMaterial.MATERIALROUGHNESS*/6,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_metaless':[ /*laya.d3.core.material.PBRMaterial.MATERIALMETALESS*/7,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_UVMatrix':[ /*laya.d3.core.material.PBRMaterial.UVMATRIX*/8,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_UVAge':[ /*laya.d3.core.material.PBRMaterial.UVAGE*/9,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'modelMatrix':[ /*laya.d3.core.Sprite3D.WORLDMATRIX*/0,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],
			'mvp':[ /*laya.d3.core.Sprite3D.MVPMATRIX*/1,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],
			'cameraPosition':[ /*laya.d3.core.BaseCamera.CAMERAPOS*/0,/*laya.d3.shader.Shader3D.PERIOD_CAMERA*/3],
			'u_View':[ /*laya.d3.core.BaseCamera.VIEWMATRIX*/1,/*laya.d3.shader.Shader3D.PERIOD_CAMERA*/3],
			'u_Project':[ /*laya.d3.core.BaseCamera.PROJECTMATRIX*/2,/*laya.d3.shader.Shader3D.PERIOD_CAMERA*/3],
			'u_FogStart':[ /*laya.d3.core.scene.Scene.FOGSTART*/1,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_FogRange':[ /*laya.d3.core.scene.Scene.FOGRANGE*/2,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_FogColor':[ /*laya.d3.core.scene.Scene.FOGCOLOR*/0,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_DirectionLight.Direction':[ /*laya.d3.core.scene.Scene.LIGHTDIRECTION*/3,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_DirectionLight.Diffuse':[ /*laya.d3.core.scene.Scene.LIGHTDIRCOLOR*/4,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_PointLight.Position':[ /*laya.d3.core.scene.Scene.POINTLIGHTPOS*/5,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_PointLight.Range':[ /*laya.d3.core.scene.Scene.POINTLIGHTRANGE*/6,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_PointLight.Attenuation':[ /*laya.d3.core.scene.Scene.POINTLIGHTATTENUATION*/7,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_PointLight.Diffuse':[ /*laya.d3.core.scene.Scene.POINTLIGHTCOLOR*/8,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_SpotLight.Position':[ /*laya.d3.core.scene.Scene.SPOTLIGHTPOS*/9,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_SpotLight.Direction':[ /*laya.d3.core.scene.Scene.SPOTLIGHTDIRECTION*/10,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_SpotLight.Range':[ /*laya.d3.core.scene.Scene.SPOTLIGHTRANGE*/12,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_SpotLight.Spot':[ /*laya.d3.core.scene.Scene.SPOTLIGHTSPOT*/11,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_SpotLight.Attenuation':[ /*laya.d3.core.scene.Scene.SPOTLIGHTATTENUATION*/13,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_SpotLight.Diffuse':[ /*laya.d3.core.scene.Scene.SPOTLIGHTCOLOR*/14,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_shadowMap1':[ /*laya.d3.core.scene.Scene.SHADOWMAPTEXTURE1*/18,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_shadowMap2':[ /*laya.d3.core.scene.Scene.SHADOWMAPTEXTURE2*/19,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_shadowMap3':[ /*laya.d3.core.scene.Scene.SHADOWMAPTEXTURE3*/20,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_shadowPSSMDistance':[ /*laya.d3.core.scene.Scene.SHADOWDISTANCE*/15,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_lightShadowVP':[ /*laya.d3.core.scene.Scene.SHADOWLIGHTVIEWPROJECT*/16,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_shadowPCFoffset':[ /*laya.d3.core.scene.Scene.SHADOWMAPPCFOFFSET*/17,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4]};
		var PBR=Shader3D.nameKey.add("PBR");
		vs="\nuniform mat4 modelMatrix;\n//uniform mat4 modelViewMatrix;\n//uniform mat4 projectionMatrix;\nuniform mat4 u_View;\nuniform mat4 u_Project;\nuniform mat4 mvp;\n//uniform mat4 viewMatrix;\nuniform vec3 cameraPosition;\n\nattribute vec3 a_position;\nattribute vec3 a_normal;\n#ifdef HAS_TANGENT\nattribute vec3 tangent;\nattribute vec3 binormal;\n#endif\nattribute vec2 uv;\n#ifdef BONE\nattribute vec4 a_BoneIndices;\nattribute vec4 a_BoneWeights;\nconst int c_MaxBoneCount = 24;\nuniform mat4 u_Bones[c_MaxBoneCount];\n#endif\n\nvarying vec2 vUv;\nvarying vec3 vWorldNorm;\nvarying vec4 vViewPos;\nvarying vec4 vWorldPos;\nvarying vec3 vLightDir;\nvarying vec3 vViewDir;\n#ifdef HAS_TANGENT\nvarying vec3 vWorldTangent;\nvarying vec3 vWorldBinormal;\n#endif\n\n#ifdef RECEIVESHADOW\nvarying float v_posViewZ;\n  #ifdef SHADOWMAP_PSSM1 \n  varying vec4 v_lightMVPPos;\n  uniform mat4 u_lightShadowVP[4];\n  #endif\n#endif\n\nvoid main() {\n#ifdef BONE\n	mat4 skinTransform=mat4(0.0);\n	skinTransform += u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\n	skinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\n	skinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\n	skinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\n	gl_Position = mvp*skinTransform*vec4(a_position,1.);\n	mat4 modelMat = modelMatrix*skinTransform;\n#else\n	gl_Position = mvp*vec4(a_position,1.);\n	mat4 modelMat = modelMatrix;\n#endif	\n	vWorldPos = modelMat*vec4(a_position,1.);\n\n#ifdef CASTSHADOW \n	#if defined(DIFFUSEMAP)&&defined(ALPHATEST)\n		vUv = uv;\n	#endif	\n#else\n    vUv = uv;\n	vWorldNorm = normalize((modelMat*vec4(a_normal,0.0)).xyz);\n	#ifdef HAS_TANGENT\n	vWorldTangent = normalize((modelMat*vec4(tangent,0.0)).xyz);\n	vWorldBinormal = normalize((modelMat*vec4(binormal,0.0)).xyz);\n	#endif\n    \n    vViewDir = (vWorldPos.xyz-cameraPosition);//这个不能normalize。否则无法线性差值了\n#ifdef RECEIVESHADOW\n	v_posViewZ = gl_Position.z;\n	#ifdef SHADOWMAP_PSSM1 \n		v_lightMVPPos = u_lightShadowVP[0] * vWorldPos;\n	#endif\n#endif	\n#endif\n}\n";
		ps="//#version 300 es\n\nprecision highp float;\nprecision lowp int;\n\nconst float PI = 3.14159265358979323846264;\nconst float _2PI = 6.2831853071796;\nvarying vec2 vUv;\nvarying vec3 vWorldNorm;\n#ifdef HAS_TANGENT\nvarying vec3 vWorldTangent;\nvarying vec3 vWorldBinormal;\n#endif\nvarying vec3 vViewDir;\nvarying vec4 vViewPos;\nvarying vec4 vWorldPos;\n//\nuniform sampler2D texBaseColor;\nuniform sampler2D texNormal;\n//预计算的贴图\nuniform sampler2D texPrefilterdEnv;\nuniform sampler2D texBRDFLUT;\nuniform sampler2D texPrefilterDiff;\n#ifdef HAS_PBRINFO\nuniform sampler2D texPbrInfo;   //Ao, Roughness, Metallic\n#endif\nuniform float u_hdrexposure;\nuniform float u_AlphaTestValue;\n\nuniform float u_roughness;\nuniform float u_metaless;\nconst float maxlv = 7.;	//现在只支持512分辨率的环境贴图\nconst int nmaxlv = 9;//\n							\nuniform mat4 irrad_mat_red;\nuniform mat4 irrad_mat_green;\nuniform mat4 irrad_mat_blue;							\n\nvec3 speccontrib = vec3(0.);\n\nconst float _maxu8 = 255.0;\nconst float _maxu16 = 65535.0;\nconst float _shift8 = 256.0;    //平移的话是*256而不是255\nvec2 _RGBAToU16(const in vec4 rgba){\n    return vec2((rgba.r*_maxu8+rgba.g*_maxu8*_shift8)/_maxu16, (rgba.b*_maxu8+rgba.a*_maxu8*_shift8)/_maxu16);\n}\nvec3 _RGBEToRGB( const in vec4 rgba ){\n    float f = pow(2.0, rgba.w * 255.0 - (128.0 + 8.0));\n    return rgba.rgb * (255.0 * f);\n}\n\nfloat saturate(float v){\n    return min(max(v,0.),1.);\n}\n\nvec4 tex2dLod(sampler2D tex, float u, float v, float lod){\n	vec2 uv = vec2(u,v);\n	uv+=mod(gl_FragCoord.xy-vec2(0.5),2.0)*vec2(128.,0.);\n	return texture2D(tex,uv,lod-16.);\n}\n\n/*\n* 对一个全景图进行采样。假设x轴指向中心。\n*/\nvec4 texPanorama(sampler2D tex, const in vec3 dir){\n	float envu = atan(dir.z,dir.x)/_2PI+0.5; 	\n	float envv = acos(dir.y)/PI;//(1.0-dir.y)/2.0;\n	return texture2D(tex,vec2(envu,envv));\n}\n\nvec4 texPanoramaLod(sampler2D tex, const in vec3 dir, float lod){\n	float envu = atan(dir.z,dir.x)/_2PI+0.5; 	\n	float envv = acos(dir.y)/PI;//(1.0-dir.y)/2.0;\n	return tex2dLod(tex,envu,envv,lod);\n}\n\n/*\n    计算sh光照。\n    使用level=2，所以需要9个系数。\n    https://cseweb.ucsd.edu/~ravir/papers/envmap/envmap.pdf\n*/\nfloat environment_exposure = 1.0;\nvec3 diff_sh9(vec3 dir){\n	vec4 shDir = vec4(dir.x,-dir.z,dir.y,1.0);\n  return max(vec3(0.0), vec3(\n	dot(shDir, irrad_mat_red * shDir),\n	dot(shDir, irrad_mat_green * shDir),\n	dot(shDir, irrad_mat_blue * shDir)\n	)) * environment_exposure;	\n}\n\n#ifdef HAS_TANGENT\nvec3 applyNormalTex( vec3 norm, vec3 surf_norm ) {\n    vec3 mapN = norm * 2.0 - 1.0;\n    //mapN.xy = normalScale * mapN.xy;\n    mat3 tsn = mat3( vWorldTangent, vWorldBinormal, surf_norm );\n    return normalize( tsn * mapN );\n}\n#endif\n\nvec4 pbrlight(vec3 normal, float rough, float NoV, vec3 R){\n    vec4 basecolor = texture2D(texBaseColor,vUv);\n	basecolor.rgb = pow(basecolor.rgb,vec3(2.2));\n	float metaless = 1.0; 	\n	const float ismetalinfov = (128./255.);\n	if(basecolor.a>=ismetalinfov){//这时候表示金属度\n		metaless = (basecolor.a-ismetalinfov)*2.;\n		basecolor.a = 1.0;\n	}else{\n		metaless = 0.;\n		basecolor.a = basecolor.a*2.0;\n	}\n	#ifdef FIX_METALESS\n	metaless = u_metaless;\n	#endif\n	#ifdef HAS_PBRINFO	\n	vec4 pbrinfo = texture2D(texPbrInfo, vUv);\n	metaless = pbrinfo.b;\n	rough = pbrinfo.g;\n	#endif\n    const vec3 nonmetalF0 =vec3(0.02);\n    vec3 F0 =  mix(nonmetalF0, basecolor.rgb, metaless);\n	\n    vec4 PrefilteredColor = texPanoramaLod(texPrefilterdEnv, R, rough*maxlv);\n    PrefilteredColor.rgb = _RGBEToRGB(PrefilteredColor);\n    vec4 EnvBRDF = texture2D(texBRDFLUT,vec2(rough , NoV));//TODO lod\n    vec2 rg = _RGBAToU16(EnvBRDF);    \n    speccontrib = (F0* rg.x + saturate( 50.0 * PrefilteredColor.g ) * rg.y);\n	vec3 color_spec = PrefilteredColor.rgb*speccontrib;\n	\n	vec3 color_diff=diff_sh9(normal);\n	vec3 outc =  color_diff*mix(basecolor.rgb,vec3(0.),metaless)*(vec3(1.0)-speccontrib)+color_spec;\n	#ifdef HAS_PBRINFO\n	outc*=pbrinfo.r;\n	#endif\n	return vec4(outc, basecolor.a);\n}\n\nvec3 oldlight(vec4 normal, float NoV, vec3 R){\n    vec4 basecolor = texture2D(texBaseColor,vUv);\n	const vec3 lightdir=normalize(vec3(1.,1.,0.));\n	const vec3 spcecol = vec3(1.,0.8,0.8);\n	const vec3 amb = vec3(0.5);\n	vec3 diffv =  (vec3(saturate(dot(lightdir,normal.xyz)))+amb);\n	//vec3 spec = spcecol* pow(saturate(dot(R,lightdir)),(1.-pbrinfo.g)*5.);\n	return diffv*basecolor.rgb;//+spec;\n}\n\n#include \"ShadowHelper.glsl\"\n#ifdef RECEIVESHADOW\nvarying float v_posViewZ;\n	#if defined(SHADOWMAP_PSSM2)||defined(SHADOWMAP_PSSM3)\n	uniform mat4 u_lightShadowVP[4];\n	#endif\n	#ifdef SHADOWMAP_PSSM1 \n	varying vec4 v_lightMVPPos;\n	#endif\n#endif\n\nvoid main() {\n#ifdef CASTSHADOW\n	gl_FragColor=packDepth(gl_FragCoord.w);\n	#if defined(DIFFUSEMAP)&&defined(ALPHATEST)\n		float alpha = texture2D(texBaseColor,vUv).w;\n		if( alpha < u_AlphaTestValue ){\n			discard;\n		}\n	#endif\n#else\n\n	#ifdef RECEIVESHADOW\n		float shadowValue = 1.0;\n		#ifdef SHADOWMAP_PSSM3\n			shadowValue = getShadowPSSM3( u_shadowMap1,u_shadowMap2,u_shadowMap3,u_lightShadowVP,u_shadowPSSMDistance,u_shadowPCFoffset,vWorldPos.xyz,v_posViewZ,0.0001);\n		#endif\n		#ifdef SHADOWMAP_PSSM2\n			shadowValue = getShadowPSSM2( u_shadowMap1,u_shadowMap2,u_lightShadowVP,u_shadowPSSMDistance,u_shadowPCFoffset,vWorldPos.xyz,v_posViewZ,0.0001);\n		#endif \n		#ifdef SHADOWMAP_PSSM1\n			shadowValue = getShadowPSSM1( u_shadowMap1,v_lightMVPPos,u_shadowPSSMDistance,u_shadowPCFoffset,v_posViewZ,0.0001);\n		#endif\n	#endif	\n	\n    vec3 normal =  normalize(vWorldNorm);\n	vec4 normtex = texture2D( texNormal, vUv );\n	#ifdef HAS_TANGENT	\n	normal = applyNormalTex(normtex.xyz, normal);\n	#endif\n    vec3 view   = -normalize(vViewDir);\n    float NoV = saturate(dot( view, normal ));\n    vec3 R = 2. * NoV * normal - view;\n	float roughness = normtex.a;\n	#ifdef FIX_ROUGHNESS\n	roughness = u_roughness;\n	#endif\n	\n	vec4 pbrl = pbrlight(normal,roughness,NoV,R)*u_hdrexposure;\n    gl_FragColor.rgb =  pow(pbrl.rgb,vec3(0.45455));\n	//gl_FragColor.rgb = oldlight(normtex,NoV,R);\n	#ifdef RECEIVESHADOW\n	gl_FragColor.rgb *= max(shadowValue,0.7);\n	#endif\n	\n    gl_FragColor.a = pbrl.a;\n\n#endif\n}\n";
		shaderCompile=ShaderCompile3D.add(PBR,vs,ps,attributeMap,uniformMap);
		PBRMaterial.SHADERDEFINE_FIX_METALESS=shaderCompile.registerMaterialDefine("FIX_METALESS");
		PBRMaterial.SHADERDEFINE_FIX_ROUGHNESS=shaderCompile.registerMaterialDefine("FIX_ROUGHNESS");
		PBRMaterial.SHADERDEFINE_HAS_TANGENT=shaderCompile.registerMaterialDefine("HAS_TANGENT");
		PBRMaterial.SHADERDEFINE_HAS_PBRINFO=shaderCompile.registerMaterialDefine("HAS_PBRINFO");
		PBRMaterial.SHADERDEFINE_USE_GROUNDTRUTH=shaderCompile.registerMaterialDefine("USE_GROUNDTRUTH");
		PBRMaterial.SHADERDEFINE_TEST_CLIPZ=shaderCompile.registerMaterialDefine("CLIPZ");
		attributeMap={
			'a_Position':/*laya.d3.graphics.VertexElementUsage.POSITION0*/0,
			'a_Normal':/*laya.d3.graphics.VertexElementUsage.NORMAL0*/3,
			'a_Tangent0':/*laya.d3.graphics.VertexElementUsage.TANGENT0*/5,
			'a_Texcoord0':/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE0*/2,
			'a_BoneWeights':/*laya.d3.graphics.VertexElementUsage.BLENDWEIGHT0*/7,
			'a_BoneIndices':/*laya.d3.graphics.VertexElementUsage.BLENDINDICES0*/6
		};
		uniformMap={
			'u_Bones':[ /*laya.d3.core.SkinnedMeshSprite3D.BONES*/0,/*laya.d3.shader.Shader3D.PERIOD_RENDERELEMENT*/0],
			'u_MvpMatrix':[ /*laya.d3.core.Sprite3D.MVPMATRIX*/1,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],
			'u_WorldMat':[ /*laya.d3.core.Sprite3D.WORLDMATRIX*/0,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],
			'u_CameraPos':[ /*laya.d3.core.BaseCamera.CAMERAPOS*/0,/*laya.d3.shader.Shader3D.PERIOD_CAMERA*/3],
			'u_AlphaTestValue':[ /*laya.d3.core.material.BaseMaterial.ALPHATESTVALUE*/0,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_DiffuseColor':[ /*laya.d3.core.material.PBRStandardMaterial.DIFFUSECOLOR*/7,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_EmissionColor':[ /*laya.d3.core.material.PBRStandardMaterial.EMISSIONCOLOR*/8,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_DiffuseTexture':[ /*laya.d3.core.material.PBRStandardMaterial.DIFFUSETEXTURE*/1,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_NormalTexture':[ /*laya.d3.core.material.PBRStandardMaterial.NORMALTEXTURE*/3,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_ParallaxTexture':[ /*laya.d3.core.material.PBRStandardMaterial.PARALLAXTEXTURE*/4,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_MetallicGlossTexture':[ /*laya.d3.core.material.PBRStandardMaterial.METALLICGLOSSTEXTURE*/2,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_OcclusionTexture':[ /*laya.d3.core.material.PBRStandardMaterial.OCCLUSIONTEXTURE*/5,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_EmissionTexture':[ /*laya.d3.core.material.PBRStandardMaterial.EMISSIONTEXTURE*/6,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_metallic':[ /*laya.d3.core.material.PBRStandardMaterial.METALLIC*/9,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_smoothness':[ /*laya.d3.core.material.PBRStandardMaterial.SMOOTHNESS*/10,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_smoothnessScale':[ /*laya.d3.core.material.PBRStandardMaterial.SMOOTHNESSSCALE*/11,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_occlusionStrength':[ /*laya.d3.core.material.PBRStandardMaterial.OCCLUSIONSTRENGTH*/13,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_normalScale':[ /*laya.d3.core.material.PBRStandardMaterial.NORMALSCALE*/14,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_parallaxScale':[ /*laya.d3.core.material.PBRStandardMaterial.PARALLAXSCALE*/15,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_TilingOffset':[ /*laya.d3.core.material.PBRStandardMaterial.TILINGOFFSET*/17,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_DirectionLight.Direction':[ /*laya.d3.core.scene.Scene.LIGHTDIRECTION*/3,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_DirectionLight.Color':[ /*laya.d3.core.scene.Scene.LIGHTDIRCOLOR*/4,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_AmbientColor':[ /*laya.d3.core.scene.Scene.AMBIENTCOLOR*/21,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_shadowMap1':[ /*laya.d3.core.scene.Scene.SHADOWMAPTEXTURE1*/18,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_shadowMap2':[ /*laya.d3.core.scene.Scene.SHADOWMAPTEXTURE2*/19,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_shadowMap3':[ /*laya.d3.core.scene.Scene.SHADOWMAPTEXTURE3*/20,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_shadowPSSMDistance':[ /*laya.d3.core.scene.Scene.SHADOWDISTANCE*/15,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_lightShadowVP':[ /*laya.d3.core.scene.Scene.SHADOWLIGHTVIEWPROJECT*/16,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_shadowPCFoffset':[ /*laya.d3.core.scene.Scene.SHADOWMAPPCFOFFSET*/17,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4]
		};
		var PBRStandard=Shader3D.nameKey.add("PBRStandard");
		vs="attribute vec4 a_Position;\nattribute vec3 a_Normal;\nattribute vec4 a_Tangent0;\nattribute vec2 a_Texcoord0;\n\nuniform mat4 u_MvpMatrix;\nuniform mat4 u_WorldMat;\nuniform vec3 u_CameraPos;\n\nvarying vec2 v_Texcoord0;\nvarying vec3 v_Normal;\nvarying vec3 v_Tangent;\nvarying vec3 v_Binormal;\nvarying vec3 v_ViewDir;\nvarying vec3 v_PositionWorld;\n\n#ifdef TILINGOFFSET\n	uniform vec4 u_TilingOffset;\n#endif\n\nvarying float v_posViewZ;\n#ifdef RECEIVESHADOW\n  #ifdef SHADOWMAP_PSSM1 \n	  varying vec4 v_lightMVPPos;\n	  uniform mat4 u_lightShadowVP[4];\n  #endif\n#endif\n\n#ifdef BONE\n	const int c_MaxBoneCount = 24;\n	attribute vec4 a_BoneIndices;\n	attribute vec4 a_BoneWeights;\n	uniform mat4 u_Bones[c_MaxBoneCount];\n#endif\n\nvoid main_castShadow()\n{\n	#ifdef BONE\n		mat4 skinTransform=mat4(0.0);\n		skinTransform += u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\n		skinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\n		skinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\n		skinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\n		vec4 position = skinTransform * a_Position;\n		gl_Position = u_MvpMatrix * position;\n	#else\n		gl_Position = u_MvpMatrix * a_Position;\n	#endif\n	 \n	//TODO没考虑UV动画呢\n	#if defined(DIFFUSEMAP)&&defined(ALPHATEST)\n		v_Texcoord0 = a_Texcoord0;\n	#endif\n		v_posViewZ = gl_Position.z;\n}\n\nvoid main_normal()\n{\n	mat3 worldMat;\n	#ifdef BONE\n		mat4 skinTransform = mat4(0.0);\n		skinTransform += u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\n		skinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\n		skinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\n		skinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\n		vec4 position = skinTransform * a_Position;\n		gl_Position = u_MvpMatrix * position;\n		worldMat=mat3(u_WorldMat*skinTransform);\n		v_PositionWorld = (u_WorldMat * position).xyz;\n	#else\n		gl_Position = u_MvpMatrix * a_Position;\n		worldMat = mat3(u_WorldMat);\n		v_PositionWorld = (u_WorldMat * a_Position).xyz;\n	#endif\n	\n	v_Normal = worldMat * a_Normal;\n	v_Tangent = worldMat * a_Tangent0.xyz;\n	v_Binormal = cross(v_Normal, v_Tangent) * a_Tangent0.w;\n  \n	v_Texcoord0 = a_Texcoord0;\n	#ifdef TILINGOFFSET\n		v_Texcoord0=(vec2(v_Texcoord0.x,v_Texcoord0.y-1.0)*u_TilingOffset.xy)+u_TilingOffset.zw;\n	#endif\n		v_Texcoord0=vec2(v_Texcoord0.x,1.0 + v_Texcoord0.y);\n  \n	v_ViewDir = u_CameraPos - v_PositionWorld;\n  \n	#ifdef RECEIVESHADOW\n		v_posViewZ = gl_Position.w;\n		#ifdef SHADOWMAP_PSSM1 \n			v_lightMVPPos = u_lightShadowVP[0] * vec4(v_PositionWorld,1.0);\n		#endif\n	#endif\n}\n\nvoid main()\n{\n	#ifdef CASTSHADOW\n		main_castShadow();\n	#else\n		main_normal();\n	#endif\n}";
		ps="#ifdef FSHIGHPRECISION\n	precision highp float;\n#else\n	precision mediump float;\n#endif\n\nvarying vec2 v_Texcoord0;\nvarying vec3 v_Normal;\nvarying vec3 v_Tangent;\nvarying vec3 v_Binormal;\nvarying vec3 v_ViewDir;\n\nuniform vec4 u_AmbientColor;\nuniform vec4 u_DiffuseColor;\n\n#ifdef DIFFUSETEXTURE\n	uniform sampler2D u_DiffuseTexture;\n#endif\n#ifdef METALLICGLOSSTEXTURE\n	uniform sampler2D u_MetallicGlossTexture;\n#endif\n#ifdef NORMALTEXTURE\n	uniform sampler2D u_NormalTexture;\n	uniform float u_normalScale;\n#endif\n#ifdef PARALLAXTEXTURE\n	uniform sampler2D u_ParallaxTexture;\n	uniform float u_parallaxScale;\n#endif\n#ifdef OCCLUSIONTEXTURE\n	uniform sampler2D u_OcclusionTexture;\n	uniform float u_occlusionStrength;\n#endif\n#ifdef EMISSION\n	#ifdef EMISSIONTEXTURE\n		uniform sampler2D u_EmissionTexture;\n	#endif\n	uniform vec4 u_EmissionColor;\n#endif\n\nuniform float u_AlphaTestValue;\nuniform float u_metallic;\nuniform float u_smoothness;\nuniform float u_smoothnessScale;\n\n#include \"PBRStandardLighting.glsl\"\n#include \"ShadowHelper.glsl\"\n\nvarying float v_posViewZ;\n#ifdef RECEIVESHADOW\n	#if defined(SHADOWMAP_PSSM2)||defined(SHADOWMAP_PSSM3)\n		uniform mat4 u_lightShadowVP[4];\n	#endif\n	#ifdef SHADOWMAP_PSSM1 \n		varying vec4 v_lightMVPPos;\n	#endif\n#endif\n\nuniform DirectionLight u_DirectionLight;\n\nvoid main_castShadow()\n{\n	gl_FragColor=packDepth(v_posViewZ);\n	#if defined(DIFFUSEMAP)&&defined(ALPHATEST)\n		float alpha = texture2D(u_DiffuseTexture,v_Texcoord0).w;\n		if( alpha < u_AlphaTestValue )\n		{\n			discard;\n		}\n	#endif\n}\n\nvoid main_normal()\n{	\n	vec3 viewDir = normalize(v_ViewDir);\n	\n	vec2 uv0 = ParallaxOffset(viewDir);\n	\n	vec2 mg;\n	#ifdef DIFFUSETEXTURE\n		vec4 diffuseTextureColor = texture2D(u_DiffuseTexture, uv0);\n		vec4 diffuseColor = diffuseTextureColor * u_DiffuseColor;\n		mg = MetallicGloss(diffuseTextureColor.a, uv0);\n	#else\n		vec4 diffuseColor = u_DiffuseColor;\n		mg = MetallicGloss(1.0, uv0);\n	#endif\n	\n	#ifdef ALPHATEST\n		if(diffuseColor.a < u_AlphaTestValue)\n			discard;\n	#endif\n	\n	gl_FragColor = diffuseColor;\n	\n	vec3 normal = UnpackScaleNormal(uv0);\n  \n	vec3 gi = (u_AmbientColor * Occlusion(uv0)).rgb;\n  \n	vec4 color = PBRStandardDiectionLight(diffuseColor.rgb, mg.r, mg.g, normal, viewDir, u_DirectionLight, gi);\n	\n	color.a = diffuseColor.a;\n	\n	#ifdef EMISSION\n		vec4 emissionColor = u_EmissionColor;\n		#ifdef EMISSIONTEXTURE\n			emissionColor *=  texture2D(u_EmissionTexture, uv0);\n		#endif\n		color.rgb += emissionColor.rgb;\n	#endif\n	\n	#ifdef RECEIVESHADOW\n		float shadowValue = 1.0;\n		#ifdef SHADOWMAP_PSSM3\n			shadowValue = getShadowPSSM3( u_shadowMap1,u_shadowMap2,u_shadowMap3,u_lightShadowVP,u_shadowPSSMDistance,u_shadowPCFoffset,v_PositionWorld,v_posViewZ,0.001);\n		#endif\n		#ifdef SHADOWMAP_PSSM2\n			shadowValue = getShadowPSSM2( u_shadowMap1,u_shadowMap2,u_lightShadowVP,u_shadowPSSMDistance,u_shadowPCFoffset,v_PositionWorld,v_posViewZ,0.001);\n		#endif \n		#ifdef SHADOWMAP_PSSM1\n			shadowValue = getShadowPSSM1( u_shadowMap1,v_lightMVPPos,u_shadowPSSMDistance,u_shadowPCFoffset,v_posViewZ,0.001);\n		#endif\n		gl_FragColor = vec4(color.rgb * shadowValue, color.a);\n	#else\n		gl_FragColor = color;\n	#endif\n}\n\nvoid main()\n{\n	#ifdef CASTSHADOW		\n		main_castShadow();\n	#else\n		main_normal();\n	#endif  \n}\n\n";
		shaderCompile=ShaderCompile3D.add(PBRStandard,vs,ps,attributeMap,uniformMap);
		PBRStandardMaterial.SHADERDEFINE_DIFFUSETEXTURE=shaderCompile.registerMaterialDefine("DIFFUSETEXTURE");
		PBRStandardMaterial.SHADERDEFINE_METALLICGLOSSTEXTURE=shaderCompile.registerMaterialDefine("METALLICGLOSSTEXTURE");
		PBRStandardMaterial.SHADERDEFINE_SMOOTHNESSSOURCE_DIFFUSETEXTURE_ALPHA=shaderCompile.registerMaterialDefine("SMOOTHNESSSOURCE_DIFFUSETEXTURE_ALPHA");
		PBRStandardMaterial.SHADERDEFINE_NORMALTEXTURE=shaderCompile.registerMaterialDefine("NORMALTEXTURE");
		PBRStandardMaterial.SHADERDEFINE_PARALLAXTEXTURE=shaderCompile.registerMaterialDefine("PARALLAXTEXTURE");
		PBRStandardMaterial.SHADERDEFINE_OCCLUSIONTEXTURE=shaderCompile.registerMaterialDefine("OCCLUSIONTEXTURE");
		PBRStandardMaterial.SHADERDEFINE_EMISSION=shaderCompile.registerMaterialDefine("EMISSION");
		PBRStandardMaterial.SHADERDEFINE_EMISSIONTEXTURE=shaderCompile.registerMaterialDefine("EMISSIONTEXTURE");
		PBRStandardMaterial.SHADERDEFINE_TILINGOFFSET=shaderCompile.registerMaterialDefine("TILINGOFFSET");
		attributeMap={
			'a_Position':/*laya.d3.graphics.VertexElementUsage.POSITION0*/0,
			'a_Normal':/*laya.d3.graphics.VertexElementUsage.NORMAL0*/3,
			'a_Tangent0':/*laya.d3.graphics.VertexElementUsage.TANGENT0*/5,
			'a_Texcoord0':/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE0*/2,
			'a_BoneWeights':/*laya.d3.graphics.VertexElementUsage.BLENDWEIGHT0*/7,
			'a_BoneIndices':/*laya.d3.graphics.VertexElementUsage.BLENDINDICES0*/6
		};
		uniformMap={
			'u_Bones':[ /*laya.d3.core.SkinnedMeshSprite3D.BONES*/0,/*laya.d3.shader.Shader3D.PERIOD_RENDERELEMENT*/0],
			'u_MvpMatrix':[ /*laya.d3.core.Sprite3D.MVPMATRIX*/1,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],
			'u_WorldMat':[ /*laya.d3.core.Sprite3D.WORLDMATRIX*/0,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],
			'u_CameraPos':[ /*laya.d3.core.BaseCamera.CAMERAPOS*/0,/*laya.d3.shader.Shader3D.PERIOD_CAMERA*/3],
			'u_AlphaTestValue':[ /*laya.d3.core.material.BaseMaterial.ALPHATESTVALUE*/0,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_DiffuseColor':[ /*laya.d3.core.material.PBRSpecularMaterial.DIFFUSECOLOR*/7,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_SpecularColor':[ /*laya.d3.core.material.PBRSpecularMaterial.SPECULARCOLOR*/8,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_EmissionColor':[ /*laya.d3.core.material.PBRSpecularMaterial.EMISSIONCOLOR*/9,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_DiffuseTexture':[ /*laya.d3.core.material.PBRSpecularMaterial.DIFFUSETEXTURE*/1,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_NormalTexture':[ /*laya.d3.core.material.PBRSpecularMaterial.NORMALTEXTURE*/3,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_ParallaxTexture':[ /*laya.d3.core.material.PBRSpecularMaterial.PARALLAXTEXTURE*/4,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_SpecularTexture':[ /*laya.d3.core.material.PBRSpecularMaterial.SPECULARTEXTURE*/2,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_OcclusionTexture':[ /*laya.d3.core.material.PBRSpecularMaterial.OCCLUSIONTEXTURE*/5,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_EmissionTexture':[ /*laya.d3.core.material.PBRSpecularMaterial.EMISSIONTEXTURE*/6,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_smoothness':[ /*laya.d3.core.material.PBRSpecularMaterial.SMOOTHNESS*/10,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_smoothnessScale':[ /*laya.d3.core.material.PBRSpecularMaterial.SMOOTHNESSSCALE*/11,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_occlusionStrength':[ /*laya.d3.core.material.PBRSpecularMaterial.OCCLUSIONSTRENGTH*/13,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_normalScale':[ /*laya.d3.core.material.PBRSpecularMaterial.NORMALSCALE*/14,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_parallaxScale':[ /*laya.d3.core.material.PBRSpecularMaterial.PARALLAXSCALE*/15,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_TilingOffset':[ /*laya.d3.core.material.PBRSpecularMaterial.TILINGOFFSET*/17,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_DirectionLight.Direction':[ /*laya.d3.core.scene.Scene.LIGHTDIRECTION*/3,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_DirectionLight.Color':[ /*laya.d3.core.scene.Scene.LIGHTDIRCOLOR*/4,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_AmbientColor':[ /*laya.d3.core.scene.Scene.AMBIENTCOLOR*/21,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_shadowMap1':[ /*laya.d3.core.scene.Scene.SHADOWMAPTEXTURE1*/18,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_shadowMap2':[ /*laya.d3.core.scene.Scene.SHADOWMAPTEXTURE2*/19,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_shadowMap3':[ /*laya.d3.core.scene.Scene.SHADOWMAPTEXTURE3*/20,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_shadowPSSMDistance':[ /*laya.d3.core.scene.Scene.SHADOWDISTANCE*/15,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_lightShadowVP':[ /*laya.d3.core.scene.Scene.SHADOWLIGHTVIEWPROJECT*/16,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_shadowPCFoffset':[ /*laya.d3.core.scene.Scene.SHADOWMAPPCFOFFSET*/17,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4]
		};
		var PBRSpecular=Shader3D.nameKey.add("PBRSpecular");
		vs="attribute vec4 a_Position;\nattribute vec3 a_Normal;\nattribute vec4 a_Tangent0;\nattribute vec2 a_Texcoord0;\n\nuniform mat4 u_MvpMatrix;\nuniform mat4 u_WorldMat;\nuniform vec3 u_CameraPos;\n\nvarying vec2 v_Texcoord0;\nvarying vec3 v_Normal;\nvarying vec3 v_Tangent;\nvarying vec3 v_Binormal;\nvarying vec3 v_ViewDir;\nvarying vec3 v_PositionWorld;\n\n#ifdef TILINGOFFSET\n	uniform vec4 u_TilingOffset;\n#endif\n\nvarying float v_posViewZ;\n#ifdef RECEIVESHADOW\n  #ifdef SHADOWMAP_PSSM1 \n	  varying vec4 v_lightMVPPos;\n	  uniform mat4 u_lightShadowVP[4];\n  #endif\n#endif\n\n#ifdef BONE\n	const int c_MaxBoneCount = 24;\n	attribute vec4 a_BoneIndices;\n	attribute vec4 a_BoneWeights;\n	uniform mat4 u_Bones[c_MaxBoneCount];\n#endif\n\nvoid main_castShadow()\n{\n	#ifdef BONE\n		mat4 skinTransform=mat4(0.0);\n		skinTransform += u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\n		skinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\n		skinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\n		skinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\n		vec4 position = skinTransform * a_Position;\n		gl_Position = u_MvpMatrix * position;\n	#else\n		gl_Position = u_MvpMatrix * a_Position;\n	#endif\n	 \n	//TODO没考虑UV动画呢\n	#if defined(DIFFUSEMAP)&&defined(ALPHATEST)\n		v_Texcoord0 = a_Texcoord0;\n	#endif\n		v_posViewZ = gl_Position.z;\n}\n\nvoid main_normal()\n{\n	mat3 worldMat;\n	#ifdef BONE\n		mat4 skinTransform = mat4(0.0);\n		skinTransform += u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\n		skinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\n		skinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\n		skinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\n		vec4 position = skinTransform * a_Position;\n		gl_Position = u_MvpMatrix * position;\n		worldMat=mat3(u_WorldMat*skinTransform);\n		v_PositionWorld = (u_WorldMat * position).xyz;\n	#else\n		gl_Position = u_MvpMatrix * a_Position;\n		worldMat = mat3(u_WorldMat);\n		v_PositionWorld = (u_WorldMat * a_Position).xyz;\n	#endif\n	\n	v_Normal = worldMat * a_Normal;\n	v_Tangent = worldMat * a_Tangent0.xyz;\n	v_Binormal = cross(v_Normal, v_Tangent) * a_Tangent0.w;\n  \n	v_Texcoord0 = a_Texcoord0;\n	#ifdef TILINGOFFSET\n		v_Texcoord0=(vec2(v_Texcoord0.x,v_Texcoord0.y-1.0)*u_TilingOffset.xy)+u_TilingOffset.zw;\n	#endif\n		v_Texcoord0=vec2(v_Texcoord0.x,1.0 + v_Texcoord0.y);\n  \n	v_ViewDir = u_CameraPos - v_PositionWorld;\n  \n	#ifdef RECEIVESHADOW\n		v_posViewZ = gl_Position.w;\n		#ifdef SHADOWMAP_PSSM1 \n			v_lightMVPPos = u_lightShadowVP[0] * vec4(v_PositionWorld,1.0);\n		#endif\n	#endif\n}\n\nvoid main()\n{\n	#ifdef CASTSHADOW\n		main_castShadow();\n	#else\n		main_normal();\n	#endif\n}";
		ps="#ifdef FSHIGHPRECISION\n	precision highp float;\n#else\n	precision mediump float;\n#endif\n\nvarying vec2 v_Texcoord0;\nvarying vec3 v_Normal;\nvarying vec3 v_Tangent;\nvarying vec3 v_Binormal;\nvarying vec3 v_ViewDir;\n\nuniform vec4 u_AmbientColor;\nuniform vec4 u_DiffuseColor;\nuniform vec4 u_SpecularColor;\n\n#ifdef DIFFUSETEXTURE\n	uniform sampler2D u_DiffuseTexture;\n#endif\n#ifdef SPECULARTEXTURE\n	uniform sampler2D u_SpecularTexture;\n#endif\n#ifdef NORMALTEXTURE\n	uniform sampler2D u_NormalTexture;\n	uniform float u_normalScale;\n#endif\n#ifdef PARALLAXTEXTURE\n	uniform sampler2D u_ParallaxTexture;\n	uniform float u_parallaxScale;\n#endif\n#ifdef OCCLUSIONTEXTURE\n	uniform sampler2D u_OcclusionTexture;\n	uniform float u_occlusionStrength;\n#endif\n#ifdef EMISSION\n	#ifdef EMISSIONTEXTURE\n		uniform sampler2D u_EmissionTexture;\n	#endif\n	uniform vec4 u_EmissionColor;\n#endif\n\nuniform float u_AlphaTestValue;\nuniform float u_metallic;\nuniform float u_smoothness;\nuniform float u_smoothnessScale;\n\n#include \"PBRSpecularLighting.glsl\"\n#include \"ShadowHelper.glsl\"\n\nvarying float v_posViewZ;\n#ifdef RECEIVESHADOW\n	#if defined(SHADOWMAP_PSSM2)||defined(SHADOWMAP_PSSM3)\n		uniform mat4 u_lightShadowVP[4];\n	#endif\n	#ifdef SHADOWMAP_PSSM1 \n		varying vec4 v_lightMVPPos;\n	#endif\n#endif\n\nuniform DirectionLight u_DirectionLight;\n\nvoid main_castShadow()\n{\n	gl_FragColor=packDepth(v_posViewZ);\n	#if defined(DIFFUSEMAP)&&defined(ALPHATEST)\n		float alpha = texture2D(u_DiffuseTexture,v_Texcoord0).w;\n		if( alpha < u_AlphaTestValue )\n		{\n			discard;\n		}\n	#endif\n}\n\nvoid main_normal()\n{	\n	vec3 viewDir = normalize(v_ViewDir);\n	\n	vec2 uv0 = ParallaxOffset(viewDir);\n	\n	vec4 sg;\n	#ifdef DIFFUSETEXTURE\n		vec4 diffuseTextureColor = texture2D(u_DiffuseTexture, uv0);\n		vec4 diffuseColor = diffuseTextureColor * u_DiffuseColor;\n		sg = SpecularGloss(diffuseTextureColor.a, uv0);\n	#else\n		vec4 diffuseColor = u_DiffuseColor;\n		sg = SpecularGloss(1.0, uv0);\n	#endif\n	\n	#ifdef ALPHATEST\n		if(diffuseColor.a < u_AlphaTestValue)\n			discard;\n	#endif\n  \n	vec3 normal = UnpackScaleNormal(uv0);\n	\n	vec3 gi = (u_AmbientColor * Occlusion(uv0)).rgb;\n	\n	//float a = (sg.r+sg.g+sg.b) / 3.0;\n  \n	vec4 color = PBRSpecularDiectionLight(diffuseColor.rgb, sg.rgb, sg.a, normal,viewDir, u_DirectionLight, gi);\n	\n	color.a = diffuseColor.a;\n	\n	#ifdef EMISSION\n		vec4 emissionColor = u_EmissionColor;\n		#ifdef EMISSIONTEXTURE\n			emissionColor *=  texture2D(u_EmissionTexture, uv0);\n		#endif\n		color.rgb += emissionColor.rgb;\n	#endif\n	\n	#ifdef RECEIVESHADOW\n		float shadowValue = 1.0;\n		#ifdef SHADOWMAP_PSSM3\n			shadowValue = getShadowPSSM3( u_shadowMap1,u_shadowMap2,u_shadowMap3,u_lightShadowVP,u_shadowPSSMDistance,u_shadowPCFoffset,v_PositionWorld,v_posViewZ,0.001);\n		#endif\n		#ifdef SHADOWMAP_PSSM2\n			shadowValue = getShadowPSSM2( u_shadowMap1,u_shadowMap2,u_lightShadowVP,u_shadowPSSMDistance,u_shadowPCFoffset,v_PositionWorld,v_posViewZ,0.001);\n		#endif \n		#ifdef SHADOWMAP_PSSM1\n			shadowValue = getShadowPSSM1( u_shadowMap1,v_lightMVPPos,u_shadowPSSMDistance,u_shadowPCFoffset,v_posViewZ,0.001);\n		#endif\n		gl_FragColor = vec4(color.rgb * shadowValue, color.a);\n	#else\n		gl_FragColor = color;\n	#endif\n}\n\nvoid main()\n{\n	#ifdef CASTSHADOW		\n		main_castShadow();\n	#else\n		main_normal();\n	#endif  \n}\n\n";
		shaderCompile=ShaderCompile3D.add(PBRSpecular,vs,ps,attributeMap,uniformMap);
		PBRSpecularMaterial.SHADERDEFINE_DIFFUSETEXTURE=shaderCompile.registerMaterialDefine("DIFFUSETEXTURE");
		PBRSpecularMaterial.SHADERDEFINE_SPECULARTEXTURE=shaderCompile.registerMaterialDefine("SPECULARTEXTURE");
		PBRSpecularMaterial.SHADERDEFINE_SMOOTHNESSSOURCE_DIFFUSETEXTURE_ALPHA=shaderCompile.registerMaterialDefine("SMOOTHNESSSOURCE_DIFFUSETEXTURE_ALPHA");
		PBRSpecularMaterial.SHADERDEFINE_NORMALTEXTURE=shaderCompile.registerMaterialDefine("NORMALTEXTURE");
		PBRSpecularMaterial.SHADERDEFINE_PARALLAXTEXTURE=shaderCompile.registerMaterialDefine("PARALLAXTEXTURE");
		PBRSpecularMaterial.SHADERDEFINE_OCCLUSIONTEXTURE=shaderCompile.registerMaterialDefine("OCCLUSIONTEXTURE");
		PBRSpecularMaterial.SHADERDEFINE_EMISSION=shaderCompile.registerMaterialDefine("EMISSION");
		PBRSpecularMaterial.SHADERDEFINE_EMISSIONTEXTURE=shaderCompile.registerMaterialDefine("EMISSIONTEXTURE");
		PBRSpecularMaterial.SHADERDEFINE_TILINGOFFSET=shaderCompile.registerMaterialDefine("TILINGOFFSET");
		attributeMap={
			'a_position':/*laya.d3.graphics.VertexElementUsage.POSITION0*/0,
			'a_normal':/*laya.d3.graphics.VertexElementUsage.NORMAL0*/3,
			'uv':/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE0*/2};
		uniformMap={
			'irrad_mat_red':[ /*laya.d3.core.BaseCamera.DIFFUSEIRRADMATR*/10,/*laya.d3.shader.Shader3D.PERIOD_CAMERA*/3],
			'irrad_mat_green':[ /*laya.d3.core.BaseCamera.DIFFUSEIRRADMATG*/11,/*laya.d3.shader.Shader3D.PERIOD_CAMERA*/3],
			'irrad_mat_blue':[ /*laya.d3.core.BaseCamera.DIFFUSEIRRADMATB*/12,/*laya.d3.shader.Shader3D.PERIOD_CAMERA*/3],
			'u_hdrexposure':[ /*laya.d3.core.BaseCamera.HDREXPOSURE*/13,/*laya.d3.shader.Shader3D.PERIOD_CAMERA*/3],
			'texBaseColor':[ /*laya.d3.core.material.WaterMaterial.DIFFUSETEXTURE*/1,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'texNormal':[ /*laya.d3.core.material.WaterMaterial.NORMALTEXTURE*/2,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'texSky':[ /*laya.d3.core.material.WaterMaterial.SKYTEXTURE*/11,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'texUnderWater':[ /*laya.d3.core.material.WaterMaterial.UNDERWATERTEXTURE*/3,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'texPrefilterdEnv':[ /*laya.d3.core.BaseCamera.ENVIRONMENTSPECULAR*/8,/*laya.d3.shader.Shader3D.PERIOD_CAMERA*/3],
			'texPrefilterDiff':[ /*laya.d3.core.BaseCamera.ENVIRONMENTDIFFUSE*/7,/*laya.d3.shader.Shader3D.PERIOD_CAMERA*/3],
			'texWaterDisp':[ /*laya.d3.core.material.WaterMaterial.VERTEXDISPTEXTURE*/4,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'texWaveDetail':[ /*laya.d3.core.material.WaterMaterial.DETAILTEXTURE*/9,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'texDeepColor':[ /*laya.d3.core.material.WaterMaterial.DEEPCOLORTEXTURE*/10,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'texWaterInfo':[ /*laya.d3.core.material.WaterMaterial.WATERINFO*/16,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'texFoam':[ /*laya.d3.core.material.WaterMaterial.FOAMTEXTURE*/17,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'GEOWAVE_UV_SCALE':[ /*laya.d3.core.material.WaterMaterial.GEOWAVE_UV_SCALE*/18,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'modelMatrix':[ /*laya.d3.core.Sprite3D.WORLDMATRIX*/0,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],
			'mvp':[ /*laya.d3.core.Sprite3D.MVPMATRIX*/1,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],
			'cameraPosition':[ /*laya.d3.core.BaseCamera.CAMERAPOS*/0,/*laya.d3.shader.Shader3D.PERIOD_CAMERA*/3],
			'u_curTm':[ /*laya.d3.core.material.WaterMaterial.CURTM*/8,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_scrsize':[ /*laya.d3.core.material.WaterMaterial.SCRSIZE*/15,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_WaveInfoD':[ /*laya.d3.core.material.WaterMaterial.WAVEINFOD*/13,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_WaveInfo':[ /*laya.d3.core.material.WaterMaterial.WAVEINFO*/12,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_WaveMainDir':[ /*laya.d3.core.material.WaterMaterial.WAVEMAINDIR*/14,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_DeepScale':[ /*laya.d3.core.material.WaterMaterial.WAVEINFODEEPSCALE*/20,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_SeaColor':[ /*laya.d3.core.material.WaterMaterial.SEA_COLOR*/19,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_View':[ /*laya.d3.core.BaseCamera.VIEWMATRIX*/1,/*laya.d3.shader.Shader3D.PERIOD_CAMERA*/3],
			'u_Project':[ /*laya.d3.core.BaseCamera.PROJECTMATRIX*/2,/*laya.d3.shader.Shader3D.PERIOD_CAMERA*/3],
			'u_FogStart':[ /*laya.d3.core.scene.Scene.FOGSTART*/1,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_FogRange':[ /*laya.d3.core.scene.Scene.FOGRANGE*/2,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_FogColor':[ /*laya.d3.core.scene.Scene.FOGCOLOR*/0,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_DirectionLight.Direction':[ /*laya.d3.core.scene.Scene.LIGHTDIRECTION*/3,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_DirectionLight.Diffuse':[ /*laya.d3.core.scene.Scene.LIGHTDIRCOLOR*/4,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_PointLight.Position':[ /*laya.d3.core.scene.Scene.POINTLIGHTPOS*/5,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_PointLight.Range':[ /*laya.d3.core.scene.Scene.POINTLIGHTRANGE*/6,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_PointLight.Attenuation':[ /*laya.d3.core.scene.Scene.POINTLIGHTATTENUATION*/7,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_PointLight.Diffuse':[ /*laya.d3.core.scene.Scene.POINTLIGHTCOLOR*/8,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_SpotLight.Position':[ /*laya.d3.core.scene.Scene.SPOTLIGHTPOS*/9,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_SpotLight.Direction':[ /*laya.d3.core.scene.Scene.SPOTLIGHTDIRECTION*/10,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_SpotLight.Range':[ /*laya.d3.core.scene.Scene.SPOTLIGHTRANGE*/12,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_SpotLight.Spot':[ /*laya.d3.core.scene.Scene.SPOTLIGHTSPOT*/11,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_SpotLight.Attenuation':[ /*laya.d3.core.scene.Scene.SPOTLIGHTATTENUATION*/13,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_SpotLight.Diffuse':[ /*laya.d3.core.scene.Scene.SPOTLIGHTCOLOR*/14,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4]};
		var Water=Shader3D.nameKey.add("Water");
		vs="\nuniform mat4 modelMatrix;\n//uniform mat4 modelViewMatrix;\n//uniform mat4 projectionMatrix;\nuniform mat4 u_View;\nuniform mat4 u_Project;\nuniform mat4 mvp;\n//uniform mat4 viewMatrix;\nuniform vec3 cameraPosition;\nuniform float u_curTm;\n\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 uv;\n//uniform sampler2D texWaterDisp;\n#ifdef USE_VERTEX_DEEPINFO\n#else\nuniform sampler2D texWaterInfo;\nvarying vec4 vWaterInfo;\nuniform float u_DeepScale;//texWaterInfo.r*vDeepScale\n#endif\nuniform float u_WaveMainDir;	//主波方向\nuniform float GEOWAVE_UV_SCALE ;//= 100.0;\n\n\nvarying vec2 vUv;\nvarying vec3 vWorldNorm;\nvarying vec3 vWorldTan;\nvarying vec3 vWorldBin;\nvarying vec4 vViewPos;\nvarying vec4 vWorldPos;\nvarying vec3 vLightDir;\nvarying vec3 vViewDir;\nvarying vec3 vDisp;\nvarying float fDeep;\nvarying mat2 matUVTrans;\nvarying float fFoam;\n\nconst float PI = 3.14159265358979323846264;\n\n#include \"WaveFunction.glsl\"\n\nvec2 getPosFromUV(vec2 uv){\n	return uv*50.;\n}\n\nvoid main() {\n	vec3 pos = a_position;\n    vUv = uv;\n	\n	//vDisp = texture2D(texWaterDisp,uv).rgb;\n	//vec3 disp = vDisp;\n	\n	//TODO 这里有个潜规则。\n	float tt = pos.y; pos.y=pos.z; pos.z=-tt;\n	\n	#ifdef USE_VERTEX_DEEPINFO\n	fDeep = -pos.y;\n	pos.y=0.0;\n	#else\n	vWaterInfo = texture2D(texWaterInfo,uv);\n	fDeep = vWaterInfo.r*u_DeepScale;\n	#endif\n	\n	\n	//计算波形\n	mat4 modelMat = modelMatrix;\n	vec3 opos, T,B,N;\n	float foams=0.;\n	vec2 uvpos = uv*GEOWAVE_UV_SCALE+vec2(modelMat[3][0],0.);//TODO 如果有旋转缩放怎么办\n	calcGerstnerWave(u_curTm, pos,fDeep, uvpos,opos,B,T,N,foams);\n	fFoam = foams;\n	gl_Position = mvp*vec4(opos,1.);\n	vWorldPos = modelMat*vec4(opos,1.);\n\n	vWorldNorm = normalize((modelMatrix*vec4(N,0.0)).xyz);\n	vWorldTan = normalize((modelMatrix*vec4(T,0.0)).xyz);\n	vWorldBin = normalize((modelMatrix*vec4(B,0.0)).xyz);\n    vViewDir = vWorldPos.xyz-cameraPosition; //这个不能取normalize，否则会引入非线性\n	\n	float s = sin(u_WaveMainDir);\n	float c = cos(u_WaveMainDir);\n	matUVTrans = mat2(c,-s,s,c);\n}\n";
		ps="//#version 300 es\n\nprecision highp float;\nprecision lowp int;\n\nconst float PI = 3.14159265358979323846264;\nconst float _2PI = 6.2831853071796;\nvarying vec2 vUv;\nvarying vec3 vWorldNorm;\nvarying vec3 vWorldTan;\nvarying vec3 vWorldBin;\nvarying vec3 vViewDir;//入射。pos-cam\nvarying vec4 vViewPos;\nvarying vec4 vWorldPos;\nvarying float fDeep;\nvarying mat2 matUVTrans;\n#ifdef USE_VERTEX_DEEPINFO\n#else\nvarying vec4 vWaterInfo;\n#endif\nmat3 matTBNOff;//\n\n//\nuniform sampler2D texBaseColor;\nuniform sampler2D texNormal;\n#ifdef CUBE_ENV\nuniform samplerCube texSky;\n#else\nuniform sampler2D texSky;\n#endif\nuniform sampler2D texUnderWater;\nuniform sampler2D texWaveDetail;\n//uniform sampler2D texDeepColor;\nuniform sampler2D texFoam;\nvarying float fFoam;\nuniform float u_curTm;\nuniform vec2 u_scrsize;\nuniform vec3 u_SeaColor;//\n\nconst int NumTexWaves=4;\nconst float Amp_over_L = 0.01;\n//const vec3 SEA_COLOR1 = vec3(0.0292,0.672,0.7467);//大洋\n//const vec3 SEA_COLOR2 = vec3(0,0.927,0.43);//近海\n\nconst float _maxu8 = 255.0;\nconst float _maxu16 = 65535.0;\nconst float _shift8 = 256.0;    //平移的话是*256而不是255\nvec2 _RGBAToU16(const in vec4 rgba){\n    return vec2((rgba.r*_maxu8+rgba.g*_maxu8*_shift8)/_maxu16, (rgba.b*_maxu8+rgba.a*_maxu8*_shift8)/_maxu16);\n}\nvec3 _RGBEToRGB( const in vec4 rgba ){\n    float f = pow(2.0, rgba.w * 255.0 - (128.0 + 8.0));\n    return rgba.rgb * (255.0 * f);\n}\n\nfloat saturate(float v){\n    return min(max(v,0.),1.);\n}\n\n/*\n	各种 ToneMap\n*/\n//Reinhard\nvec3 ReinhardToneMapping(vec3 color, float adapted_lum) {\n    const float MIDDLE_GREY = 1.;\n    color *= MIDDLE_GREY / adapted_lum;\n    return color / (1.0 + color);\n}\n\n//CE2\nvec3 CEToneMapping(vec3 color, float adapted_lum){\n    return 1. - exp(-adapted_lum * color);\n}\n\n//UC2\nvec3 F1(vec3 x){\n	const float A = 0.22;\n	const float B = 0.30;\n	const float C = 0.10;\n	const float D = 0.20;\n	const float E = 0.01;\n	const float F = 0.30;\n \n	return ((x * (A * x + C * B) + D * E) / (x * (A * x + B) + D * F)) - E / F;\n}\n\nvec3 Uncharted2ToneMapping(vec3 color, float adapted_lum){\n	const vec3 WHITE = vec3(11.2);\n	return F1(1.6 * adapted_lum * color) / F1(WHITE);\n}\n\n//ACES\nvec3 ACESToneMapping(vec3 color, float adapted_lum){\n	const float A = 2.51;\n	const float B = 0.03;\n	const float C = 2.43;\n	const float D = 0.59;\n	const float E = 0.14;\n\n	color *= adapted_lum;\n	return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\n\n/*\n* 对一个全景图进行采样。假设x轴指向中心。\n*/\nvec4 texPanorama(sampler2D tex, const in vec3 dir){\n	float envu = atan(dir.z,dir.x)/_2PI+0.5; 	\n	float envv = acos(dir.y)/PI;//(1.0-dir.y)/2.0;\n	return texture2D(tex,vec2(envu,envv));\n}\n\n/*\n	与位于0点的测试棒的相交测试交点\n	这个是瞎写的，只是为了测试\n*/\nbool hitClydiner(vec3 pos, vec3 dir, out vec3 hitpos, out vec3 hitnormal){\n	const float r = 0.5;\n	float a = dir.x*dir.x+dir.z*dir.z;\n	float b = 2.*dir.x*pos.x+2.*dir.z*pos.z;\n	float c = pos.x*pos.x+pos.z*pos.z-r*r;\n	float d = b*b-4.*a*c;\n	if(d>=0.0){\n		float t = (-b+sqrt(d))/2./a;\n		t =min(t, (-b-sqrt(d))/2./a);\n		hitpos = pos+dir*t;\n		return true;\n	}\n	/*\n	vec3 v1 = normalize(cross(dir,vec3(0.,1.,0.)));//公垂线\n	float dist = dot(pos,v1);//最短距离\n	if(abs(dist)<r){\n		return true;\n	}\n	*/\n	return false;\n}\n\n///* 根据散射公式来计算某个方向的颜色 *///\n//\nfloat phase_function(float costheta, float g, float g2){\n	return 1.5*( (1.0-g2) / (2.0+g2) ) * (1.0+costheta*costheta) / pow(1.0+g2-2.0*g*costheta, 1.5);	\n}\n\nconst float _density = .2;\nconst vec3 _vLightDir=vec3(0.,-1.,0.);//必须是规格化的\nconst int _SAMPLENUM = 20;\nconst float _K1 = 1.0;\nconst float _g = -0.93;\n//\nvec3 calcScatter(vec3 start, vec3 dir, vec3 end){\n	float len = length(end-start);\n	float costheta = dot(dir,_vLightDir);\n	float g2 = _g*_g;\n	float K = _K1*len*_density*phase_function(costheta,_g,g2);\n	//用分段的方式来积分\n	float dlen = len/float(_SAMPLENUM);//距离平分\n	float ddeep = (start.y-end.y)/float(_SAMPLENUM);//深度平分\n	float sum=0.;\n	for( int i=0; i<_SAMPLENUM; i++){\n		float fi = float(i);\n		float v1 = exp(-_density*(dlen+ddeep)*fi);//TODO 应该可以用分析法计算出来\n		sum += v1;\n	}\n	return vec3(K*sum);\n}\n///* 根据散射公式来计算某个方向的亮度  END *///\n\nconst float cDeep = -2.;	//假设水的深度\nvec3 getShuiDiColor(vec3 pos, vec3 dir, vec3 normal){\n	//一个无限大的水底，黑白格纹理。纹理长度为1米\n	float t = ( cDeep-pos.y )/dir.y;\n	if(t<0.) return vec3(1.,0.,0.);//TEST\n	bool bhit = false;\n	vec3 hitpos;\n	vec3 hitcolor;\n	vec3 hn;\n	if(hitClydiner(pos,dir,hitpos,hn) && hitpos.y>cDeep && hitpos.y<pos.y){\n		bhit=true;\n		hitcolor = vec3(.8,.8,.8);\n\n	}else\n	{\n		hitpos = pos+dir*t;\n		vec3 hp = floor(hitpos);\n		float a = mod((hp.x+hp.z),2.);\n		hitcolor = (a<.9)?vec3(0.,0.,0.):vec3(1.,1.,1.);\n		//hitcolor = texture2D(texUnderWater,hitpos.xz/10.).rgb;\n	}\n	\n	float l = length(hitpos-pos);\n	//return texture2D(texDeepColor,vec2(min(max(l/400.,0.),1.),0.5)).rgb;\n	//return SEA_COLOR1*calcScatter(pos,dir,hitpos);\n	float left = pow(0.8,l);//假设透过率为80%，则到达水底的时候的光强。\n	return mix(hitcolor,u_SeaColor,1.-left);\n}\n\n/*\n	view已经normalize了\n*/\nvec3 getRefractColor(vec3 view,vec3 normal){\n	vec3 T = refract(-view, normal, 0.7);\n	return getShuiDiColor(vWorldPos.xyz,T,normal); \n}\n\nvec4 calcWaterC(vec3 view, vec3 normal, float von, vec3 R, float rough){\n	/*\n	只有浪顶的法线向下，也就是波形形成了交叠的时候，才会这样，所以要通过参数控制避免出现这种情况，而不是在这里保护。\n	if(dot(R,vec3(0.,1.,0.))<0.){\n		R = -R;\n	}\n	*/\n	//vec3 refr = getRefractColor(-view,normal);\n#ifdef USE_REFR_TEX	\n	vec3 refr = texture2D(texUnderWater, gl_FragCoord.xy/u_scrsize+normal.xz/8.).rgb;\n#else\n	vec3 refr = u_SeaColor;\n#endif\n	float F0=0.02;\n	//菲涅尔，越大反射越强\n	float f =  F0+(1.0-F0)*exp2((-5.55473*von-6.98316)*von);\n	//float f = F0+(1.0-F0)*pow(1.-von,5.);\n	//能看到水底的程度。反射剩余的*水中的衰减\n	//float a = (1.-f)*(1.-deepk);\n#ifdef CUBE_ENV\n	vec4 reflc = textureCube(texSky,R);\n#else\n	vec4 reflc = texPanorama(texSky, R);\n#endif\n#ifdef HDR_ENV\n	vec3 refl = _RGBEToRGB(reflc)*f;\n#else\n	vec3 refl = reflc.rgb*f;\n#endif\n	//return vec4(refl*(1.-rough),1.);\n	\n	//vec3 refl = reflc.rgb*f;\n	vec3 final = mix(refr, u_SeaColor, min(fDeep/10.,1.))+refl*(max(0.,1.-rough));\n#ifdef HDR_ENV\n	final = ACESToneMapping(final,1.);//TODO 这个要uniform传入\n#endif\n	return vec4(final,f);\n}\n\nvoid main() {\n    vec3 normal =  normalize(vWorldNorm);\n	//如果uv=1为100米，希望每个细节纹理表示20米的小波形，则uv缩放是 100/20。细节纹理内部也要用这个值，即pos=uv*20\n	vec2 ruv = matUVTrans*vUv;\n	vec3 detailNorm = texture2D(texWaveDetail,fract(ruv*5.)).rgb*2.-vec3(1.);//TODO uv怎么算\n	float texNormScale = 2.*PI*float(NumTexWaves)*Amp_over_L*2.5;\n	detailNorm *= vec3(texNormScale,1.,texNormScale);\n	//旋转\n	//细节纹理来自rendertarget，因此需要颠倒z\n	\n	matTBNOff = mat3(matUVTrans[0][0],0.,matUVTrans[1][0],\n	0.,1.,0.,\n	matUVTrans[0][1],0.,matUVTrans[1][1]\n	);\n	\n	/*\n	matTBNOff = mat3(0.,0.,1.,\n	0.,1.,0.,\n	-1.,0.,0.\n	);\n	*/\n\n    mat3 tsn = mat3( vWorldBin, normal, vWorldTan);	\n    //normal = normalize(tsn * matTBNOff * detailNorm);\n	normal = normalize(tsn * detailNorm); //这个应该更正确。因为本身方向就是根据uv算的，如果是静态图片才需要转换。\n	//vec4 normtex = texture2D( texNormal, vUv );\n    vec3 view   = -normalize(vViewDir);//view 是指向camera的\n    float NoV = saturate(dot( view, normal ));\n    //vec3 R = 2. * NoV * normal - view;\n	\n#ifdef USE_FOAM	\n	vec4 foamc = (texture2D(texFoam,vUv*50.)+texture2D(texFoam,vUv*20.))/2.;\n	float nearcoast = 1.-min(fDeep/10.,1.);// 1.-vWaterInfo.r;\n	float foams = (nearcoast/4.+fFoam)*2.*nearcoast;\n#else\n	float foams =0.;\n#endif\n	\n	vec3 R = reflect(-view,normal);\n	vec4 wc = calcWaterC(view, normal,NoV,R, foams);\n\n	gl_FragColor.rgb = wc.rgb;//normalize(detailNorm).rrr;//((normal)+vec3(0.0))/1.;//normalize(normal).rgb;//texture2D(texWaveDetail,vUv).rgb;// fracColor * texture2D(texUnderWater, vUv*20.0).rgb;// vec3(1.0);//pbrl.rgb;\n    gl_FragColor.a = 1.0;//wc.a;\n#ifdef USE_FOAM\n	gl_FragColor.rgb = mix(gl_FragColor.rgb,vec3(1.),foamc.a*foams);\n	gl_FragColor.a = foamc.r;\n#endif\n	//if(mod(vUv.x*100.,1.0)<0.02 || mod(vUv.y*100.,1.0)<0.02) gl_FragColor.rgb=vec3(0.5,.5,.5);\n	//gl_FragColor.rgb = detailNorm;\n}\n";
		shaderCompile=ShaderCompile3D.add(Water,vs,ps,attributeMap,uniformMap);
		WaterMaterial.SHADERDEFINE_CUBE_ENV=shaderCompile.registerMaterialDefine("CUBE_ENV");
		WaterMaterial.SHADERDEFINE_HDR_ENV=shaderCompile.registerMaterialDefine("HDR_ENV");
		WaterMaterial.SHADERDEFINE_SHOW_NORMAL=shaderCompile.registerMaterialDefine("SHOW_NORMAL");
		WaterMaterial.SHADERDEFINE_USEVERTEXHEIGHT=shaderCompile.registerMaterialDefine("USE_VERTEX_DEEPINFO");
		WaterMaterial.SHADERDEFINE_USE_FOAM=shaderCompile.registerMaterialDefine("USE_FOAM");
		WaterMaterial.SHADERDEFINE_USE_REFRACT_TEX=shaderCompile.registerMaterialDefine("USE_REFR_TEX");
		attributeMap={
			'a_CornerTextureCoordinate':/*laya.d3.graphics.VertexElementUsage.CORNERTEXTURECOORDINATE0*/17,
			'a_MeshPosition':/*laya.d3.graphics.VertexElementUsage.POSITION0*/0,
			'a_MeshColor':/*laya.d3.graphics.VertexElementUsage.COLOR0*/1,
			'a_MeshTextureCoordinate':/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE0*/2,
			'a_ShapePositionStartLifeTime':/*laya.d3.graphics.VertexElementUsage.SHAPEPOSITIONSTARTLIFETIME*/30,
			'a_DirectionTime':/*laya.d3.graphics.VertexElementUsage.DIRECTIONTIME*/32,
			'a_StartColor':/*laya.d3.graphics.VertexElementUsage.STARTCOLOR0*/19,
			'a_EndColor':/*laya.d3.graphics.VertexElementUsage.ENDCOLOR0*/23,
			'a_StartSize':/*laya.d3.graphics.VertexElementUsage.STARTSIZE*/20,
			'a_StartRotation0':/*laya.d3.graphics.VertexElementUsage.STARTROTATION*/22,
			'a_StartSpeed':/*laya.d3.graphics.VertexElementUsage.STARTSPEED*/31,
			'a_Random0':/*laya.d3.graphics.VertexElementUsage.RANDOM0*/34,
			'a_Random1':/*laya.d3.graphics.VertexElementUsage.RANDOM1*/35,
			'a_SimulationWorldPostion':/*laya.d3.graphics.VertexElementUsage.SIMULATIONWORLDPOSTION*/36,
			'a_SimulationWorldRotation':/*laya.d3.graphics.VertexElementUsage.SIMULATIONWORLDROTATION*/37};
		uniformMap={
			'u_Tintcolor':[ /*laya.d3.core.particleShuriKen.ShurikenParticleMaterial.TINTCOLOR*/2,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_TilingOffset':[ /*laya.d3.core.particleShuriKen.ShurikenParticleMaterial.TILINGOFFSET*/3,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_texture':[ /*laya.d3.core.particleShuriKen.ShurikenParticleMaterial.DIFFUSETEXTURE*/1,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_WorldPosition':[ /*laya.d3.core.particleShuriKen.ShuriKenParticle3D.WORLDPOSITION*/0,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],
			'u_WorldRotation':[ /*laya.d3.core.particleShuriKen.ShuriKenParticle3D.WORLDROTATION*/1,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],
			'u_PositionScale':[ /*laya.d3.core.particleShuriKen.ShuriKenParticle3D.POSITIONSCALE*/4,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],
			'u_SizeScale':[ /*laya.d3.core.particleShuriKen.ShuriKenParticle3D.SIZESCALE*/5,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],
			'u_ScalingMode':[ /*laya.d3.core.particleShuriKen.ShuriKenParticle3D.SCALINGMODE*/6,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],
			'u_Gravity':[ /*laya.d3.core.particleShuriKen.ShuriKenParticle3D.GRAVITY*/7,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],
			'u_ThreeDStartRotation':[ /*laya.d3.core.particleShuriKen.ShuriKenParticle3D.THREEDSTARTROTATION*/8,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],
			'u_StretchedBillboardLengthScale':[ /*laya.d3.core.particleShuriKen.ShuriKenParticle3D.STRETCHEDBILLBOARDLENGTHSCALE*/9,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],
			'u_StretchedBillboardSpeedScale':[ /*laya.d3.core.particleShuriKen.ShuriKenParticle3D.STRETCHEDBILLBOARDSPEEDSCALE*/10,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],
			'u_SimulationSpace':[ /*laya.d3.core.particleShuriKen.ShuriKenParticle3D.SIMULATIONSPACE*/11,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],
			'u_CurrentTime':[ /*laya.d3.core.particleShuriKen.ShuriKenParticle3D.CURRENTTIME*/12,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],
			'u_ColorOverLifeGradientAlphas':[ /*laya.d3.core.particleShuriKen.ShuriKenParticle3D.COLOROVERLIFEGRADIENTALPHAS*/22,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],
			'u_ColorOverLifeGradientColors':[ /*laya.d3.core.particleShuriKen.ShuriKenParticle3D.COLOROVERLIFEGRADIENTCOLORS*/23,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],
			'u_MaxColorOverLifeGradientAlphas':[ /*laya.d3.core.particleShuriKen.ShuriKenParticle3D.MAXCOLOROVERLIFEGRADIENTALPHAS*/24,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],
			'u_MaxColorOverLifeGradientColors':[ /*laya.d3.core.particleShuriKen.ShuriKenParticle3D.MAXCOLOROVERLIFEGRADIENTCOLORS*/25,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],
			'u_VOLVelocityConst':[ /*laya.d3.core.particleShuriKen.ShuriKenParticle3D.VOLVELOCITYCONST*/13,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],
			'u_VOLVelocityGradientX':[ /*laya.d3.core.particleShuriKen.ShuriKenParticle3D.VOLVELOCITYGRADIENTX*/14,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],
			'u_VOLVelocityGradientY':[ /*laya.d3.core.particleShuriKen.ShuriKenParticle3D.VOLVELOCITYGRADIENTY*/15,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],
			'u_VOLVelocityGradientZ':[ /*laya.d3.core.particleShuriKen.ShuriKenParticle3D.VOLVELOCITYGRADIENTZ*/16,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],
			'u_VOLVelocityConstMax':[ /*laya.d3.core.particleShuriKen.ShuriKenParticle3D.VOLVELOCITYCONSTMAX*/17,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],
			'u_VOLVelocityGradientMaxX':[ /*laya.d3.core.particleShuriKen.ShuriKenParticle3D.VOLVELOCITYGRADIENTXMAX*/18,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],
			'u_VOLVelocityGradientMaxY':[ /*laya.d3.core.particleShuriKen.ShuriKenParticle3D.VOLVELOCITYGRADIENTYMAX*/19,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],
			'u_VOLVelocityGradientMaxZ':[ /*laya.d3.core.particleShuriKen.ShuriKenParticle3D.VOLVELOCITYGRADIENTZMAX*/20,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],
			'u_VOLSpaceType':[ /*laya.d3.core.particleShuriKen.ShuriKenParticle3D.VOLSPACETYPE*/21,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],
			'u_SOLSizeGradient':[ /*laya.d3.core.particleShuriKen.ShuriKenParticle3D.SOLSIZEGRADIENT*/26,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],
			'u_SOLSizeGradientX':[ /*laya.d3.core.particleShuriKen.ShuriKenParticle3D.SOLSIZEGRADIENTX*/27,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],
			'u_SOLSizeGradientY':[ /*laya.d3.core.particleShuriKen.ShuriKenParticle3D.SOLSIZEGRADIENTY*/28,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],
			'u_SOLSizeGradientZ':[ /*laya.d3.core.particleShuriKen.ShuriKenParticle3D.SOLSizeGradientZ*/29,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],
			'u_SOLSizeGradientMax':[ /*laya.d3.core.particleShuriKen.ShuriKenParticle3D.SOLSizeGradientMax*/30,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],
			'u_SOLSizeGradientMaxX':[ /*laya.d3.core.particleShuriKen.ShuriKenParticle3D.SOLSIZEGRADIENTXMAX*/31,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],
			'u_SOLSizeGradientMaxY':[ /*laya.d3.core.particleShuriKen.ShuriKenParticle3D.SOLSIZEGRADIENTYMAX*/32,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],
			'u_SOLSizeGradientMaxZ':[ /*laya.d3.core.particleShuriKen.ShuriKenParticle3D.SOLSizeGradientZMAX*/33,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],
			'u_ROLAngularVelocityConst':[ /*laya.d3.core.particleShuriKen.ShuriKenParticle3D.ROLANGULARVELOCITYCONST*/34,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],
			'u_ROLAngularVelocityConstSeprarate':[ /*laya.d3.core.particleShuriKen.ShuriKenParticle3D.ROLANGULARVELOCITYCONSTSEPRARATE*/35,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],
			'u_ROLAngularVelocityGradient':[ /*laya.d3.core.particleShuriKen.ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENT*/36,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],
			'u_ROLAngularVelocityGradientX':[ /*laya.d3.core.particleShuriKen.ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTX*/37,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],
			'u_ROLAngularVelocityGradientY':[ /*laya.d3.core.particleShuriKen.ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTY*/38,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],
			'u_ROLAngularVelocityGradientZ':[ /*laya.d3.core.particleShuriKen.ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTZ*/39,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],
			'u_ROLAngularVelocityGradientW':[ /*laya.d3.core.particleShuriKen.ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTW*/40,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],
			'u_ROLAngularVelocityConstMax':[ /*laya.d3.core.particleShuriKen.ShuriKenParticle3D.ROLANGULARVELOCITYCONSTMAX*/41,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],
			'u_ROLAngularVelocityConstMaxSeprarate':[ /*laya.d3.core.particleShuriKen.ShuriKenParticle3D.ROLANGULARVELOCITYCONSTMAXSEPRARATE*/42,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],
			'u_ROLAngularVelocityGradientMax':[ /*laya.d3.core.particleShuriKen.ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTMAX*/43,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],
			'u_ROLAngularVelocityGradientMaxX':[ /*laya.d3.core.particleShuriKen.ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTXMAX*/44,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],
			'u_ROLAngularVelocityGradientMaxY':[ /*laya.d3.core.particleShuriKen.ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTYMAX*/45,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],
			'u_ROLAngularVelocityGradientMaxZ':[ /*laya.d3.core.particleShuriKen.ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTZMAX*/46,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],
			'u_ROLAngularVelocityGradientMaxW':[ /*laya.d3.core.particleShuriKen.ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTWMAX*/47,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],
			'u_TSACycles':[ /*laya.d3.core.particleShuriKen.ShuriKenParticle3D.TEXTURESHEETANIMATIONCYCLES*/48,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],
			'u_TSASubUVLength':[ /*laya.d3.core.particleShuriKen.ShuriKenParticle3D.TEXTURESHEETANIMATIONSUBUVLENGTH*/49,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],
			'u_TSAGradientUVs':[ /*laya.d3.core.particleShuriKen.ShuriKenParticle3D.TEXTURESHEETANIMATIONGRADIENTUVS*/50,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],
			'u_TSAMaxGradientUVs':[ /*laya.d3.core.particleShuriKen.ShuriKenParticle3D.TEXTURESHEETANIMATIONGRADIENTMAXUVS*/51,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],
			'u_CameraPosition':[ /*laya.d3.core.BaseCamera.CAMERAPOS*/0,/*laya.d3.shader.Shader3D.PERIOD_CAMERA*/3],
			'u_CameraDirection':[ /*laya.d3.core.BaseCamera.CAMERADIRECTION*/5,/*laya.d3.shader.Shader3D.PERIOD_CAMERA*/3],
			'u_CameraUp':[ /*laya.d3.core.BaseCamera.CAMERAUP*/6,/*laya.d3.shader.Shader3D.PERIOD_CAMERA*/3],
			'u_View':[ /*laya.d3.core.BaseCamera.VIEWMATRIX*/1,/*laya.d3.shader.Shader3D.PERIOD_CAMERA*/3],
			'u_Projection':[ /*laya.d3.core.BaseCamera.PROJECTMATRIX*/2,/*laya.d3.shader.Shader3D.PERIOD_CAMERA*/3],
			'u_FogStart':[ /*laya.d3.core.scene.Scene.FOGSTART*/1,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_FogRange':[ /*laya.d3.core.scene.Scene.FOGRANGE*/2,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_FogColor':[ /*laya.d3.core.scene.Scene.FOGCOLOR*/0,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4]};
		var PARTICLESHURIKEN=Shader3D.nameKey.add("PARTICLESHURIKEN");
		vs="#ifdef HIGHPRECISION\n  precision highp float;\n#else\n  precision mediump float;\n#endif\n\n#if defined(SPHERHBILLBOARD)||defined(STRETCHEDBILLBOARD)||defined(HORIZONTALBILLBOARD)||defined(VERTICALBILLBOARD)\n	attribute vec4 a_CornerTextureCoordinate;\n#endif\n#ifdef RENDERMODE_MESH\n	attribute vec3 a_MeshPosition;\n	attribute vec4 a_MeshColor;\n	attribute vec2 a_MeshTextureCoordinate;\n	varying vec4 v_MeshColor;\n#endif\n\nattribute vec4 a_ShapePositionStartLifeTime;\nattribute vec4 a_DirectionTime;\nattribute vec4 a_StartColor;\nattribute vec3 a_StartSize;\nattribute vec3 a_StartRotation0;\nattribute float a_StartSpeed;\n#if defined(COLOROVERLIFETIME)||defined(RANDOMCOLOROVERLIFETIME)||defined(SIZEOVERLIFETIMERANDOMCURVES)||defined(SIZEOVERLIFETIMERANDOMCURVESSEPERATE)||defined(ROTATIONOVERLIFETIMERANDOMCONSTANTS)||defined(ROTATIONOVERLIFETIMERANDOMCURVES)\n  attribute vec4 a_Random0;\n#endif\n#if defined(TEXTURESHEETANIMATIONRANDOMCURVE)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\n  attribute vec4 a_Random1;\n#endif\nattribute vec3 a_SimulationWorldPostion;\nattribute vec4 a_SimulationWorldRotation;\n\nvarying float v_Discard;\nvarying vec4 v_Color;\n#ifdef DIFFUSEMAP\n	varying vec2 v_TextureCoordinate;\n#endif\n\nuniform float u_CurrentTime;\nuniform vec3 u_Gravity;\n\nuniform vec3 u_WorldPosition;\nuniform vec4 u_WorldRotation;\nuniform bool u_ThreeDStartRotation;\nuniform int u_ScalingMode;\nuniform vec3 u_PositionScale;\nuniform vec3 u_SizeScale;\nuniform mat4 u_View;\nuniform mat4 u_Projection;\n\n#ifdef STRETCHEDBILLBOARD\n	uniform vec3 u_CameraPosition;\n#endif\nuniform vec3 u_CameraDirection;//TODO:只有几种广告牌模式需要用\nuniform vec3 u_CameraUp;\n\nuniform  float u_StretchedBillboardLengthScale;\nuniform  float u_StretchedBillboardSpeedScale;\nuniform int u_SimulationSpace;\n\n#if defined(VELOCITYOVERLIFETIMECONSTANT)||defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\n  uniform  int  u_VOLSpaceType;\n#endif\n#if defined(VELOCITYOVERLIFETIMECONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)\n  uniform  vec3 u_VOLVelocityConst;\n#endif\n#if defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\n  uniform  vec2 u_VOLVelocityGradientX[4];//x为key,y为速度\n  uniform  vec2 u_VOLVelocityGradientY[4];//x为key,y为速度\n  uniform  vec2 u_VOLVelocityGradientZ[4];//x为key,y为速度\n#endif\n#ifdef VELOCITYOVERLIFETIMERANDOMCONSTANT\n  uniform  vec3 u_VOLVelocityConstMax;\n#endif\n#ifdef VELOCITYOVERLIFETIMERANDOMCURVE\n  uniform  vec2 u_VOLVelocityGradientMaxX[4];//x为key,y为速度\n  uniform  vec2 u_VOLVelocityGradientMaxY[4];//x为key,y为速度\n  uniform  vec2 u_VOLVelocityGradientMaxZ[4];//x为key,y为速度\n#endif\n\n#ifdef COLOROVERLIFETIME\n  uniform  vec4 u_ColorOverLifeGradientColors[4];//x为key,yzw为Color\n  uniform  vec2 u_ColorOverLifeGradientAlphas[4];//x为key,y为Alpha\n#endif\n#ifdef RANDOMCOLOROVERLIFETIME\n  uniform  vec4 u_ColorOverLifeGradientColors[4];//x为key,yzw为Color\n  uniform  vec2 u_ColorOverLifeGradientAlphas[4];//x为key,y为Alpha\n  uniform  vec4 u_MaxColorOverLifeGradientColors[4];//x为key,yzw为Color\n  uniform  vec2 u_MaxColorOverLifeGradientAlphas[4];//x为key,y为Alpha\n#endif\n\n\n#if defined(SIZEOVERLIFETIMECURVE)||defined(SIZEOVERLIFETIMERANDOMCURVES)\n  uniform  vec2 u_SOLSizeGradient[4];//x为key,y为尺寸\n#endif\n#ifdef SIZEOVERLIFETIMERANDOMCURVES\n  uniform  vec2 u_SOLSizeGradientMax[4];//x为key,y为尺寸\n#endif\n#if defined(SIZEOVERLIFETIMECURVESEPERATE)||defined(SIZEOVERLIFETIMERANDOMCURVESSEPERATE)\n  uniform  vec2 u_SOLSizeGradientX[4];//x为key,y为尺寸\n  uniform  vec2 u_SOLSizeGradientY[4];//x为key,y为尺寸\n  uniform  vec2 u_SOLSizeGradientZ[4];//x为key,y为尺寸\n#endif\n#ifdef SIZEOVERLIFETIMERANDOMCURVESSEPERATE\n  uniform  vec2 u_SOLSizeGradientMaxX[4];//x为key,y为尺寸\n  uniform  vec2 u_SOLSizeGradientMaxY[4];//x为key,y为尺寸\n  uniform  vec2 u_SOLSizeGradientMaxZ[4];//x为key,y为尺寸\n#endif\n\n\n#ifdef ROTATIONOVERLIFETIME\n  #if defined(ROTATIONOVERLIFETIMECONSTANT)||defined(ROTATIONOVERLIFETIMERANDOMCONSTANTS)\n    uniform  float u_ROLAngularVelocityConst;\n  #endif\n  #ifdef ROTATIONOVERLIFETIMERANDOMCONSTANTS\n    uniform  float u_ROLAngularVelocityConstMax;\n  #endif\n  #if defined(ROTATIONOVERLIFETIMECURVE)||defined(ROTATIONOVERLIFETIMERANDOMCURVES)\n    uniform  vec2 u_ROLAngularVelocityGradient[4];//x为key,y为旋转\n  #endif\n  #ifdef ROTATIONOVERLIFETIMERANDOMCURVES\n    uniform  vec2 u_ROLAngularVelocityGradientMax[4];//x为key,y为旋转\n  #endif\n#endif\n#ifdef ROTATIONOVERLIFETIMESEPERATE\n  #if defined(ROTATIONOVERLIFETIMECONSTANT)||defined(ROTATIONOVERLIFETIMERANDOMCONSTANTS)\n    uniform  vec3 u_ROLAngularVelocityConstSeprarate;\n  #endif\n  #ifdef ROTATIONOVERLIFETIMERANDOMCONSTANTS\n    uniform  vec3 u_ROLAngularVelocityConstMaxSeprarate;\n  #endif\n  #if defined(ROTATIONOVERLIFETIMECURVE)||defined(ROTATIONOVERLIFETIMERANDOMCURVES)\n    uniform  vec2 u_ROLAngularVelocityGradientX[4];\n    uniform  vec2 u_ROLAngularVelocityGradientY[4];\n    uniform  vec2 u_ROLAngularVelocityGradientZ[4];\n	uniform  vec2 u_ROLAngularVelocityGradientW[4];\n  #endif\n  #ifdef ROTATIONOVERLIFETIMERANDOMCURVES\n    uniform  vec2 u_ROLAngularVelocityGradientMaxX[4];\n    uniform  vec2 u_ROLAngularVelocityGradientMaxY[4];\n    uniform  vec2 u_ROLAngularVelocityGradientMaxZ[4];\n	uniform  vec2 u_ROLAngularVelocityGradientMaxW[4];\n  #endif\n#endif\n\n#if defined(TEXTURESHEETANIMATIONCURVE)||defined(TEXTURESHEETANIMATIONRANDOMCURVE)\n  uniform  float u_TSACycles;\n  uniform  vec2 u_TSASubUVLength;\n  uniform  vec2 u_TSAGradientUVs[4];//x为key,y为frame\n#endif\n#ifdef TEXTURESHEETANIMATIONRANDOMCURVE\n  uniform  vec2 u_TSAMaxGradientUVs[4];//x为key,y为frame\n#endif\n\n#ifdef FOG\n	varying vec3 v_PositionWorld;\n#endif\n\n#ifdef TILINGOFFSET\n	uniform vec4 u_TilingOffset;\n#endif\n\nvec3 rotationByEuler(in vec3 vector,in vec3 rot)\n{\n	float halfRoll = rot.z * 0.5;\n    float halfPitch = rot.x * 0.5;\n	float halfYaw = rot.y * 0.5;\n\n	float sinRoll = sin(halfRoll);\n	float cosRoll = cos(halfRoll);\n	float sinPitch = sin(halfPitch);\n	float cosPitch = cos(halfPitch);\n	float sinYaw = sin(halfYaw);\n	float cosYaw = cos(halfYaw);\n\n	float quaX = (cosYaw * sinPitch * cosRoll) + (sinYaw * cosPitch * sinRoll);\n	float quaY = (sinYaw * cosPitch * cosRoll) - (cosYaw * sinPitch * sinRoll);\n	float quaZ = (cosYaw * cosPitch * sinRoll) - (sinYaw * sinPitch * cosRoll);\n	float quaW = (cosYaw * cosPitch * cosRoll) + (sinYaw * sinPitch * sinRoll);\n	\n	//vec4 q=vec4(quaX,quaY,quaZ,quaW);\n	//vec3 temp = cross(q.xyz, vector) + q.w * vector;\n	//return (cross(temp, -q.xyz) + dot(q.xyz,vector) * q.xyz + q.w * temp);\n	\n	float x = quaX + quaX;\n    float y = quaY + quaY;\n    float z = quaZ + quaZ;\n    float wx = quaW * x;\n    float wy = quaW * y;\n    float wz = quaW * z;\n	float xx = quaX * x;\n    float xy = quaX * y;\n	float xz = quaX * z;\n    float yy = quaY * y;\n    float yz = quaY * z;\n    float zz = quaZ * z;\n\n    return vec3(((vector.x * ((1.0 - yy) - zz)) + (vector.y * (xy - wz))) + (vector.z * (xz + wy)),\n                ((vector.x * (xy + wz)) + (vector.y * ((1.0 - xx) - zz))) + (vector.z * (yz - wx)),\n                ((vector.x * (xz - wy)) + (vector.y * (yz + wx))) + (vector.z * ((1.0 - xx) - yy)));\n	\n}\n\n//假定axis已经归一化\nvec3 rotationByAxis(in vec3 vector,in vec3 axis, in float angle)\n{\n	float halfAngle = angle * 0.5;\n	float sin = sin(halfAngle);\n	\n	float quaX = axis.x * sin;\n	float quaY = axis.y * sin;\n	float quaZ = axis.z * sin;\n	float quaW = cos(halfAngle);\n	\n	//vec4 q=vec4(quaX,quaY,quaZ,quaW);\n	//vec3 temp = cross(q.xyz, vector) + q.w * vector;\n	//return (cross(temp, -q.xyz) + dot(q.xyz,vector) * q.xyz + q.w * temp);\n	\n	float x = quaX + quaX;\n    float y = quaY + quaY;\n    float z = quaZ + quaZ;\n    float wx = quaW * x;\n    float wy = quaW * y;\n    float wz = quaW * z;\n	float xx = quaX * x;\n    float xy = quaX * y;\n	float xz = quaX * z;\n    float yy = quaY * y;\n    float yz = quaY * z;\n    float zz = quaZ * z;\n\n    return vec3(((vector.x * ((1.0 - yy) - zz)) + (vector.y * (xy - wz))) + (vector.z * (xz + wy)),\n                ((vector.x * (xy + wz)) + (vector.y * ((1.0 - xx) - zz))) + (vector.z * (yz - wx)),\n                ((vector.x * (xz - wy)) + (vector.y * (yz + wx))) + (vector.z * ((1.0 - xx) - yy)));\n	\n}\n\nvec3 rotationByQuaternions(in vec3 v,in vec4 q) \n{\n	return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);\n}\n\n \n#if defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)||defined(SIZEOVERLIFETIMECURVE)||defined(SIZEOVERLIFETIMECURVESEPERATE)||defined(SIZEOVERLIFETIMERANDOMCURVES)||defined(SIZEOVERLIFETIMERANDOMCURVESSEPERATE)\nfloat getCurValueFromGradientFloat(in vec2 gradientNumbers[4],in float normalizedAge)\n{\n	float curValue;\n	for(int i=1;i<4;i++)\n	{\n		vec2 gradientNumber=gradientNumbers[i];\n		float key=gradientNumber.x;\n		if(key>=normalizedAge)\n		{\n			vec2 lastGradientNumber=gradientNumbers[i-1];\n			float lastKey=lastGradientNumber.x;\n			float age=(normalizedAge-lastKey)/(key-lastKey);\n			curValue=mix(lastGradientNumber.y,gradientNumber.y,age);\n			break;\n		}\n	}\n	return curValue;\n}\n#endif\n\n#if defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)||defined(ROTATIONOVERLIFETIMECURVE)||defined(ROTATIONOVERLIFETIMERANDOMCURVES)\nfloat getTotalValueFromGradientFloat(in vec2 gradientNumbers[4],in float normalizedAge)\n{\n	float totalValue=0.0;\n	for(int i=1;i<4;i++)\n	{\n		vec2 gradientNumber=gradientNumbers[i];\n		float key=gradientNumber.x;\n		vec2 lastGradientNumber=gradientNumbers[i-1];\n		float lastValue=lastGradientNumber.y;\n		\n		if(key>=normalizedAge){\n			float lastKey=lastGradientNumber.x;\n			float age=(normalizedAge-lastKey)/(key-lastKey);\n			totalValue+=(lastValue+mix(lastValue,gradientNumber.y,age))/2.0*a_ShapePositionStartLifeTime.w*(normalizedAge-lastKey);\n			break;\n		}\n		else{\n			totalValue+=(lastValue+gradientNumber.y)/2.0*a_ShapePositionStartLifeTime.w*(key-lastGradientNumber.x);\n		}\n	}\n	return totalValue;\n}\n#endif\n\n#if defined(COLOROVERLIFETIME)||defined(RANDOMCOLOROVERLIFETIME)\nvec4 getColorFromGradient(in vec2 gradientAlphas[4],in vec4 gradientColors[4],in float normalizedAge)\n{\n	vec4 overTimeColor;\n	for(int i=1;i<4;i++)\n	{\n		vec2 gradientAlpha=gradientAlphas[i];\n		float alphaKey=gradientAlpha.x;\n		if(alphaKey>=normalizedAge)\n		{\n			vec2 lastGradientAlpha=gradientAlphas[i-1];\n			float lastAlphaKey=lastGradientAlpha.x;\n			float age=(normalizedAge-lastAlphaKey)/(alphaKey-lastAlphaKey);\n			overTimeColor.a=mix(lastGradientAlpha.y,gradientAlpha.y,age);\n			break;\n		}\n	}\n	\n	for(int i=1;i<4;i++)\n	{\n		vec4 gradientColor=gradientColors[i];\n		float colorKey=gradientColor.x;\n		if(colorKey>=normalizedAge)\n		{\n			vec4 lastGradientColor=gradientColors[i-1];\n			float lastColorKey=lastGradientColor.x;\n			float age=(normalizedAge-lastColorKey)/(colorKey-lastColorKey);\n			overTimeColor.rgb=mix(gradientColors[i-1].yzw,gradientColor.yzw,age);\n			break;\n		}\n	}\n	return overTimeColor;\n}\n#endif\n\n\n#if defined(TEXTURESHEETANIMATIONCURVE)||defined(TEXTURESHEETANIMATIONRANDOMCURVE)\nfloat getFrameFromGradient(in vec2 gradientFrames[4],in float normalizedAge)\n{\n	float overTimeFrame;\n	for(int i=1;i<4;i++)\n	{\n		vec2 gradientFrame=gradientFrames[i];\n		float key=gradientFrame.x;\n		if(key>=normalizedAge)\n		{\n			vec2 lastGradientFrame=gradientFrames[i-1];\n			float lastKey=lastGradientFrame.x;\n			float age=(normalizedAge-lastKey)/(key-lastKey);\n			overTimeFrame=mix(lastGradientFrame.y,gradientFrame.y,age);\n			break;\n		}\n	}\n	return floor(overTimeFrame);\n}\n#endif\n\n#if defined(VELOCITYOVERLIFETIMECONSTANT)||defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\nvec3 computeParticleLifeVelocity(in float normalizedAge)\n{\n  vec3 outLifeVelocity;\n  #ifdef VELOCITYOVERLIFETIMECONSTANT\n	 outLifeVelocity=u_VOLVelocityConst; \n  #endif\n  #ifdef VELOCITYOVERLIFETIMECURVE\n     outLifeVelocity= vec3(getCurValueFromGradientFloat(u_VOLVelocityGradientX,normalizedAge),getCurValueFromGradientFloat(u_VOLVelocityGradientY,normalizedAge),getCurValueFromGradientFloat(u_VOLVelocityGradientZ,normalizedAge));\n  #endif\n  #ifdef VELOCITYOVERLIFETIMERANDOMCONSTANT\n	 outLifeVelocity=mix(u_VOLVelocityConst,u_VOLVelocityConstMax,vec3(a_Random1.y,a_Random1.z,a_Random1.w)); \n  #endif\n  #ifdef VELOCITYOVERLIFETIMERANDOMCURVE\n     outLifeVelocity=vec3(mix(getCurValueFromGradientFloat(u_VOLVelocityGradientX,normalizedAge),getCurValueFromGradientFloat(u_VOLVelocityGradientMaxX,normalizedAge),a_Random1.y),\n	                 mix(getCurValueFromGradientFloat(u_VOLVelocityGradientY,normalizedAge),getCurValueFromGradientFloat(u_VOLVelocityGradientMaxY,normalizedAge),a_Random1.z),\n					 mix(getCurValueFromGradientFloat(u_VOLVelocityGradientZ,normalizedAge),getCurValueFromGradientFloat(u_VOLVelocityGradientMaxZ,normalizedAge),a_Random1.w));\n  #endif\n					\n  return outLifeVelocity;\n} \n#endif\n\nvec3 computeParticlePosition(in vec3 startVelocity, in vec3 lifeVelocity,in float age,in float normalizedAge,vec3 gravityVelocity,vec4 worldRotation)\n{\n   vec3 startPosition;\n   vec3 lifePosition;\n   #if defined(VELOCITYOVERLIFETIMECONSTANT)||defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\n	#ifdef VELOCITYOVERLIFETIMECONSTANT\n		  startPosition=startVelocity*age;\n		  lifePosition=lifeVelocity*age;\n	#endif\n	#ifdef VELOCITYOVERLIFETIMECURVE\n		  startPosition=startVelocity*age;\n		  lifePosition=vec3(getTotalValueFromGradientFloat(u_VOLVelocityGradientX,normalizedAge),getTotalValueFromGradientFloat(u_VOLVelocityGradientY,normalizedAge),getTotalValueFromGradientFloat(u_VOLVelocityGradientZ,normalizedAge));\n	#endif\n	#ifdef VELOCITYOVERLIFETIMERANDOMCONSTANT\n		  startPosition=startVelocity*age;\n		  lifePosition=lifeVelocity*age;\n	#endif\n	#ifdef VELOCITYOVERLIFETIMERANDOMCURVE\n		  startPosition=startVelocity*age;\n		  lifePosition=vec3(mix(getTotalValueFromGradientFloat(u_VOLVelocityGradientX,normalizedAge),getTotalValueFromGradientFloat(u_VOLVelocityGradientMaxX,normalizedAge),a_Random1.y)\n	      ,mix(getTotalValueFromGradientFloat(u_VOLVelocityGradientY,normalizedAge),getTotalValueFromGradientFloat(u_VOLVelocityGradientMaxY,normalizedAge),a_Random1.z)\n	      ,mix(getTotalValueFromGradientFloat(u_VOLVelocityGradientZ,normalizedAge),getTotalValueFromGradientFloat(u_VOLVelocityGradientMaxZ,normalizedAge),a_Random1.w));\n	#endif\n	\n	vec3 finalPosition;\n	if(u_VOLSpaceType==0){\n	  if(u_ScalingMode!=2)\n	   finalPosition =rotationByQuaternions(u_PositionScale*(a_ShapePositionStartLifeTime.xyz+startPosition+lifePosition),worldRotation);\n	  else\n	   finalPosition =rotationByQuaternions(u_PositionScale*a_ShapePositionStartLifeTime.xyz+startPosition+lifePosition,worldRotation);\n	}\n	else{\n	  if(u_ScalingMode!=2)\n	    finalPosition = rotationByQuaternions(u_PositionScale*(a_ShapePositionStartLifeTime.xyz+startPosition),worldRotation)+lifePosition;\n	  else\n	    finalPosition = rotationByQuaternions(u_PositionScale*a_ShapePositionStartLifeTime.xyz+startPosition,worldRotation)+lifePosition;\n	}\n  #else\n	 startPosition=startVelocity*age;\n	 vec3 finalPosition;\n	 if(u_ScalingMode!=2)\n	   finalPosition = rotationByQuaternions(u_PositionScale*(a_ShapePositionStartLifeTime.xyz+startPosition),worldRotation);\n	 else\n	   finalPosition = rotationByQuaternions(u_PositionScale*a_ShapePositionStartLifeTime.xyz+startPosition,worldRotation);\n  #endif\n  \n  if(u_SimulationSpace==0)\n    finalPosition=finalPosition+a_SimulationWorldPostion;\n  else if(u_SimulationSpace==1) \n    finalPosition=finalPosition+u_WorldPosition;\n  \n  finalPosition+=0.5*gravityVelocity*age;\n \n  return  finalPosition;\n}\n\n\nvec4 computeParticleColor(in vec4 color,in float normalizedAge)\n{\n	#ifdef COLOROVERLIFETIME\n	  color*=getColorFromGradient(u_ColorOverLifeGradientAlphas,u_ColorOverLifeGradientColors,normalizedAge);\n	#endif\n	\n	#ifdef RANDOMCOLOROVERLIFETIME\n	  color*=mix(getColorFromGradient(u_ColorOverLifeGradientAlphas,u_ColorOverLifeGradientColors,normalizedAge),getColorFromGradient(u_MaxColorOverLifeGradientAlphas,u_MaxColorOverLifeGradientColors,normalizedAge),a_Random0.y);\n	#endif\n\n    return color;\n}\n\nvec2 computeParticleSizeBillbard(in vec2 size,in float normalizedAge)\n{\n	#ifdef SIZEOVERLIFETIMECURVE\n		size*=getCurValueFromGradientFloat(u_SOLSizeGradient,normalizedAge);\n	#endif\n	#ifdef SIZEOVERLIFETIMERANDOMCURVES\n	    size*=mix(getCurValueFromGradientFloat(u_SOLSizeGradient,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMax,normalizedAge),a_Random0.z); \n	#endif\n	#ifdef SIZEOVERLIFETIMECURVESEPERATE\n		size*=vec2(getCurValueFromGradientFloat(u_SOLSizeGradientX,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientY,normalizedAge));\n	#endif\n	#ifdef SIZEOVERLIFETIMERANDOMCURVESSEPERATE\n	    size*=vec2(mix(getCurValueFromGradientFloat(u_SOLSizeGradientX,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMaxX,normalizedAge),a_Random0.z)\n	    ,mix(getCurValueFromGradientFloat(u_SOLSizeGradientY,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMaxY,normalizedAge),a_Random0.z));\n	#endif\n	return size;\n}\n\n#ifdef RENDERMODE_MESH\nvec3 computeParticleSizeMesh(in vec3 size,in float normalizedAge)\n{\n	#ifdef SIZEOVERLIFETIMECURVE\n		size*=getCurValueFromGradientFloat(u_SOLSizeGradient,normalizedAge);\n	#endif\n	#ifdef SIZEOVERLIFETIMERANDOMCURVES\n	    size*=mix(getCurValueFromGradientFloat(u_SOLSizeGradient,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMax,normalizedAge),a_Random0.z); \n	#endif\n	#ifdef SIZEOVERLIFETIMECURVESEPERATE\n		size*=vec3(getCurValueFromGradientFloat(u_SOLSizeGradientX,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientY,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientZ,normalizedAge));\n	#endif\n	#ifdef SIZEOVERLIFETIMERANDOMCURVESSEPERATE\n	    size*=vec3(mix(getCurValueFromGradientFloat(u_SOLSizeGradientX,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMaxX,normalizedAge),a_Random0.z)\n	    ,mix(getCurValueFromGradientFloat(u_SOLSizeGradientY,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMaxY,normalizedAge),a_Random0.z)\n		,mix(getCurValueFromGradientFloat(u_SOLSizeGradientZ,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMaxZ,normalizedAge),a_Random0.z));\n	#endif\n	return size;\n}\n#endif\n\nfloat computeParticleRotationFloat(in float rotation,in float age,in float normalizedAge)\n{ \n	#ifdef ROTATIONOVERLIFETIME\n		#ifdef ROTATIONOVERLIFETIMECONSTANT\n			float ageRot=u_ROLAngularVelocityConst*age;\n	        rotation+=ageRot;\n		#endif\n		#ifdef ROTATIONOVERLIFETIMECURVE\n			rotation+=getTotalValueFromGradientFloat(u_ROLAngularVelocityGradient,normalizedAge);\n		#endif\n		#ifdef ROTATIONOVERLIFETIMERANDOMCONSTANTS\n			float ageRot=mix(u_ROLAngularVelocityConst,u_ROLAngularVelocityConstMax,a_Random0.w)*age;\n	        rotation+=ageRot;\n	    #endif\n		#ifdef ROTATIONOVERLIFETIMERANDOMCURVES\n			rotation+=mix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradient,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientMax,normalizedAge),a_Random0.w);\n		#endif\n	#endif\n	#ifdef ROTATIONOVERLIFETIMESEPERATE\n		#ifdef ROTATIONOVERLIFETIMECONSTANT\n			float ageRot=u_ROLAngularVelocityConstSeprarate.z*age;\n	        rotation+=ageRot;\n		#endif\n		#ifdef ROTATIONOVERLIFETIMECURVE\n			rotation+=getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientZ,normalizedAge);\n		#endif\n		#ifdef ROTATIONOVERLIFETIMERANDOMCONSTANTS\n			float ageRot=mix(u_ROLAngularVelocityConstSeprarate.z,u_ROLAngularVelocityConstMaxSeprarate.z,a_Random0.w)*age;\n	        rotation+=ageRot;\n	    #endif\n		#ifdef ROTATIONOVERLIFETIMERANDOMCURVES\n			rotation+=mix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientZ,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientMaxZ,normalizedAge),a_Random0.w));\n		#endif\n	#endif\n	return rotation;\n}\n\n\n#if defined(RENDERMODE_MESH)&&(defined(ROTATIONOVERLIFETIME)||defined(ROTATIONOVERLIFETIMESEPERATE))\nvec3 computeParticleRotationVec3(in vec3 rotation,in float age,in float normalizedAge)\n{ \n	#ifdef ROTATIONOVERLIFETIME\n	#ifdef ROTATIONOVERLIFETIMECONSTANT\n			float ageRot=u_ROLAngularVelocityConst*age;\n	        rotation+=ageRot;\n		#endif\n		#ifdef ROTATIONOVERLIFETIMECURVE\n			rotation+=getTotalValueFromGradientFloat(u_ROLAngularVelocityGradient,normalizedAge);\n		#endif\n		#ifdef ROTATIONOVERLIFETIMERANDOMCONSTANTS\n			float ageRot=mix(u_ROLAngularVelocityConst,u_ROLAngularVelocityConstMax,a_Random0.w)*age;\n	        rotation+=ageRot;\n	    #endif\n		#ifdef ROTATIONOVERLIFETIMERANDOMCURVES\n			rotation+=mix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradient,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientMax,normalizedAge),a_Random0.w);\n		#endif\n	#endif\n	#ifdef ROTATIONOVERLIFETIMESEPERATE\n	#ifdef ROTATIONOVERLIFETIMECONSTANT\n			vec3 ageRot=u_ROLAngularVelocityConstSeprarate*age;\n	        rotation+=ageRot;\n		#endif\n		#ifdef ROTATIONOVERLIFETIMECURVE\n			rotation+=vec3(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientX,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientY,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientZ,normalizedAge));\n		#endif\n		#ifdef ROTATIONOVERLIFETIMERANDOMCONSTANTS\n			vec3 ageRot=mix(u_ROLAngularVelocityConstSeprarate,u_ROLAngularVelocityConstMaxSeprarate,a_Random0.w)*age;\n	        rotation+=ageRot;\n	    #endif\n		#ifdef ROTATIONOVERLIFETIMERANDOMCURVES\n			rotation+=vec3(mix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientX,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientMaxX,normalizedAge),a_Random0.w)\n	        ,mix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientY,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientMaxY,normalizedAge),a_Random0.w)\n	        ,mix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientZ,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientMaxZ,normalizedAge),a_Random0.w));\n		#endif\n	#endif\n	return rotation;\n}\n#endif\n\nvec2 computeParticleUV(in vec2 uv,in float normalizedAge)\n{ \n	#ifdef TEXTURESHEETANIMATIONCURVE\n		float cycleNormalizedAge=normalizedAge*u_TSACycles;\n		float frame=getFrameFromGradient(u_TSAGradientUVs,cycleNormalizedAge-floor(cycleNormalizedAge));\n		float totalULength=frame*u_TSASubUVLength.x;\n		float floorTotalULength=floor(totalULength);\n	    uv.x+=totalULength-floorTotalULength;\n		uv.y+=floorTotalULength*u_TSASubUVLength.y;\n    #endif\n	#ifdef TEXTURESHEETANIMATIONRANDOMCURVE\n		float cycleNormalizedAge=normalizedAge*u_TSACycles;\n		float uvNormalizedAge=cycleNormalizedAge-floor(cycleNormalizedAge);\n	    float frame=floor(mix(getFrameFromGradient(u_TSAGradientUVs,uvNormalizedAge),getFrameFromGradient(u_TSAMaxGradientUVs,uvNormalizedAge),a_Random1.x));\n		float totalULength=frame*u_TSASubUVLength.x;\n		float floorTotalULength=floor(totalULength);\n	    uv.x+=totalULength-floorTotalULength;\n		uv.y+=floorTotalULength*u_TSASubUVLength.y;\n    #endif\n	return uv;\n}\n\nvoid main()\n{\n	float age = u_CurrentTime - a_DirectionTime.w;\n	float normalizedAge = age/a_ShapePositionStartLifeTime.w;\n	vec3 lifeVelocity;\n	if(normalizedAge<1.0){ \n	vec3 startVelocity=a_DirectionTime.xyz*a_StartSpeed;\n	#if defined(VELOCITYOVERLIFETIMECONSTANT)||defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\n		lifeVelocity= computeParticleLifeVelocity(normalizedAge);//计算粒子生命周期速度\n	#endif \n	vec3 gravityVelocity=u_Gravity*age;\n	\n	vec4 worldRotation;\n	if(u_SimulationSpace==0)\n		worldRotation=a_SimulationWorldRotation;\n	else\n		worldRotation=u_WorldRotation;\n	\n	vec3 center=computeParticlePosition(startVelocity, lifeVelocity, age, normalizedAge,gravityVelocity,worldRotation);//计算粒子位置\n   \n   \n   #ifdef SPHERHBILLBOARD\n		vec2 corner=a_CornerTextureCoordinate.xy;//Billboard模式z轴无效\n        vec3 cameraUpVector =normalize(u_CameraUp);//TODO:是否外面归一化\n        vec3 sideVector = normalize(cross(u_CameraDirection,cameraUpVector));\n        vec3 upVector = normalize(cross(sideVector,u_CameraDirection));\n	    corner*=computeParticleSizeBillbard(a_StartSize.xy,normalizedAge);\n		#if defined(ROTATIONOVERLIFETIME)||defined(ROTATIONOVERLIFETIMESEPERATE)\n			if(u_ThreeDStartRotation){\n				vec3 rotation=vec3(a_StartRotation0.xy,computeParticleRotationFloat(a_StartRotation0.z,age,normalizedAge));\n				center += u_SizeScale.xzy*rotationByEuler(corner.x*sideVector+corner.y*upVector,rotation);\n			}\n			else{\n				float rot = computeParticleRotationFloat(a_StartRotation0.x, age,normalizedAge);\n				float c = cos(rot);\n				float s = sin(rot);\n				mat2 rotation= mat2(c, -s, s, c);\n				corner=rotation*corner;\n				center += u_SizeScale.xzy*(corner.x*sideVector+corner.y*upVector);\n			}\n		#else\n			if(u_ThreeDStartRotation){\n				center += u_SizeScale.xzy*rotationByEuler(corner.x*sideVector+corner.y*upVector,a_StartRotation0);\n			}\n			else{\n				float c = cos(a_StartRotation0.x);\n				float s = sin(a_StartRotation0.x);\n				mat2 rotation= mat2(c, -s, s, c);\n				corner=rotation*corner;\n				center += u_SizeScale.xzy*(corner.x*sideVector+corner.y*upVector);\n			}\n		#endif\n   #endif\n   \n   #ifdef STRETCHEDBILLBOARD\n	vec2 corner=a_CornerTextureCoordinate.xy;//Billboard模式z轴无效\n	vec3 velocity;\n	#if defined(VELOCITYOVERLIFETIMECONSTANT)||defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\n	    if(u_VOLSpaceType==0)\n		  velocity=rotationByQuaternions(u_SizeScale*(startVelocity+lifeVelocity),worldRotation)+gravityVelocity;\n	    else\n		  velocity=rotationByQuaternions(u_SizeScale*startVelocity,worldRotation)+lifeVelocity+gravityVelocity;\n    #else\n	    velocity= rotationByQuaternions(u_SizeScale*startVelocity,worldRotation)+gravityVelocity;\n    #endif	\n		vec3 cameraUpVector = normalize(velocity);\n		vec3 direction = normalize(center-u_CameraPosition);\n        vec3 sideVector = normalize(cross(direction,normalize(velocity)));\n		\n		sideVector=u_SizeScale.xzy*sideVector;\n		cameraUpVector=length(vec3(u_SizeScale.x,0.0,0.0))*cameraUpVector;\n		\n	    vec2 size=computeParticleSizeBillbard(a_StartSize.xy,normalizedAge);\n		\n	    const mat2 rotaionZHalfPI=mat2(0.0, -1.0, 1.0, 0.0);\n	    corner=rotaionZHalfPI*corner;\n	    corner.y=corner.y-abs(corner.y);\n		\n	    float speed=length(velocity);//TODO:\n	    center +=sign(u_SizeScale.x)*(sign(u_StretchedBillboardLengthScale)*size.x*corner.x*sideVector+(speed*u_StretchedBillboardSpeedScale+size.y*u_StretchedBillboardLengthScale)*corner.y*cameraUpVector);\n   #endif\n   \n   #ifdef HORIZONTALBILLBOARD\n		vec2 corner=a_CornerTextureCoordinate.xy;//Billboard模式z轴无效\n        const vec3 cameraUpVector=vec3(0.0,0.0,1.0);\n	    const vec3 sideVector = vec3(-1.0,0.0,0.0);\n		\n		float rot = computeParticleRotationFloat(a_StartRotation0.x, age,normalizedAge);\n        float c = cos(rot);\n        float s = sin(rot);\n        mat2 rotation= mat2(c, -s, s, c);\n	    corner=rotation*corner*cos(0.78539816339744830961566084581988);//TODO:临时缩小cos45,不确定U3D原因\n		corner*=computeParticleSizeBillbard(a_StartSize.xy,normalizedAge);\n        center +=u_SizeScale.xzy*(corner.x*sideVector+ corner.y*cameraUpVector);\n   #endif\n   \n   #ifdef VERTICALBILLBOARD\n		vec2 corner=a_CornerTextureCoordinate.xy;//Billboard模式z轴无效\n        const vec3 cameraUpVector =vec3(0.0,1.0,0.0);\n        vec3 sideVector = normalize(cross(u_CameraDirection,cameraUpVector));\n		\n		float rot = computeParticleRotationFloat(a_StartRotation0.x, age,normalizedAge);\n        float c = cos(rot);\n        float s = sin(rot);\n        mat2 rotation= mat2(c, -s, s, c);\n	    corner=rotation*corner*cos(0.78539816339744830961566084581988);//TODO:临时缩小cos45,不确定U3D原因\n		corner*=computeParticleSizeBillbard(a_StartSize.xy,normalizedAge);\n        center +=u_SizeScale.xzy*(corner.x*sideVector+ corner.y*cameraUpVector);\n   #endif\n   \n   #ifdef RENDERMODE_MESH\n	    vec3 size=computeParticleSizeMesh(a_StartSize,normalizedAge);\n		#if defined(ROTATIONOVERLIFETIME)||defined(ROTATIONOVERLIFETIMESEPERATE)\n			if(u_ThreeDStartRotation){\n				vec3 rotation=vec3(a_StartRotation0.xy,-computeParticleRotationFloat(a_StartRotation0.z, age,normalizedAge));\n				center+= rotationByQuaternions(u_SizeScale*rotationByEuler(a_MeshPosition*size,rotation),worldRotation);\n			}\n			else{\n				#ifdef ROTATIONOVERLIFETIME\n					float angle=computeParticleRotationFloat(a_StartRotation0.x, age,normalizedAge);\n					if(a_ShapePositionStartLifeTime.x!=0.0||a_ShapePositionStartLifeTime.y!=0.0){\n						center+= (rotationByQuaternions(rotationByAxis(u_SizeScale*a_MeshPosition*size,normalize(cross(vec3(0.0,0.0,1.0),vec3(a_ShapePositionStartLifeTime.xy,0.0))),angle),worldRotation));//已验证\n					}\n					else{\n						#ifdef SHAPE\n							center+= u_SizeScale.xzy*(rotationByQuaternions(rotationByAxis(a_MeshPosition*size,vec3(0.0,-1.0,0.0),angle),worldRotation));\n						#else\n							if(u_SimulationSpace==0)\n								center+=rotationByAxis(u_SizeScale*a_MeshPosition*size,vec3(0.0,0.0,-1.0),angle);//已验证\n							else if(u_SimulationSpace==1)\n								center+=rotationByQuaternions(u_SizeScale*rotationByAxis(a_MeshPosition*size,vec3(0.0,0.0,-1.0),angle),worldRotation);//已验证\n						#endif\n					}\n				#endif\n				#ifdef ROTATIONOVERLIFETIMESEPERATE\n					//TODO:是否应合并if(u_ThreeDStartRotation)分支代码,待测试\n					vec3 angle=computeParticleRotationVec3(vec3(0.0,0.0,a_StartRotation0.z), age,normalizedAge);\n					center+= (rotationByQuaternions(rotationByEuler(u_SizeScale*a_MeshPosition*size,vec3(angle.x,angle.y,angle.z)),worldRotation));//已验证\n				#endif	\n			}\n		#else\n			if(u_ThreeDStartRotation){\n				center+= rotationByQuaternions(u_SizeScale*rotationByEuler(a_MeshPosition*size,a_StartRotation0),worldRotation);//已验证\n			}\n			else{\n				if(a_ShapePositionStartLifeTime.x!=0.0||a_ShapePositionStartLifeTime.y!=0.0){\n					if(u_SimulationSpace==0)\n						center+= rotationByAxis(u_SizeScale*a_MeshPosition*size,normalize(cross(vec3(0.0,0.0,1.0),vec3(a_ShapePositionStartLifeTime.xy,0.0))),a_StartRotation0.x);\n					else if(u_SimulationSpace==1)\n						center+= (rotationByQuaternions(u_SizeScale*rotationByAxis(a_MeshPosition*size,normalize(cross(vec3(0.0,0.0,1.0),vec3(a_ShapePositionStartLifeTime.xy,0.0))),a_StartRotation0.x),worldRotation));//已验证\n				}\n				else{\n					#ifdef SHAPE\n						if(u_SimulationSpace==0)\n							center+= u_SizeScale*rotationByAxis(a_MeshPosition*size,vec3(0.0,-1.0,0.0),a_StartRotation0.x);\n						else if(u_SimulationSpace==1)\n							center+= rotationByQuaternions(u_SizeScale*rotationByAxis(a_MeshPosition*size,vec3(0.0,-1.0,0.0),a_StartRotation0.x),worldRotation);	\n					#else\n						if(u_SimulationSpace==0)\n							center+= rotationByAxis(u_SizeScale*a_MeshPosition*size,vec3(0.0,0.0,-1.0),a_StartRotation0.x);\n						else if(u_SimulationSpace==1)\n							center+= rotationByQuaternions(u_SizeScale*rotationByAxis(a_MeshPosition*size,vec3(0.0,0.0,-1.0),a_StartRotation0.x),worldRotation);//已验证\n					#endif\n				}\n			}\n		#endif\n		v_MeshColor=a_MeshColor;\n   #endif\n   \n    gl_Position=u_Projection*u_View*vec4(center,1.0);\n    v_Color = computeParticleColor(a_StartColor, normalizedAge);\n	#ifdef DIFFUSEMAP\n		#if defined(SPHERHBILLBOARD)||defined(STRETCHEDBILLBOARD)||defined(HORIZONTALBILLBOARD)||defined(VERTICALBILLBOARD)\n			v_TextureCoordinate =computeParticleUV(a_CornerTextureCoordinate.zw, normalizedAge);\n		#endif\n		#ifdef RENDERMODE_MESH\n			v_TextureCoordinate =computeParticleUV(a_MeshTextureCoordinate, normalizedAge);\n		#endif\n		\n		#ifdef TILINGOFFSET\n			v_TextureCoordinate=vec2(v_TextureCoordinate.x,1.0-v_TextureCoordinate.y)*u_TilingOffset.xy+vec2(u_TilingOffset.z,-u_TilingOffset.w);//需要特殊处理\n			v_TextureCoordinate=vec2(v_TextureCoordinate.x,1.0-v_TextureCoordinate.y);//需要特殊处理\n		#endif\n	#endif\n    v_Discard=0.0;\n	  \n	#ifdef FOG\n		v_PositionWorld=center;\n	#endif\n   }\n   else\n	{\n		v_Discard=1.0;\n	}\n}\n\n";
		ps="#ifdef HIGHPRECISION\n  precision highp float;\n#else\n  precision mediump float;\n#endif\n\nvarying float v_Discard;\nvarying vec4 v_Color;\nvarying vec2 v_TextureCoordinate;\nuniform sampler2D u_texture;\nuniform vec4 u_Tintcolor;\n\n#ifdef RENDERMODE_MESH\n	varying vec4 v_MeshColor;\n#endif\n\n#ifdef FOG\n	varying vec3 v_PositionWorld;\n	uniform vec3 u_CameraPosition;\n	uniform float u_FogStart;\n	uniform float u_FogRange;\n	#ifdef ADDTIVEFOG\n	#else\n		uniform vec3 u_FogColor;\n	#endif\n#endif\n\n\nvoid main()\n{	\n	#ifdef RENDERMODE_MESH\n		gl_FragColor=v_MeshColor;\n	#else\n		gl_FragColor=vec4(1.0);	\n	#endif\n		\n	#ifdef DIFFUSEMAP\n		if(v_Discard!=0.0)\n			discard;\n		#ifdef TINTCOLOR\n			gl_FragColor*=texture2D(u_texture,v_TextureCoordinate)*u_Tintcolor*2.0*v_Color;\n		#else\n			gl_FragColor*=texture2D(u_texture,v_TextureCoordinate)*v_Color;\n		#endif\n	#else\n		#ifdef TINTCOLOR\n			gl_FragColor*=u_Tintcolor*2.0*v_Color;\n		#else\n			gl_FragColor*=v_Color;\n		#endif\n	#endif\n	\n	#ifdef FOG\n		vec3 toEye=u_CameraPosition-v_PositionWorld;\n		float toEyeLength=length(toEye);\n		toEye/=toEyeLength;\n		\n		float lerpFact=clamp((toEyeLength-u_FogStart)/u_FogRange,0.0,1.0);\n		#ifdef ADDTIVEFOG\n			gl_FragColor.rgb=mix(gl_FragColor.rgb,vec3(0.0,0.0,0.0),lerpFact);\n		#else\n			gl_FragColor.rgb=mix(gl_FragColor.rgb,u_FogColor,lerpFact);\n		#endif\n	#endif\n}";
		shaderCompile=ShaderCompile3D.add(PARTICLESHURIKEN,vs,ps,attributeMap,uniformMap);
		ShurikenParticleMaterial.SHADERDEFINE_DIFFUSEMAP=shaderCompile.registerMaterialDefine("DIFFUSEMAP");
		ShurikenParticleMaterial.SHADERDEFINE_TINTCOLOR=shaderCompile.registerMaterialDefine("TINTCOLOR");
		ShurikenParticleMaterial.SHADERDEFINE_ADDTIVEFOG=shaderCompile.registerMaterialDefine("ADDTIVEFOG");
		ShurikenParticleMaterial.SHADERDEFINE_TILINGOFFSET=shaderCompile.registerMaterialDefine("TILINGOFFSET");
		ShuriKenParticle3D.SHADERDEFINE_RENDERMODE_BILLBOARD=shaderCompile.registerSpriteDefine("SPHERHBILLBOARD");
		ShuriKenParticle3D.SHADERDEFINE_RENDERMODE_STRETCHEDBILLBOARD=shaderCompile.registerSpriteDefine("STRETCHEDBILLBOARD");
		ShuriKenParticle3D.SHADERDEFINE_RENDERMODE_HORIZONTALBILLBOARD=shaderCompile.registerSpriteDefine("HORIZONTALBILLBOARD");
		ShuriKenParticle3D.SHADERDEFINE_RENDERMODE_VERTICALBILLBOARD=shaderCompile.registerSpriteDefine("VERTICALBILLBOARD");
		ShuriKenParticle3D.SHADERDEFINE_COLOROVERLIFETIME=shaderCompile.registerSpriteDefine("COLOROVERLIFETIME");
		ShuriKenParticle3D.SHADERDEFINE_RANDOMCOLOROVERLIFETIME=shaderCompile.registerSpriteDefine("RANDOMCOLOROVERLIFETIME");
		ShuriKenParticle3D.SHADERDEFINE_VELOCITYOVERLIFETIMECONSTANT=shaderCompile.registerSpriteDefine("VELOCITYOVERLIFETIMECONSTANT");
		ShuriKenParticle3D.SHADERDEFINE_VELOCITYOVERLIFETIMECURVE=shaderCompile.registerSpriteDefine("VELOCITYOVERLIFETIMECURVE");
		ShuriKenParticle3D.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCONSTANT=shaderCompile.registerSpriteDefine("VELOCITYOVERLIFETIMERANDOMCONSTANT");
		ShuriKenParticle3D.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCURVE=shaderCompile.registerSpriteDefine("VELOCITYOVERLIFETIMERANDOMCURVE");
		ShuriKenParticle3D.SHADERDEFINE_TEXTURESHEETANIMATIONCURVE=shaderCompile.registerSpriteDefine("TEXTURESHEETANIMATIONCURVE");
		ShuriKenParticle3D.SHADERDEFINE_TEXTURESHEETANIMATIONRANDOMCURVE=shaderCompile.registerSpriteDefine("TEXTURESHEETANIMATIONRANDOMCURVE");
		ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIME=shaderCompile.registerSpriteDefine("ROTATIONOVERLIFETIME");
		ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMESEPERATE=shaderCompile.registerSpriteDefine("ROTATIONOVERLIFETIMESEPERATE");
		ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMECONSTANT=shaderCompile.registerSpriteDefine("ROTATIONOVERLIFETIMECONSTANT");
		ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMECURVE=shaderCompile.registerSpriteDefine("ROTATIONOVERLIFETIMECURVE");
		ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCONSTANTS=shaderCompile.registerSpriteDefine("ROTATIONOVERLIFETIMERANDOMCONSTANTS");
		ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCURVES=shaderCompile.registerSpriteDefine("ROTATIONOVERLIFETIMERANDOMCURVES");
		ShuriKenParticle3D.SHADERDEFINE_SIZEOVERLIFETIMECURVE=shaderCompile.registerSpriteDefine("SIZEOVERLIFETIMECURVE");
		ShuriKenParticle3D.SHADERDEFINE_SIZEOVERLIFETIMECURVESEPERATE=shaderCompile.registerSpriteDefine("SIZEOVERLIFETIMECURVESEPERATE");
		ShuriKenParticle3D.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVES=shaderCompile.registerSpriteDefine("SIZEOVERLIFETIMERANDOMCURVES");
		ShuriKenParticle3D.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVESSEPERATE=shaderCompile.registerSpriteDefine("SIZEOVERLIFETIMERANDOMCURVESSEPERATE");
		ShuriKenParticle3D.SHADERDEFINE_RENDERMODE_MESH=shaderCompile.registerSpriteDefine("RENDERMODE_MESH");
		ShuriKenParticle3D.SHADERDEFINE_SHAPE=shaderCompile.registerSpriteDefine("SHAPE");
		attributeMap={
			'a_Position':/*laya.d3.graphics.VertexElementUsage.POSITION0*/0,
			'a_Texcoord0':/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE0*/2,
			'a_Time':/*laya.d3.graphics.VertexElementUsage.TIME0*/33};
		uniformMap={
			'u_Texture':[ /*laya.d3.core.material.GlitterMaterial.DIFFUSETEXTURE*/1,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_Albedo':[ /*laya.d3.core.material.GlitterMaterial.ALBEDO*/2,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_Color':[ /*laya.d3.core.material.GlitterMaterial.UNICOLOR*/3,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_CurrentTime':[ /*laya.d3.core.glitter.Glitter.CURRENTTIME*/2,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],
			'u_Duration':[ /*laya.d3.core.glitter.Glitter.DURATION*/3,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],
			'u_MvpMatrix':[ /*laya.d3.core.Sprite3D.MVPMATRIX*/1,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2]};
		var GLITTER=Shader3D.nameKey.add("GLITTER");
		vs="attribute vec4 a_Position;\nattribute vec2 a_Texcoord0;\nattribute float a_Time;\n\nuniform mat4 u_MvpMatrix;\nuniform  float u_CurrentTime;\nuniform  vec4 u_Color;\nuniform float u_Duration;\n\nvarying vec2 v_Texcoord;\nvarying vec4 v_Color;\n\n\nvoid main()\n{\n  gl_Position = u_MvpMatrix * a_Position;\n  \n  float age = u_CurrentTime-a_Time;\n  float normalizedAge = clamp(age / u_Duration,0.0,1.0);\n   \n  v_Texcoord=a_Texcoord0;\n  \n  v_Color=u_Color;\n  v_Color.a*=1.0-normalizedAge;\n}\n";
		ps="#ifdef HIGHPRECISION\n	precision highp float;\n#else\n	precision mediump float;\n#endif\n\nuniform vec4 u_Albedo;\nuniform sampler2D u_Texture;\n\nvarying vec2 v_Texcoord;\nvarying vec4 v_Color;\n\n\nvoid main()\n{	\n  gl_FragColor=texture2D(u_Texture, v_Texcoord)*v_Color;\n  gl_FragColor=gl_FragColor*u_Albedo;\n}\n\n";
		shaderCompile=ShaderCompile3D.add(GLITTER,vs,ps,attributeMap,uniformMap);
		attributeMap={
			'a_Position':/*laya.d3.graphics.VertexElementUsage.POSITION0*/0};
		uniformMap={
			'u_Intensity':[ /*laya.d3.resource.models.Sky.INTENSITY*/1,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_AlphaBlending':[ /*laya.d3.resource.models.Sky.ALPHABLENDING*/2,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_CubeTexture':[ /*laya.d3.resource.models.Sky.DIFFUSETEXTURE*/3,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_MvpMatrix':[ /*laya.d3.core.BaseCamera.VPMATRIX_NO_TRANSLATE*/4,/*laya.d3.shader.Shader3D.PERIOD_CAMERA*/3]};
		var skyBox=Shader3D.nameKey.add("SkyBox");
		vs="attribute vec4 a_Position;\nuniform mat4 u_MvpMatrix;\nvarying vec3 v_Texcoord;\n\n\nvoid main()\n{\n  gl_Position = (u_MvpMatrix*a_Position).xyww;\n  v_Texcoord=a_Position.xyz;\n}\n";
		ps="#ifdef HIGHPRECISION\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nuniform float u_Intensity;\nuniform float u_AlphaBlending;\nuniform samplerCube u_CubeTexture;\n\nvarying vec3 v_Texcoord;\n\n\nvoid main()\n{	\n  gl_FragColor=vec4(textureCube(u_CubeTexture, v_Texcoord).rgb*u_Intensity,u_AlphaBlending);\n}\n\n";
		ShaderCompile3D.add(skyBox,vs,ps,attributeMap,uniformMap);
		attributeMap={
			'a_Position':/*laya.d3.graphics.VertexElementUsage.POSITION0*/0,
			'a_Texcoord0':/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE0*/2};
		uniformMap={
			'u_Intensity':[ /*laya.d3.resource.models.Sky.INTENSITY*/1,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_AlphaBlending':[ /*laya.d3.resource.models.Sky.ALPHABLENDING*/2,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_texture':[ /*laya.d3.resource.models.Sky.DIFFUSETEXTURE*/3,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_MvpMatrix':[ /*laya.d3.core.BaseCamera.VPMATRIX_NO_TRANSLATE*/4,/*laya.d3.shader.Shader3D.PERIOD_CAMERA*/3]};
		var skyDome=Shader3D.nameKey.add("SkyDome");
		vs="attribute vec4 a_Position;\nattribute vec2 a_Texcoord0;\nuniform mat4 u_MvpMatrix;\nvarying vec2 v_Texcoord;\n\n\nvoid main()\n{\n  gl_Position = (u_MvpMatrix*a_Position).xyww;\n  v_Texcoord = a_Texcoord0;\n}\n";
		ps="#ifdef HIGHPRECISION\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nuniform float u_Intensity;\nuniform float u_AlphaBlending;\nuniform sampler2D u_texture;\n\nvarying vec2 v_Texcoord;\n\n\nvoid main()\n{	\n  gl_FragColor=vec4(texture2D(u_texture, v_Texcoord).rgb*u_Intensity,u_AlphaBlending);\n}\n\n";
		ShaderCompile3D.add(skyDome,vs,ps,attributeMap,uniformMap);
		attributeMap={
			'a_Position':/*laya.d3.graphics.VertexElementUsage.POSITION0*/0,
			'a_Normal':/*laya.d3.graphics.VertexElementUsage.NORMAL0*/3,
			'a_Texcoord0':/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE0*/2,
			'a_Texcoord1':/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE1*/15};
		uniformMap={
			'u_MvpMatrix':[ /*laya.d3.core.Sprite3D.MVPMATRIX*/1,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],
			'u_WorldMat':[ /*laya.d3.core.Sprite3D.WORLDMATRIX*/0,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],
			'u_LightmapScaleOffset':[ /*laya.d3.core.RenderableSprite3D.LIGHTMAPSCALEOFFSET*/2,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],
			'u_LightMap':[ /*laya.d3.core.RenderableSprite3D.LIGHTMAP*/3,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],
			'u_SplatAlphaTexture':[ /*laya.d3.core.material.TerrainMaterial.SPLATALPHATEXTURE*/0,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_NormalTexture':[ /*laya.d3.core.material.TerrainMaterial.NORMALTEXTURE*/1,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_DiffuseTexture1':[ /*laya.d3.core.material.TerrainMaterial.DIFFUSETEXTURE1*/2,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_DiffuseTexture2':[ /*laya.d3.core.material.TerrainMaterial.DIFFUSETEXTURE2*/3,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_DiffuseTexture3':[ /*laya.d3.core.material.TerrainMaterial.DIFFUSETEXTURE3*/4,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_DiffuseTexture4':[ /*laya.d3.core.material.TerrainMaterial.DIFFUSETEXTURE4*/5,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_DiffuseScale1':[ /*laya.d3.core.material.TerrainMaterial.DIFFUSESCALE1*/6,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_DiffuseScale2':[ /*laya.d3.core.material.TerrainMaterial.DIFFUSESCALE2*/7,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_DiffuseScale3':[ /*laya.d3.core.material.TerrainMaterial.DIFFUSESCALE3*/8,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_DiffuseScale4':[ /*laya.d3.core.material.TerrainMaterial.DIFFUSESCALE4*/9,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_MaterialDiffuse':[ /*laya.d3.core.material.TerrainMaterial.MATERIALDIFFUSE*/11,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_MaterialAmbient':[ /*laya.d3.core.material.TerrainMaterial.MATERIALAMBIENT*/10,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_MaterialSpecular':[ /*laya.d3.core.material.TerrainMaterial.MATERIALSPECULAR*/12,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_CameraPos':[ /*laya.d3.core.BaseCamera.CAMERAPOS*/0,/*laya.d3.shader.Shader3D.PERIOD_CAMERA*/3],
			'u_FogStart':[ /*laya.d3.core.scene.Scene.FOGSTART*/1,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_FogRange':[ /*laya.d3.core.scene.Scene.FOGRANGE*/2,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_FogColor':[ /*laya.d3.core.scene.Scene.FOGCOLOR*/0,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_DirectionLight.Direction':[ /*laya.d3.core.scene.Scene.LIGHTDIRECTION*/3,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_DirectionLight.Diffuse':[ /*laya.d3.core.scene.Scene.LIGHTDIRCOLOR*/4,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_PointLight.Position':[ /*laya.d3.core.scene.Scene.POINTLIGHTPOS*/5,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_PointLight.Range':[ /*laya.d3.core.scene.Scene.POINTLIGHTRANGE*/6,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_PointLight.Attenuation':[ /*laya.d3.core.scene.Scene.POINTLIGHTATTENUATION*/7,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_PointLight.Diffuse':[ /*laya.d3.core.scene.Scene.POINTLIGHTCOLOR*/8,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_SpotLight.Position':[ /*laya.d3.core.scene.Scene.SPOTLIGHTPOS*/9,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_SpotLight.Direction':[ /*laya.d3.core.scene.Scene.SPOTLIGHTDIRECTION*/10,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_SpotLight.Range':[ /*laya.d3.core.scene.Scene.SPOTLIGHTRANGE*/12,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_SpotLight.Spot':[ /*laya.d3.core.scene.Scene.SPOTLIGHTSPOT*/11,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_SpotLight.Attenuation':[ /*laya.d3.core.scene.Scene.SPOTLIGHTATTENUATION*/13,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_SpotLight.Diffuse':[ /*laya.d3.core.scene.Scene.SPOTLIGHTCOLOR*/14,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_AmbientColor':[ /*laya.d3.core.scene.Scene.AMBIENTCOLOR*/21,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_shadowMap1':[ /*laya.d3.core.scene.Scene.SHADOWMAPTEXTURE1*/18,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_shadowMap2':[ /*laya.d3.core.scene.Scene.SHADOWMAPTEXTURE2*/19,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_shadowMap3':[ /*laya.d3.core.scene.Scene.SHADOWMAPTEXTURE3*/20,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_shadowPSSMDistance':[ /*laya.d3.core.scene.Scene.SHADOWDISTANCE*/15,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_lightShadowVP':[ /*laya.d3.core.scene.Scene.SHADOWLIGHTVIEWPROJECT*/16,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_shadowPCFoffset':[ /*laya.d3.core.scene.Scene.SHADOWMAPPCFOFFSET*/17,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4]};
		var terrain=Shader3D.nameKey.add("Terrain");
		vs="attribute vec4 a_Position;\n\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(LIGHTMAP)\n	attribute vec3 a_Normal;\n	varying vec3 v_Normal;\n#endif\n\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||(defined(RECEIVESHADOW)&&defined(SHADOWMAP_PSSM1))\n	uniform mat4 u_WorldMat;\n	varying vec3 v_PositionWorld;\n#endif\n\nvarying float v_posViewZ;\n#ifdef RECEIVESHADOW\n  #ifdef SHADOWMAP_PSSM1 \n  varying vec4 v_lightMVPPos;\n  uniform mat4 u_lightShadowVP[4];\n  #endif\n#endif\n\n#ifdef LIGHTMAP\n	uniform vec4 u_LightmapScaleOffset;\n	varying vec2 v_LightMapUV;\n#endif\n\nattribute vec2 a_Texcoord0;\nattribute vec2 a_Texcoord1;\nvarying vec2 v_Texcoord0;\nvarying vec2 v_Texcoord1;\nuniform mat4 u_MvpMatrix;\n\nvoid main()\n{\n	gl_Position = u_MvpMatrix * a_Position;\n	v_Texcoord0=a_Texcoord0;\n	v_Texcoord1=a_Texcoord1;\n	\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\n	v_Normal=a_Normal;\n#endif\n\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||(defined(RECEIVESHADOW)&&defined(SHADOWMAP_PSSM1))\n	v_PositionWorld=(u_WorldMat*a_Position).xyz;\n#endif\n\n#ifdef LIGHTMAP\n	//这个地方使用a_Normal 并不是真的代表normal，其实凑巧法线图的uv正好是符合 light_Map的UV\n	v_LightMapUV=vec2(a_Normal.x*u_LightmapScaleOffset.x+u_LightmapScaleOffset.z,(a_Normal.y-1.0)*u_LightmapScaleOffset.y+u_LightmapScaleOffset.w);\n#endif\n\n#ifdef RECEIVESHADOW\n	v_posViewZ = gl_Position.w;\n	#ifdef SHADOWMAP_PSSM1\n		v_lightMVPPos = u_lightShadowVP[0] * vec4(v_PositionWorld,1.0);\n	#endif\n#endif\n\n}";
		ps="#ifdef HIGHPRECISION\n	precision highp float;\n#else\n	precision mediump float;\n#endif\n\n#include \"LightHelper.glsl\";\n\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\n	uniform vec3 u_MaterialDiffuse;\n	uniform vec4 u_MaterialSpecular;\n	uniform vec3 u_CameraPos;\n	varying vec3 v_Normal;\n	varying vec3 v_PositionWorld;\n#endif\n\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(LIGHTMAP)\n	uniform vec3 u_MaterialAmbient;\n#endif\n\n#ifdef FOG\n	uniform float u_FogStart;\n	uniform float u_FogRange;\n	uniform vec3 u_FogColor;\n#endif\n\n\n#ifdef DIRECTIONLIGHT\n	uniform DirectionLight u_DirectionLight;\n#endif\n\n#ifdef POINTLIGHT\n	uniform PointLight u_PointLight;\n#endif\n\n#ifdef SPOTLIGHT\n	uniform SpotLight u_SpotLight;\n#endif\n\nuniform vec3 u_AmbientColor;\n\n#include \"ShadowHelper.glsl\"\n#ifdef RECEIVESHADOW\n	#if defined(SHADOWMAP_PSSM2)||defined(SHADOWMAP_PSSM3)\n	uniform mat4 u_lightShadowVP[4];\n	#endif\n	#ifdef SHADOWMAP_PSSM1 \n	varying vec4 v_lightMVPPos;\n	#endif\n#endif\nvarying float v_posViewZ;\n\n\nuniform sampler2D u_SplatAlphaTexture;\nuniform sampler2D u_NormalTexture;\nuniform sampler2D u_DiffuseTexture1;\nuniform sampler2D u_DiffuseTexture2;\nuniform sampler2D u_DiffuseTexture3;\nuniform sampler2D u_DiffuseTexture4;\nuniform vec2 u_DiffuseScale1;\nuniform vec2 u_DiffuseScale2;\nuniform vec2 u_DiffuseScale3;\nuniform vec2 u_DiffuseScale4;\nvarying vec2 v_Texcoord0;\nvarying vec2 v_Texcoord1;\n\n#ifdef LIGHTMAP\n	uniform sampler2D u_LightMap;\n	varying vec2 v_LightMapUV;\n#endif\n\nvoid main()\n{\n#ifdef DETAIL_NUM1\n	vec4 color1 = texture2D(u_DiffuseTexture1, v_Texcoord1/u_DiffuseScale1);\n	vec4 splatAlpha = texture2D(u_SplatAlphaTexture, v_Texcoord0);\n	gl_FragColor.xyz = color1.xyz;\n#endif\n#ifdef DETAIL_NUM2\n	vec4 color1 = texture2D(u_DiffuseTexture1, v_Texcoord1/u_DiffuseScale1);\n	vec4 color2 = texture2D(u_DiffuseTexture2, v_Texcoord1/u_DiffuseScale2);\n	vec4 splatAlpha = texture2D(u_SplatAlphaTexture, v_Texcoord0);\n	gl_FragColor.xyz = color1.xyz * (1.0-splatAlpha.r) + color2.xyz * splatAlpha.r;\n#endif\n#ifdef DETAIL_NUM3\n	vec4 color1 = texture2D(u_DiffuseTexture1, v_Texcoord1/u_DiffuseScale1);\n	vec4 color2 = texture2D(u_DiffuseTexture2, v_Texcoord1/u_DiffuseScale2);\n	vec4 color3 = texture2D(u_DiffuseTexture3, v_Texcoord1/u_DiffuseScale3);\n	vec4 splatAlpha = texture2D(u_SplatAlphaTexture, v_Texcoord0);\n	gl_FragColor.xyz = color1.xyz * (1.0-(splatAlpha.r+splatAlpha.g)) + color2.xyz * splatAlpha.r + color3.xyz * splatAlpha.g;\n#endif\n#ifdef DETAIL_NUM4\n	vec4 color1 = texture2D(u_DiffuseTexture1, v_Texcoord1/u_DiffuseScale1);\n	vec4 color2 = texture2D(u_DiffuseTexture2, v_Texcoord1/u_DiffuseScale2);\n	vec4 color3 = texture2D(u_DiffuseTexture3, v_Texcoord1/u_DiffuseScale3);\n	vec4 color4 = texture2D(u_DiffuseTexture4, v_Texcoord1/u_DiffuseScale4);\n	vec4 splatAlpha = texture2D(u_SplatAlphaTexture, v_Texcoord0);\n	gl_FragColor.xyz = color1.xyz * (1.0-(splatAlpha.r+splatAlpha.g+splatAlpha.b))+ color2.xyz * splatAlpha.r + color3.xyz * splatAlpha.g + color4.xyz * splatAlpha.b;\n#endif\n	gl_FragColor.w = splatAlpha.a;\n		\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\n    vec3 normal = texture2D(u_NormalTexture,v_Normal.xy).xyz;\n	normal = normal*2.0 - vec3(1.0);\n	vec3 diffuse = vec3(0.0);\n	vec3 ambient = vec3(0.0);\n	vec3 specular= vec3(0.0);\n	vec3 dif, amb, spe;\n#endif\n\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(FOG)\n	vec3 toEye;\n	#ifdef FOG\n		toEye=u_CameraPos-v_PositionWorld;\n		float toEyeLength=length(toEye);\n		toEye/=toEyeLength;\n	#else\n		toEye=normalize(u_CameraPos-v_PositionWorld);\n	#endif\n#endif\n\n#ifdef DIRECTIONLIGHT\n	computeDirectionLight(u_MaterialDiffuse,u_MaterialAmbient,u_MaterialSpecular,u_DirectionLight,u_AmbientColor,normal,toEye, dif, amb, spe);\n	diffuse+=dif;\n	ambient+=amb;\n	specular+=spe;\n#endif\n \n#ifdef POINTLIGHT\n	computePointLight(u_MaterialDiffuse,u_MaterialAmbient,u_MaterialSpecular,u_PointLight,u_AmbientColor,v_PositionWorld,normal,toEye, dif, amb, spe);\n	diffuse+=dif;\n	ambient+=amb;\n	specular+=spe;\n#endif\n\n#ifdef SPOTLIGHT\n	ComputeSpotLight(u_MaterialDiffuse,u_MaterialAmbient,u_MaterialSpecular,u_SpotLight,u_AmbientColor,v_PositionWorld,normal,toEye, dif, amb, spe);\n	diffuse+=dif;\n	ambient+=amb;\n	specular+=spe;\n#endif\n\n#ifdef RECEIVESHADOW\n	float shadowValue = 1.0;\n	#ifdef SHADOWMAP_PSSM3\n		shadowValue = getShadowPSSM3( u_shadowMap1,u_shadowMap2,u_shadowMap3,u_lightShadowVP,u_shadowPSSMDistance,u_shadowPCFoffset,v_PositionWorld,v_posViewZ,0.001);\n	#endif\n	#ifdef SHADOWMAP_PSSM2\n		shadowValue = getShadowPSSM2( u_shadowMap1,u_shadowMap2,u_lightShadowVP,u_shadowPSSMDistance,u_shadowPCFoffset,v_PositionWorld,v_posViewZ,0.001);\n	#endif \n	#ifdef SHADOWMAP_PSSM1\n		shadowValue = getShadowPSSM1( u_shadowMap1,v_lightMVPPos,u_shadowPSSMDistance,u_shadowPCFoffset,v_posViewZ,0.001);\n	#endif\n#endif\n\n#ifdef LIGHTMAP\n	#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\n		gl_FragColor.rgb=gl_FragColor.rgb*(u_MaterialAmbient + texture2D(u_LightMap, v_LightMapUV).rgb);\n	#else\n		#if defined(RECEIVESHADOW)\n			gl_FragColor.rgb=gl_FragColor.rgb*(u_MaterialAmbient + texture2D(u_LightMap, v_LightMapUV).rgb * shadowValue);\n		#else\n			gl_FragColor.rgb=gl_FragColor.rgb*(u_MaterialAmbient + texture2D(u_LightMap, v_LightMapUV).rgb);\n		#endif\n	#endif\n#endif\n\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\n	#ifdef RECEIVESHADOW\n		gl_FragColor =vec4( gl_FragColor.rgb*(ambient + diffuse*shadowValue) + specular * shadowValue,gl_FragColor.a);\n	#else\n		gl_FragColor =vec4( gl_FragColor.rgb*(ambient + diffuse) + specular, gl_FragColor.a);\n	#endif\n#endif\n\n#ifdef FOG\n	float lerpFact=clamp((toEyeLength-u_FogStart)/u_FogRange,0.0,1.0);\n	gl_FragColor.rgb=mix(gl_FragColor.rgb,u_FogColor,lerpFact);\n#endif\n}\n\n";
		var terrainCompile3D=ShaderCompile3D.add(terrain,vs,ps,attributeMap,uniformMap);
		TerrainMaterial.SHADERDEFINE_DETAIL_NUM1=terrainCompile3D.registerMaterialDefine("DETAIL_NUM1");
		TerrainMaterial.SHADERDEFINE_DETAIL_NUM2=terrainCompile3D.registerMaterialDefine("DETAIL_NUM2");
		TerrainMaterial.SHADERDEFINE_DETAIL_NUM4=terrainCompile3D.registerMaterialDefine("DETAIL_NUM4");
		TerrainMaterial.SHADERDEFINE_DETAIL_NUM3=terrainCompile3D.registerMaterialDefine("DETAIL_NUM3");
		attributeMap={
			'a_Position':/*laya.d3.graphics.VertexElementUsage.POSITION0*/0,
			'a_Normal':/*laya.d3.graphics.VertexElementUsage.NORMAL0*/3,
			'a_Texcoord0':/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE0*/2
		};
		uniformMap={
			'u_MvpMatrix':[ /*laya.d3.core.Sprite3D.MVPMATRIX*/1,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],
			'u_WorldMat':[ /*laya.d3.core.Sprite3D.WORLDMATRIX*/0,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],
			'u_CameraPos':[ /*laya.d3.core.BaseCamera.CAMERAPOS*/0,/*laya.d3.shader.Shader3D.PERIOD_CAMERA*/3],
			'u_LightmapScaleOffset':[ /*laya.d3.core.RenderableSprite3D.LIGHTMAPSCALEOFFSET*/2,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],
			'u_LightMap':[ /*laya.d3.core.RenderableSprite3D.LIGHTMAP*/3,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],
			'u_SplatAlphaTexture':[ /*laya.d3.core.material.ExtendTerrainMaterial.SPLATALPHATEXTURE*/0,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_DiffuseTexture1':[ /*laya.d3.core.material.ExtendTerrainMaterial.DIFFUSETEXTURE1*/1,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_DiffuseTexture2':[ /*laya.d3.core.material.ExtendTerrainMaterial.DIFFUSETEXTURE2*/2,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_DiffuseTexture3':[ /*laya.d3.core.material.ExtendTerrainMaterial.DIFFUSETEXTURE3*/3,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_DiffuseTexture4':[ /*laya.d3.core.material.ExtendTerrainMaterial.DIFFUSETEXTURE4*/4,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_DiffuseTexture5':[ /*laya.d3.core.material.ExtendTerrainMaterial.DIFFUSETEXTURE5*/5,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_DiffuseScaleOffset1':[ /*laya.d3.core.material.ExtendTerrainMaterial.DIFFUSESCALEOFFSET1*/6,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_DiffuseScaleOffset2':[ /*laya.d3.core.material.ExtendTerrainMaterial.DIFFUSESCALEOFFSET2*/7,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_DiffuseScaleOffset3':[ /*laya.d3.core.material.ExtendTerrainMaterial.DIFFUSESCALEOFFSET3*/8,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_DiffuseScaleOffset4':[ /*laya.d3.core.material.ExtendTerrainMaterial.DIFFUSESCALEOFFSET4*/9,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_DiffuseScaleOffset5':[ /*laya.d3.core.material.ExtendTerrainMaterial.DIFFUSESCALEOFFSET5*/10,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_MaterialAlbedo':[ /*laya.d3.core.material.ExtendTerrainMaterial.MATERIALALBEDO*/14,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_MaterialDiffuse':[ /*laya.d3.core.material.ExtendTerrainMaterial.MATERIALDIFFUSE*/12,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_MaterialAmbient':[ /*laya.d3.core.material.ExtendTerrainMaterial.MATERIALAMBIENT*/11,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_MaterialSpecular':[ /*laya.d3.core.material.ExtendTerrainMaterial.MATERIALSPECULAR*/13,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_FogStart':[ /*laya.d3.core.scene.Scene.FOGSTART*/1,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_FogRange':[ /*laya.d3.core.scene.Scene.FOGRANGE*/2,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_FogColor':[ /*laya.d3.core.scene.Scene.FOGCOLOR*/0,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_DirectionLight.Direction':[ /*laya.d3.core.scene.Scene.LIGHTDIRECTION*/3,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_DirectionLight.Diffuse':[ /*laya.d3.core.scene.Scene.LIGHTDIRCOLOR*/4,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_PointLight.Position':[ /*laya.d3.core.scene.Scene.POINTLIGHTPOS*/5,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_PointLight.Range':[ /*laya.d3.core.scene.Scene.POINTLIGHTRANGE*/6,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_PointLight.Attenuation':[ /*laya.d3.core.scene.Scene.POINTLIGHTATTENUATION*/7,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_PointLight.Diffuse':[ /*laya.d3.core.scene.Scene.POINTLIGHTCOLOR*/8,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_SpotLight.Position':[ /*laya.d3.core.scene.Scene.SPOTLIGHTPOS*/9,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_SpotLight.Direction':[ /*laya.d3.core.scene.Scene.SPOTLIGHTDIRECTION*/10,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_SpotLight.Range':[ /*laya.d3.core.scene.Scene.SPOTLIGHTRANGE*/12,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_SpotLight.Spot':[ /*laya.d3.core.scene.Scene.SPOTLIGHTSPOT*/11,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_SpotLight.Attenuation':[ /*laya.d3.core.scene.Scene.SPOTLIGHTATTENUATION*/13,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_SpotLight.Diffuse':[ /*laya.d3.core.scene.Scene.SPOTLIGHTCOLOR*/14,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_AmbientColor':[ /*laya.d3.core.scene.Scene.AMBIENTCOLOR*/21,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_shadowMap1':[ /*laya.d3.core.scene.Scene.SHADOWMAPTEXTURE1*/18,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_shadowMap2':[ /*laya.d3.core.scene.Scene.SHADOWMAPTEXTURE2*/19,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_shadowMap3':[ /*laya.d3.core.scene.Scene.SHADOWMAPTEXTURE3*/20,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_shadowPSSMDistance':[ /*laya.d3.core.scene.Scene.SHADOWDISTANCE*/15,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_lightShadowVP':[ /*laya.d3.core.scene.Scene.SHADOWLIGHTVIEWPROJECT*/16,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
			'u_shadowPCFoffset':[ /*laya.d3.core.scene.Scene.SHADOWMAPPCFOFFSET*/17,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4]
		};
		var extendTerrainShader=Shader3D.nameKey.add("ExtendTerrain");
		vs="attribute vec4 a_Position;\nattribute vec2 a_Texcoord0;\n\nuniform mat4 u_MvpMatrix;\n\nvarying vec2 v_Texcoord0;\n\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(LIGHTMAP)\n	attribute vec3 a_Normal;\n	varying vec3 v_Normal;\n#endif\n\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(FOG)||(defined(RECEIVESHADOW)&&defined(SHADOWMAP_PSSM1))\n	uniform mat4 u_WorldMat;\n	varying vec3 v_PositionWorld;\n#endif\n\n#ifdef LIGHTMAP\n	varying vec2 v_LightMapUV;\n	uniform vec4 u_LightmapScaleOffset;\n#endif\n\n#ifdef RECEIVESHADOW\n	varying float v_posViewZ;\n	#ifdef SHADOWMAP_PSSM1 \n		varying vec4 v_lightMVPPos;\n		uniform mat4 u_lightShadowVP[4];\n	#endif\n#endif\n\nvoid main()\n{\n	gl_Position = u_MvpMatrix * a_Position;\n  \n	v_Texcoord0 = a_Texcoord0;\n  \n	#ifdef LIGHTMAP\n		v_LightMapUV = vec2(a_Texcoord0.x*u_LightmapScaleOffset.x+u_LightmapScaleOffset.z,(a_Texcoord0.y-1.0)*u_LightmapScaleOffset.y+u_LightmapScaleOffset.w);\n	#endif\n  \n	#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\n		v_Normal = a_Normal;\n	#endif\n\n	#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(FOG)||(defined(RECEIVESHADOW)&&defined(SHADOWMAP_PSSM1))\n		v_PositionWorld=(u_WorldMat*a_Position).xyz;\n	#endif\n\n	#ifdef RECEIVESHADOW\n		v_posViewZ = gl_Position.w;\n		#ifdef SHADOWMAP_PSSM1\n			v_lightMVPPos = u_lightShadowVP[0] * vec4(v_PositionWorld,1.0);\n		#endif\n	#endif\n}";
		ps="#ifdef HIGHPRECISION\n	precision highp float;\n#else\n	precision mediump float;\n#endif\n\n#include \"LightHelper.glsl\";\n\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(FOG)\n	uniform vec3 u_MaterialDiffuse;\n	uniform vec4 u_MaterialSpecular;\n	uniform vec3 u_CameraPos;\n	varying vec3 v_Normal;\n	varying vec3 v_PositionWorld;\n#endif\n\n#ifdef FOG\n	uniform float u_FogStart;\n	uniform float u_FogRange;\n	uniform vec3 u_FogColor;\n#endif\n\n\n#ifdef DIRECTIONLIGHT\n	uniform DirectionLight u_DirectionLight;\n#endif\n\n#ifdef POINTLIGHT\n	uniform PointLight u_PointLight;\n#endif\n\n#ifdef SPOTLIGHT\n	uniform SpotLight u_SpotLight;\n#endif\n\nuniform vec3 u_AmbientColor;\n\n#include \"ShadowHelper.glsl\"\n#ifdef RECEIVESHADOW\n	#if defined(SHADOWMAP_PSSM2)||defined(SHADOWMAP_PSSM3)\n	uniform mat4 u_lightShadowVP[4];\n	#endif\n	#ifdef SHADOWMAP_PSSM1 \n	varying vec4 v_lightMVPPos;\n	#endif\n#endif\nvarying float v_posViewZ;\n\n\nuniform sampler2D u_SplatAlphaTexture;\n\nuniform sampler2D u_DiffuseTexture1;\nuniform sampler2D u_DiffuseTexture2;\nuniform sampler2D u_DiffuseTexture3;\nuniform sampler2D u_DiffuseTexture4;\nuniform sampler2D u_DiffuseTexture5;\n\nuniform vec4 u_DiffuseScaleOffset1;\nuniform vec4 u_DiffuseScaleOffset2;\nuniform vec4 u_DiffuseScaleOffset3;\nuniform vec4 u_DiffuseScaleOffset4;\nuniform vec4 u_DiffuseScaleOffset5;\n\nvarying vec2 v_Texcoord0;\n\nuniform vec3 u_MaterialAmbient;\nuniform vec4 u_MaterialAlbedo;\n\n#ifdef LIGHTMAP\n	uniform sampler2D u_LightMap;\n	varying vec2 v_LightMapUV;\n#endif\n\nvoid main()\n{\n	#ifdef ExtendTerrain_DETAIL_NUM1\n		vec4 splatAlpha = texture2D(u_SplatAlphaTexture, v_Texcoord0);\n		vec4 color1 = texture2D(u_DiffuseTexture1, v_Texcoord0 * u_DiffuseScaleOffset1.xy);\n		gl_FragColor.xyz = color1.xyz * splatAlpha.r;\n	#endif\n	#ifdef ExtendTerrain_DETAIL_NUM2\n		vec4 splatAlpha = texture2D(u_SplatAlphaTexture, v_Texcoord0);\n		vec4 color1 = texture2D(u_DiffuseTexture1, v_Texcoord0 * u_DiffuseScaleOffset1.xy);\n		vec4 color2 = texture2D(u_DiffuseTexture2, v_Texcoord0 * u_DiffuseScaleOffset2.xy);\n		gl_FragColor.xyz = color1.xyz * splatAlpha.r + color2.xyz * (1.0 - splatAlpha.r);\n	#endif\n	#ifdef ExtendTerrain_DETAIL_NUM3\n		vec4 splatAlpha = texture2D(u_SplatAlphaTexture, v_Texcoord0);\n		vec4 color1 = texture2D(u_DiffuseTexture1, v_Texcoord0 * u_DiffuseScaleOffset1.xy);\n		vec4 color2 = texture2D(u_DiffuseTexture2, v_Texcoord0 * u_DiffuseScaleOffset2.xy);\n		vec4 color3 = texture2D(u_DiffuseTexture3, v_Texcoord0 * u_DiffuseScaleOffset3.xy);\n		gl_FragColor.xyz = color1.xyz * splatAlpha.r  + color2.xyz * splatAlpha.g + color3.xyz * (1.0 - splatAlpha.r - splatAlpha.g);\n	#endif\n	#ifdef ExtendTerrain_DETAIL_NUM4\n		vec4 splatAlpha = texture2D(u_SplatAlphaTexture, v_Texcoord0);\n		vec4 color1 = texture2D(u_DiffuseTexture1, v_Texcoord0 * u_DiffuseScaleOffset1.xy);\n		vec4 color2 = texture2D(u_DiffuseTexture2, v_Texcoord0 * u_DiffuseScaleOffset2.xy);\n		vec4 color3 = texture2D(u_DiffuseTexture3, v_Texcoord0 * u_DiffuseScaleOffset3.xy);\n		vec4 color4 = texture2D(u_DiffuseTexture4, v_Texcoord0 * u_DiffuseScaleOffset4.xy);\n		gl_FragColor.xyz = color1.xyz * splatAlpha.r  + color2.xyz * splatAlpha.g + color3.xyz * splatAlpha.b + color4.xyz * (1.0 - splatAlpha.r - splatAlpha.g - splatAlpha.b);\n	#endif\n	#ifdef ExtendTerrain_DETAIL_NUM5\n		vec4 splatAlpha = texture2D(u_SplatAlphaTexture, v_Texcoord0);\n		vec4 color1 = texture2D(u_DiffuseTexture1, v_Texcoord0 * u_DiffuseScaleOffset1.xy);\n		vec4 color2 = texture2D(u_DiffuseTexture2, v_Texcoord0 * u_DiffuseScaleOffset2.xy);\n		vec4 color3 = texture2D(u_DiffuseTexture3, v_Texcoord0 * u_DiffuseScaleOffset3.xy);\n		vec4 color4 = texture2D(u_DiffuseTexture4, v_Texcoord0 * u_DiffuseScaleOffset4.xy);\n		vec4 color5 = texture2D(u_DiffuseTexture5, v_Texcoord0 * u_DiffuseScaleOffset5.xy);\n		gl_FragColor.xyz = color1.xyz * splatAlpha.r  + color2.xyz * splatAlpha.g + color3.xyz * splatAlpha.b + color4.xyz * splatAlpha.a + color5.xyz * (1.0 - splatAlpha.r - splatAlpha.g - splatAlpha.b - splatAlpha.a);\n	#endif\n		gl_FragColor.w = splatAlpha.a;\n		\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\n    vec3 normal = v_Normal;\n	vec3 diffuse = vec3(0.0);\n	vec3 ambient = vec3(0.0);\n	vec3 specular= vec3(0.0);\n	vec3 dif, amb, spe;\n#endif\n\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(FOG)\n	vec3 toEye;\n	#ifdef FOG\n		toEye=u_CameraPos-v_PositionWorld;\n		float toEyeLength=length(toEye);\n		toEye/=toEyeLength;\n	#else\n		toEye=normalize(u_CameraPos-v_PositionWorld);\n	#endif\n#endif\n\n#ifdef DIRECTIONLIGHT\n	computeDirectionLight(u_MaterialDiffuse,u_MaterialAmbient,u_MaterialSpecular,u_DirectionLight,u_AmbientColor,normal,toEye, dif, amb, spe);\n	diffuse+=dif;\n	ambient+=amb;\n	specular+=spe;\n#endif\n \n#ifdef POINTLIGHT\n	computePointLight(u_MaterialDiffuse,u_MaterialAmbient,u_MaterialSpecular,u_PointLight,u_AmbientColor,v_PositionWorld,normal,toEye, dif, amb, spe);\n	diffuse+=dif;\n	ambient+=amb;\n	specular+=spe;\n#endif\n\n#ifdef SPOTLIGHT\n	ComputeSpotLight(u_MaterialDiffuse,u_MaterialAmbient,u_MaterialSpecular,u_SpotLight,u_AmbientColor,v_PositionWorld,normal,toEye, dif, amb, spe);\n	diffuse+=dif;\n	ambient+=amb;\n	specular+=spe;\n#endif\n\n#ifdef RECEIVESHADOW\n	float shadowValue = 1.0;\n	#ifdef SHADOWMAP_PSSM3\n		shadowValue = getShadowPSSM3( u_shadowMap1,u_shadowMap2,u_shadowMap3,u_lightShadowVP,u_shadowPSSMDistance,u_shadowPCFoffset,v_PositionWorld,v_posViewZ,0.001);\n	#endif\n	#ifdef SHADOWMAP_PSSM2\n		shadowValue = getShadowPSSM2( u_shadowMap1,u_shadowMap2,u_lightShadowVP,u_shadowPSSMDistance,u_shadowPCFoffset,v_PositionWorld,v_posViewZ,0.001);\n	#endif \n	#ifdef SHADOWMAP_PSSM1\n		shadowValue = getShadowPSSM1( u_shadowMap1,v_lightMVPPos,u_shadowPSSMDistance,u_shadowPCFoffset,v_posViewZ,0.001);\n	#endif\n#endif\n\n#ifdef LIGHTMAP\n	#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\n		gl_FragColor.rgb=gl_FragColor.rgb*(u_MaterialAmbient + texture2D(u_LightMap, v_LightMapUV).rgb);\n	#else\n		#if defined(RECEIVESHADOW)		\n			gl_FragColor.rgb=gl_FragColor.rgb*(u_MaterialAmbient+texture2D(u_LightMap, v_LightMapUV).rgb * shadowValue);\n			//vec3 tColor= u_MaterialAmbient + texture2D(u_LightMap, v_LightMapUV).rgb * shadowValue + mix(vec3(0.15,0.15,0.15),vec3(0.0),shadowValue);\n			//gl_FragColor.rgb*=tColor;\n		#else\n			gl_FragColor.rgb=gl_FragColor.rgb*(u_MaterialAmbient + texture2D(u_LightMap, v_LightMapUV).rgb);\n		#endif\n	#endif\n#endif\n\ngl_FragColor=gl_FragColor*u_MaterialAlbedo;\n\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\n	#ifdef RECEIVESHADOW\n		gl_FragColor = vec4( gl_FragColor.rgb*(ambient + diffuse*shadowValue) + specular * shadowValue,gl_FragColor.a);\n	#else\n		gl_FragColor =vec4( gl_FragColor.rgb*(ambient + diffuse) + specular, gl_FragColor.a);\n	#endif\n#endif\n\n#ifdef FOG\n	float lerpFact=clamp((toEyeLength-u_FogStart)/u_FogRange,0.0,1.0);\n	gl_FragColor.rgb=mix(gl_FragColor.rgb,u_FogColor,lerpFact);\n#endif\n}\n\n\n\n\n\n";
		var extendTerrainCompile3D=ShaderCompile3D.add(extendTerrainShader,vs,ps,attributeMap,uniformMap);
		extendTerrainCompile3D.addSpriteDefines(RenderableSprite3D.shaderDefines);
		extendTerrainCompile3D.addMaterialDefines(ExtendTerrainMaterial.shaderDefines);
		attributeMap={
			'a_Position' :/*laya.d3.graphics.VertexElementUsage.POSITION0*/0,
			'a_OffsetVector':/*laya.d3.graphics.VertexElementUsage.OFFSETVECTOR*/41,
			'a_Texcoord0X' :/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE0X*/38,
			'a_Texcoord0Y' :/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE0Y*/40,
			'a_BirthTime' :/*laya.d3.graphics.VertexElementUsage.TIME0*/33
		};
		uniformMap={
			'u_MvpMatrix':[ /*laya.d3.core.Sprite3D.MVPMATRIX*/1,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],
			'u_VMatrix':[ /*laya.d3.core.BaseCamera.VIEWMATRIX*/1,/*laya.d3.shader.Shader3D.PERIOD_CAMERA*/3],
			'u_PMatrix':[ /*laya.d3.core.BaseCamera.PROJECTMATRIX*/2,/*laya.d3.shader.Shader3D.PERIOD_CAMERA*/3],
			'u_TilingOffset':[ /*laya.d3.core.trail.TrailMaterial.TILINGOFFSET*/3,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_MainTexture':[ /*laya.d3.core.trail.TrailMaterial.DIFFUSETEXTURE*/1,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_MainColor':[ /*laya.d3.core.trail.TrailMaterial.TINTCOLOR*/2,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
			'u_CurTime' :[ /*laya.d3.core.trail.TrailSprite3D.CURTIME*/3,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],
			'u_LifeTime' :[ /*laya.d3.core.trail.TrailSprite3D.LIFETIME*/4,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],
			'u_WidthCurve' :[ /*laya.d3.core.trail.TrailSprite3D.WIDTHCURVE*/5,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],
			'u_WidthCurveKeyLength' :[ /*laya.d3.core.trail.TrailSprite3D.WIDTHCURVEKEYLENGTH*/6,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],
			'u_GradientColorkey' :[ /*laya.d3.core.trail.TrailSprite3D.GRADIENTCOLORKEY*/7,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],
			'u_GradientAlphakey' :[ /*laya.d3.core.trail.TrailSprite3D.GRADIENTALPHAKEY*/8,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2]
		};
		var trailShader=Shader3D.nameKey.add("Trail");
		vs="attribute vec3 a_Position;\nattribute vec3 a_OffsetVector;\nattribute vec4 a_Color;\nattribute float a_Texcoord0X;\nattribute float a_Texcoord0Y;\nattribute float a_BirthTime;\n\nuniform mat4 u_VMatrix;\nuniform mat4 u_PMatrix;\n\nuniform vec4 u_TilingOffset;\n\nuniform float u_CurTime;\nuniform float u_LifeTime;\nuniform vec4 u_WidthCurve[10];\nuniform int u_WidthCurveKeyLength;\n\nuniform vec4 u_GradientColorkey[10];\nuniform vec2 u_GradientAlphakey[10];\n\nvarying vec2 v_Texcoord0;\nvarying vec4 v_Color;\n\nfloat hermiteInterpolate(float t, float outTangent, float inTangent, float duration, float value1, float value2)\n{\n	float t2 = t * t;\n	float t3 = t2 * t;\n	float a = 2.0 * t3 - 3.0 * t2 + 1.0;\n	float b = t3 - 2.0 * t2 + t;\n	float c = t3 - t2;\n	float d = -2.0 * t3 + 3.0 * t2;\n	return a * value1 + b * outTangent * duration + c * inTangent * duration + d * value2;\n}\n\nfloat getCurWidth(in float normalizeTime)\n{\n	if(normalizeTime == 0.0){\n		return u_WidthCurve[0].w;\n	}\n	else if(normalizeTime >= 1.0){\n		return u_WidthCurve[u_WidthCurveKeyLength - 1].w;\n	}\n	else{\n		for(int i = 0; i < 10; i ++ )\n		{\n			if(normalizeTime == u_WidthCurve[i].x)\n			{\n				return u_WidthCurve[i].w;\n			}\n			\n			vec4 lastFrame = u_WidthCurve[i];\n			vec4 nextFrame = u_WidthCurve[i + 1];\n			if(normalizeTime > lastFrame.x && normalizeTime < nextFrame.x)\n			{\n				float duration = nextFrame.x - lastFrame.x;\n				float t = (normalizeTime - lastFrame.x) / duration;\n				float outTangent = lastFrame.z;\n				float inTangent = nextFrame.y;\n				float value1 = lastFrame.w;\n				float value2 = nextFrame.w;\n				return hermiteInterpolate(t, outTangent, inTangent, duration, value1, value2);\n			}\n		}	\n	}\n}	\n\nvec4 getColorFromGradientByBlend(in vec4 gradientColors[10], in vec2 gradientAlphas[10], in float normalizeTime)\n{\n	vec4 color;\n	for(int i = 1; i < 10; i++)\n	{\n		vec4 gradientColor = gradientColors[i];\n		float colorKey = gradientColor.w;\n		if(colorKey >= normalizeTime)\n		{\n			vec4 lastGradientColor = gradientColors[i-1];\n			float lastColorKey = lastGradientColor.w;\n			float age = (normalizeTime - lastColorKey) / (colorKey - lastColorKey);\n			color.rgb = mix(gradientColors[i-1].xyz, gradientColor.xyz, age);\n			break;\n		}\n	}\n	for(int i = 1; i < 10; i++)\n	{\n		vec2 gradientAlpha = gradientAlphas[i];\n		float alphaKey = gradientAlpha.y;\n		if(alphaKey >= normalizeTime)\n		{\n			vec2 lastGradientAlpha = gradientAlphas[i-1];\n			float lastAlphaKey = lastGradientAlpha.y;\n			float age = (normalizeTime - lastAlphaKey) / (alphaKey - lastAlphaKey);\n			color.a = mix(lastGradientAlpha.x, gradientAlpha.x, age);\n			break;\n		}\n	}\n	return color;\n}\n\nvec4 getColorFromGradientByFixed(in vec4 gradientColors[10], in vec2 gradientAlphas[10], in float normalizeTime)\n{\n	vec4 color;\n	for(int i = 1; i < 10; i++)\n	{\n		vec4 gradientColor = gradientColors[i];\n		if(gradientColor.w >= normalizeTime)\n		{\n			color.rgb = gradientColor.xyz;\n			break;\n		}\n	}\n	for(int i = 1; i < 10; i++)\n	{\n		vec2 gradientAlpha = gradientAlphas[i];\n		if(gradientAlpha.y >= normalizeTime)\n		{\n			color.a = gradientAlpha.x;\n			break;\n		}\n	}\n	return color;\n}\n\nvoid main()\n{\n	float normalizeTime = (u_CurTime - a_BirthTime) / u_LifeTime;\n	\n	gl_Position = u_PMatrix * u_VMatrix * vec4(a_Position + a_OffsetVector * getCurWidth(normalizeTime),1.0);\n	\n	#ifdef TILINGOFFSET\n		v_Texcoord0 = (vec2(a_Texcoord0X, a_Texcoord0Y) * u_TilingOffset.xy) + u_TilingOffset.zw;\n	#else\n		v_Texcoord0 = vec2(a_Texcoord0X, a_Texcoord0Y);\n	#endif\n	\n	#ifdef GRADIENTMODE_BLEND\n		v_Color = getColorFromGradientByBlend(u_GradientColorkey, u_GradientAlphakey, normalizeTime);\n	#else\n		v_Color = getColorFromGradientByFixed(u_GradientColorkey, u_GradientAlphakey, normalizeTime);\n	#endif\n}\n\n\n\n";
		ps="#ifdef HIGHPRECISION\n	precision highp float;\n#else\n	precision mediump float;\n#endif\n\nuniform sampler2D u_MainTexture;\nuniform vec4 u_MainColor;\n\nvarying vec2 v_Texcoord0;\nvarying vec4 v_Color;\n\nvoid main()\n{	\n	vec4 color = 2.0 * u_MainColor * v_Color;\n	#ifdef DIFFUSETEXTURE\n		vec4 mainTextureColor = texture2D(u_MainTexture, v_Texcoord0);\n		color *= mainTextureColor;\n	#endif\n	gl_FragColor = color;\n}\n\n";
		var trailCompile3D=ShaderCompile3D.add(trailShader,vs,ps,attributeMap,uniformMap);
		TrailMaterial.SHADERDEFINE_DIFFUSETEXTURE=trailCompile3D.registerMaterialDefine("DIFFUSETEXTURE");
		TrailMaterial.SHADERDEFINE_TILINGOFFSET=trailCompile3D.registerSpriteDefine("TILINGOFFSET");
		TrailSprite3D.SHADERDEFINE_GRADIENTMODE_BLEND=trailCompile3D.registerSpriteDefine("GRADIENTMODE_BLEND");
	}

	return ShaderInit3D;
})()


/**
*@private
*<code>Shader3D</code> 主要用数组的方式保存shader变量定义，后期合并ShaderValue不使用for in，性能较高。
*/
//class laya.d3.shader.ValusArray
var ValusArray=(function(){
	function ValusArray(){
		this._data=null;
		this._data=[];
	}

	__class(ValusArray,'laya.d3.shader.ValusArray');
	var __proto=ValusArray.prototype;
	__proto.setValue=function(name,value){
		this._data[name]=value;
	}

	__getset(0,__proto,'data',function(){
		return this._data;
	});

	return ValusArray;
})()


/**
*...
*@author ...
*/
//class laya.d3.shadowMap.ParallelSplitShadowMap
var ParallelSplitShadowMap=(function(){
	function ParallelSplitShadowMap(){
		/**@private */
		//this.lastNearPlane=NaN;
		/**@private */
		//this.lastFieldOfView=NaN;
		/**@private */
		//this.lastAspectRatio=NaN;
		/**@private */
		this._currentPSSM=-1;
		/**@private */
		this._numberOfPSSM=3;
		/**@private */
		this._maxDistance=200.0;
		/**@private */
		this._ratioOfDistance=1.0 / this._numberOfPSSM;
		/**@private */
		this._statesDirty=true;
		/**@private */
		this._lightCulling=null;
		/**@private */
		this._renderTarget=null;
		/**@private */
		this._lightVPMatrix=null;
		/**@private */
		this._lightCameras=null;
		/**@private */
		this._shadowQuenes=null;
		/**@private */
		this._shadowMapTextureSize=1024;
		/**@private */
		this._scene=null;
		/**@private */
		this._PCFType=0;
		/**@private */
		this._shaderValueLightVP=null;
		/**@private */
		this._shaderValueVPs=null;
		this._spiltDistance=new Array(/*CLASS CONST:laya.d3.shadowMap.ParallelSplitShadowMap.MAX_PSSM_COUNT*/3+1);
		this._globalParallelLightDir=new Vector3(0,-1,0);
		this._boundingSphere=new Array(/*CLASS CONST:laya.d3.shadowMap.ParallelSplitShadowMap.MAX_PSSM_COUNT*/3+1);
		this._boundingBox=new Array(/*CLASS CONST:laya.d3.shadowMap.ParallelSplitShadowMap.MAX_PSSM_COUNT*/3+1);
		this._frustumPos=new Array((/*CLASS CONST:laya.d3.shadowMap.ParallelSplitShadowMap.MAX_PSSM_COUNT*/3+1)*4);
		this._uniformDistance=new Array(/*CLASS CONST:laya.d3.shadowMap.ParallelSplitShadowMap.MAX_PSSM_COUNT*/3+1);
		this._logDistance=new Array(/*CLASS CONST:laya.d3.shadowMap.ParallelSplitShadowMap.MAX_PSSM_COUNT*/3+1);
		this._dimension=new Array(/*CLASS CONST:laya.d3.shadowMap.ParallelSplitShadowMap.MAX_PSSM_COUNT*/3+1);
		this._tempLookAt3=new Vector3();
		this._tempLookAt4=new Vector4();
		this._tempValue=new Vector4();
		this._tempPos=new Vector3();
		this._tempLightUp=new Vector3();
		this._tempMin=new Vector4();
		this._tempMax=new Vector4();
		this._tempMatrix44=new Matrix4x4;
		this._splitFrustumCulling=new BoundFrustum(Matrix4x4.DEFAULT);
		this._tempScaleMatrix44=new Matrix4x4;
		this._shadowPCFOffset=new Vector2(1.0 / 1024.0,1.0 / 1024.0);
		this._shaderValueDistance=new Vector4();
		var i=0;
		for (i=0;i < this._spiltDistance.length;i++){
			this._spiltDistance[i]=0.0;
		}
		for (i=0;i < this._dimension.length;i++){
			this._dimension[i]=new Vector2();
		}
		for (i=0;i < this._frustumPos.length;i++){
			this._frustumPos[i]=new Vector3();
		}
		for (i=0;i < this._boundingBox.length;i++){
			this._boundingBox[i]=new BoundBox(new Vector3(),new Vector3());
		}
		for (i=0;i < this._boundingSphere.length;i++){
			this._boundingSphere[i]=new BoundSphere(new Vector3(),0.0);
		}
		Matrix4x4.createScaling(new Vector3(0.5,0.5,1.0),this._tempScaleMatrix44);
		this._tempScaleMatrix44.elements[12]=0.5;
		this._tempScaleMatrix44.elements[13]=0.5;
	}

	__class(ParallelSplitShadowMap,'laya.d3.shadowMap.ParallelSplitShadowMap');
	var __proto=ParallelSplitShadowMap.prototype;
	__proto.setInfo=function(scene,maxDistance,globalParallelDir,shadowMapTextureSize,numberOfPSSM,PCFType){
		if (numberOfPSSM > /*CLASS CONST:laya.d3.shadowMap.ParallelSplitShadowMap.MAX_PSSM_COUNT*/3){
			this._numberOfPSSM=/*CLASS CONST:laya.d3.shadowMap.ParallelSplitShadowMap.MAX_PSSM_COUNT*/3;
		}
		this._scene=scene;
		this._maxDistance=maxDistance;
		this.PSSMNum=numberOfPSSM;
		this._globalParallelLightDir=globalParallelDir;
		this._ratioOfDistance=1.0 / this._numberOfPSSM;
		for (var i=0;i < this._spiltDistance.length;i++){
			this._spiltDistance[i]=0.0;
		}
		this._shadowMapTextureSize=shadowMapTextureSize;
		this._shadowPCFOffset.x=1.0 / this._shadowMapTextureSize;
		this._shadowPCFOffset.y=1.0 / this._shadowMapTextureSize;
		this.setPCFType(PCFType);
		this._statesDirty=true;
	}

	__proto.setPCFType=function(PCFtype){
		this._PCFType=PCFtype;
		switch (this._PCFType){
			case 0:
				this._scene.addShaderDefine(laya.d3.shadowMap.ParallelSplitShadowMap.SHADERDEFINE_SHADOW_PCF_NO);
				this._scene.removeShaderDefine(laya.d3.shadowMap.ParallelSplitShadowMap.SHADERDEFINE_SHADOW_PCF1);
				this._scene.removeShaderDefine(laya.d3.shadowMap.ParallelSplitShadowMap.SHADERDEFINE_SHADOW_PCF2);
				this._scene.removeShaderDefine(laya.d3.shadowMap.ParallelSplitShadowMap.SHADERDEFINE_SHADOW_PCF3);
				break ;
			case 1:
				this._scene.addShaderDefine(laya.d3.shadowMap.ParallelSplitShadowMap.SHADERDEFINE_SHADOW_PCF1);
				this._scene.removeShaderDefine(laya.d3.shadowMap.ParallelSplitShadowMap.SHADERDEFINE_SHADOW_PCF_NO);
				this._scene.removeShaderDefine(laya.d3.shadowMap.ParallelSplitShadowMap.SHADERDEFINE_SHADOW_PCF2);
				this._scene.removeShaderDefine(laya.d3.shadowMap.ParallelSplitShadowMap.SHADERDEFINE_SHADOW_PCF3);
				break ;
			case 2:
				this._scene.addShaderDefine(laya.d3.shadowMap.ParallelSplitShadowMap.SHADERDEFINE_SHADOW_PCF2);
				this._scene.removeShaderDefine(laya.d3.shadowMap.ParallelSplitShadowMap.SHADERDEFINE_SHADOW_PCF_NO);
				this._scene.removeShaderDefine(laya.d3.shadowMap.ParallelSplitShadowMap.SHADERDEFINE_SHADOW_PCF1);
				this._scene.removeShaderDefine(laya.d3.shadowMap.ParallelSplitShadowMap.SHADERDEFINE_SHADOW_PCF3);
				break ;
			case 3:
				this._scene.addShaderDefine(laya.d3.shadowMap.ParallelSplitShadowMap.SHADERDEFINE_SHADOW_PCF3);
				this._scene.removeShaderDefine(laya.d3.shadowMap.ParallelSplitShadowMap.SHADERDEFINE_SHADOW_PCF_NO);
				this._scene.removeShaderDefine(laya.d3.shadowMap.ParallelSplitShadowMap.SHADERDEFINE_SHADOW_PCF1);
				this._scene.removeShaderDefine(laya.d3.shadowMap.ParallelSplitShadowMap.SHADERDEFINE_SHADOW_PCF2);
				break ;
			}
	}

	__proto.getPCFType=function(){
		return this._PCFType;
	}

	__proto.setFarDistance=function(value){
		if (this._maxDistance !=value){
			this._maxDistance=value;
			this._statesDirty=true;
		}
	}

	__proto.getFarDistance=function(){
		return this._maxDistance;
	}

	__proto._setGlobalParallelLightDir=function(dir){
		this._globalParallelLightDir=dir;
	}

	__proto.getGlobalParallelLightDir=function(){
		return this._globalParallelLightDir;
	}

	__proto.getCurrentPSSM=function(){
		return this._currentPSSM;
	}

	__proto.getLightCamera=function(index){
		return this._lightCameras[index];
	}

	/**
	*@private
	*/
	__proto._beginSampler=function(index,sceneCamera){
		if (index < 0 || index > this._numberOfPSSM)
			throw new Error("ParallelSplitShadowMap: beginSample invalid index");
		this._currentPSSM=index;
		this._update(sceneCamera);
	}

	/**
	*@private
	*/
	__proto.endSampler=function(sceneCamera){
		this._currentPSSM=-1;
	}

	/**
	*@private
	*/
	__proto._calcAllLightCameraInfo=function(sceneCamera){
		if (this._numberOfPSSM===1){
			this._beginSampler(0,sceneCamera);
			this.endSampler(sceneCamera);
			}else {
			for (var i=0,n=this._numberOfPSSM+1;i < n;i++){
				this._beginSampler(i,sceneCamera);
				this.endSampler(sceneCamera);
			}
		}
	}

	/**
	*@private
	*/
	__proto._recalculate=function(nearPlane,fieldOfView,aspectRatio){
		this._calcSplitDistance(nearPlane);
		this._calcBoundingBox(fieldOfView,aspectRatio);
		this._rebuildRenderInfo();
	}

	/**
	*@private
	*/
	__proto._update=function(sceneCamera){
		var nearPlane=sceneCamera.nearPlane;
		var fieldOfView=sceneCamera.fieldOfView;
		var aspectRatio=(sceneCamera).aspectRatio;
		if (this._statesDirty || this.lastNearPlane!==nearPlane || this.lastFieldOfView!==fieldOfView || this.lastAspectRatio!==aspectRatio){
			this._recalculate(nearPlane,fieldOfView,aspectRatio);
			this._uploadShaderValue();
			this._statesDirty=false;
			this.lastNearPlane=nearPlane;
			this.lastFieldOfView=fieldOfView;
			this.lastAspectRatio=aspectRatio;
		}
		this._calcLightViewProject(sceneCamera);
	}

	/**
	*@private
	*/
	__proto._uploadShaderValue=function(){
		var scene=this._scene;
		switch (this._numberOfPSSM){
			case 1:
				scene.addShaderDefine(laya.d3.shadowMap.ParallelSplitShadowMap.SHADERDEFINE_SHADOW_PSSM1);
				scene.removeShaderDefine(laya.d3.shadowMap.ParallelSplitShadowMap.SHADERDEFINE_SHADOW_PSSM2);
				scene.removeShaderDefine(laya.d3.shadowMap.ParallelSplitShadowMap.SHADERDEFINE_SHADOW_PSSM3);
				break ;
			case 2:
				scene.addShaderDefine(laya.d3.shadowMap.ParallelSplitShadowMap.SHADERDEFINE_SHADOW_PSSM2);
				scene.removeShaderDefine(laya.d3.shadowMap.ParallelSplitShadowMap.SHADERDEFINE_SHADOW_PSSM1);
				scene.removeShaderDefine(laya.d3.shadowMap.ParallelSplitShadowMap.SHADERDEFINE_SHADOW_PSSM3);
				break ;
			case 3:
				scene.addShaderDefine(laya.d3.shadowMap.ParallelSplitShadowMap.SHADERDEFINE_SHADOW_PSSM3);
				scene.removeShaderDefine(laya.d3.shadowMap.ParallelSplitShadowMap.SHADERDEFINE_SHADOW_PSSM1);
				scene.removeShaderDefine(laya.d3.shadowMap.ParallelSplitShadowMap.SHADERDEFINE_SHADOW_PSSM2);
				break ;
			};
		var sceneSV=scene._shaderValues;
		sceneSV.setValue(/*laya.d3.core.scene.Scene.SHADOWDISTANCE*/15,this._shaderValueDistance.elements);
		sceneSV.setValue(/*laya.d3.core.scene.Scene.SHADOWLIGHTVIEWPROJECT*/16,this._shaderValueLightVP);
		sceneSV.setValue(/*laya.d3.core.scene.Scene.SHADOWMAPPCFOFFSET*/17,this._shadowPCFOffset.elements);
		switch (this._numberOfPSSM){
			case 3:
				sceneSV.setValue(/*laya.d3.core.scene.Scene.SHADOWMAPTEXTURE1*/18,this.getRenderTarget(1));
				sceneSV.setValue(/*laya.d3.core.scene.Scene.SHADOWMAPTEXTURE2*/19,this.getRenderTarget(2));
				sceneSV.setValue(/*laya.d3.core.scene.Scene.SHADOWMAPTEXTURE3*/20,this.getRenderTarget(3));
				break ;
			case 2:
				sceneSV.setValue(/*laya.d3.core.scene.Scene.SHADOWMAPTEXTURE1*/18,this.getRenderTarget(1));
				sceneSV.setValue(/*laya.d3.core.scene.Scene.SHADOWMAPTEXTURE2*/19,this.getRenderTarget(2));
				break ;
			case 1:
				sceneSV.setValue(/*laya.d3.core.scene.Scene.SHADOWMAPTEXTURE1*/18,this.getRenderTarget(1));
				break ;
			}
	}

	/**
	*@private
	*/
	__proto._calcSplitDistance=function(nearPlane){
		var far=this._maxDistance;
		var invNumberOfPSSM=1.0 / this._numberOfPSSM;
		var i=0;
		for (i=0;i <=this._numberOfPSSM;i++){
			this._uniformDistance[i]=nearPlane+(far-nearPlane)*i *invNumberOfPSSM;
		};
		var farDivNear=far / nearPlane;
		for (i=0;i <=this._numberOfPSSM;i++){
			var n=Math.pow(farDivNear,i *invNumberOfPSSM);
			this._logDistance[i]=nearPlane *n;
		}
		for (i=0;i <=this._numberOfPSSM;i++){
			this._spiltDistance[i]=this._uniformDistance[i] *this._ratioOfDistance+this._logDistance[i] *(1.0-this._ratioOfDistance);
		}
		this._shaderValueDistance.x=this._spiltDistance[1];
		this._shaderValueDistance.y=this._spiltDistance[2];
		this._shaderValueDistance.z=this._spiltDistance[3];
		this._shaderValueDistance.w=this._spiltDistance[4];
	}

	/**
	*@private
	*/
	__proto._calcBoundingBox=function(fieldOfView,aspectRatio){
		var fov=3.1415926 *fieldOfView / 180.0;
		var halfTanValue=Math.tan(fov / 2.0);
		var height=NaN;
		var width=NaN;
		var distance=NaN;
		var i=0;
		for (i=0;i <=this._numberOfPSSM;i++){
			distance=this._spiltDistance[i];
			height=distance *halfTanValue;
			width=height *aspectRatio;
			var temp=this._frustumPos[i *4+0].elements;
			temp[0]=-width;
			temp[1]=-height;
			temp[2]=-distance;
			temp=this._frustumPos[i *4+1].elements;
			temp[0]=width;
			temp[1]=-height;
			temp[2]=-distance;
			temp=this._frustumPos[i *4+2].elements;
			temp[0]=-width;
			temp[1]=height;
			temp[2]=-distance;
			temp=this._frustumPos[i *4+3].elements;
			temp[0]=width;
			temp[1]=height;
			temp[2]=-distance;
			temp=this._dimension[i].elements;
			temp[0]=width;
			temp[1]=height;
		};
		var d;
		var min;
		var max;
		var center;
		for (i=1;i <=this._numberOfPSSM;i++){
			d=this._dimension[i].elements;
			min=this._boundingBox[i].min.elements;
			min[0]=-d[0];
			min[1]=-d[1];
			min[2]=-this._spiltDistance[i];
			max=this._boundingBox[i].max.elements;
			max[0]=d[0];
			max[1]=d[1];
			max[2]=-this._spiltDistance[i-1];
			center=this._boundingSphere[i].center.elements;
			center[0]=(min[0]+max[0])*0.5;
			center[1]=(min[1]+max[1])*0.5;
			center[2]=(min[2]+max[2])*0.5;
			this._boundingSphere[i].radius=Math.sqrt(Math.pow(max[0]-min[0],2)+Math.pow(max[1]-min[1],2)+Math.pow(max[2]-min[2],2))*0.5;
		}
		min=this._boundingBox[0].min.elements;
		d=this._dimension[this._numberOfPSSM].elements;
		min[0]=-d[0];
		min[1]=-d[1];
		min[2]=-this._spiltDistance[this._numberOfPSSM];
		max=this._boundingBox[0].max.elements;
		max[0]=d[0];
		max[1]=d[1];
		max[2]=-this._spiltDistance[0];
		center=this._boundingSphere[0].center.elements;
		center[0]=(min[0]+max[0])*0.5;
		center[1]=(min[1]+max[1])*0.5;
		center[2]=(min[2]+max[2])*0.5;
		this._boundingSphere[0].radius=Math.sqrt(Math.pow(max[0]-min[0],2)+Math.pow(max[1]-min[1],2)+Math.pow(max[2]-min[2],2))*0.5;
	}

	__proto.calcSplitFrustum=function(sceneCamera){
		if (this._currentPSSM > 0){
			Matrix4x4.createPerspective(3.1416 *sceneCamera.fieldOfView / 180.0,(sceneCamera).aspectRatio,this._spiltDistance[this._currentPSSM-1],this._spiltDistance[this._currentPSSM],this._tempMatrix44);
			}else {
			Matrix4x4.createPerspective(3.1416 *sceneCamera.fieldOfView / 180.0,(sceneCamera).aspectRatio,this._spiltDistance[0],this._spiltDistance[this._numberOfPSSM],this._tempMatrix44);
		}
		Matrix4x4.multiply(this._tempMatrix44,(sceneCamera).viewMatrix,this._tempMatrix44);
		this._splitFrustumCulling.matrix=this._tempMatrix44;
	}

	/**
	*@private
	*/
	__proto._rebuildRenderInfo=function(){
		var nNum=this._numberOfPSSM+1;
		var i=0;
		if (this._renderTarget==null){
			this._renderTarget=__newvec(nNum);
			this._renderTarget[0]=null;
			for (i=1;i < nNum;i++){
				this._renderTarget[i]=new RenderTexture(this._shadowMapTextureSize,this._shadowMapTextureSize,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401,/*laya.webgl.WebGLContext.DEPTH_COMPONENT16*/0x81A5,false,false,/*laya.webgl.WebGLContext.NEAREST*/0x2600,/*laya.webgl.WebGLContext.NEAREST*/0x2600);
			}
			}else if (this._renderTarget.length !=nNum){
			this.disposeAllRenderTarget();
			this._renderTarget.length=nNum;
			this._renderTarget[0]=null;
			for (i=1;i < nNum;i++){
				this._renderTarget[i]=new RenderTexture(this._shadowMapTextureSize,this._shadowMapTextureSize,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401,/*laya.webgl.WebGLContext.DEPTH_COMPONENT16*/0x81A5,false,false,/*laya.webgl.WebGLContext.NEAREST*/0x2600,/*laya.webgl.WebGLContext.NEAREST*/0x2600);
			}
			}else {
			for (i=1;i < nNum;i++){
				if (this._renderTarget[i]==null || this._renderTarget[i].width !=this._shadowMapTextureSize || this._renderTarget[i].height !=this._shadowMapTextureSize){
					if (this._renderTarget[i] !=null){
						this._renderTarget[i].destroy();
					}
					this._renderTarget[i]=new RenderTexture(this._shadowMapTextureSize,this._shadowMapTextureSize,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401,/*laya.webgl.WebGLContext.DEPTH_COMPONENT16*/0x81A5,false,false,/*laya.webgl.WebGLContext.NEAREST*/0x2600,/*laya.webgl.WebGLContext.NEAREST*/0x2600);
				}
			}
		}
		if (this._lightCulling==null || this._lightCulling.length !=nNum){
			if (this._lightCulling){
				this._lightCulling.length=nNum;
				}else {
				this._lightCulling=__newvec(nNum);
			}
			for (i=0;i < this._lightCulling.length;i++){
				this._lightCulling[i]=new BoundFrustum(Matrix4x4.DEFAULT);
			}
		}
		if (this._lightVPMatrix==null || this._lightVPMatrix.length !=nNum){
			if (this._lightVPMatrix){
				this._lightVPMatrix.length=nNum;
				}else {
				this._lightVPMatrix=__newvec(nNum);
			}
			for (i=0;i < this._lightVPMatrix.length;i++){
				this._lightVPMatrix[i]=new Matrix4x4();
			}
		}
		if (this._lightCameras==null || this._lightCameras.length !=nNum){
			if (this._lightCameras){
				this._lightCameras.length=nNum;
				}else {
				this._lightCameras=__newvec(nNum);
			}
			for (i=0;i < this._lightCameras.length;i++){
				this._lightCameras[i]=new Camera();
				this._lightCameras[i].name="lightCamera"+i;
			}
		}
		if (this._shadowQuenes==null || this._shadowQuenes.length !=this._numberOfPSSM){
			if (this._shadowQuenes){
				this._shadowQuenes.length=this._numberOfPSSM;
				}else {
				this._shadowQuenes=__newvec(this._numberOfPSSM);
			}
			for (i=0;i < this._shadowQuenes.length;i++){
				this._shadowQuenes[i]=new RenderQueue(this._scene);
			}
		}
		if (this._shaderValueVPs==null || this._shaderValueVPs.length !=nNum){
			if (this._shaderValueVPs){
				this._shaderValueVPs.length=nNum;
				}else {
				this._shaderValueVPs=__newvec(nNum);
			}
			this._shaderValueLightVP=new Float32Array(nNum *16);
			for (i=0;i < nNum;i++){
				this._shaderValueVPs[i]=new Float32Array(this._shaderValueLightVP.buffer,i *64);
			}
		}
	}

	/**
	*@private
	*/
	__proto._calcLightViewProject=function(sceneCamera){
		var boundSphere=this._boundingSphere[this._currentPSSM];
		var cameraMatViewInv=sceneCamera.transform.worldMatrix;
		var radius=boundSphere.radius;
		boundSphere.center.cloneTo(this._tempLookAt3);
		Vector3.transformV3ToV4(this._tempLookAt3,cameraMatViewInv,this._tempLookAt4);
		var lookAt3Element=this._tempLookAt3.elements;
		var lookAt4Element=this._tempLookAt4.elements;
		lookAt3Element[0]=lookAt4Element[0];
		lookAt3Element[1]=lookAt4Element[1];
		lookAt3Element[2]=lookAt4Element[2];
		var lightUpElement=this._tempLightUp.elements;
		var sceneCameraDir=sceneCamera.forward.elements;
		lightUpElement[0]=sceneCameraDir[0];
		lightUpElement[1]=1.0;
		lightUpElement[2]=sceneCameraDir[2];
		Vector3.normalize(this._tempLightUp,this._tempLightUp);
		Vector3.scale(this._globalParallelLightDir,boundSphere.radius *4,this._tempPos);
		Vector3.subtract(this._tempLookAt3,this._tempPos,this._tempPos);
		var curLightCamera=this._lightCameras[this._currentPSSM];
		curLightCamera.transform.position=this._tempPos;
		curLightCamera.transform.lookAt(this._tempLookAt3,this._tempLightUp,false);
		var tempMaxElements=this._tempMax.elements;
		var tempMinElements=this._tempMin.elements;
		tempMaxElements[0]=tempMaxElements[1]=tempMaxElements[2]=-100000.0;
		tempMaxElements[3]=1.0;
		tempMinElements[0]=tempMinElements[1]=tempMinElements[2]=100000.0;
		tempMinElements[3]=1.0;
		Matrix4x4.multiply(curLightCamera.viewMatrix,cameraMatViewInv,this._tempMatrix44);
		var tempValueElement=this._tempValue.elements;
		var corners=[];
		corners.length=8;
		this._boundingBox[this._currentPSSM].getCorners(corners);
		for (var i=0;i < 8;i++){
			var frustumPosElements=corners[i].elements;
			tempValueElement[0]=frustumPosElements[0];
			tempValueElement[1]=frustumPosElements[1];
			tempValueElement[2]=frustumPosElements[2];
			tempValueElement[3]=1.0;
			Vector4.transformByM4x4(this._tempValue,this._tempMatrix44,this._tempValue);
			tempMinElements[0]=(tempValueElement[0] < tempMinElements[0])? tempValueElement[0] :tempMinElements[0];
			tempMinElements[1]=(tempValueElement[1] < tempMinElements[1])? tempValueElement[1] :tempMinElements[1];
			tempMinElements[2]=(tempValueElement[2] < tempMinElements[2])? tempValueElement[2] :tempMinElements[2];
			tempMaxElements[0]=(tempValueElement[0] > tempMaxElements[0])? tempValueElement[0] :tempMaxElements[0];
			tempMaxElements[1]=(tempValueElement[1] > tempMaxElements[1])? tempValueElement[1] :tempMaxElements[1];
			tempMaxElements[2]=(tempValueElement[2] > tempMaxElements[2])? tempValueElement[2] :tempMaxElements[2];
		}
		Vector4.add(this._tempMax,this._tempMin,this._tempValue);
		tempValueElement[0] *=0.5;
		tempValueElement[1] *=0.5;
		tempValueElement[2] *=0.5;
		tempValueElement[3]=1;
		Vector4.transformByM4x4(this._tempValue,curLightCamera.transform.worldMatrix,this._tempValue);
		var distance=Math.abs(-this._tempMax.z);
		var farPlane=distance > this._maxDistance ? distance :this._maxDistance;
		Vector3.scale(this._globalParallelLightDir,farPlane,this._tempPos);
		var tempPosElement=this._tempPos.elements;
		tempPosElement[0]=tempValueElement[0]-tempPosElement[0];
		tempPosElement[1]=tempValueElement[1]-tempPosElement[1];
		tempPosElement[2]=tempValueElement[2]-tempPosElement[2];
		curLightCamera.transform.position=this._tempPos;
		curLightCamera.transform.lookAt(this._tempLookAt3,this._tempLightUp,false);
		Matrix4x4.createOrthoOffCenterRH(tempMinElements[0],tempMaxElements[0],tempMinElements[1],tempMaxElements[1],1.0,farPlane+0.5 *(tempMaxElements[2]-tempMinElements[2]),curLightCamera.projectionMatrix);
		curLightCamera.projectionViewMatrix.cloneTo(this._lightVPMatrix[this._currentPSSM]);
		this._lightCulling[this._currentPSSM].matrix=this._lightVPMatrix[this._currentPSSM];
		ParallelSplitShadowMap.multiplyMatrixOutFloat32Array(this._tempScaleMatrix44,this._lightVPMatrix[this._currentPSSM],this._shaderValueVPs[this._currentPSSM]);
	}

	__proto.getLightFrustumCulling=function(currentPSSM){
		return this._lightCulling[currentPSSM];
	}

	__proto.getSplitFrustumCulling=function(){
		return this._splitFrustumCulling;
	}

	__proto.getSplitDistance=function(index){
		return this._spiltDistance[index];
	}

	__proto.setShadowMapTextureSize=function(size){
		if (size!==this._shadowMapTextureSize){
			this._shadowMapTextureSize=size;
			this._shadowPCFOffset.x=1 / this._shadowMapTextureSize;
			this._shadowPCFOffset.y=1 / this._shadowMapTextureSize;
			this._statesDirty=true;
		}
	}

	__proto.getShadowMapTextureSize=function(){
		return this._shadowMapTextureSize;
	}

	__proto.beginRenderTarget=function(index){
		this._renderTarget[index].start();
	}

	__proto.endRenderTarget=function(index){
		this._renderTarget[index].end();
	}

	__proto.getRenderTarget=function(index){
		return this._renderTarget[index];
	}

	__proto.disposeAllRenderTarget=function(){
		for (var i=0,n=this._numberOfPSSM+1;i < n;i++){
			if (this._renderTarget[i]){
				this._renderTarget[i].destroy();
				this._renderTarget[i]=null;
			}
		}
	}

	__getset(0,__proto,'PSSMNum',function(){
		return this._numberOfPSSM;
		},function(value){
		value=value > 0 ? value :1;
		value=value <=3 ? value :3;
		if (this._numberOfPSSM !=value){
			this._numberOfPSSM=value;
			this._ratioOfDistance=1.0 / this._numberOfPSSM;
			this._statesDirty=true;
		}
	});

	ParallelSplitShadowMap.multiplyMatrixOutFloat32Array=function(left,right,out){
		var i,a,b,ai0,ai1,ai2,ai3;
		a=left.elements;
		b=right.elements;
		for (i=0;i < 4;i++){
			ai0=a[i];
			ai1=a[i+4];
			ai2=a[i+8];
			ai3=a[i+12];
			out[i]=ai0 *b[0]+ai1 *b[1]+ai2 *b[2]+ai3 *b[3];
			out[i+4]=ai0 *b[4]+ai1 *b[5]+ai2 *b[6]+ai3 *b[7];
			out[i+8]=ai0 *b[8]+ai1 *b[9]+ai2 *b[10]+ai3 *b[11];
			out[i+12]=ai0 *b[12]+ai1 *b[13]+ai2 *b[14]+ai3 *b[15];
		}
	}

	ParallelSplitShadowMap.SHADERDEFINE_RECEIVE_SHADOW=0x1;
	ParallelSplitShadowMap.SHADERDEFINE_CAST_SHADOW=0x200;
	ParallelSplitShadowMap.SHADERDEFINE_SHADOW_PSSM1=0x400;
	ParallelSplitShadowMap.SHADERDEFINE_SHADOW_PSSM2=0x800;
	ParallelSplitShadowMap.SHADERDEFINE_SHADOW_PSSM3=0x1000;
	ParallelSplitShadowMap.SHADERDEFINE_SHADOW_PCF_NO=0x2000;
	ParallelSplitShadowMap.SHADERDEFINE_SHADOW_PCF1=0x4000;
	ParallelSplitShadowMap.SHADERDEFINE_SHADOW_PCF2=0x8000;
	ParallelSplitShadowMap.SHADERDEFINE_SHADOW_PCF3=0x10000;
	ParallelSplitShadowMap.MAX_PSSM_COUNT=3;
	return ParallelSplitShadowMap;
})()


/**
*<code>TerrainLeaf</code> Terrain的叶子节点
*/
//class laya.d3.terrain.TerrainLeaf
var TerrainLeaf=(function(){
	function TerrainLeaf(){
		this._boundingSphere=null;
		this._boundingBox=null;
		this._sizeOfY=null;
		this._currentLODLevel=0;
		this._lastDistanceToEye=NaN;
		this._originalBoundingSphere=null;
		this._originalBoundingBox=null;
		this._originalBoundingBoxCorners=null;
		this._bUseStrip=false;
		this._gridSize=NaN;
		this._beginGridX=0;
		//针对整个大地形的偏移
		this._beginGridZ=0;
		//针对整个大地形的偏移
		this._LODError=null;
		TerrainLeaf.__init__();
		this._currentLODLevel=0;
	}

	__class(TerrainLeaf,'laya.d3.terrain.TerrainLeaf');
	var __proto=TerrainLeaf.prototype;
	__proto.calcVertextNorml=function(x,z,terrainHeightData,heighDataWidth,heightDataHeight,normal){
		var dZ=0,dX=0;
		dX=TerrainLeaf.getHeightFromTerrainHeightData(x-1,z-1,terrainHeightData,heighDataWidth,heightDataHeight)*-1.0;
		dX+=TerrainLeaf.getHeightFromTerrainHeightData(x-1,z,terrainHeightData,heighDataWidth,heightDataHeight)*-1.0;
		dX+=TerrainLeaf.getHeightFromTerrainHeightData(x-1,z+1,terrainHeightData,heighDataWidth,heightDataHeight)*-1.0;
		dX+=TerrainLeaf.getHeightFromTerrainHeightData(x+1,z-1,terrainHeightData,heighDataWidth,heightDataHeight)*1.0;
		dX+=TerrainLeaf.getHeightFromTerrainHeightData(x+1,z,terrainHeightData,heighDataWidth,heightDataHeight)*1.0;
		dX+=TerrainLeaf.getHeightFromTerrainHeightData(x+1,z+1,terrainHeightData,heighDataWidth,heightDataHeight)*1.0;
		dZ=TerrainLeaf.getHeightFromTerrainHeightData(x-1,z-1,terrainHeightData,heighDataWidth,heightDataHeight)*-1.0;
		dZ+=TerrainLeaf.getHeightFromTerrainHeightData(x,z-1,terrainHeightData,heighDataWidth,heightDataHeight)*-1.0;
		dZ+=TerrainLeaf.getHeightFromTerrainHeightData(x+1,z-1,terrainHeightData,heighDataWidth,heightDataHeight)*-1.0;
		dZ+=TerrainLeaf.getHeightFromTerrainHeightData(x-1,z+1,terrainHeightData,heighDataWidth,heightDataHeight)*1.0;
		dZ+=TerrainLeaf.getHeightFromTerrainHeightData(x,z+1,terrainHeightData,heighDataWidth,heightDataHeight)*1.0;
		dZ+=TerrainLeaf.getHeightFromTerrainHeightData(x+1,z+1,terrainHeightData,heighDataWidth,heightDataHeight)*1.0;
		normal.x=-dX;
		normal.y=6;
		normal.z=-dZ;
		Vector3.normalize(normal,normal);
	}

	__proto.calcVertextNormlUV=function(x,z,terrainWidth,terrainHeight,normal){
		normal.x=x / terrainWidth;
		normal.y=z / terrainHeight;
		normal.z=z / terrainHeight;
	}

	__proto.calcVertextBuffer=function(offsetChunkX,offsetChunkZ,beginX,beginZ,girdSize,vertextBuffer,offset,strideSize,terrainHeightData,heighDataWidth,heightDataHeight,cameraCoordinateInverse){
		if (cameraCoordinateInverse==true && !TerrainLeaf.__ADAPT_MATRIX__){
			TerrainLeaf.__ADAPT_MATRIX__=new Matrix4x4();
			var mat=new Matrix4x4();
			Matrix4x4.createRotationY(Math.PI,TerrainLeaf.__ADAPT_MATRIX__);
			Matrix4x4.createTranslate(new Vector3(0,0,(heightDataHeight-1)*girdSize),mat);
			Matrix4x4.multiply(mat,TerrainLeaf.__ADAPT_MATRIX__,TerrainLeaf.__ADAPT_MATRIX__);
			TerrainLeaf.__ADAPT_MATRIX_INV__=new Matrix4x4();
			TerrainLeaf.__ADAPT_MATRIX__.invert(TerrainLeaf.__ADAPT_MATRIX_INV__);
		}
		this._gridSize=girdSize;
		this._beginGridX=offsetChunkX *TerrainLeaf.CHUNK_GRID_NUM+beginX;
		this._beginGridZ=offsetChunkZ *TerrainLeaf.CHUNK_GRID_NUM+beginZ;
		var nNum=offset *strideSize;
		var minY=2147483647;
		var maxY=-2147483648;
		var normal=new Vector3();
		for (var i=0,s=TerrainLeaf.LEAF_GRID_NUM+1;i < s;i++){
			for (var j=0,s1=TerrainLeaf.LEAF_GRID_NUM+1;j < s1;j++){
				TerrainLeaf.__VECTOR3__.x=(this._beginGridX+j)*this._gridSize;
				TerrainLeaf.__VECTOR3__.z=(this._beginGridZ+i)*this._gridSize;
				TerrainLeaf.__VECTOR3__.y=terrainHeightData[(this._beginGridZ+i)*(heighDataWidth)+(this._beginGridX+j)];
				minY=TerrainLeaf.__VECTOR3__.y < minY ? TerrainLeaf.__VECTOR3__.y :minY;
				maxY=TerrainLeaf.__VECTOR3__.y > maxY ? TerrainLeaf.__VECTOR3__.y :maxY;
				if (TerrainLeaf.__ADAPT_MATRIX__){
					Vector3.transformV3ToV3(TerrainLeaf.__VECTOR3__,TerrainLeaf.__ADAPT_MATRIX__,TerrainLeaf.__VECTOR3__);
				}
				vertextBuffer[nNum]=TerrainLeaf.__VECTOR3__.x;
				nNum++;
				vertextBuffer[nNum]=TerrainLeaf.__VECTOR3__.y;
				nNum++;
				vertextBuffer[nNum]=TerrainLeaf.__VECTOR3__.z;
				nNum++;
				this.calcVertextNormlUV(this._beginGridX+j,this._beginGridZ+i,heighDataWidth,heightDataHeight,normal);
				vertextBuffer[nNum]=normal.x;
				nNum++;
				vertextBuffer[nNum]=normal.y;
				nNum++;
				vertextBuffer[nNum]=normal.z;
				nNum++;
				vertextBuffer[nNum]=(beginX+j)/ TerrainLeaf.CHUNK_GRID_NUM;
				nNum++;
				vertextBuffer[nNum]=(beginZ+i)/ TerrainLeaf.CHUNK_GRID_NUM;
				nNum++;
				vertextBuffer[nNum]=this._beginGridX+j;
				nNum++;
				vertextBuffer[nNum]=this._beginGridZ+i;
				nNum++;
			}
		}
		this._sizeOfY=new Vector2(minY-1,maxY+1);
		this.calcLODErrors(terrainHeightData,heighDataWidth,heightDataHeight);
		this.calcOriginalBoudingBoxAndSphere();
	}

	__proto.calcSkirtVertextBuffer=function(offsetChunkX,offsetChunkZ,beginX,beginZ,girdSize,vertextBuffer,offset,strideSize,terrainHeightData,heighDataWidth,heightDataHeight){
		this._gridSize=girdSize;
		this._beginGridX=offsetChunkX *TerrainLeaf.CHUNK_GRID_NUM+beginX;
		this._beginGridZ=offsetChunkZ *TerrainLeaf.CHUNK_GRID_NUM+beginZ;
		var nNum=offset *strideSize;
		var i=0,j=0,s=TerrainLeaf.LEAF_GRID_NUM+1;
		var normal=new Vector3();
		var hZIndex=0;
		var hXIndex=0;
		var h=0;
		var zh=0;
		var xh=0;
		for (i=0;i < 2;i++){
			for (j=0;j < s;j++){
				TerrainLeaf.__VECTOR3__.x=(this._beginGridX+j)*this._gridSize;
				TerrainLeaf.__VECTOR3__.y=(i==1 ? terrainHeightData[this._beginGridZ *heighDataWidth+(this._beginGridX+j)] :-this._gridSize);
				TerrainLeaf.__VECTOR3__.z=(this._beginGridZ+0)*this._gridSize;
				if (TerrainLeaf.__ADAPT_MATRIX__){
					Vector3.transformV3ToV3(TerrainLeaf.__VECTOR3__,TerrainLeaf.__ADAPT_MATRIX__,TerrainLeaf.__VECTOR3__);
				}
				vertextBuffer[nNum]=TerrainLeaf.__VECTOR3__.x;
				nNum++;
				vertextBuffer[nNum]=TerrainLeaf.__VECTOR3__.y;
				nNum++;
				vertextBuffer[nNum]=TerrainLeaf.__VECTOR3__.z;
				nNum++;
				if (i==0){
					hZIndex=(this._beginGridZ-1);
					}else {
					hZIndex=this._beginGridZ;
				}
				this.calcVertextNormlUV(this._beginGridX+j,hZIndex,heighDataWidth,heightDataHeight,normal);
				vertextBuffer[nNum]=normal.x;
				nNum++;
				vertextBuffer[nNum]=normal.y;
				nNum++;
				vertextBuffer[nNum]=normal.z;
				nNum++;
				vertextBuffer[nNum]=(beginX+j)/ TerrainLeaf.CHUNK_GRID_NUM;
				nNum++;
				vertextBuffer[nNum]=(beginZ+0)/ TerrainLeaf.CHUNK_GRID_NUM;
				nNum++;
				vertextBuffer[nNum]=this._beginGridX+j;
				nNum++;
				vertextBuffer[nNum]=hZIndex;
				nNum++;
			}
		}
		for (i=0;i < 2;i++){
			for (j=0;j < s;j++){
				TerrainLeaf.__VECTOR3__.x=(this._beginGridX+j)*this._gridSize;
				TerrainLeaf.__VECTOR3__.y=(i==0 ? terrainHeightData[(this._beginGridZ+TerrainLeaf.LEAF_GRID_NUM)*(heighDataWidth)+(this._beginGridX+j)] :-this._gridSize);
				TerrainLeaf.__VECTOR3__.z=(this._beginGridZ+TerrainLeaf.LEAF_GRID_NUM)*this._gridSize;
				if (TerrainLeaf.__ADAPT_MATRIX__){
					Vector3.transformV3ToV3(TerrainLeaf.__VECTOR3__,TerrainLeaf.__ADAPT_MATRIX__,TerrainLeaf.__VECTOR3__);
				}
				vertextBuffer[nNum]=TerrainLeaf.__VECTOR3__.x;
				nNum++;
				vertextBuffer[nNum]=TerrainLeaf.__VECTOR3__.y;
				nNum++;
				vertextBuffer[nNum]=TerrainLeaf.__VECTOR3__.z;
				nNum++;
				if (i==0){
					hZIndex=this._beginGridZ+TerrainLeaf.LEAF_GRID_NUM;
					}else {
					hZIndex=(this._beginGridZ+TerrainLeaf.LEAF_GRID_NUM+1);
				}
				this.calcVertextNormlUV(this._beginGridX+j,hZIndex,heighDataWidth,heightDataHeight,normal);
				vertextBuffer[nNum]=normal.x;
				nNum++;
				vertextBuffer[nNum]=normal.y;
				nNum++;
				vertextBuffer[nNum]=normal.z;
				nNum++;
				vertextBuffer[nNum]=(beginX+j)/ TerrainLeaf.CHUNK_GRID_NUM;
				nNum++;
				vertextBuffer[nNum]=(beginZ+TerrainLeaf.LEAF_GRID_NUM)/ TerrainLeaf.CHUNK_GRID_NUM;
				nNum++;
				vertextBuffer[nNum]=this._beginGridX+j;
				nNum++;
				vertextBuffer[nNum]=hZIndex;
				nNum++;
			}
		}
		for (i=0;i < 2;i++){
			for (j=0;j < s;j++){
				TerrainLeaf.__VECTOR3__.x=(this._beginGridX+0)*this._gridSize;
				TerrainLeaf.__VECTOR3__.y=(i==0 ? terrainHeightData[(this._beginGridZ+j)*(heighDataWidth)+(this._beginGridX+0)] :-this._gridSize);
				TerrainLeaf.__VECTOR3__.z=(this._beginGridZ+j)*this._gridSize;
				if (TerrainLeaf.__ADAPT_MATRIX__){
					Vector3.transformV3ToV3(TerrainLeaf.__VECTOR3__,TerrainLeaf.__ADAPT_MATRIX__,TerrainLeaf.__VECTOR3__);
				}
				vertextBuffer[nNum]=TerrainLeaf.__VECTOR3__.x;
				nNum++;
				vertextBuffer[nNum]=TerrainLeaf.__VECTOR3__.y;
				nNum++;
				vertextBuffer[nNum]=TerrainLeaf.__VECTOR3__.z;
				nNum++;
				if (i==0){
					hXIndex=this._beginGridX;
					}else {
					hXIndex=(this._beginGridX-1);
				}
				this.calcVertextNormlUV(hXIndex,this._beginGridZ+j,heighDataWidth,heightDataHeight,normal);
				vertextBuffer[nNum]=normal.x;
				nNum++;
				vertextBuffer[nNum]=normal.y;
				nNum++;
				vertextBuffer[nNum]=normal.z;
				nNum++;
				vertextBuffer[nNum]=(beginX+0)/ TerrainLeaf.CHUNK_GRID_NUM;
				nNum++;
				vertextBuffer[nNum]=(beginZ+j)/ TerrainLeaf.CHUNK_GRID_NUM;
				nNum++;
				vertextBuffer[nNum]=hXIndex;
				nNum++;
				vertextBuffer[nNum]=this._beginGridZ+j;
				nNum++;
			}
		}
		for (i=0;i < 2;i++){
			for (j=0;j < s;j++){
				TerrainLeaf.__VECTOR3__.x=(this._beginGridX+TerrainLeaf.LEAF_GRID_NUM)*this._gridSize;
				TerrainLeaf.__VECTOR3__.y=(i==1 ? terrainHeightData[(this._beginGridZ+j)*(heighDataWidth)+(this._beginGridX+TerrainLeaf.LEAF_GRID_NUM)] :-this._gridSize);
				TerrainLeaf.__VECTOR3__.z=(this._beginGridZ+j)*this._gridSize;
				if (TerrainLeaf.__ADAPT_MATRIX__){
					Vector3.transformV3ToV3(TerrainLeaf.__VECTOR3__,TerrainLeaf.__ADAPT_MATRIX__,TerrainLeaf.__VECTOR3__);
				}
				vertextBuffer[nNum]=TerrainLeaf.__VECTOR3__.x;
				nNum++;
				vertextBuffer[nNum]=TerrainLeaf.__VECTOR3__.y;
				nNum++;
				vertextBuffer[nNum]=TerrainLeaf.__VECTOR3__.z;
				nNum++;
				if (i==0){
					hXIndex=this._beginGridX+TerrainLeaf.LEAF_GRID_NUM+1;
					}else {
					hXIndex=this._beginGridX+TerrainLeaf.LEAF_GRID_NUM;
				}
				this.calcVertextNormlUV(hXIndex,this._beginGridZ+j,heighDataWidth,heightDataHeight,normal);
				vertextBuffer[nNum]=normal.x;
				nNum++;
				vertextBuffer[nNum]=normal.y;
				nNum++;
				vertextBuffer[nNum]=normal.z;
				nNum++;
				vertextBuffer[nNum]=(beginX+TerrainLeaf.LEAF_GRID_NUM)/ TerrainLeaf.CHUNK_GRID_NUM;
				nNum++;
				vertextBuffer[nNum]=(beginZ+j)/ TerrainLeaf.CHUNK_GRID_NUM;
				nNum++;
				vertextBuffer[nNum]=hXIndex;
				nNum++;
				vertextBuffer[nNum]=this._beginGridZ+j;
				nNum++;
			}
		}
	}

	__proto.calcOriginalBoudingBoxAndSphere=function(){
		var min=new Vector3(this._beginGridX *this._gridSize,this._sizeOfY.x,this._beginGridZ *this._gridSize);
		var max=new Vector3((this._beginGridX+TerrainLeaf.LEAF_GRID_NUM)*this._gridSize,this._sizeOfY.y,(this._beginGridZ+TerrainLeaf.LEAF_GRID_NUM)*this._gridSize);
		if (TerrainLeaf.__ADAPT_MATRIX__){
			Vector3.transformV3ToV3(min,TerrainLeaf.__ADAPT_MATRIX__,min);
			Vector3.transformV3ToV3(max,TerrainLeaf.__ADAPT_MATRIX__,max);
		}
		this._originalBoundingBox=new BoundBox(min,max);
		var size=new Vector3();
		Vector3.subtract(max,min,size);
		Vector3.scale(size,0.5,size);
		var center=new Vector3();
		Vector3.add(min,size,center);
		this._originalBoundingSphere=new BoundSphere(center,Vector3.scalarLength(size));
		this._originalBoundingBoxCorners=__newvec(8,null);
		this._originalBoundingBox.getCorners(this._originalBoundingBoxCorners);
		this._boundingBox=new BoundBox(new Vector3(-0.5,-0.5,-0.5),new Vector3(0.5,0.5,0.5));
		this._boundingSphere=new BoundSphere(new Vector3(0,0,0),1);
	}

	__proto.calcLeafBoudingBox=function(worldMatrix){
		for (var i=0;i < 8;i++){
			Vector3.transformCoordinate(this._originalBoundingBoxCorners[i],worldMatrix,BaseRender._tempBoundBoxCorners[i]);
		}
		BoundBox.createfromPoints(BaseRender._tempBoundBoxCorners,this._boundingBox);
	}

	__proto.calcLeafBoudingSphere=function(worldMatrix,maxScale){
		Vector3.transformCoordinate(this._originalBoundingSphere.center,worldMatrix,this._boundingSphere.center);
		this._boundingSphere.radius=this._originalBoundingSphere.radius *maxScale;
	}

	__proto.calcLODErrors=function(terrainHeightData,heighDataWidth,heightDataHeight){
		this._LODError=new Float32Array(TerrainLeaf._maxLODLevel+1);
		var step=1;
		for (var i=0,n=TerrainLeaf._maxLODLevel+1;i < n;i++){
			var maxError=0;
			for (var y=0,n1=TerrainLeaf.LEAF_GRID_NUM;y < n1;y+=step){
				for (var x=0,n2=TerrainLeaf.LEAF_GRID_NUM;x < n2;x+=step){
					var z00=terrainHeightData[(this._beginGridZ+y)*heighDataWidth+(this._beginGridX+x)];
					var z10=terrainHeightData[(this._beginGridZ+y)*heighDataWidth+(this._beginGridX+x)+step];
					var z01=terrainHeightData[(this._beginGridZ+y+step)*heighDataWidth+(this._beginGridX+x)];
					var z11=terrainHeightData[(this._beginGridZ+y+step)*heighDataWidth+(this._beginGridX+x)+step];
					for (var j=0;j < step;j++){
						var ys=j / step;
						for (var k=0;k < step;k++){
							var xs=k / step;
							var z=terrainHeightData[(this._beginGridZ+y+j)*heighDataWidth+(this._beginGridX+x)+k];
							var iz=(xs+ys <=1)? (z00+(z10-z00)*xs+(z01-z00)*ys):(z11+(z01-z11)*(1-xs)+(z10-z11)*(1-ys));
							var error=Math.abs(iz-z);
							maxError=Math.max(maxError,error);
						}
					}
				}
			}
			step *=2;
			this._LODError[i]=maxError;
		}
	}

	__proto.determineLod=function(eyePos,perspectiveFactor,tolerance,tolerAndPerspectiveChanged){
		var nDistanceToEye=Vector3.distance(eyePos,this._boundingSphere.center);
		var n=TerrainLeaf._maxLODLevel;
		if (!tolerAndPerspectiveChanged){
			if (this._lastDistanceToEye==nDistanceToEye){
				return this._currentLODLevel;
				}else if (this._lastDistanceToEye > nDistanceToEye){
				n=this._currentLODLevel;
			}
		}
		for (var i=n;i >=1;i--){
			if (Terrain.LOD_DISTANCE_FACTOR *this._LODError[i] / nDistanceToEye *perspectiveFactor < tolerance){
				this._currentLODLevel=i;
				break ;
			}
		}
		this._lastDistanceToEye=nDistanceToEye;
		return this._currentLODLevel;
	}

	TerrainLeaf.__init__=function(){
		if (!TerrainLeaf._bInit){
			var nLeafNum=(TerrainLeaf.CHUNK_GRID_NUM / TerrainLeaf.LEAF_GRID_NUM)*(TerrainLeaf.CHUNK_GRID_NUM / TerrainLeaf.LEAF_GRID_NUM);
			TerrainLeaf._planeLODIndex=__newvec(nLeafNum);
			var i=0,j=0,k=0,n=0,n1=0,nOffset=0;
			var nOriginIndexArray=null,nTempIndex=null;
			for (i=0;i < nLeafNum;i++){
				TerrainLeaf._planeLODIndex[i]=new Array(TerrainLeaf._maxLODLevel+1);
			}
			for (i=0,n=TerrainLeaf._maxLODLevel+1;i < n;i++){
				TerrainLeaf._planeLODIndex[0][i]=TerrainLeaf.calcPlaneLODIndex(i);
			}
			for (i=1;i < nLeafNum;i++){
				nOffset=i *TerrainLeaf.LEAF_PLANE_VERTEXT_COUNT;
				for (j=0,n1=TerrainLeaf._maxLODLevel+1;j < n1;j++){
					nOriginIndexArray=TerrainLeaf._planeLODIndex[0][j];
					nTempIndex=new Uint16Array(nOriginIndexArray.length);
					for (k=0;k < nOriginIndexArray.length;k++){
						nTempIndex[k]=nOriginIndexArray[k]+nOffset;
					}
					TerrainLeaf._planeLODIndex[i][j]=nTempIndex;
				}
			}
			TerrainLeaf._skirtLODIndex=__newvec(nLeafNum);
			for (i=0;i < nLeafNum;i++){
				TerrainLeaf._skirtLODIndex[i]=new Array(TerrainLeaf._maxLODLevel+1);
			}
			for (i=0,n=TerrainLeaf._maxLODLevel+1;i < n;i++){
				TerrainLeaf._skirtLODIndex[0][i]=TerrainLeaf.calcSkirtLODIndex(i);
			}
			for (i=1;i < nLeafNum;i++){
				nOffset=i *TerrainLeaf.LEAF_SKIRT_VERTEXT_COUNT;
				for (j=0,n1=TerrainLeaf._maxLODLevel+1;j < n1;j++){
					nOriginIndexArray=TerrainLeaf._skirtLODIndex[0][j];
					nTempIndex=new Uint16Array(nOriginIndexArray.length);
					for (k=0;k < nOriginIndexArray.length;k++){
						nTempIndex[k]=nOriginIndexArray[k]+nOffset;
					}
					TerrainLeaf._skirtLODIndex[i][j]=nTempIndex;
				}
			}
			TerrainLeaf._bInit=true;
		}
	}

	TerrainLeaf.getPlaneLODIndex=function(leafIndex,LODLevel){
		return TerrainLeaf._planeLODIndex[leafIndex][LODLevel];
	}

	TerrainLeaf.getSkirtLODIndex=function(leafIndex,LODLevel){
		return TerrainLeaf._skirtLODIndex[leafIndex][LODLevel];
	}

	TerrainLeaf.calcPlaneLODIndex=function(level){
		if (level > TerrainLeaf._maxLODLevel)level=TerrainLeaf._maxLODLevel;
		var nGridNumAddOne=TerrainLeaf.LEAF_GRID_NUM+1;
		var nNum=0;
		var indexBuffer=null;
		var nLODGridNum=laya.d3.terrain.TerrainLeaf.LEAF_GRID_NUM / Math.pow(2,level);
		indexBuffer=new Uint16Array(nLODGridNum *nLODGridNum *6);
		var nGridSpace=laya.d3.terrain.TerrainLeaf.LEAF_GRID_NUM / nLODGridNum;
		for (var i=0;i < TerrainLeaf.LEAF_GRID_NUM;i+=nGridSpace){
			for (var j=0;j < TerrainLeaf.LEAF_GRID_NUM;j+=nGridSpace){
				indexBuffer[nNum]=(i+nGridSpace)*nGridNumAddOne+j;
				nNum++;
				indexBuffer[nNum]=i *nGridNumAddOne+j;
				nNum++;
				indexBuffer[nNum]=i *nGridNumAddOne+j+nGridSpace;
				nNum++;
				indexBuffer[nNum]=i *nGridNumAddOne+j+nGridSpace;
				nNum++;
				indexBuffer[nNum]=(i+nGridSpace)*nGridNumAddOne+j+nGridSpace;
				nNum++;
				indexBuffer[nNum]=(i+nGridSpace)*nGridNumAddOne+j;
				nNum++;
			}
		}
		return indexBuffer;
	}

	TerrainLeaf.calcSkirtLODIndex=function(level){
		if (level > TerrainLeaf._maxLODLevel)level=TerrainLeaf._maxLODLevel;
		var nSkirtIndexOffset=(TerrainLeaf.CHUNK_GRID_NUM / TerrainLeaf.LEAF_GRID_NUM)*(TerrainLeaf.CHUNK_GRID_NUM / TerrainLeaf.LEAF_GRID_NUM)*TerrainLeaf.LEAF_PLANE_VERTEXT_COUNT;
		var nGridNumAddOne=TerrainLeaf.LEAF_GRID_NUM+1;
		var nNum=0;
		var indexBuffer=null;
		var nLODGridNum=laya.d3.terrain.TerrainLeaf.LEAF_GRID_NUM / Math.pow(2,level);
		indexBuffer=new Uint16Array(nLODGridNum *4 *6);
		var nGridSpace=laya.d3.terrain.TerrainLeaf.LEAF_GRID_NUM / nLODGridNum;
		for (var j=0;j < 4;j++){
			for (var i=0;i < TerrainLeaf.LEAF_GRID_NUM;i+=nGridSpace){
				indexBuffer[nNum]=nSkirtIndexOffset+nGridNumAddOne+i;
				nNum++;
				indexBuffer[nNum]=nSkirtIndexOffset+i;
				nNum++;
				indexBuffer[nNum]=nSkirtIndexOffset+i+nGridSpace;
				nNum++;
				indexBuffer[nNum]=nSkirtIndexOffset+i+nGridSpace;
				nNum++;
				indexBuffer[nNum]=nSkirtIndexOffset+nGridNumAddOne+i+nGridSpace;
				nNum++;
				indexBuffer[nNum]=nSkirtIndexOffset+nGridNumAddOne+i;
				nNum++;
			}
			nSkirtIndexOffset+=nGridNumAddOne *2;
		}
		return indexBuffer;
	}

	TerrainLeaf.getHeightFromTerrainHeightData=function(x,z,terrainHeightData,heighDataWidth,heightDataHeight){
		x=x < 0 ? 0 :x;
		x=(x >=heighDataWidth)? heighDataWidth-1 :x;
		z=z < 0 ? 0 :z;
		z=(z >=heightDataHeight)? heightDataHeight-1 :z;
		return terrainHeightData[z *heighDataWidth+x];
	}

	TerrainLeaf.CHUNK_GRID_NUM=64;
	TerrainLeaf.LEAF_GRID_NUM=32;
	TerrainLeaf.__ADAPT_MATRIX__=null;
	TerrainLeaf.__ADAPT_MATRIX_INV__=null;
	TerrainLeaf._planeLODIndex=null;
	TerrainLeaf._skirtLODIndex=null;
	TerrainLeaf._bInit=false;
	__static(TerrainLeaf,
	['LEAF_PLANE_VERTEXT_COUNT',function(){return this.LEAF_PLANE_VERTEXT_COUNT=(TerrainLeaf.LEAF_GRID_NUM+1)*(TerrainLeaf.LEAF_GRID_NUM+1);},'LEAF_SKIRT_VERTEXT_COUNT',function(){return this.LEAF_SKIRT_VERTEXT_COUNT=(TerrainLeaf.LEAF_GRID_NUM+1)*2 *4;},'LEAF_VERTEXT_COUNT',function(){return this.LEAF_VERTEXT_COUNT=TerrainLeaf.LEAF_PLANE_VERTEXT_COUNT+TerrainLeaf.LEAF_SKIRT_VERTEXT_COUNT;},'LEAF_PLANE_MAX_INDEX_COUNT',function(){return this.LEAF_PLANE_MAX_INDEX_COUNT=TerrainLeaf.LEAF_GRID_NUM *TerrainLeaf.LEAF_GRID_NUM *6;},'LEAF_SKIRT_MAX_INDEX_COUNT',function(){return this.LEAF_SKIRT_MAX_INDEX_COUNT=TerrainLeaf.LEAF_GRID_NUM *4 *6;},'LEAF_MAX_INDEX_COUNT',function(){return this.LEAF_MAX_INDEX_COUNT=TerrainLeaf.LEAF_PLANE_MAX_INDEX_COUNT+TerrainLeaf.LEAF_SKIRT_MAX_INDEX_COUNT;},'__VECTOR3__',function(){return this.__VECTOR3__=new Vector3();},'_maxLODLevel',function(){return this._maxLODLevel=/*__JS__ */Math.log2(TerrainLeaf.LEAF_GRID_NUM);}
	]);
	return TerrainLeaf;
})()


/**
*<code>DetailTextureInfo</code> 类用于描述地形细节纹理。
*/
//class laya.d3.terrain.unit.ChunkInfo
var ChunkInfo=(function(){
	function ChunkInfo(){
		this.alphaMap=null;
		this.detailID=null;
		this.normalMap=null;
		;
	}

	__class(ChunkInfo,'laya.d3.terrain.unit.ChunkInfo');
	return ChunkInfo;
})()


/**
*<code>DetailTextureInfo</code> 类用于描述地形细节纹理。
*/
//class laya.d3.terrain.unit.DetailTextureInfo
var DetailTextureInfo=(function(){
	function DetailTextureInfo(){
		this.diffuseTexture=null;
		this.normalTexture=null;
		this.scale=null;
		this.offset=null;
		;
	}

	__class(DetailTextureInfo,'laya.d3.terrain.unit.DetailTextureInfo');
	return DetailTextureInfo;
})()


/**
*<code>MaterialInfo</code> 类用于描述地形材质信息。
*/
//class laya.d3.terrain.unit.MaterialInfo
var MaterialInfo=(function(){
	function MaterialInfo(){
		this.ambientColor=null;
		this.diffuseColor=null;
		this.specularColor=null;
		;
	}

	__class(MaterialInfo,'laya.d3.terrain.unit.MaterialInfo');
	return MaterialInfo;
})()


/**
*<code>Physics</code> 类用于简单物理检测。
*/
//class laya.d3.utils.Physics
var Physics=(function(){
	/**
	*创建一个 <code>Physics</code> 实例。
	*/
	function Physics(){}
	__class(Physics,'laya.d3.utils.Physics');
	Physics.__init__=function(){
		var maxCount=/*laya.d3.core.Layer.maxCount*/31;
		Physics._layerCollsionMatrix.length=maxCount;
		for (var i=0;i < maxCount;i++){
			var collArray=[];
			var count=maxCount-i;
			collArray.length=count;
			for (var j=0;j < count;j++)
			if (j===count-1)
				collArray[j]=true;
			else
			collArray[j]=false;
			Physics._layerCollsionMatrix[i]=collArray;
		}
	}

	Physics.setLayerCollision=function(layer1,layer2,collison){
		Physics._layerCollsionMatrix[layer1.number][(/*laya.d3.core.Layer.maxCount*/31-1)-layer2.number]=collison;
	}

	Physics.getLayerCollision=function(layer1,layer2){
		return Physics._layerCollsionMatrix[layer1.number][(/*laya.d3.core.Layer.maxCount*/31-1)-layer2.number];
	}

	Physics.setColliderCollision=function(collider1,collider2,collsion){
		if (collsion){
			delete collider1._ignoreCollisonMap[collider2.id];
			delete collider2._ignoreCollisonMap[collider1.id];
			}else {
			collider1._ignoreCollisonMap[collider2.id]=collider2;
			collider2._ignoreCollisonMap[collider1.id]=collider1;
		}
	}

	Physics.getIColliderCollision=function(collider1,collider2){
		return collider1._ignoreCollisonMap[collider2.id] ? true :false;
	}

	Physics.rayCast=function(ray,outHitInfo,distance,layer){
		(distance===void 0)&& (distance=1.79e+308);
		(layer===void 0)&& (layer=0);
		Physics._outHitAllInfo.length=0;
		var colliders=Layer.getLayerByNumber(layer)._colliders;
		for (var i=0,n=colliders.length;i < n;i++){
			var collider=colliders[i];
			if (collider.enable){
				collider.raycast(ray,Physics._outHitInfo,distance);
				if (Physics._outHitInfo.distance!==-1 && Physics._outHitInfo.distance <=distance){
					var outHit=new RaycastHit();
					Physics._outHitInfo.cloneTo(outHit);
					Physics._outHitAllInfo.push(outHit);
				}
			}
		}
		if (Physics._outHitAllInfo.length==0){
			outHitInfo.sprite3D=null;
			outHitInfo.distance=-1;
			return;
		};
		var minDistance=Number.MAX_VALUE;
		var minIndex=0;
		for (var j=0;j < Physics._outHitAllInfo.length;j++){
			if (Physics._outHitAllInfo[j].distance < minDistance){
				minDistance=Physics._outHitAllInfo[j].distance;
				minIndex=j;
			}
		}
		Physics._outHitAllInfo[minIndex].cloneTo(outHitInfo);
	}

	Physics.rayCastAll=function(ray,outHitAllInfo,distance,layer){
		(distance===void 0)&& (distance=1.79e+308);
		(layer===void 0)&& (layer=0);
		outHitAllInfo.length=0;
		var colliders=Layer.getLayerByNumber(layer)._colliders;
		for (var i=0,n=colliders.length;i < n;i++){
			var collider=colliders[i];
			if (collider.enable){
				Physics._outHitInfo.distance=-1;
				Physics._outHitInfo.sprite3D=null;
				collider.raycast(ray,Physics._outHitInfo,distance);
				if (Physics._outHitInfo.distance!==-1 && Physics._outHitInfo.distance <=distance){
					var outHit=new RaycastHit();
					Physics._outHitInfo.cloneTo(outHit);
					outHitAllInfo.push(outHit);
				}
			}
		}
	}

	Physics._outHitAllInfo=[];
	Physics._layerCollsionMatrix=[];
	__static(Physics,
	['_outHitInfo',function(){return this._outHitInfo=new RaycastHit();},'collisionManager',function(){return this.collisionManager=new CollisionManager();},'gravity',function(){return this.gravity=new Vector3(0,-9.81,0);}
	]);
	return Physics;
})()


/**
*<code>Picker</code> 类用于创建拾取。
*/
//class laya.d3.utils.Picker
var Picker=(function(){
	/**
	*创建一个 <code>Picker</code> 实例。
	*/
	function Picker(){}
	__class(Picker,'laya.d3.utils.Picker');
	Picker.calculateCursorRay=function(point,viewPort,projectionMatrix,viewMatrix,world,out){
		var x=point.elements[0];
		var y=point.elements[1];
		var nearSource=Picker._tempVector30;
		var nerSourceE=nearSource.elements;
		nerSourceE[0]=x;
		nerSourceE[1]=y;
		nerSourceE[2]=viewPort.minDepth;
		var farSource=Picker._tempVector31;
		var farSourceE=farSource.elements;
		farSourceE[0]=x;
		farSourceE[1]=y;
		farSourceE[2]=viewPort.maxDepth;
		var nearPoint=out.origin;
		var farPoint=Picker._tempVector32;
		viewPort.unprojectFromWVP(nearSource,projectionMatrix,viewMatrix,world,nearPoint);
		viewPort.unprojectFromWVP(farSource,projectionMatrix,viewMatrix,world,farPoint);
		var outDire=out.direction.elements;
		outDire[0]=farPoint.x-nearPoint.x;
		outDire[1]=farPoint.y-nearPoint.y;
		outDire[2]=farPoint.z-nearPoint.z;
		Vector3.normalize(out.direction,out.direction);
	}

	Picker.rayIntersectsPositionsAndIndices=function(ray,vertexDatas,vertexDeclaration,indices,outHitInfo){
		var vertexStrideFloatCount=vertexDeclaration.vertexStride / 4;
		var positionVertexElementOffset=vertexDeclaration.getVertexElementByUsage(/*laya.d3.graphics.VertexElementUsage.POSITION0*/0).offset / 4;
		var closestIntersection=Number.MAX_VALUE;
		var closestTriangleVertexIndex1=-1;
		var closestTriangleVertexIndex2=-1;
		var closestTriangleVertexIndex3=-1;
		for (var j=0;j < indices.length;j+=3){
			var vertex1=Picker._tempVector35;
			var vertex1E=vertex1.elements;
			var vertex1Index=indices[j] *vertexStrideFloatCount;
			var vertex1PositionIndex=vertex1Index+positionVertexElementOffset;
			vertex1E[0]=vertexDatas[vertex1PositionIndex];
			vertex1E[1]=vertexDatas[vertex1PositionIndex+1];
			vertex1E[2]=vertexDatas[vertex1PositionIndex+2];
			var vertex2=Picker._tempVector36;
			var vertex2E=vertex2.elements;
			var vertex2Index=indices[j+1] *vertexStrideFloatCount;
			var vertex2PositionIndex=vertex2Index+positionVertexElementOffset;
			vertex2E[0]=vertexDatas[vertex2PositionIndex];
			vertex2E[1]=vertexDatas[vertex2PositionIndex+1];
			vertex2E[2]=vertexDatas[vertex2PositionIndex+2];
			var vertex3=Picker._tempVector37;
			var vertex3E=vertex3.elements;
			var vertex3Index=indices[j+2] *vertexStrideFloatCount;
			var vertex3PositionIndex=vertex3Index+positionVertexElementOffset;
			vertex3E[0]=vertexDatas[vertex3PositionIndex];
			vertex3E[1]=vertexDatas[vertex3PositionIndex+1];
			vertex3E[2]=vertexDatas[vertex3PositionIndex+2];
			var intersection=laya.d3.utils.Picker.rayIntersectsTriangle(ray,vertex1,vertex2,vertex3);
			if (!isNaN(intersection)&& intersection < closestIntersection){
				closestIntersection=intersection;
				closestTriangleVertexIndex1=vertex1Index;
				closestTriangleVertexIndex2=vertex2Index;
				closestTriangleVertexIndex3=vertex3Index;
			}
		}
		if (closestIntersection!==Number.MAX_VALUE){
			outHitInfo.distance=closestIntersection;
			Vector3.scale(ray.direction,closestIntersection,outHitInfo.position);
			Vector3.add(ray.origin,outHitInfo.position,outHitInfo.position);
			var trianglePositions=outHitInfo.trianglePositions;
			var position0=trianglePositions[0];
			var position1=trianglePositions[1];
			var position2=trianglePositions[2];
			var position0E=position0.elements;
			var position1E=position1.elements;
			var position2E=position2.elements;
			var closestVertex1PositionIndex=closestTriangleVertexIndex1+positionVertexElementOffset;
			position0E[0]=vertexDatas[closestVertex1PositionIndex];
			position0E[1]=vertexDatas[closestVertex1PositionIndex+1];
			position0E[2]=vertexDatas[closestVertex1PositionIndex+2];
			var closestVertex2PositionIndex=closestTriangleVertexIndex2+positionVertexElementOffset;
			position1E[0]=vertexDatas[closestVertex2PositionIndex];
			position1E[1]=vertexDatas[closestVertex2PositionIndex+1];
			position1E[2]=vertexDatas[closestVertex2PositionIndex+2];
			var closestVertex3PositionIndex=closestTriangleVertexIndex3+positionVertexElementOffset;
			position2E[0]=vertexDatas[closestVertex3PositionIndex];
			position2E[1]=vertexDatas[closestVertex3PositionIndex+1];
			position2E[2]=vertexDatas[closestVertex3PositionIndex+2];
			var normalVertexElement=vertexDeclaration.getVertexElementByUsage(/*laya.d3.graphics.VertexElementUsage.NORMAL0*/3);
			if (normalVertexElement){
				var normalVertexElementOffset=normalVertexElement.offset / 4;
				var triangleNormals=outHitInfo.triangleNormals;
				var normal0=triangleNormals[0];
				var normal1=triangleNormals[1];
				var normal2=triangleNormals[2];
				var normal0E=normal0.elements;
				var normal1E=normal1.elements;
				var normal2E=normal2.elements;
				var closestVertex1NormalIndex=closestTriangleVertexIndex1+normalVertexElementOffset;
				normal0E[0]=vertexDatas[closestVertex1NormalIndex];
				normal0E[1]=vertexDatas[closestVertex1NormalIndex+1];
				normal0E[2]=vertexDatas[closestVertex1NormalIndex+2];
				var closestVertex2NormalIndex=closestTriangleVertexIndex2+normalVertexElementOffset;
				normal1E[0]=vertexDatas[closestVertex2NormalIndex];
				normal1E[1]=vertexDatas[closestVertex2NormalIndex+1];
				normal1E[2]=vertexDatas[closestVertex2NormalIndex+2];
				var closestVertex3NormalIndex=closestTriangleVertexIndex3+normalVertexElementOffset;
				normal2E[0]=vertexDatas[closestVertex3NormalIndex];
				normal2E[1]=vertexDatas[closestVertex3NormalIndex+1];
				normal2E[2]=vertexDatas[closestVertex3NormalIndex+2];
			}
			return true;
			}else {
			outHitInfo.position.toDefault();
			outHitInfo.distance=Number.MAX_VALUE;
			outHitInfo.trianglePositions[0].toDefault();
			outHitInfo.trianglePositions[1].toDefault();
			outHitInfo.trianglePositions[2].toDefault();
			outHitInfo.triangleNormals[0].toDefault();
			outHitInfo.triangleNormals[1].toDefault();
			outHitInfo.triangleNormals[2].toDefault();
			return false;
		}
	}

	Picker.rayIntersectsTriangle=function(ray,vertex1,vertex2,vertex3){
		var result;
		var edge1=Picker._tempVector30,edge2=Picker._tempVector31;
		Vector3.subtract(vertex2,vertex1,edge1);
		Vector3.subtract(vertex3,vertex1,edge2);
		var directionCrossEdge2=Picker._tempVector32;
		Vector3.cross(ray.direction,edge2,directionCrossEdge2);
		var determinant;
		determinant=Vector3.dot(edge1,directionCrossEdge2);
		if (determinant >-Number.MIN_VALUE && determinant < Number.MIN_VALUE){
			result=Number.NaN;
			return result;
		};
		var inverseDeterminant=1.0 / determinant;
		var distanceVector=Picker._tempVector33;
		Vector3.subtract(ray.origin,vertex1,distanceVector);
		var triangleU;
		triangleU=Vector3.dot(distanceVector,directionCrossEdge2);
		triangleU *=inverseDeterminant;
		if (triangleU < 0 || triangleU > 1){
			result=Number.NaN;
			return result;
		};
		var distanceCrossEdge1=Picker._tempVector34;
		Vector3.cross(distanceVector,edge1,distanceCrossEdge1);
		var triangleV;
		triangleV=Vector3.dot(ray.direction,distanceCrossEdge1);
		triangleV *=inverseDeterminant;
		if (triangleV < 0 || triangleU+triangleV > 1){
			result=Number.NaN;
			return result;
		};
		var rayDistance;
		rayDistance=Vector3.dot(edge2,distanceCrossEdge1);
		rayDistance *=inverseDeterminant;
		if (rayDistance < 0){
			result=Number.NaN;
			return result;
		}
		result=rayDistance;
		return result;
	}

	__static(Picker,
	['_tempVector30',function(){return this._tempVector30=new Vector3();},'_tempVector31',function(){return this._tempVector31=new Vector3();},'_tempVector32',function(){return this._tempVector32=new Vector3();},'_tempVector33',function(){return this._tempVector33=new Vector3();},'_tempVector34',function(){return this._tempVector34=new Vector3();},'_tempVector35',function(){return this._tempVector35=new Vector3();},'_tempVector36',function(){return this._tempVector36=new Vector3();},'_tempVector37',function(){return this._tempVector37=new Vector3();}
	]);
	return Picker;
})()


/**
*...
*@author ...
*/
//class laya.d3.utils.RaycastHit
var RaycastHit=(function(){
	function RaycastHit(){
		this.distance=NaN;
		this.trianglePositions=null;
		this.triangleNormals=null;
		this.position=null;
		this.sprite3D=null;
		this.distance=-1;
		this.trianglePositions=[new Vector3(),new Vector3(),new Vector3()];
		this.trianglePositions.length=3;
		this.triangleNormals=[new Vector3(),new Vector3(),new Vector3()];
		this.triangleNormals.length=3;
		this.position=new Vector3();
	}

	__class(RaycastHit,'laya.d3.utils.RaycastHit');
	var __proto=RaycastHit.prototype;
	__proto.cloneTo=function(dec){
		dec.distance=this.distance;
		this.trianglePositions[0].cloneTo(dec.trianglePositions[0]);
		this.trianglePositions[1].cloneTo(dec.trianglePositions[1]);
		this.trianglePositions[2].cloneTo(dec.trianglePositions[2]);
		this.triangleNormals[0].cloneTo(dec.triangleNormals[0]);
		this.triangleNormals[1].cloneTo(dec.triangleNormals[1]);
		this.triangleNormals[2].cloneTo(dec.triangleNormals[2]);
		this.position.cloneTo(dec.position);
		dec.sprite3D=this.sprite3D;
	}

	return RaycastHit;
})()


//class laya.d3.utils.Size
var Size=(function(){
	function Size(width,height){
		this._width=0;
		this._height=0;
		this._width=width;
		this._height=height;
	}

	__class(Size,'laya.d3.utils.Size');
	var __proto=Size.prototype;
	__getset(0,__proto,'width',function(){
		if (this._width===-1)
			return RenderState.clientWidth;
		return this._width;
	});

	__getset(0,__proto,'height',function(){
		if (this._height===-1)
			return RenderState.clientHeight;
		return this._height;
	});

	__getset(1,Size,'fullScreen',function(){
		return new Size(-1,-1);
	});

	return Size;
})()


/**
*<code>Utils3D</code> 类用于创建3D工具。
*/
//class laya.d3.utils.Utils3D
var Utils3D=(function(){
	function Utils3D(){}
	__class(Utils3D,'laya.d3.utils.Utils3D');
	Utils3D._rotationTransformScaleSkinAnimation=function(tx,ty,tz,qx,qy,qz,qw,sx,sy,sz,outArray,outOffset){
		var re=Utils3D._tempArray16_0;
		var se=Utils3D._tempArray16_1;
		var tse=Utils3D._tempArray16_2;
		var x2=qx+qx;
		var y2=qy+qy;
		var z2=qz+qz;
		var xx=qx *x2;
		var yx=qy *x2;
		var yy=qy *y2;
		var zx=qz *x2;
		var zy=qz *y2;
		var zz=qz *z2;
		var wx=qw *x2;
		var wy=qw *y2;
		var wz=qw *z2;
		re[15]=1;
		re[0]=1-yy-zz;
		re[1]=yx+wz;
		re[2]=zx-wy;
		re[4]=yx-wz;
		re[5]=1-xx-zz;
		re[6]=zy+wx;
		re[8]=zx+wy;
		re[9]=zy-wx;
		re[10]=1-xx-yy;
		se[15]=1;
		se[0]=sx;
		se[5]=sy;
		se[10]=sz;
		var i,a,b,e,ai0,ai1,ai2,ai3;
		for (i=0;i < 4;i++){
			ai0=re[i];
			ai1=re[i+4];
			ai2=re[i+8];
			ai3=re[i+12];
			tse[i]=ai0;
			tse[i+4]=ai1;
			tse[i+8]=ai2;
			tse[i+12]=ai0 *tx+ai1 *ty+ai2 *tz+ai3;
		}
		for (i=0;i < 4;i++){
			ai0=tse[i];
			ai1=tse[i+4];
			ai2=tse[i+8];
			ai3=tse[i+12];
			outArray[i+outOffset]=ai0 *se[0]+ai1 *se[1]+ai2 *se[2]+ai3 *se[3];
			outArray[i+outOffset+4]=ai0 *se[4]+ai1 *se[5]+ai2 *se[6]+ai3 *se[7];
			outArray[i+outOffset+8]=ai0 *se[8]+ai1 *se[9]+ai2 *se[10]+ai3 *se[11];
			outArray[i+outOffset+12]=ai0 *se[12]+ai1 *se[13]+ai2 *se[14]+ai3 *se[15];
		}
	}

	Utils3D._createNodeByJson=function(rootNode,nodeData,node,innerResouMap){
		if (!node){
			switch (nodeData.type){
				case "Sprite3D":
					node=new Sprite3D();
					break ;
				case "MeshSprite3D":
					node=new MeshSprite3D();
					break ;
				case "SkinnedMeshSprite3D":
					node=new SkinnedMeshSprite3D();
					break ;
				case "ShuriKenParticle3D":
					node=new ShuriKenParticle3D();
					break ;
				case "TrailSprite3D":
					node=new TrailSprite3D();
					break ;
					break ;
				case "Terrain":
					node=new Terrain();
					break ;
				case "Camera":
					node=new Camera();
					break ;
				case "DirectionLight":
					node=new DirectionLight();
					break ;
				default :
					throw new Error("Utils3D:unidentified class type in (.lh) file.");
				}
		};
		var props=nodeData.props;
		if (props)
			for (var key in props)
		node[key]=props[key];
		var customProps=nodeData.customProps;
		if (customProps){
			if ((node instanceof laya.d3.core.Sprite3D )){
				node._parseBaseCustomProps(customProps);
				node._parseCustomProps(rootNode,innerResouMap,customProps,nodeData);
				node._parseCustomComponent(rootNode,innerResouMap,nodeData.components);
				}else {
				node._parseCustomProps(rootNode,innerResouMap,customProps,nodeData);
			}
		};
		var childData=nodeData.child;
		if (childData){
			for (var i=0,n=childData.length;i < n;i++){
				var child=Utils3D._createNodeByJson(rootNode,childData[i],null,innerResouMap)
				node.addChild(child);
			}
		}
		return node;
	}

	Utils3D._computeBoneAndAnimationDatasByBindPoseMatrxix=function(bones,curData,inverGlobalBindPose,outBonesDatas,outAnimationDatas,boneIndexToMesh){
		var offset=0;
		var matOffset=0;
		var i;
		var parentOffset;
		var boneLength=bones.length;
		for (i=0;i < boneLength;offset+=bones[i].keyframeWidth,matOffset+=16,i++){
			laya.d3.utils.Utils3D._rotationTransformScaleSkinAnimation(curData[offset+0],curData[offset+1],curData[offset+2],curData[offset+3],curData[offset+4],curData[offset+5],curData[offset+6],curData[offset+7],curData[offset+8],curData[offset+9],outBonesDatas,matOffset);
			if (i !=0){
				parentOffset=bones[i].parentIndex *16;
				laya.d3.utils.Utils3D.mulMatrixByArray(outBonesDatas,parentOffset,outBonesDatas,matOffset,outBonesDatas,matOffset);
			}
		};
		var n=inverGlobalBindPose.length;
		for (i=0;i < n;i++){
			laya.d3.utils.Utils3D.mulMatrixByArrayAndMatrixFast(outBonesDatas,boneIndexToMesh[i] *16,inverGlobalBindPose[i],outAnimationDatas,i *16);
		}
	}

	Utils3D._computeAnimationDatasByArrayAndMatrixFast=function(inverGlobalBindPose,bonesDatas,outAnimationDatas,boneIndexToMesh){
		for (var i=0,n=inverGlobalBindPose.length;i < n;i++)
		laya.d3.utils.Utils3D.mulMatrixByArrayAndMatrixFast(bonesDatas,boneIndexToMesh[i] *16,inverGlobalBindPose[i],outAnimationDatas,i *16);
	}

	Utils3D._computeBoneAndAnimationDatasByBindPoseMatrxixOld=function(bones,curData,inverGlobalBindPose,outBonesDatas,outAnimationDatas){
		var offset=0;
		var matOffset=0;
		var i;
		var parentOffset;
		var boneLength=bones.length;
		for (i=0;i < boneLength;offset+=bones[i].keyframeWidth,matOffset+=16,i++){
			laya.d3.utils.Utils3D._rotationTransformScaleSkinAnimation(curData[offset+7],curData[offset+8],curData[offset+9],curData[offset+3],curData[offset+4],curData[offset+5],curData[offset+6],curData[offset+0],curData[offset+1],curData[offset+2],outBonesDatas,matOffset);
			if (i !=0){
				parentOffset=bones[i].parentIndex *16;
				laya.d3.utils.Utils3D.mulMatrixByArray(outBonesDatas,parentOffset,outBonesDatas,matOffset,outBonesDatas,matOffset);
			}
		};
		var n=inverGlobalBindPose.length;
		for (i=0;i < n;i++){
			var arrayOffset=i *16;
			laya.d3.utils.Utils3D.mulMatrixByArrayAndMatrixFast(outBonesDatas,arrayOffset,inverGlobalBindPose[i],outAnimationDatas,arrayOffset);
		}
	}

	Utils3D._computeAnimationDatasByArrayAndMatrixFastOld=function(inverGlobalBindPose,bonesDatas,outAnimationDatas){
		var n=inverGlobalBindPose.length;
		for (var i=0;i < n;i++){
			var arrayOffset=i *16;
			laya.d3.utils.Utils3D.mulMatrixByArrayAndMatrixFast(bonesDatas,arrayOffset,inverGlobalBindPose[i],outAnimationDatas,arrayOffset);
		}
	}

	Utils3D._computeRootAnimationData=function(bones,curData,animationDatas){
		for (var i=0,offset=0,matOffset=0,boneLength=bones.length;i < boneLength;offset+=bones[i].keyframeWidth,matOffset+=16,i++)
		laya.d3.utils.Utils3D.createAffineTransformationArray(curData[offset+0],curData[offset+1],curData[offset+2],curData[offset+3],curData[offset+4],curData[offset+5],curData[offset+6],curData[offset+7],curData[offset+8],curData[offset+9],animationDatas,matOffset);
	}

	Utils3D.transformVector3ArrayByQuat=function(sourceArray,sourceOffset,rotation,outArray,outOffset){
		var re=rotation.elements;
		var x=sourceArray[sourceOffset],y=sourceArray[sourceOffset+1],z=sourceArray[sourceOffset+2],qx=re[0],qy=re[1],qz=re[2],qw=re[3],ix=qw *x+qy *z-qz *y,iy=qw *y+qz *x-qx *z,iz=qw *z+qx *y-qy *x,iw=-qx *x-qy *y-qz *z;
		outArray[outOffset]=ix *qw+iw *-qx+iy *-qz-iz *-qy;
		outArray[outOffset+1]=iy *qw+iw *-qy+iz *-qx-ix *-qz;
		outArray[outOffset+2]=iz *qw+iw *-qz+ix *-qy-iy *-qx;
	}

	Utils3D.mulMatrixByArray=function(leftArray,leftOffset,rightArray,rightOffset,outArray,outOffset){
		var i,ai0,ai1,ai2,ai3;
		if (outArray===rightArray){
			rightArray=Utils3D._tempArray16_3;
			for (i=0;i < 16;++i){
				rightArray[i]=outArray[outOffset+i];
			}
			rightOffset=0;
		}
		for (i=0;i < 4;i++){
			ai0=leftArray[leftOffset+i];
			ai1=leftArray[leftOffset+i+4];
			ai2=leftArray[leftOffset+i+8];
			ai3=leftArray[leftOffset+i+12];
			outArray[outOffset+i]=ai0 *rightArray[rightOffset+0]+ai1 *rightArray[rightOffset+1]+ai2 *rightArray[rightOffset+2]+ai3 *rightArray[rightOffset+3];
			outArray[outOffset+i+4]=ai0 *rightArray[rightOffset+4]+ai1 *rightArray[rightOffset+5]+ai2 *rightArray[rightOffset+6]+ai3 *rightArray[rightOffset+7];
			outArray[outOffset+i+8]=ai0 *rightArray[rightOffset+8]+ai1 *rightArray[rightOffset+9]+ai2 *rightArray[rightOffset+10]+ai3 *rightArray[rightOffset+11];
			outArray[outOffset+i+12]=ai0 *rightArray[rightOffset+12]+ai1 *rightArray[rightOffset+13]+ai2 *rightArray[rightOffset+14]+ai3 *rightArray[rightOffset+15];
		}
	}

	Utils3D.mulMatrixByArrayFast=function(leftArray,leftOffset,rightArray,rightOffset,outArray,outOffset){
		var i,ai0,ai1,ai2,ai3;
		for (i=0;i < 4;i++){
			ai0=leftArray[leftOffset+i];
			ai1=leftArray[leftOffset+i+4];
			ai2=leftArray[leftOffset+i+8];
			ai3=leftArray[leftOffset+i+12];
			outArray[outOffset+i]=ai0 *rightArray[rightOffset+0]+ai1 *rightArray[rightOffset+1]+ai2 *rightArray[rightOffset+2]+ai3 *rightArray[rightOffset+3];
			outArray[outOffset+i+4]=ai0 *rightArray[rightOffset+4]+ai1 *rightArray[rightOffset+5]+ai2 *rightArray[rightOffset+6]+ai3 *rightArray[rightOffset+7];
			outArray[outOffset+i+8]=ai0 *rightArray[rightOffset+8]+ai1 *rightArray[rightOffset+9]+ai2 *rightArray[rightOffset+10]+ai3 *rightArray[rightOffset+11];
			outArray[outOffset+i+12]=ai0 *rightArray[rightOffset+12]+ai1 *rightArray[rightOffset+13]+ai2 *rightArray[rightOffset+14]+ai3 *rightArray[rightOffset+15];
		}
	}

	Utils3D.mulMatrixByArrayAndMatrixFast=function(leftArray,leftOffset,rightMatrix,outArray,outOffset){
		var i,ai0,ai1,ai2,ai3;
		var rightMatrixE=rightMatrix.elements;
		var m11=rightMatrixE[0],m12=rightMatrixE[1],m13=rightMatrixE[2],m14=rightMatrixE[3];
		var m21=rightMatrixE[4],m22=rightMatrixE[5],m23=rightMatrixE[6],m24=rightMatrixE[7];
		var m31=rightMatrixE[8],m32=rightMatrixE[9],m33=rightMatrixE[10],m34=rightMatrixE[11];
		var m41=rightMatrixE[12],m42=rightMatrixE[13],m43=rightMatrixE[14],m44=rightMatrixE[15];
		var ai0LeftOffset=leftOffset;
		var ai1LeftOffset=leftOffset+4;
		var ai2LeftOffset=leftOffset+8;
		var ai3LeftOffset=leftOffset+12;
		var ai0OutOffset=outOffset;
		var ai1OutOffset=outOffset+4;
		var ai2OutOffset=outOffset+8;
		var ai3OutOffset=outOffset+12;
		for (i=0;i < 4;i++){
			ai0=leftArray[ai0LeftOffset+i];
			ai1=leftArray[ai1LeftOffset+i];
			ai2=leftArray[ai2LeftOffset+i];
			ai3=leftArray[ai3LeftOffset+i];
			outArray[ai0OutOffset+i]=ai0 *m11+ai1 *m12+ai2 *m13+ai3 *m14;
			outArray[ai1OutOffset+i]=ai0 *m21+ai1 *m22+ai2 *m23+ai3 *m24;
			outArray[ai2OutOffset+i]=ai0 *m31+ai1 *m32+ai2 *m33+ai3 *m34;
			outArray[ai3OutOffset+i]=ai0 *m41+ai1 *m42+ai2 *m43+ai3 *m44;
		}
	}

	Utils3D.createAffineTransformationArray=function(tX,tY,tZ,rX,rY,rZ,rW,sX,sY,sZ,outArray,outOffset){
		var x2=rX+rX,y2=rY+rY,z2=rZ+rZ;
		var xx=rX *x2,xy=rX *y2,xz=rX *z2,yy=rY *y2,yz=rY *z2,zz=rZ *z2;
		var wx=rW *x2,wy=rW *y2,wz=rW *z2;
		outArray[outOffset+0]=(1-(yy+zz))*sX;
		outArray[outOffset+1]=(xy+wz)*sX;
		outArray[outOffset+2]=(xz-wy)*sX;
		outArray[outOffset+3]=0;
		outArray[outOffset+4]=(xy-wz)*sY;
		outArray[outOffset+5]=(1-(xx+zz))*sY;
		outArray[outOffset+6]=(yz+wx)*sY;
		outArray[outOffset+7]=0;
		outArray[outOffset+8]=(xz+wy)*sZ;
		outArray[outOffset+9]=(yz-wx)*sZ;
		outArray[outOffset+10]=(1-(xx+yy))*sZ;
		outArray[outOffset+11]=0;
		outArray[outOffset+12]=tX;
		outArray[outOffset+13]=tY;
		outArray[outOffset+14]=tZ;
		outArray[outOffset+15]=1;
	}

	Utils3D.transformVector3ArrayToVector3ArrayCoordinate=function(source,sourceOffset,transform,result,resultOffset){
		var vectorElem=Utils3D._tempArray4_0;
		var coordinateX=source[sourceOffset+0];
		var coordinateY=source[sourceOffset+1];
		var coordinateZ=source[sourceOffset+2];
		var transformElem=transform.elements;
		vectorElem[0]=(coordinateX *transformElem[0])+(coordinateY *transformElem[4])+(coordinateZ *transformElem[8])+transformElem[12];
		vectorElem[1]=(coordinateX *transformElem[1])+(coordinateY *transformElem[5])+(coordinateZ *transformElem[9])+transformElem[13];
		vectorElem[2]=(coordinateX *transformElem[2])+(coordinateY *transformElem[6])+(coordinateZ *transformElem[10])+transformElem[14];
		vectorElem[3]=1.0 / ((coordinateX *transformElem[3])+(coordinateY *transformElem[7])+(coordinateZ *transformElem[11])+transformElem[15]);
		result[resultOffset+0]=vectorElem[0] *vectorElem[3];
		result[resultOffset+1]=vectorElem[1] *vectorElem[3];
		result[resultOffset+2]=vectorElem[2] *vectorElem[3];
	}

	Utils3D.transformLightingMapTexcoordByUV0Array=function(source,sourceOffset,lightingMapScaleOffset,result,resultOffset){
		var lightingMapScaleOffsetE=lightingMapScaleOffset.elements;
		result[resultOffset+0]=source[sourceOffset+0] *lightingMapScaleOffsetE[0]+lightingMapScaleOffsetE[2];
		result[resultOffset+1]=(source[sourceOffset+1]-1.0)*lightingMapScaleOffsetE[1]+lightingMapScaleOffsetE[3];
	}

	Utils3D.transformLightingMapTexcoordByUV1Array=function(source,sourceOffset,lightingMapScaleOffset,result,resultOffset){
		var lightingMapScaleOffsetE=lightingMapScaleOffset.elements;
		result[resultOffset+0]=source[sourceOffset+0] *lightingMapScaleOffsetE[0]+lightingMapScaleOffsetE[2];
		result[resultOffset+1]=1.0+source[sourceOffset+1] *lightingMapScaleOffsetE[1]+lightingMapScaleOffsetE[3];
	}

	Utils3D.getURLVerion=function(url){
		var index=url.indexOf("?");
		return index >=0 ? url.substr(index):null;
	}

	Utils3D._quaternionCreateFromYawPitchRollArray=function(yaw,pitch,roll,out){
		var halfRoll=roll *0.5;
		var halfPitch=pitch *0.5;
		var halfYaw=yaw *0.5;
		var sinRoll=Math.sin(halfRoll);
		var cosRoll=Math.cos(halfRoll);
		var sinPitch=Math.sin(halfPitch);
		var cosPitch=Math.cos(halfPitch);
		var sinYaw=Math.sin(halfYaw);
		var cosYaw=Math.cos(halfYaw);
		out[0]=(cosYaw *sinPitch *cosRoll)+(sinYaw *cosPitch *sinRoll);
		out[1]=(sinYaw *cosPitch *cosRoll)-(cosYaw *sinPitch *sinRoll);
		out[2]=(cosYaw *cosPitch *sinRoll)-(sinYaw *sinPitch *cosRoll);
		out[3]=(cosYaw *cosPitch *cosRoll)+(sinYaw *sinPitch *sinRoll);
	}

	Utils3D._createAffineTransformationArray=function(trans,rot,scale,outE){
		var x=rot[0],y=rot[1],z=rot[2],w=rot[3],x2=x+x,y2=y+y,z2=z+z;
		var xx=x *x2,xy=x *y2,xz=x *z2,yy=y *y2,yz=y *z2,zz=z *z2;
		var wx=w *x2,wy=w *y2,wz=w *z2,sx=scale[0],sy=scale[1],sz=scale[2];
		outE[0]=(1-(yy+zz))*sx;
		outE[1]=(xy+wz)*sx;
		outE[2]=(xz-wy)*sx;
		outE[3]=0;
		outE[4]=(xy-wz)*sy;
		outE[5]=(1-(xx+zz))*sy;
		outE[6]=(yz+wx)*sy;
		outE[7]=0;
		outE[8]=(xz+wy)*sz;
		outE[9]=(yz-wx)*sz;
		outE[10]=(1-(xx+yy))*sz;
		outE[11]=0;
		outE[12]=trans[0];
		outE[13]=trans[1];
		outE[14]=trans[2];
		outE[15]=1;
	}

	Utils3D._mulMatrixArray=function(leftMatrixE,rightMatrix,outArray,outOffset){
		var i,ai0,ai1,ai2,ai3;
		var rightMatrixE=rightMatrix.elements;
		var m11=rightMatrixE[0],m12=rightMatrixE[1],m13=rightMatrixE[2],m14=rightMatrixE[3];
		var m21=rightMatrixE[4],m22=rightMatrixE[5],m23=rightMatrixE[6],m24=rightMatrixE[7];
		var m31=rightMatrixE[8],m32=rightMatrixE[9],m33=rightMatrixE[10],m34=rightMatrixE[11];
		var m41=rightMatrixE[12],m42=rightMatrixE[13],m43=rightMatrixE[14],m44=rightMatrixE[15];
		var ai0OutOffset=outOffset;
		var ai1OutOffset=outOffset+4;
		var ai2OutOffset=outOffset+8;
		var ai3OutOffset=outOffset+12;
		for (i=0;i < 4;i++){
			ai0=leftMatrixE[i];
			ai1=leftMatrixE[i+4];
			ai2=leftMatrixE[i+8];
			ai3=leftMatrixE[i+12];
			outArray[ai0OutOffset+i]=ai0 *m11+ai1 *m12+ai2 *m13+ai3 *m14;
			outArray[ai1OutOffset+i]=ai0 *m21+ai1 *m22+ai2 *m23+ai3 *m24;
			outArray[ai2OutOffset+i]=ai0 *m31+ai1 *m32+ai2 *m33+ai3 *m34;
			outArray[ai3OutOffset+i]=ai0 *m41+ai1 *m42+ai2 *m43+ai3 *m44;
		}
	}

	Utils3D.getYawPitchRoll=function(quaternion,out){
		Utils3D.transformQuat(Vector3.ForwardRH,quaternion,Quaternion.TEMPVector31);
		Utils3D.transformQuat(Vector3.Up,quaternion,Quaternion.TEMPVector32);
		var upe=Quaternion.TEMPVector32.elements;
		Utils3D.angleTo(Vector3.ZERO,Quaternion.TEMPVector31,Quaternion.TEMPVector33);
		var anglee=Quaternion.TEMPVector33.elements;
		if (anglee[0]==Math.PI / 2){
			anglee[1]=Utils3D.arcTanAngle(upe[2],upe[0]);
			anglee[2]=0;
			}else if (anglee[0]==-Math.PI / 2){
			anglee[1]=Utils3D.arcTanAngle(-upe[2],-upe[0]);
			anglee[2]=0;
			}else {
			Matrix4x4.createRotationY(-anglee[1],Quaternion.TEMPMatrix0);
			Matrix4x4.createRotationX(-anglee[0],Quaternion.TEMPMatrix1);
			Vector3.transformCoordinate(Quaternion.TEMPVector32,Quaternion.TEMPMatrix0,Quaternion.TEMPVector32);
			Vector3.transformCoordinate(Quaternion.TEMPVector32,Quaternion.TEMPMatrix1,Quaternion.TEMPVector32);
			anglee[2]=Utils3D.arcTanAngle(upe[1],-upe[0]);
		}
		if (anglee[1] <=-Math.PI)
			anglee[1]=Math.PI;
		if (anglee[2] <=-Math.PI)
			anglee[2]=Math.PI;
		if (anglee[1] >=Math.PI && anglee[2] >=Math.PI){
			anglee[1]=0;
			anglee[2]=0;
			anglee[0]=Math.PI-anglee[0];
		}
		out[0]=anglee[1];
		out[1]=anglee[0];
		out[2]=anglee[2];
	}

	Utils3D.arcTanAngle=function(x,y){
		if (x==0){
			if (y==1)
				return Math.PI / 2;
			return-Math.PI / 2;
		}
		if (x > 0)
			return Math.atan(y / x);
		if (x < 0){
			if (y > 0)
				return Math.atan(y / x)+Math.PI;
			return Math.atan(y / x)-Math.PI;
		}
		return 0;
	}

	Utils3D.angleTo=function(from,location,angle){
		Vector3.subtract(location,from,Quaternion.TEMPVector30);
		Vector3.normalize(Quaternion.TEMPVector30,Quaternion.TEMPVector30);
		angle.elements[0]=Math.asin(Quaternion.TEMPVector30.y);
		angle.elements[1]=Utils3D.arcTanAngle(-Quaternion.TEMPVector30.z,-Quaternion.TEMPVector30.x);
	}

	Utils3D.transformQuat=function(source,rotation,out){
		var destination=out.elements;
		var se=source.elements;
		var re=rotation;
		var x=se[0],y=se[1],z=se[2],qx=re[0],qy=re[1],qz=re[2],qw=re[3],
		ix=qw *x+qy *z-qz *y,iy=qw *y+qz *x-qx *z,iz=qw *z+qx *y-qy *x,iw=-qx *x-qy *y-qz *z;
		destination[0]=ix *qw+iw *-qx+iy *-qz-iz *-qy;
		destination[1]=iy *qw+iw *-qy+iz *-qx-ix *-qz;
		destination[2]=iz *qw+iw *-qz+ix *-qy-iy *-qx;
	}

	Utils3D.quaterionNormalize=function(f,e){
		var x=f[0],y=f[1],z=f[2],w=f[3];
		var len=x *x+y *y+z *z+w *w;
		if (len > 0){
			len=1 / Math.sqrt(len);
			e[0]=x *len;
			e[1]=y *len;
			e[2]=z *len;
			e[3]=w *len;
		}
	}

	Utils3D.matrix4x4MultiplyFFF=function(a,b,e){
		var i,ai0,ai1,ai2,ai3;
		if (e===b){
			b=new Float32Array(16);
			for (i=0;i < 16;++i){
				b[i]=e[i];
			}
		}
		for (i=0;i < 4;i++){
			ai0=a[i];
			ai1=a[i+4];
			ai2=a[i+8];
			ai3=a[i+12];
			e[i]=ai0 *b[0]+ai1 *b[1]+ai2 *b[2]+ai3 *b[3];
			e[i+4]=ai0 *b[4]+ai1 *b[5]+ai2 *b[6]+ai3 *b[7];
			e[i+8]=ai0 *b[8]+ai1 *b[9]+ai2 *b[10]+ai3 *b[11];
			e[i+12]=ai0 *b[12]+ai1 *b[13]+ai2 *b[14]+ai3 *b[15];
		}
	}

	Utils3D.matrix4x4MultiplyMFM=function(left,right,out){
		Utils3D.matrix4x4MultiplyFFF(left.elements,right,out.elements);
	}

	Utils3D._tempVector3_0=new Vector3();
	Utils3D._tempVector3_1=new Vector3();
	Utils3D._tempVector3_2=new Vector3();
	Utils3D._tempVector3_3=new Vector3();
	Utils3D._tempVector3_4=new Vector3();
	Utils3D._tempVector3_5=new Vector3();
	Utils3D._tempVector3_6=new Vector3();
	Utils3D._tempArray4_0=new Float32Array(4);
	Utils3D._tempArray16_0=new Float32Array(16);
	Utils3D._tempArray16_1=new Float32Array(16);
	Utils3D._tempArray16_2=new Float32Array(16);
	Utils3D._tempArray16_3=new Float32Array(16);
	__static(Utils3D,
	['_typeToFunO',function(){return this._typeToFunO={"INT16":"writeInt16","SHORT":"writeInt16","UINT16":"writeUint16","UINT32":"writeUint32","FLOAT32":"writeFloat32","INT":"writeInt32","UINT":"writeUint32","BYTE":"writeByte","STRING":"writeUTFString"};}
	]);
	return Utils3D;
})()


/**
*<code>Laya3D</code> 类用于初始化3D设置。
*/
//class Laya3D
var Laya3D=(function(){
	/**
	*创建一个 <code>Laya3D</code> 实例。
	*/
	function Laya3D(){}
	__class(Laya3D,'Laya3D');
	Laya3D._cancelLoadByUrl=function(url){
		Laya.loader.cancelLoadByUrl(url);
		Laya3D._innerFirstLevelLoaderManager.cancelLoadByUrl(url);
		Laya3D._innerSecondLevelLoaderManager.cancelLoadByUrl(url);
		Laya3D._innerThirdLevelLoaderManager.cancelLoadByUrl(url);
		Laya3D._innerFourthLevelLoaderManager.cancelLoadByUrl(url);
	}

	Laya3D._changeWebGLSize=function(width,height){
		WebGL.onStageResize(width,height);
		RenderState.clientWidth=width;
		RenderState.clientHeight=height;
	}

	Laya3D.__init__=function(){
		var createMap=LoaderManager.createMap;
		createMap["lh"]=[Sprite3D,/*CLASS CONST:Laya3D.HIERARCHY*/"SPRITE3DHIERARCHY"];
		createMap["ls"]=[Scene,/*CLASS CONST:Laya3D.HIERARCHY*/"SPRITE3DHIERARCHY"];
		createMap["lm"]=[Mesh,/*CLASS CONST:Laya3D.MESH*/"MESH"];
		createMap["lmat"]=[StandardMaterial,/*CLASS CONST:Laya3D.MATERIAL*/"MATERIAL"];
		createMap["lpbr"]=[PBRMaterial,/*CLASS CONST:Laya3D.MATERIAL*/"MATERIAL"];
		createMap["ltc"]=[TextureCube,/*CLASS CONST:Laya3D.TEXTURECUBE*/"TEXTURECUBE"];
		createMap["jpg"]=[Texture2D,"nativeimage"];
		createMap["jpeg"]=[Texture2D,"nativeimage"];
		createMap["png"]=[Texture2D,"nativeimage"];
		createMap["pkm"]=[Texture2D,/*laya.net.Loader.BUFFER*/"arraybuffer"];
		createMap["lsani"]=[AnimationTemplet,/*laya.net.Loader.BUFFER*/"arraybuffer"];
		createMap["lrani"]=[AnimationTemplet,/*laya.net.Loader.BUFFER*/"arraybuffer"];
		createMap["raw"]=[DataTexture2D,/*laya.net.Loader.BUFFER*/"arraybuffer"];
		createMap["mipmaps"]=[DataTexture2D,/*laya.net.Loader.BUFFER*/"arraybuffer"];
		createMap["thdata"]=[TerrainHeightData,/*laya.net.Loader.BUFFER*/"arraybuffer"];
		createMap["lt"]=[TerrainRes,/*CLASS CONST:Laya3D.TERRAIN*/"TERRAIN"];
		createMap["lani"]=[AnimationClip,/*laya.net.Loader.BUFFER*/"arraybuffer"];
		createMap["lav"]=[Avatar,/*laya.net.Loader.JSON*/"json"];
		createMap["ani"]=[AnimationTemplet,/*laya.net.Loader.BUFFER*/"arraybuffer"];
		Loader.parserMap[ /*CLASS CONST:Laya3D.HIERARCHY*/"SPRITE3DHIERARCHY"]=Laya3D._loadHierarchy;
		Loader.parserMap[ /*CLASS CONST:Laya3D.MESH*/"MESH"]=Laya3D._loadMesh;
		Loader.parserMap[ /*CLASS CONST:Laya3D.MATERIAL*/"MATERIAL"]=Laya3D._loadMaterial;
		Loader.parserMap[ /*CLASS CONST:Laya3D.TEXTURECUBE*/"TEXTURECUBE"]=Laya3D._loadTextureCube;
		Loader.parserMap[ /*CLASS CONST:Laya3D.TERRAIN*/"TERRAIN"]=Laya3D._loadTerrain;
		Laya3D._innerFirstLevelLoaderManager.on(/*laya.events.Event.ERROR*/"error",null,Laya3D._eventLoadManagerError);
		Laya3D._innerSecondLevelLoaderManager.on(/*laya.events.Event.ERROR*/"error",null,Laya3D._eventLoadManagerError);
		Laya3D._innerThirdLevelLoaderManager.on(/*laya.events.Event.ERROR*/"error",null,Laya3D._eventLoadManagerError);
		Laya3D._innerFourthLevelLoaderManager.on(/*laya.events.Event.ERROR*/"error",null,Laya3D._eventLoadManagerError);
	}

	Laya3D.READ_BLOCK=function(){
		Laya3D._readData.pos+=4;
		return true;
	}

	Laya3D.READ_DATA=function(){
		Laya3D._DATA.offset=Laya3D._readData.getUint32();
		Laya3D._DATA.size=Laya3D._readData.getUint32();
		return true;
	}

	Laya3D.READ_STRINGS=function(){
		var materialUrls=[];
		var _STRINGS={offset:0,size:0};
		_STRINGS.offset=Laya3D._readData.getUint16();
		_STRINGS.size=Laya3D._readData.getUint16();
		var ofs=Laya3D._readData.pos;
		Laya3D._readData.pos=_STRINGS.offset+Laya3D._DATA.offset;
		for (var i=0;i < _STRINGS.size;i++){
			var string=Laya3D._readData.readUTFString();
			if (string.lastIndexOf(".lmat")!==-1 || string.lastIndexOf(".lpbr")!==-1)
				materialUrls.push(string);
		}
		return materialUrls;
	}

	Laya3D.formatRelativePath=function(base,value){
		var path;
		var char1=value.charAt(0);
		if (char1==="."){
			var parts=(base+value).split("/");
			for (var i=0,len=parts.length;i < len;i++){
				if (parts[i]=='..'){
					var index=i-1;
					if (index > 0 && parts[index]!=='..'){
						parts.splice(index,2);
						i-=2;
					}
				}
			}
			path=parts.join('/');
			}else {
			path=base+value;
		}
		(URL.customFormat !=null)&&(path=URL.customFormat(path,null));
		return path;
	}

	Laya3D._eventLoadManagerError=function(msg){
		Laya.loader.event(/*laya.events.Event.ERROR*/"error",msg);
	}

	Laya3D._addHierarchyInnerUrls=function(urls,urlMap,urlVersion,hierarchyBasePath,path,clas){
		var formatSubUrl=Laya3D.formatRelativePath(hierarchyBasePath,path);
		(urlVersion)&& (formatSubUrl=formatSubUrl+urlVersion);
		urls.push({url:formatSubUrl,clas:clas});
		urlMap[path]=formatSubUrl;
	}

	Laya3D._getSprite3DHierarchyInnerUrls=function(node,firstLevelUrls,secondLevelUrls,fourthLelUrls,urlMap,urlVersion,hierarchyBasePath){
		var i=0,n=0;
		var customProps;
		switch (node.type){
			case "Scene":;
				var lightmaps=node.customProps.lightmaps;
				for (i=0,n=lightmaps.length;i < n;i++){
					var lightMap=lightmaps[i].replace(".exr",".png");
					Laya3D._addHierarchyInnerUrls(fourthLelUrls,urlMap,urlVersion,hierarchyBasePath,lightMap,Texture2D);
				}
				break ;
			case "MeshSprite3D":
			case "TrailSprite3D":
			case "LineSprite3D":
			case "SkinnedMeshSprite3D":;
				var meshPath;
				if (node.instanceParams){
					meshPath=node.instanceParams.loadPath;
					(meshPath)&& (Laya3D._addHierarchyInnerUrls(firstLevelUrls,urlMap,urlVersion,hierarchyBasePath,meshPath,Mesh));
					}else {
					customProps=node.customProps;
					meshPath=customProps.meshPath;
					(meshPath)&& (Laya3D._addHierarchyInnerUrls(firstLevelUrls,urlMap,urlVersion,hierarchyBasePath,meshPath,Mesh));
					var materials=customProps.materials;
					if (materials)
						for (i=0,n=materials.length;i < n;i++){
						var mat=materials[i];
						var clasPaths=mat.type.split('.');
						var clas=Browser.window;
						clasPaths.forEach(function(cls){
							clas=clas[cls];
						});
						if (typeof(clas)=='function')Laya3D._addHierarchyInnerUrls(secondLevelUrls,urlMap,urlVersion,hierarchyBasePath,mat.path,clas);
						else {
							throw('_getSprite3DHierarchyInnerUrls 错误: '+mat.type+' 不是类');
						}
					}
				}
				break ;
			case "ShuriKenParticle3D":
				customProps=node.customProps;
				var parMeshPath=customProps.meshPath;
				(parMeshPath)&& (Laya3D._addHierarchyInnerUrls(firstLevelUrls,urlMap,urlVersion,hierarchyBasePath,parMeshPath,Mesh));
				var materialData=customProps.material;
				if (materialData){
					clasPaths=materialData.type.split('.');
					clas=Browser.window;
					clasPaths.forEach(function(cls){
						clas=clas[cls];
					});
					Laya3D._addHierarchyInnerUrls(secondLevelUrls,urlMap,urlVersion,hierarchyBasePath,materialData.path,clas);
					}else {
					var materialPath=customProps.materialPath;
					if (materialPath){
						Laya3D._addHierarchyInnerUrls(secondLevelUrls,urlMap,urlVersion,hierarchyBasePath,materialPath,ShurikenParticleMaterial);
						}else {
						var texturePath=customProps.texturePath;
						if (texturePath)
							Laya3D._addHierarchyInnerUrls(fourthLelUrls,urlMap,urlVersion,hierarchyBasePath,texturePath,Texture2D);
					}
				}
				break ;
			case "Terrain":
				Laya3D._addHierarchyInnerUrls(fourthLelUrls,urlMap,urlVersion,hierarchyBasePath,node.customProps.dataPath,TerrainRes);
				break ;
			};
		var components=node.components;
		for (var k in components){
			var component=components[k];
			switch (k){
				case "Animator":;
					var avatarPath=component.avatarPath;
					if (avatarPath){
						Laya3D._addHierarchyInnerUrls(fourthLelUrls,urlMap,urlVersion,hierarchyBasePath,avatarPath,Avatar);
						}else {
						var avatarData=component.avatar;
						(avatarData)&& (Laya3D._addHierarchyInnerUrls(fourthLelUrls,urlMap,urlVersion,hierarchyBasePath,avatarData.path,Avatar));
					};
					var clipPaths=component.clipPaths;
					for (i=0,n=clipPaths.length;i < n;i++)
					Laya3D._addHierarchyInnerUrls(fourthLelUrls,urlMap,urlVersion,hierarchyBasePath,clipPaths[i],AnimationClip);
					break ;
				}
		};
		var children=node.child;
		for (i=0,n=children.length;i < n;i++)
		Laya3D._getSprite3DHierarchyInnerUrls(children[i],firstLevelUrls,secondLevelUrls,fourthLelUrls,urlMap,urlVersion,hierarchyBasePath);
	}

	Laya3D._loadHierarchy=function(loader){
		loader.on(/*laya.events.Event.LOADED*/"loaded",null,Laya3D._onHierarchylhLoaded,[loader,loader._class._getGroup()]);
		loader.load(loader.url,/*laya.net.Loader.JSON*/"json",false,null,true);
	}

	Laya3D._onHierarchylhLoaded=function(loader,group,lhData){
		if (loader._class.destroyed){
			loader.endLoad();
			}else {
			var url=loader.url;
			var urlVersion=Utils3D.getURLVerion(url);
			var hierarchyBasePath=URL.getPath(url);
			var firstLevUrls=[];
			var secondLevUrls=[];
			var forthLevUrls=[];
			var urlMap={};
			Laya3D._getSprite3DHierarchyInnerUrls(lhData,firstLevUrls,secondLevUrls,forthLevUrls,urlMap,urlVersion,hierarchyBasePath);
			var urlCount=firstLevUrls.length+secondLevUrls.length+forthLevUrls.length;
			var totalProcessCount=urlCount+1;
			var weight=1 / totalProcessCount;
			Laya3D._onProcessChange(loader,0,weight,1.0);
			if (forthLevUrls.length > 0){
				var processCeil=urlCount / totalProcessCount;
				var processHandler=Handler.create(null,Laya3D._onProcessChange,[loader,weight,processCeil],false);
				Laya3D._innerFourthLevelLoaderManager.create(forthLevUrls,Handler.create(null,Laya3D._onHierarchyInnerForthLevResouLoaded,[loader,group,processHandler,lhData,urlMap,firstLevUrls,secondLevUrls,weight+processCeil *forthLevUrls.length,processCeil]),processHandler,null,null,1,true,group);
				}else {
				Laya3D._onHierarchyInnerForthLevResouLoaded(loader,group,null,lhData,urlMap,firstLevUrls,secondLevUrls,weight,processCeil);
			}
		}
	}

	Laya3D._onHierarchyInnerForthLevResouLoaded=function(loader,group,processHandler,lhData,urlMap,firstLevUrls,secondLevUrls,processOffset,processCeil){
		if (loader._class.destroyed){
			loader.endLoad();
			}else {
			(processHandler)&& (processHandler.recover());
			if (secondLevUrls.length > 0){
				var process=Handler.create(null,Laya3D._onProcessChange,[loader,processOffset,processCeil],false);
				Laya3D._innerSecondLevelLoaderManager.create(secondLevUrls,Handler.create(null,Laya3D._onHierarchyInnerSecondLevResouLoaded,[loader,group,process,lhData,urlMap,firstLevUrls,processOffset+processCeil *secondLevUrls.length,processCeil]),processHandler,null,null,1,true,group);
				}else {
				Laya3D._onHierarchyInnerSecondLevResouLoaded(loader,group,null,lhData,urlMap,firstLevUrls,processOffset,processCeil);
			}
		}
	}

	Laya3D._onHierarchyInnerSecondLevResouLoaded=function(loader,group,processHandler,lhData,urlMap,firstLevUrls,processOffset,processCeil){
		if (loader._class.destroyed){
			loader.endLoad();
			}else {
			(processHandler)&& (processHandler.recover());
			if (firstLevUrls.length > 0){
				var process=Handler.create(null,Laya3D._onProcessChange,[loader,processOffset,processCeil],false);
				Laya3D._innerFirstLevelLoaderManager.create(firstLevUrls,Handler.create(null,Laya3D._onHierarchyInnerFirstLevResouLoaded,[loader,process,lhData,urlMap,]),processHandler,null,null,1,true,group);
				}else {
				Laya3D._onHierarchyInnerFirstLevResouLoaded(loader,null,lhData,urlMap);
			}
		}
	}

	Laya3D._onHierarchyInnerFirstLevResouLoaded=function(loader,processHandler,lhData,urlMap){
		(processHandler)&& (processHandler.recover());
		loader.endLoad([lhData,urlMap]);
	}

	Laya3D._loadTerrain=function(loader){
		loader.on(/*laya.events.Event.LOADED*/"loaded",null,Laya3D._onTerrainLtLoaded,[loader,loader._class._getGroup()]);
		loader.load(loader.url,/*laya.net.Loader.JSON*/"json",false,null,true);
	}

	Laya3D._onTerrainLtLoaded=function(loader,group,ltData){
		if (loader._class.destroyed){
			loader.endLoad();
			}else {
			var url=loader.url;
			var urlVersion=Utils3D.getURLVerion(url);
			var terrainBasePath=URL.getPath(url);
			var heightMapURL,textureURLs=[];
			var urlMap={};
			var formatUrl;
			var i=0,n=0,count=0;
			var heightData=ltData.heightData;
			heightMapURL=heightData.url;
			formatUrl=Laya3D.formatRelativePath(terrainBasePath,heightMapURL);
			(urlVersion)&& (formatUrl=formatUrl+urlVersion);
			urlMap[heightMapURL]=formatUrl;
			heightMapURL=formatUrl;
			var detailTextures=ltData.detailTexture;
			for (i=0,n=detailTextures.length;i < n;i++)
			textureURLs.push({url:detailTextures[i].diffuse});
			var normalMaps=ltData.normalMap;
			for (i=0,n=normalMaps.length;i < n;i++)
			textureURLs.push({url:normalMaps[i]});
			var alphaMaps=ltData.alphaMap;
			for (i=0,n=alphaMaps.length;i < n;i++)
			textureURLs.push({url:alphaMaps[i],params:[false,false,/*laya.webgl.WebGLContext.RGBA*/0x1908,true]});
			for (i=0,n=textureURLs.length;i < n;i++){
				var subUrl=textureURLs[i].url;
				formatUrl=Laya3D.formatRelativePath(terrainBasePath,subUrl);
				(urlVersion)&& (formatUrl=formatUrl+urlVersion);
				textureURLs[i].url=formatUrl;
				urlMap[subUrl]=formatUrl;
			};
			var texsUrlCount=textureURLs.length;
			var totalProcessCount=texsUrlCount+2;
			var weight=1 / totalProcessCount;
			Laya3D._onProcessChange(loader,0,weight,1.0);
			var loadInfo={heightMapLoaded:false,texturesLoaded:false};
			var hmProcessHandler=Handler.create(null,Laya3D._onProcessChange,[loader,weight,weight],false);
			Laya3D._innerFourthLevelLoaderManager.create(heightMapURL,Handler.create(null,Laya3D._onTerrainHeightMapLoaded,[loader,hmProcessHandler,ltData,urlMap,loadInfo]),hmProcessHandler,null,[heightData.numX,heightData.numZ,heightData.bitType,heightData.value],1,true,group);
			var texsProcessHandler=Handler.create(null,Laya3D._onProcessChange,[loader,weight *2,texsUrlCount / totalProcessCount],false);
			Laya3D._innerFourthLevelLoaderManager.create(textureURLs,Handler.create(null,Laya3D._onTerrainTexturesLoaded,[loader,texsProcessHandler,ltData,urlMap,loadInfo]),texsProcessHandler,null,null,1,true,group);
		}
	}

	Laya3D._onTerrainHeightMapLoaded=function(loader,processHandler,ltData,urlMap,loadInfo){
		loadInfo.heightMapLoaded=true;
		if (loadInfo.texturesLoaded){
			loader.endLoad([ltData,urlMap]);
			processHandler.recover();
		}
	}

	Laya3D._onTerrainTexturesLoaded=function(loader,processHandler,ltData,urlMap,loadInfo){
		loadInfo.texturesLoaded=true;
		if (loadInfo.heightMapLoaded){
			loader.endLoad([ltData,urlMap]);
			processHandler.recover();
		}
	}

	Laya3D._loadMesh=function(loader){
		loader.on(/*laya.events.Event.LOADED*/"loaded",null,Laya3D._onMeshLmLoaded,[loader,loader._class._getGroup()]);
		loader.load(loader.url,/*laya.net.Loader.BUFFER*/"arraybuffer",false,null,true);
	}

	Laya3D._onMeshLmLoaded=function(loader,group,lmData){
		if (loader._class.destroyed){
			loader.endLoad();
			}else {
			var url=loader.url;
			var urlVersion=Utils3D.getURLVerion(url);
			var meshBasePath=URL.getPath(url);
			var urls;
			var urlMap={};
			var formatSubUrl;
			var i=0,n=0,count=0;
			Laya3D._readData=new Byte(lmData);
			Laya3D._readData.pos=0;
			var version=Laya3D._readData.readUTFString();
			switch (version){
				case "LAYAMODEL:02":
				case "LAYAMODEL:03":
				case "LAYAMODEL:0301":;
					var dataOffset=Laya3D._readData.getUint32();
					Laya3D._readData.pos=Laya3D._readData.pos+4;
					count=Laya3D._readData.getUint16();
					Laya3D._readData.pos=Laya3D._readData.pos+count *8;
					var offset=Laya3D._readData.getUint32();
					count=Laya3D._readData.getUint16();
					Laya3D._readData.pos=dataOffset+offset;
					urls=[];
					for (i=0;i < count;i++){
						var string=Laya3D._readData.readUTFString();
						if (string.lastIndexOf(".lmat")!==-1)
							urls.push(string);
					}
					break ;
				default :
					Laya3D.READ_BLOCK();
					for (i=0;i < 2;i++){
						var index=Laya3D._readData.getUint16();
						var blockName=Laya3D._strings[index];
						var fn=Laya3D["READ_"+blockName];
						if (fn==null)throw new Error("model file err,no this function:"+index+" "+blockName);
						if (i===1)
							urls=fn.call();
						else
						fn.call()
					}
				}
			for (i=0,n=urls.length;i < n;i++){
				var subUrl=urls[i];
				formatSubUrl=Laya3D.formatRelativePath(meshBasePath,subUrl);
				(urlVersion)&& (formatSubUrl=formatSubUrl+urlVersion);
				urls[i]=formatSubUrl;
				urlMap[subUrl]=formatSubUrl;
			}
			if (urls.length > 0){
				var urlCount=1;
				var totalProcessCount=urlCount+1;
				var lmatWeight=1 / totalProcessCount;
				Laya3D._onProcessChange(loader,0,lmatWeight,1.0);
				var processHandler=Handler.create(null,Laya3D._onProcessChange,[loader,lmatWeight,urlCount / totalProcessCount],false);
				Laya3D._innerSecondLevelLoaderManager.create(urls,Handler.create(null,Laya3D._onMeshMateialLoaded,[loader,processHandler,lmData,urlMap]),processHandler,null,null,1,true,group);
				}else {
				loader.endLoad([lmData,urlMap]);
			}
		}
	}

	Laya3D._onMeshMateialLoaded=function(loader,processHandler,lmData,urlMap){
		loader.endLoad([lmData,urlMap]);
		processHandler.recover();
	}

	Laya3D._getMaterialTexturePath=function(path,urlVersion,materialBath){
		var extenIndex=path.length-4;
		if (path.indexOf(".dds")==extenIndex || path.indexOf(".tga")==extenIndex || path.indexOf(".exr")==extenIndex || path.indexOf(".DDS")==extenIndex || path.indexOf(".TGA")==extenIndex || path.indexOf(".EXR")==extenIndex)
			path=path.substr(0,extenIndex)+".png";
		path=Laya3D.formatRelativePath(materialBath,path);
		(urlVersion)&& (path=path+urlVersion);
		return path;
	}

	Laya3D._loadMaterial=function(loader){
		loader.on(/*laya.events.Event.LOADED*/"loaded",null,Laya3D._onMaterilLmatLoaded,[loader,loader._class._getGroup()]);
		loader.load(loader.url,/*laya.net.Loader.JSON*/"json",false,null,true);
	}

	Laya3D._onMaterilLmatLoaded=function(loader,group,lmatData){
		if (loader._class.destroyed){
			loader.endLoad();
			}else {
			var url=loader.url;
			var urlVersion=Utils3D.getURLVerion(url);
			var materialBasePath=URL.getPath(url);
			var urls=[];
			var urlMap={};
			var customProps=lmatData.customProps;
			var formatSubUrl;
			var version=lmatData.version;
			if (version){
				switch (version){
					case "LAYAMATERIAL:01":
					case "LAYAMATERIAL:02":;
						var textures=lmatData.props.textures;
						for (var i=0,n=textures.length;i < n;i++){
							var tex=textures[i];
							var path=tex.path;
							if (path){
								var extenIndex=path.length-4;
								if (path.indexOf(".exr")==extenIndex || path.indexOf(".EXR")==extenIndex)
									path=path.substr(0,extenIndex)+".png";
								formatSubUrl=Laya3D.formatRelativePath(materialBasePath,path);
								(urlVersion)&& (formatSubUrl=formatSubUrl+urlVersion);
								urls.push({url:formatSubUrl,params:tex.params});
								urlMap[path]=formatSubUrl;
							}
						}
						break ;
					default :
						throw new Error("Laya3D:unkonwn version.");
					}
				}else {
				var diffuseTexture=customProps.diffuseTexture.texture2D;
				if (diffuseTexture){
					formatSubUrl=Laya3D._getMaterialTexturePath(diffuseTexture,urlVersion,materialBasePath);
					urls.push(formatSubUrl);
					urlMap[diffuseTexture]=formatSubUrl;
				}
				if (customProps.normalTexture){
					var normalTexture=customProps.normalTexture.texture2D;
					if (normalTexture){
						formatSubUrl=Laya3D._getMaterialTexturePath(normalTexture,urlVersion,materialBasePath);
						urls.push(formatSubUrl);
						urlMap[normalTexture]=formatSubUrl;
					}
				}
				if (customProps.specularTexture){
					var specularTexture=customProps.specularTexture.texture2D;
					if (specularTexture){
						formatSubUrl=Laya3D._getMaterialTexturePath(specularTexture,urlVersion,materialBasePath);
						urls.push(formatSubUrl);
						urlMap[specularTexture]=formatSubUrl;
					}
				}
				if (customProps.emissiveTexture){
					var emissiveTexture=customProps.emissiveTexture.texture2D;
					if (emissiveTexture){
						formatSubUrl=Laya3D._getMaterialTexturePath(emissiveTexture,urlVersion,materialBasePath);
						urls.push(formatSubUrl);
						urlMap[emissiveTexture]=formatSubUrl;
					}
				}
				if (customProps.ambientTexture){
					var ambientTexture=customProps.ambientTexture.texture2D;
					if (ambientTexture){
						formatSubUrl=Laya3D._getMaterialTexturePath(ambientTexture,urlVersion,materialBasePath);
						urls.push(formatSubUrl);
						urlMap[ambientTexture]=formatSubUrl;
					}
				}
				if (customProps.reflectTexture){
					var reflectTexture=customProps.reflectTexture.texture2D;
					if (reflectTexture){
						formatSubUrl=Laya3D._getMaterialTexturePath(reflectTexture,urlVersion,materialBasePath);
						urls.push(formatSubUrl);
						urlMap[reflectTexture]=formatSubUrl;
					}
				}
			};
			var urlCount=urls.length;
			var totalProcessCount=urlCount+1;
			var lmatWeight=1 / totalProcessCount;
			Laya3D._onProcessChange(loader,0,lmatWeight,1.0);
			if (urlCount > 0){
				var processHandler=Handler.create(null,Laya3D._onProcessChange,[loader,lmatWeight,urlCount / totalProcessCount],false);
				Laya3D._innerFourthLevelLoaderManager.create(urls,Handler.create(null,Laya3D._onMateialTexturesLoaded,[loader,processHandler,lmatData,urlMap]),processHandler,Texture2D,null,1,true,group);
				}else {
				Laya3D._onMateialTexturesLoaded(loader,null,lmatData,null);
			}
		}
	}

	Laya3D._onMateialTexturesLoaded=function(loader,processHandler,lmatData,urlMap){
		loader.endLoad([lmatData,urlMap]);
		(processHandler)&& (processHandler.recover());
	}

	Laya3D._loadTextureCube=function(loader){
		loader.on(/*laya.events.Event.LOADED*/"loaded",null,Laya3D._onTextureCubeLtcLoaded,[loader]);
		loader.load(loader.url,/*laya.net.Loader.JSON*/"json",false,null,true);
	}

	Laya3D._onTextureCubeLtcLoaded=function(loader,ltcData){
		if (loader._class.destroyed){
			loader.endLoad();
			}else {
			var ltcBasePath=URL.getPath(loader.url);
			var urls=[Laya3D.formatRelativePath(ltcBasePath,ltcData.px),Laya3D.formatRelativePath(ltcBasePath,ltcData.nx),Laya3D.formatRelativePath(ltcBasePath,ltcData.py),Laya3D.formatRelativePath(ltcBasePath,ltcData.ny),Laya3D.formatRelativePath(ltcBasePath,ltcData.pz),Laya3D.formatRelativePath(ltcBasePath,ltcData.nz)];
			var ltcWeight=1.0 / 7.0;
			Laya3D._onProcessChange(loader,0,ltcWeight,1.0);
			var processHandler=Handler.create(null,Laya3D._onProcessChange,[loader,ltcWeight,6 / 7],false);
			Laya3D._innerFourthLevelLoaderManager.load(urls,Handler.create(null,Laya3D._onTextureCubeImagesLoaded,[loader,urls,processHandler]),processHandler,"nativeimage");
		}
	}

	Laya3D._onTextureCubeImagesLoaded=function(loader,urls,processHandler){
		var images=[];
		images.length=6;
		for (var i=0;i < 6;i++){
			var url=urls[i];
			images[i]=Loader.getRes(url);
			Loader.clearRes(url);
		}
		loader.endLoad(images);
		processHandler.recover();
	}

	Laya3D._onProcessChange=function(loader,offset,weight,process){
		process=offset+process *weight;
		(process < 1.0)&& (loader.event(/*laya.events.Event.PROGRESS*/"progress",process));
	}

	Laya3D.init=function(width,height,antialias,alpha,premultipliedAlpha,stencil){
		(antialias===void 0)&& (antialias=false);
		(alpha===void 0)&& (alpha=false);
		(premultipliedAlpha===void 0)&& (premultipliedAlpha=true);
		(stencil===void 0)&& (stencil=true);
		RunDriver.update3DLoop=function (){
			CollisionManager._triggerCollision();
		}
		RunDriver.cancelLoadByUrl=function (url){
			Laya3D._cancelLoadByUrl(url);
		}
		Config.isAntialias=antialias;
		Config.isAlpha=alpha;
		Config.premultipliedAlpha=premultipliedAlpha;
		Config.isStencil=stencil;
		if (!WebGL.enable()){
			alert("Laya3D init error,must support webGL!");
			return;
		}
		RunDriver.changeWebGLSize=Laya3D._changeWebGLSize;
		Render.is3DMode=true;
		Laya.init(width,height);
		Layer.__init__();
		Physics.__init__();
		ExtendTerrainMaterial.__init__();
		ShaderInit3D.__init__();
		MeshSprite3D.__init__();
		AnimationNode.__init__();
		Laya3D.__init__();
		AtlasResourceManager.maxTextureCount=2;
		if (Laya3D.debugMode || OctreeNode.debugMode)
			Laya3D._debugPhasorSprite=new PhasorSpriter3D();
	}

	Laya3D.HIERARCHY="SPRITE3DHIERARCHY";
	Laya3D.MESH="MESH";
	Laya3D.MATERIAL="MATERIAL";
	Laya3D.PBRMATERIAL="PBRMTL";
	Laya3D.TEXTURECUBE="TEXTURECUBE";
	Laya3D.TERRAIN="TERRAIN";
	Laya3D._readData=null;
	Laya3D._debugPhasorSprite=null;
	Laya3D.debugMode=false;
	__static(Laya3D,
	['_DATA',function(){return this._DATA={offset:0,size:0};},'_strings',function(){return this._strings=['BLOCK','DATA',"STRINGS"];},'_innerFirstLevelLoaderManager',function(){return this._innerFirstLevelLoaderManager=new LoaderManager();},'_innerSecondLevelLoaderManager',function(){return this._innerSecondLevelLoaderManager=new LoaderManager();},'_innerThirdLevelLoaderManager',function(){return this._innerThirdLevelLoaderManager=new LoaderManager();},'_innerFourthLevelLoaderManager',function(){return this._innerFourthLevelLoaderManager=new LoaderManager();}
	]);
	return Laya3D;
})()


/**
*<code>Transform3D</code> 类用于实现3D变换。
*/
//class laya.d3.animation.AnimationTransform3D extends laya.events.EventDispatcher
var AnimationTransform3D=(function(_super){
	function AnimationTransform3D(owner){
		/**@private */
		//this._localMatrix=null;
		/**@private */
		//this._worldMatrix=null;
		/**@private */
		//this._localPosition=null;
		/**@private */
		//this._localRotation=null;
		/**@private */
		//this._localScale=null;
		/**@private */
		//this._localQuaternionUpdate=false;
		/**@private */
		//this._locaEulerlUpdate=false;
		/**@private */
		//this._localUpdate=false;
		/**@private */
		//this._parent=null;
		/**@private */
		//this._childs=null;
		/**@private */
		//this._localRotationEuler=null;
		/**@private */
		//this._owner=null;
		/**@private */
		//this._worldUpdate=false;
		/**@private */
		//this._entity=null;
		AnimationTransform3D.__super.call(this);
		this._owner=owner;
		this._childs=[];
		this._localMatrix=new Float32Array(16);
		this._localQuaternionUpdate=false;
		this._locaEulerlUpdate=false;
		this._localUpdate=false;
		this._worldUpdate=true;
	}

	__class(AnimationTransform3D,'laya.d3.animation.AnimationTransform3D',_super);
	var __proto=AnimationTransform3D.prototype;
	/**
	*@private
	*/
	__proto._getlocalMatrix=function(){
		if (this._localUpdate){
			Utils3D._createAffineTransformationArray(this._localPosition,this._localRotation,this._localScale,this._localMatrix);
			this._localUpdate=false;
		}
		return this._localMatrix;
	}

	/**
	*@private
	*/
	__proto._onWorldTransform=function(){
		if (!this._worldUpdate){
			this._worldUpdate=true;
			for (var i=0,n=this._childs.length;i < n;i++)
			this._childs[i]._onWorldTransform();
		}
	}

	/**
	*@private
	*/
	__proto._setWorldMatrixAndUpdate=function(matrix){
		this._worldMatrix=matrix;
		if (this._parent==null){
			throw new Error("don't need to set worldMatrix to root Node.");
			}else {
			if (this._parent._parent==null){
				var locMat=this._getlocalMatrix();
				for (var i=0;i < 16;++i)
				this._worldMatrix[i]=locMat[i];
				}else {
				Utils3D.matrix4x4MultiplyFFF(this._parent.getWorldMatrix(),this._getlocalMatrix(),this._worldMatrix);
			}
		}
		this._worldUpdate=false;
	}

	/**
	*@private
	*/
	__proto._setWorldMatrixNoUpdate=function(matrix){
		this._worldMatrix=matrix;
	}

	/**
	*@private
	*/
	__proto._setWorldMatrixIgnoreUpdate=function(matrix){
		this._worldMatrix=matrix;
		this._worldUpdate=false;
	}

	/**
	*获取局部位置。
	*@return 局部位置。
	*/
	__proto.getLocalPosition=function(){
		return this._localPosition;
	}

	/**
	*设置局部位置。
	*@param value 局部位置。
	*/
	__proto.setLocalPosition=function(value){
		if (this._parent){
			this._localPosition=value;
			this._localUpdate=true;
			this._onWorldTransform();
			}else {
			var entityTransform=this._entity.owner._transform;
			var entityPosition=this._entity.localPosition;
			var entityPositionE=entityPosition.elements;
			entityPositionE[0]=value[0];
			entityPositionE[1]=value[1];
			entityPositionE[2]=value[2];
			entityTransform.localPosition=entityPosition;
		}
	}

	/**
	*获取局部旋转。
	*@return 局部旋转。
	*/
	__proto.getLocalRotation=function(){
		if (this._localQuaternionUpdate){
			var eulerE=this._localRotationEuler;
			Utils3D._quaternionCreateFromYawPitchRollArray(eulerE[1] / AnimationTransform3D._angleToRandin,eulerE[0] / AnimationTransform3D._angleToRandin,eulerE[2] / AnimationTransform3D._angleToRandin,this._localRotation);
			this._localQuaternionUpdate=false;
		}
		return this._localRotation;
	}

	/**
	*设置局部旋转。
	*@param value 局部旋转。
	*/
	__proto.setLocalRotation=function(value){
		if (this._parent){
			this._localRotation=value;
			Utils3D.quaterionNormalize(this._localRotation,this._localRotation);
			this._locaEulerlUpdate=true;
			this._localQuaternionUpdate=false;
			this._localUpdate=true;
			this._onWorldTransform();
			}else {
			var entityTransform=this._entity.owner._transform;
			var entityRotation=this._entity.localRotation;
			var entityRotationE=entityRotation.elements;
			entityRotationE[0]=value[0];
			entityRotationE[1]=value[1];
			entityRotationE[2]=value[2];
			entityRotationE[3]=value[3];
			entityTransform.localRotation=entityRotation;
		}
	}

	/**
	*获取局部缩放。
	*@return 局部缩放。
	*/
	__proto.getLocalScale=function(){
		return this._localScale;
	}

	/**
	*设置局部缩放。
	*@param value 局部缩放。
	*/
	__proto.setLocalScale=function(value){
		if (this._parent){
			this._localScale=value;
			this._localUpdate=true;
			this._onWorldTransform();
			}else {
			var entityTransform=this._entity.owner._transform;
			var entityScale=this._entity.localScale;
			var entityScaleE=entityScale.elements;
			entityScaleE[0]=value[0];
			entityScaleE[1]=value[1];
			entityScaleE[2]=value[2];
			entityTransform.localScale=entityScale;
		}
	}

	/**
	*获取局部空间的旋转角度。
	*@return 欧拉角的旋转值，顺序为x、y、z。
	*/
	__proto.getLocalRotationEuler=function(){
		if (this._locaEulerlUpdate){
			Utils3D.getYawPitchRoll(this._localRotation,AnimationTransform3D._tempVector3);
			var eulerE=AnimationTransform3D._tempVector3;
			var localRotationEulerE=this._localRotationEuler;
			localRotationEulerE[0]=eulerE[1] *AnimationTransform3D._angleToRandin;
			localRotationEulerE[1]=eulerE[0] *AnimationTransform3D._angleToRandin;
			localRotationEulerE[2]=eulerE[2] *AnimationTransform3D._angleToRandin;
			this._locaEulerlUpdate=false;
		}
		return this._localRotationEuler;
	}

	/**
	*设置局部空间的旋转角度。
	*@param value 欧拉角的旋转值，顺序为x、y、z。
	*/
	__proto.setLocalRotationEuler=function(value){
		if (this._parent){
			Utils3D._quaternionCreateFromYawPitchRollArray(value[1] / AnimationTransform3D._angleToRandin,value[0] / AnimationTransform3D._angleToRandin,value[2] / AnimationTransform3D._angleToRandin,this._localRotation);
			this._localRotationEuler=value;
			this._locaEulerlUpdate=false;
			this._localQuaternionUpdate=false;
			this._localUpdate=true;
			this._onWorldTransform();
			}else {
			var entityTransform=this._entity.owner._transform;
			var entityLocalRotationEuler=this._entity.localRotationEuler;
			var elements=entityLocalRotationEuler.elements;
			elements[0]=value[0];
			elements[1]=value[1];
			elements[2]=value[2];
			entityTransform.localRotationEuler=entityLocalRotationEuler;
		}
	}

	/**
	*获取世界矩阵。
	*@return 世界矩阵。
	*/
	__proto.getWorldMatrix=function(){
		if (this._worldUpdate){
			if (this._parent._parent !=null){
				Utils3D.matrix4x4MultiplyFFF(this._parent.getWorldMatrix(),this._getlocalMatrix(),this._worldMatrix);
				}else {
				var locMat=this._getlocalMatrix();
				for (var i=0;i < 16;++i)
				this._worldMatrix[i]=locMat[i];
			}
			this._worldUpdate=false;
		}
		return this._worldMatrix;
	}

	/**
	*设置父3D变换。
	*@param value 父3D变换。
	*/
	__proto.setParent=function(value){
		if (this._parent!==value){
			if (this._parent){
				var parentChilds=this._parent._childs;
				var index=parentChilds.indexOf(this);
				parentChilds.splice(index,1);
			}
			if (value){
				value._childs.push(this);
				(value)&& (this._onWorldTransform());
			}
			this._parent=value;
		}
	}

	__static(AnimationTransform3D,
	['_tempVector3',function(){return this._tempVector3=new Float32Array(3);},'_angleToRandin',function(){return this._angleToRandin=180 / Math.PI;}
	]);
	return AnimationTransform3D;
})(EventDispatcher)


/**
*<code>Component3D</code> 类用于创建组件的父类。
*/
//class laya.d3.component.Component3D extends laya.events.EventDispatcher
var Component3D=(function(_super){
	function Component3D(){
		/**@private */
		this._destroyed=false;
		/**@private 唯一标识ID。*/
		this._id=0;
		/**@private 是否启动。*/
		this._enable=false;
		/**@private 所属Sprite3D节点。*/
		this._owner=null;
		/**是否已执行start函数。*/
		this.started=false;
		Component3D.__super.call(this);
		this._destroyed=false;
		this._id=Component3D._uniqueIDCounter;
		Component3D._uniqueIDCounter++;
	}

	__class(Component3D,'laya.d3.component.Component3D',_super);
	var __proto=Component3D.prototype;
	Laya.imps(__proto,{"laya.d3.core.render.IUpdate":true,"laya.resource.IDestroy":true})
	/**
	*@private
	*初始化组件。
	*@param owner 所属Sprite3D节点。
	*/
	__proto._initialize=function(owner){
		this._owner=owner;
		this._enable=true;
		this.started=false;
		this._load(owner);
	}

	/**
	*@private
	*销毁组件。
	*/
	__proto._destroy=function(){
		this._unload(this._owner);
		this._owner=null;
		this._destroyed=true;
	}

	/**
	*@private
	*载入组件时执行,可重写此函数。
	*/
	__proto._load=function(owner){}
	/**
	*@private
	*在任意第一次更新时执行,可重写此函数。
	*/
	__proto._start=function(state){}
	/**
	*@private
	*更新组件,可重写此函数。
	*@param state 渲染状态参数。
	*/
	__proto._update=function(state){}
	/**
	*@private
	*更新的最后阶段执行,可重写此函数。
	*@param state 渲染状态参数。
	*/
	__proto._lateUpdate=function(state){}
	/**
	*@private
	*渲染前设置组件相关参数,可重写此函数。
	*@param state 渲染状态参数。
	*/
	__proto._preRenderUpdate=function(state){}
	/**
	*@private
	*渲染的最后阶段执行,可重写此函数。
	*@param state 渲染状态参数。
	*/
	__proto._postRenderUpdate=function(state){}
	/**
	*@private
	*卸载组件时执行,可重写此函数。
	*/
	__proto._unload=function(owner){
		this.offAll();
	}

	/**
	*@private
	*/
	__proto._cloneTo=function(dest){}
	/**
	*获取唯一标识ID。
	*@return 唯一标识ID。
	*/
	__getset(0,__proto,'id',function(){
		return this._id;
	});

	/**
	*获取是否已销毁。
	*@return 是否已销毁。
	*/
	__getset(0,__proto,'destroyed',function(){
		return this._destroyed;
	});

	/**
	*获取所属Sprite3D节点。
	*@return 所属Sprite3D节点。
	*/
	__getset(0,__proto,'owner',function(){
		return this._owner;
	});

	/**
	*设置是否启用。
	*@param value 是否启动
	*/
	/**
	*获取是否启用。
	*@return 是否启动。
	*/
	__getset(0,__proto,'enable',function(){
		return this._enable;
		},function(value){
		if (this._enable!==value){
			this._enable=value;
			this.event(/*laya.events.Event.ENABLE_CHANGED*/"enablechanged",this._enable);
		}
	});

	/**
	*获取是否为单实例组件。
	*@return 是否为单实例组件。
	*/
	__getset(0,__proto,'isSingleton',function(){
		return Component3D._isSingleton;
	});

	Component3D._isSingleton=true;
	Component3D._uniqueIDCounter=1;
	return Component3D;
})(EventDispatcher)


/**
*<code>GeometryFilter</code> 类用于创建集合体过滤器,抽象类不允许实例。
*/
//class laya.d3.core.GeometryFilter extends laya.events.EventDispatcher
var GeometryFilter=(function(_super){
	function GeometryFilter(){
		/**@private */
		this._destroyed=false;
		GeometryFilter.__super.call(this);
		this._destroyed=false;
	}

	__class(GeometryFilter,'laya.d3.core.GeometryFilter',_super);
	var __proto=GeometryFilter.prototype;
	Laya.imps(__proto,{"laya.resource.IDestroy":true})
	/**
	*@private
	*/
	__proto._destroy=function(){
		this.offAll();
		this._destroyed=true;
	}

	/**@private */
	__getset(0,__proto,'_isAsyncLoaded',function(){
		return true;
	});

	/**
	*@private
	*/
	__getset(0,__proto,'_originalBoundingBoxCorners',function(){
		throw new Error("BaseRender: must override it.");
	});

	/**
	*@private
	*/
	__getset(0,__proto,'_originalBoundingSphere',function(){
		throw new Error("BaseRender: must override it.");
	});

	/**
	*@private
	*/
	__getset(0,__proto,'_originalBoundingBox',function(){
		throw new Error("BaseRender: must override it.");
	});

	/**
	*获取是否已销毁。
	*@return 是否已销毁。
	*/
	__getset(0,__proto,'destroyed',function(){
		return this._destroyed;
	});

	return GeometryFilter;
})(EventDispatcher)


/**
*<code>Render</code> 类用于渲染器的父类，抽象类不允许实例。
*/
//class laya.d3.core.render.BaseRender extends laya.events.EventDispatcher
var BaseRender=(function(_super){
	function BaseRender(owner){
		/**@private */
		//this._id=0;
		/**@private */
		//this._destroyed=false;
		/**@private */
		//this._lightmapScaleOffset=null;
		/**@private */
		//this._lightmapIndex=0;
		/**@private */
		//this._enable=false;
		/**@private */
		//this._receiveShadow=false;
		/**@private */
		//this._materialsInstance=null;
		/**@private */
		//this._boundingSphere=null;
		/**@private */
		//this._boundingBox=null;
		/**@private */
		//this._boundingBoxCenter=null;
		/**@private */
		//this._boundingSphereNeedChange=false;
		/**@private */
		//this._boundingBoxNeedChange=false;
		/**@private */
		//this._boundingBoxCenterNeedChange=false;
		/**@private */
		//this._octreeNodeNeedChange=false;
		/**@private */
		//this._indexInSceneFrustumCullingObjects=0;
		/**@private */
		//this._materials=null;
		/**@private */
		//this._owner=null;
		/**@private */
		//this._renderElements=null;
		/**@private */
		//this._distanceForSort=NaN;
		/**@private */
		//this._treeNode=null;
		/**@private */
		//this._isPartOfStaticBatch=false;
		/**@private */
		//this._staticBatchRootSprite3D=null;
		/**@private */
		//this._staticBatchRenderElements=null;
		/**排序矫正值。*/
		//this.sortingFudge=NaN;
		/**是否产生阴影。 */
		//this.castShadow=false;
		BaseRender.__super.call(this);
		this._id=++BaseRender._uniqueIDCounter;
		this._indexInSceneFrustumCullingObjects=-1;
		this._boundingBox=new BoundBox(new Vector3(),new Vector3());
		this._boundingBoxCenter=new Vector3();
		this._boundingSphere=new BoundSphere(new Vector3(),0);
		this._boundingSphereNeedChange=true;
		this._boundingBoxNeedChange=true;
		this._boundingBoxCenterNeedChange=true;
		this._octreeNodeNeedChange=true;
		this._materials=[];
		this._renderElements=[];
		this._isPartOfStaticBatch=false;
		this._destroyed=false;
		this._owner=owner;
		this._enable=true;
		this._materialsInstance=[];
		this.lightmapIndex=-1;
		this.castShadow=false;
		this.receiveShadow=false;
		this.sortingFudge=0.0;
		this._owner.transform.on(/*laya.events.Event.WORLDMATRIX_NEEDCHANGE*/"worldmatrixneedchanged",this,this._onWorldMatNeedChange);
	}

	__class(BaseRender,'laya.d3.core.render.BaseRender',_super);
	var __proto=BaseRender.prototype;
	Laya.imps(__proto,{"laya.resource.IDestroy":true})
	/**
	*@private
	*/
	__proto._changeMaterialReference=function(lastValue,value){
		(lastValue)&& (lastValue._removeReference());
		value._addReference();
	}

	/**
	*@private
	*/
	__proto._getInstanceMaterial=function(material,index){
		var insMat=/*__JS__ */new material.constructor();
		material.cloneTo(insMat);
		insMat.name=insMat.name+"(Instance)";
		this._materialsInstance[index]=true;
		this._changeMaterialReference(this._materials[index],insMat);
		this._materials[index]=insMat;
		return insMat;
	}

	/**
	*@private
	*/
	__proto._setShaderValuelightMap=function(lightMap){
		this._setShaderValueTexture(/*laya.d3.core.RenderableSprite3D.LIGHTMAP*/3,lightMap);
	}

	/**
	*@private
	*/
	__proto._onWorldMatNeedChange=function(){
		this._boundingSphereNeedChange=true;
		this._boundingBoxNeedChange=true;
		this._boundingBoxCenterNeedChange=true;
		this._octreeNodeNeedChange=true;
	}

	/**
	*@private
	*/
	__proto._renderRenderableBoundBox=function(){
		var linePhasor=Laya3D._debugPhasorSprite;
		var boundBox=this.boundingBox;
		var corners=BaseRender._tempBoundBoxCorners;
		boundBox.getCorners(corners);
		linePhasor.line(corners[0],BaseRender._greenColor,corners[1],BaseRender._greenColor);
		linePhasor.line(corners[2],BaseRender._greenColor,corners[3],BaseRender._greenColor);
		linePhasor.line(corners[4],BaseRender._greenColor,corners[5],BaseRender._greenColor);
		linePhasor.line(corners[6],BaseRender._greenColor,corners[7],BaseRender._greenColor);
		linePhasor.line(corners[0],BaseRender._greenColor,corners[3],BaseRender._greenColor);
		linePhasor.line(corners[1],BaseRender._greenColor,corners[2],BaseRender._greenColor);
		linePhasor.line(corners[2],BaseRender._greenColor,corners[6],BaseRender._greenColor);
		linePhasor.line(corners[3],BaseRender._greenColor,corners[7],BaseRender._greenColor);
		linePhasor.line(corners[0],BaseRender._greenColor,corners[4],BaseRender._greenColor);
		linePhasor.line(corners[1],BaseRender._greenColor,corners[5],BaseRender._greenColor);
		linePhasor.line(corners[4],BaseRender._greenColor,corners[7],BaseRender._greenColor);
		linePhasor.line(corners[5],BaseRender._greenColor,corners[6],BaseRender._greenColor);
	}

	/**
	*@private
	*/
	__proto._calculateBoundingSphere=function(){
		throw("BaseRender: must override it.");
	}

	/**
	*@private
	*/
	__proto._calculateBoundingBox=function(){
		throw("BaseRender: must override it.");
	}

	/**
	*@private
	*/
	__proto._setShaderValueTexture=function(shaderName,texture){
		this._owner._shaderValues.setValue(shaderName,texture);
	}

	/**
	*@private
	*/
	__proto._setShaderValueMatrix4x4=function(shaderName,matrix4x4){
		this._owner._shaderValues.setValue(shaderName,matrix4x4 ? matrix4x4.elements :null);
	}

	/**
	*设置颜色。
	*@param shaderIndex shader索引。
	*@param color 颜色向量。
	*/
	__proto._setShaderValueColor=function(shaderIndex,color){
		this._owner._shaderValues.setValue(shaderIndex,color ? color.elements :null);
	}

	/**
	*设置Buffer。
	*@param shaderIndex shader索引。
	*@param buffer buffer数据。
	*/
	__proto._setShaderValueBuffer=function(shaderIndex,buffer){
		this._owner._shaderValues.setValue(shaderIndex,buffer);
	}

	/**
	*设置整型。
	*@param shaderIndex shader索引。
	*@param i 整形。
	*/
	__proto._setShaderValueInt=function(shaderIndex,i){
		this._owner._shaderValues.setValue(shaderIndex,i);
	}

	/**
	*设置布尔。
	*@param shaderIndex shader索引。
	*@param b 布尔。
	*/
	__proto._setShaderValueBool=function(shaderIndex,b){
		this._owner._shaderValues.setValue(shaderIndex,b);
	}

	/**
	*设置浮点。
	*@param shaderIndex shader索引。
	*@param i 浮点。
	*/
	__proto._setShaderValueNumber=function(shaderIndex,number){
		this._owner._shaderValues.setValue(shaderIndex,number);
	}

	/**
	*设置二维向量。
	*@param shaderIndex shader索引。
	*@param vector2 二维向量。
	*/
	__proto._setShaderValueVector2=function(shaderIndex,vector2){
		this._owner._shaderValues.setValue(shaderIndex,vector2 ? vector2.elements :null);
	}

	/**
	*增加Shader宏定义。
	*@param value 宏定义。
	*/
	__proto._addShaderDefine=function(value){
		this._owner._shaderDefineValue |=value;
	}

	/**
	*移除Shader宏定义。
	*@param value 宏定义。
	*/
	__proto._removeShaderDefine=function(value){
		this._owner._shaderDefineValue &=~value;
	}

	/**
	*@private
	*/
	__proto._renderUpdate=function(projectionView){
		return true;
	}

	/**
	*@private
	*/
	__proto._applyLightMapParams=function(){
		if (this._lightmapIndex >=0){
			var scene=this._owner.scene;
			if (scene){
				var lightMaps=scene.getlightmaps();
				var lightMap=lightMaps[this._lightmapIndex];
				if (lightMap){
					this._addShaderDefine(RenderableSprite3D.SAHDERDEFINE_LIGHTMAP);
					if (lightMap.loaded)
						this._setShaderValuelightMap(lightMap);
					else
					lightMap.once(/*laya.events.Event.LOADED*/"loaded",this,this._setShaderValuelightMap);
					}else {
					this._removeShaderDefine(RenderableSprite3D.SAHDERDEFINE_LIGHTMAP);
				}
				}else {
				this._removeShaderDefine(RenderableSprite3D.SAHDERDEFINE_LIGHTMAP);
			}
			}else {
			this._removeShaderDefine(RenderableSprite3D.SAHDERDEFINE_LIGHTMAP);
		}
	}

	/**
	*@private
	*/
	__proto._updateOctreeNode=function(){
		var treeNode=this._treeNode;
		if (treeNode && this._octreeNodeNeedChange){
			treeNode.updateObject(this);
			this._octreeNodeNeedChange=false;
		}
	}

	/**
	*@private
	*/
	__proto._destroy=function(){
		this.offAll();
		var i=0,n=0;
		for (i=0,n=this._renderElements.length;i < n;i++)
		this._renderElements[i]._destroy();
		for (i=0,n=this._materials.length;i < n;i++)
		this._materials[i]._removeReference();
		this._renderElements=null;
		this._owner=null;
		this._materials=null;
		this._boundingBox=null;
		this._boundingBoxCenter=null;
		this._boundingSphere=null;
		this._lightmapScaleOffset=null;
		this._destroyed=true;
	}

	/**
	*获取包围球,只读,不允许修改其值。
	*@return 包围球。
	*/
	__getset(0,__proto,'boundingSphere',function(){
		if (this._boundingSphereNeedChange){
			this._calculateBoundingSphere();
			this._boundingSphereNeedChange=false;
		}
		return this._boundingSphere;
	});

	/**
	*获取唯一标识ID,通常用于识别。
	*/
	__getset(0,__proto,'id',function(){
		return this._id;
	});

	/**
	*设置第一个实例材质。
	*@param value 第一个实例材质。
	*/
	/**
	*返回第一个实例材质,第一次使用会拷贝实例对象。
	*@return 第一个实例材质。
	*/
	__getset(0,__proto,'material',function(){
		var material=this._materials[0];
		if (material && !this._materialsInstance[0]){
			var insMat=this._getInstanceMaterial(material,0);
			this.event(/*laya.events.Event.MATERIAL_CHANGED*/"materialchanged",[this,0,insMat]);
		}
		return this._materials[0];
		},function(value){
		this.sharedMaterial=value;
	});

	/**
	*设置第一个材质。
	*@param value 第一个材质。
	*/
	/**
	*返回第一个材质。
	*@return 第一个材质。
	*/
	__getset(0,__proto,'sharedMaterial',function(){
		return this._materials[0];
		},function(value){
		var lastValue=this._materials[0];
		if (lastValue!==value){
			this._materials[0]=value;
			this._materialsInstance[0]=false;
			this._changeMaterialReference(lastValue,value);
			this.event(/*laya.events.Event.MATERIAL_CHANGED*/"materialchanged",[this,0,value]);
		}
	});

	/**
	*设置光照贴图的索引。
	*@param value 光照贴图的索引。
	*/
	/**
	*获取光照贴图的索引。
	*@return 光照贴图的索引。
	*/
	__getset(0,__proto,'lightmapIndex',function(){
		return this._lightmapIndex;
		},function(value){
		this._lightmapIndex=value;
		this._applyLightMapParams();
	});

	/**
	*设置光照贴图的缩放和偏移。
	*@param 光照贴图的缩放和偏移。
	*/
	/**
	*获取光照贴图的缩放和偏移。
	*@return 光照贴图的缩放和偏移。
	*/
	__getset(0,__proto,'lightmapScaleOffset',function(){
		return this._lightmapScaleOffset;
		},function(value){
		this._lightmapScaleOffset=value;
		this._setShaderValueColor(/*laya.d3.core.RenderableSprite3D.LIGHTMAPSCALEOFFSET*/2,value);
		this._addShaderDefine(RenderableSprite3D.SHADERDEFINE_SCALEOFFSETLIGHTINGMAPUV);
	});

	/**
	*设置是否可用。
	*@param value 是否可用。
	*/
	/**
	*获取是否可用。
	*@return 是否可用。
	*/
	__getset(0,__proto,'enable',function(){
		return this._enable;
		},function(value){
		this._enable=value;
		this.event(/*laya.events.Event.ENABLE_CHANGED*/"enablechanged",[this,value]);
	});

	/**
	*设置实例材质列表。
	*@param value 实例材质列表。
	*/
	/**
	*获取潜拷贝实例材质列表,第一次使用会拷贝实例对象。
	*@return 浅拷贝实例材质列表。
	*/
	__getset(0,__proto,'materials',function(){
		for (var i=0,n=this._materials.length;i < n;i++){
			if (!this._materialsInstance[i]){
				var insMat=this._getInstanceMaterial(this._materials[i],i);
				this.event(/*laya.events.Event.MATERIAL_CHANGED*/"materialchanged",[this,i,insMat]);
			}
		}
		return this._materials.slice();
		},function(value){
		this.sharedMaterials=value;
	});

	/**
	*设置材质列表。
	*@param value 材质列表。
	*/
	/**
	*获取浅拷贝材质列表。
	*@return 浅拷贝材质列表。
	*/
	__getset(0,__proto,'sharedMaterials',function(){
		var materials=this._materials.slice();
		return materials;
		},function(value){
		if (!value)
			throw new Error("MeshRender: shadredMaterials value can't be null.");
		var len=value.length;
		this._materialsInstance.length=len;
		for (var i=0;i < len;i++){
			var lastValue=this._materials[i];
			if (lastValue!==value[i]){
				this._materialsInstance[i]=false;
				this._changeMaterialReference(lastValue,value[i]);
				this.event(/*laya.events.Event.MATERIAL_CHANGED*/"materialchanged",[this,i,value[i]]);
			}
		}
		this._materials=value;
	});

	/**
	*获取包围盒,只读,不允许修改其值。
	*@return 包围盒。
	*/
	__getset(0,__proto,'boundingBox',function(){
		if (this._boundingBoxNeedChange){
			this._calculateBoundingBox();
			this._boundingBoxNeedChange=false;
		}
		return this._boundingBox;
	});

	/**
	*获取包围盒中心,不允许修改其值。
	*@return 包围盒中心。
	*/
	__getset(0,__proto,'boundingBoxCenter',function(){
		if (this._boundingBoxCenterNeedChange){
			var boundBox=this.boundingBox;
			Vector3.add(boundBox.min,boundBox.max,this._boundingBoxCenter);
			Vector3.scale(this._boundingBoxCenter,0.5,this._boundingBoxCenter);
			this._boundingBoxCenterNeedChange=false;
		}
		return this._boundingBoxCenter;
	});

	/**
	*设置是否接收阴影属性
	*/
	/**
	*获得是否接收阴影属性
	*/
	__getset(0,__proto,'receiveShadow',function(){
		return this._receiveShadow;
		},function(value){
		if (this._receiveShadow!==value){
			this._receiveShadow=value;
			if (value)
				this._addShaderDefine(ParallelSplitShadowMap.SHADERDEFINE_RECEIVE_SHADOW);
			else
			this._removeShaderDefine(ParallelSplitShadowMap.SHADERDEFINE_RECEIVE_SHADOW);
		}
	});

	/**
	*获取是否已销毁。
	*@return 是否已销毁。
	*/
	__getset(0,__proto,'destroyed',function(){
		return this._destroyed;
	});

	BaseRender._uniqueIDCounter=0;
	__static(BaseRender,
	['_tempBoundBoxCorners',function(){return this._tempBoundBoxCorners=/*new vector.<>*/[new Vector3(),new Vector3(),new Vector3(),new Vector3(),new Vector3(),new Vector3(),new Vector3(),new Vector3()];},'_greenColor',function(){return this._greenColor=new Vector4(0.0,1.0,0.0,1.0);}
	]);
	return BaseRender;
})(EventDispatcher)


/**
*<code>Transform3D</code> 类用于实现3D变换。
*/
//class laya.d3.core.Transform3D extends laya.events.EventDispatcher
var Transform3D=(function(_super){
	function Transform3D(owner){
		/**@private */
		this._owner=null;
		/**@private */
		this._localQuaternionUpdate=false;
		/**@private */
		this._locaEulerlUpdate=false;
		/**@private */
		this._localUpdate=false;
		/**@private */
		this._worldUpdate=true;
		/**@private */
		this._positionUpdate=true;
		/**@private */
		this._rotationUpdate=true;
		/**@private */
		this._scaleUpdate=true;
		/**@private */
		this._parent=null;
		/**@private */
		this._childs=null;
		/**@private */
		this._dummy=null;
		/**变换中心点,注意:该中心点不受变换的影响。*/
		this.pivot=null;
		Transform3D.__super.call(this);
		this._localPosition=new Vector3();
		this._localRotation=new Quaternion(0,0,0,1);
		this._localScale=new Vector3(1,1,1);
		this._localRotationEuler=new Vector3();
		this._localMatrix=new Matrix4x4();
		this._position=new Vector3();
		this._rotation=new Quaternion(0,0,0,1);
		this._scale=new Vector3(1,1,1);
		this._worldMatrix=new Matrix4x4();
		this._forward=new Vector3();
		this._up=new Vector3();
		this._right=new Vector3();
		this._owner=owner;
		this._childs=[];
	}

	__class(Transform3D,'laya.d3.core.Transform3D',_super);
	var __proto=Transform3D.prototype;
	/**
	*@private
	*/
	__proto._updateLocalMatrix=function(){
		if (this.pivot && (this.pivot.x!==0 || this.pivot.y!==0 || this.pivot.z!==0)){
			var scalePivot=Transform3D._tempVector30;
			Vector3.multiply(this.pivot,this._localScale,scalePivot);
			var scaleOffsetPosition=Transform3D._tempVector31;
			Vector3.subtract(scalePivot,this.pivot,scaleOffsetPosition);
			var rotationOffsetPosition=Transform3D._tempVector32;
			var localRot=this.localRotation;
			Vector3.transformQuat(scalePivot,localRot,rotationOffsetPosition);
			Vector3.subtract(rotationOffsetPosition,scalePivot,rotationOffsetPosition);
			var resultLocalPosition=Transform3D._tempVector33;
			Vector3.subtract(this._localPosition,scaleOffsetPosition,resultLocalPosition);
			Vector3.subtract(resultLocalPosition,rotationOffsetPosition,resultLocalPosition);
			Matrix4x4.createAffineTransformation(resultLocalPosition,localRot,this._localScale,this._localMatrix);
			}else {
			Matrix4x4.createAffineTransformation(this._localPosition,this.localRotation,this._localScale,this._localMatrix);
		}
	}

	/**
	*@private
	*/
	__proto._onWorldPositionRotationTransform=function(){
		if (!this._worldUpdate || !this._positionUpdate || !this._rotationUpdate){
			this._worldUpdate=this._positionUpdate=this._rotationUpdate=true;
			this.event(/*laya.events.Event.WORLDMATRIX_NEEDCHANGE*/"worldmatrixneedchanged");
			for (var i=0,n=this._childs.length;i < n;i++)
			this._childs[i]._onWorldPositionRotationTransform();
		}
	}

	/**
	*@private
	*/
	__proto._onWorldPositionScaleTransform=function(){
		if (!this._worldUpdate || !this._positionUpdate || !this._scaleUpdate){
			this._worldUpdate=this._positionUpdate=this._scaleUpdate=true;
			this.event(/*laya.events.Event.WORLDMATRIX_NEEDCHANGE*/"worldmatrixneedchanged");
			for (var i=0,n=this._childs.length;i < n;i++)
			this._childs[i]._onWorldPositionScaleTransform();
		}
	}

	/**
	*@private
	*/
	__proto._onWorldPositionTransform=function(){
		if (!this._worldUpdate || !this._positionUpdate){
			this._worldUpdate=this._positionUpdate=true;
			this.event(/*laya.events.Event.WORLDMATRIX_NEEDCHANGE*/"worldmatrixneedchanged");
			for (var i=0,n=this._childs.length;i < n;i++)
			this._childs[i]._onWorldPositionTransform();
		}
	}

	/**
	*@private
	*/
	__proto._onWorldRotationTransform=function(){
		if (!this._worldUpdate || !this._rotationUpdate){
			this._worldUpdate=this._rotationUpdate=true;
			this.event(/*laya.events.Event.WORLDMATRIX_NEEDCHANGE*/"worldmatrixneedchanged");
			for (var i=0,n=this._childs.length;i < n;i++)
			this._childs[i]._onWorldPositionRotationTransform();
		}
	}

	/**
	*@private
	*/
	__proto._onWorldScaleTransform=function(){
		if (!this._worldUpdate || !this._scaleUpdate){
			this._worldUpdate=this._scaleUpdate=true;
			this.event(/*laya.events.Event.WORLDMATRIX_NEEDCHANGE*/"worldmatrixneedchanged");
			for (var i=0,n=this._childs.length;i < n;i++)
			this._childs[i]._onWorldPositionScaleTransform();
		}
	}

	/**
	*@private
	*/
	__proto._onWorldTransform=function(){
		if (!this._worldUpdate || !this._positionUpdate || !this._rotationUpdate || !this._scaleUpdate){
			this._worldUpdate=this._positionUpdate=this._rotationUpdate=this._scaleUpdate=true;
			this.event(/*laya.events.Event.WORLDMATRIX_NEEDCHANGE*/"worldmatrixneedchanged");
			for (var i=0,n=this._childs.length;i < n;i++)
			this._childs[i]._onWorldTransform();
		}
	}

	/**
	*平移变换。
	*@param translation 移动距离。
	*@param isLocal 是否局部空间。
	*/
	__proto.translate=function(translation,isLocal){
		(isLocal===void 0)&& (isLocal=true);
		if (isLocal){
			Matrix4x4.createFromQuaternion(this.localRotation,Transform3D._tempMatrix0);
			Vector3.transformCoordinate(translation,Transform3D._tempMatrix0,Transform3D._tempVector30);
			Vector3.add(this.localPosition,Transform3D._tempVector30,this._localPosition);
			this.localPosition=this._localPosition;
			}else {
			Vector3.add(this.position,translation,this._position);
			this.position=this._position;
		}
	}

	/**
	*旋转变换。
	*@param rotations 旋转幅度。
	*@param isLocal 是否局部空间。
	*@param isRadian 是否弧度制。
	*/
	__proto.rotate=function(rotation,isLocal,isRadian){
		(isLocal===void 0)&& (isLocal=true);
		(isRadian===void 0)&& (isRadian=true);
		var rot;
		if (isRadian){
			rot=rotation;
			}else {
			Vector3.scale(rotation,Math.PI / 180.0,Transform3D._tempVector30);
			rot=Transform3D._tempVector30;
		}
		Quaternion.createFromYawPitchRoll(rot.y,rot.x,rot.z,Transform3D._tempQuaternion0);
		if (isLocal){
			Quaternion.multiply(this._localRotation,Transform3D._tempQuaternion0,this._localRotation);
			this.localRotation=this._localRotation;
			}else {
			Quaternion.multiply(Transform3D._tempQuaternion0,this.rotation,this._rotation);
			this.rotation=this._rotation;
		}
	}

	/**
	*观察目标位置。
	*@param target 观察目标。
	*@param up 向上向量。
	*@param isLocal 是否局部空间。
	*/
	__proto.lookAt=function(target,up,isLocal){
		(isLocal===void 0)&& (isLocal=false);
		var targetE=target.elements;
		var eyeE;
		if (isLocal){
			eyeE=this._localPosition.elements;
			if (Math.abs(eyeE[0]-targetE[0])< MathUtils3D.zeroTolerance && Math.abs(eyeE[1]-targetE[1])< MathUtils3D.zeroTolerance && Math.abs(eyeE[2]-targetE[2])< MathUtils3D.zeroTolerance)
				return;
			Quaternion.lookAt(this._localPosition,target,up,this._localRotation);
			this._localRotation.invert(this._localRotation);
			this.localRotation=this._localRotation;
			}else {
			var worldPosition=this.position;
			eyeE=worldPosition.elements;
			if (Math.abs(eyeE[0]-targetE[0])< MathUtils3D.zeroTolerance && Math.abs(eyeE[1]-targetE[1])< MathUtils3D.zeroTolerance && Math.abs(eyeE[2]-targetE[2])< MathUtils3D.zeroTolerance)
				return;
			Quaternion.lookAt(worldPosition,target,up,this._rotation);
			this._rotation.invert(this._rotation);
			this.rotation=this._rotation;
		}
	}

	/**
	*@private
	*/
	__getset(0,__proto,'_isFrontFaceInvert',function(){
		var scale=this.scale;
		var isInvert=scale.x < 0;
		(scale.y < 0)&& (isInvert=!isInvert);
		(scale.z < 0)&& (isInvert=!isInvert);
		return isInvert;
	});

	/**
	*获取所属精灵。
	*/
	__getset(0,__proto,'owner',function(){
		return this._owner;
	});

	/**
	*设置局部旋转。
	*@param value 局部旋转。
	*/
	/**
	*获取局部旋转。
	*@return 局部旋转。
	*/
	__getset(0,__proto,'localRotation',function(){
		if (this._localQuaternionUpdate){
			var eulerE=this._localRotationEuler.elements;
			Quaternion.createFromYawPitchRoll(eulerE[1] / Transform3D._angleToRandin,eulerE[0] / Transform3D._angleToRandin,eulerE[2] / Transform3D._angleToRandin,this._localRotation);
		}
		return this._localRotation;
		},function(value){
		this._localRotation=value;
		this._localRotation.normalize(this._localRotation);
		this._locaEulerlUpdate=true;
		this._localQuaternionUpdate=false;
		this._localUpdate=true;
		if (this.pivot && (this.pivot.x!==0 || this.pivot.y!==0 || this.pivot.z!==0))
			this._onWorldPositionRotationTransform();
		else
		this._onWorldRotationTransform();
	});

	/**
	*设置世界矩阵。
	*@param value 世界矩阵。
	*/
	/**
	*获取世界矩阵。
	*@return 世界矩阵。
	*/
	__getset(0,__proto,'worldMatrix',function(){
		if (this._worldUpdate){
			if (this._parent !=null)
				Matrix4x4.multiply(this._parent.worldMatrix,this.localMatrix,this._worldMatrix);
			else
			this.localMatrix.cloneTo(this._worldMatrix);
			this._worldUpdate=false;
		}
		return this._worldMatrix;
		},function(value){
		if (this._parent===null){
			value.cloneTo(this._localMatrix);
			}else {
			this._parent.worldMatrix.invert(this._localMatrix);
			Matrix4x4.multiply(this._localMatrix,value,this._localMatrix);
		}
		this.localMatrix=this._localMatrix;
		this._worldMatrix=value;
		this._worldUpdate=false;
	});

	/**
	*获取世界矩阵是否需要更新。
	*@return 世界矩阵是否需要更新。
	*/
	__getset(0,__proto,'worldNeedUpdate',function(){
		return this._worldUpdate;
	});

	/**
	*设置局部矩阵。
	*@param value 局部矩阵。
	*/
	/**
	*获取局部矩阵。
	*@return 局部矩阵。
	*/
	__getset(0,__proto,'localMatrix',function(){
		if (this._localUpdate){
			this._updateLocalMatrix();
			this._localUpdate=false;
		}
		return this._localMatrix;
		},function(value){
		this._localMatrix=value;
		this._localMatrix.decomposeTransRotScale(this._localPosition,this._localRotation,this._localScale);
		this._localUpdate=false;
		this._onWorldTransform();
	});

	/**
	*设置关联虚拟变换。
	*@param value 虚拟变换。
	*/
	/**
	*获取关联虚拟变换。
	*@return 虚拟变换。
	*/
	__getset(0,__proto,'dummy',function(){
		return this._dummy;
		},function(value){
		if (this._dummy!==value){
			(this._dummy)&& (this._dummy._entity=null);
			(value)&& (value._entity=this);
			this._dummy=value;
		}
	});

	/**
	*设置局部位置。
	*@param value 局部位置。
	*/
	/**
	*获取局部位置。
	*@return 局部位置。
	*/
	__getset(0,__proto,'localPosition',function(){
		return this._localPosition;
		},function(value){
		this._localPosition=value;
		this._localUpdate=true;
		this._onWorldPositionTransform();
	});

	/**
	*设置世界位置。
	*@param value 世界位置。
	*/
	/**
	*获取世界位置。
	*@return 世界位置。
	*/
	__getset(0,__proto,'position',function(){
		if (this._positionUpdate){
			if (this._parent !=null){
				var parentPosition=this._parent.position;
				Vector3.multiply(this._localPosition,this._parent.scale,Transform3D._tempVector30);
				Vector3.transformQuat(Transform3D._tempVector30,this._parent.rotation,Transform3D._tempVector30);
				Vector3.add(parentPosition,Transform3D._tempVector30,this._position);
				}else {
				this._localPosition.cloneTo(this._position);
			}
			this._positionUpdate=false;
		}
		return this._position;
		},function(value){
		if (this._parent !=null){
			Vector3.subtract(value,this._parent.position,this._localPosition);
			var parentScaleE=this._parent.scale.elements;
			var psX=parentScaleE[0],psY=parentScaleE[1],psZ=parentScaleE[2];
			if (psX!==1.0 || psY!==1.0 || psZ!==1.0){
				var invertScale=Transform3D._tempVector30;
				var invertScaleE=invertScale.elements;
				invertScaleE[0]=1.0 / psX;
				invertScaleE[1]=1.0 / psY;
				invertScaleE[2]=1.0 / psZ;
				Vector3.multiply(this._localPosition,invertScale,this._localPosition);
			};
			var parentRotation=this._parent.rotation;
			parentRotation.invert(Transform3D._tempQuaternion0);
			Vector3.transformQuat(this._localPosition,Transform3D._tempQuaternion0,this._localPosition);
			}else {
			value.cloneTo(this._localPosition);
		}
		this.localPosition=this._localPosition;
		this._position=value;
		this._positionUpdate=false;
	});

	/**
	*设置局部缩放。
	*@param value 局部缩放。
	*/
	/**
	*获取局部缩放。
	*@return 局部缩放。
	*/
	__getset(0,__proto,'localScale',function(){
		return this._localScale;
		},function(value){
		this._localScale=value;
		this._localUpdate=true;
		if (this.pivot && (this.pivot.x!==0 || this.pivot.y!==0 || this.pivot.z!==0))
			this._onWorldPositionScaleTransform();
		else
		this._onWorldScaleTransform();
	});

	/**
	*设置局部空间的旋转角度。
	*@param value 欧拉角的旋转值，顺序为x、y、z。
	*/
	/**
	*获取局部空间的旋转角度。
	*@return 欧拉角的旋转值，顺序为x、y、z。
	*/
	__getset(0,__proto,'localRotationEuler',function(){
		if (this._locaEulerlUpdate){
			this._localRotation.getYawPitchRoll(Transform3D._tempVector30);
			var eulerE=Transform3D._tempVector30.elements;
			var localRotationEulerE=this._localRotationEuler.elements;
			localRotationEulerE[0]=eulerE[1] *Transform3D._angleToRandin;
			localRotationEulerE[1]=eulerE[0] *Transform3D._angleToRandin;
			localRotationEulerE[2]=eulerE[2] *Transform3D._angleToRandin;
		}
		return this._localRotationEuler;
		},function(value){
		this._localRotationEuler=value;
		this._locaEulerlUpdate=false;
		this._localQuaternionUpdate=true;
		this._localUpdate=true;
		if (this.pivot && (this.pivot.x!==0 || this.pivot.y!==0 || this.pivot.z!==0))
			this._onWorldPositionRotationTransform();
		else
		this._onWorldRotationTransform();
	});

	/**
	*设置世界旋转。
	*@param value 世界旋转。
	*/
	/**
	*获取世界旋转。
	*@return 世界旋转。
	*/
	__getset(0,__proto,'rotation',function(){
		if (this._rotationUpdate){
			if (this._parent !=null)
				Quaternion.multiply(this._parent.rotation,this.localRotation,this._rotation);
			else
			this.localRotation.cloneTo(this._rotation);
			this._rotationUpdate=false;
		}
		return this._rotation;
		},function(value){
		if (this._parent !=null){
			this._parent.rotation.invert(Transform3D._tempQuaternion0);
			Quaternion.multiply(value,Transform3D._tempQuaternion0,this._localRotation);
			}else {
			value.cloneTo(this._localRotation);
		}
		this.localRotation=this._localRotation;
		this._rotation=value;
		this._rotationUpdate=false;
	});

	/**
	*设置世界缩放。
	*@param value 世界缩放。
	*/
	/**
	*获取世界缩放。
	*@return 世界缩放。
	*/
	__getset(0,__proto,'scale',function(){
		if (!this._scaleUpdate)
			return this._scale;
		if (this._parent!==null)
			Vector3.multiply(this._parent.scale,this._localScale,this._scale);
		else
		this._localScale.cloneTo(this._scale);
		this._scaleUpdate=false;
		return this._scale;
		},function(value){
		if (this._parent!==null){
			var pScaleE=this._parent.scale.elements;
			var invPScaleE=Transform3D._tempVector30.elements;
			invPScaleE[0]=1.0 / pScaleE[0];
			invPScaleE[1]=1.0 / pScaleE[1];
			invPScaleE[2]=1.0 / pScaleE[2];
			Vector3.multiply(value,Transform3D._tempVector30,this._localScale);
			}else {
			value.cloneTo(this._localScale);
		}
		this.localScale=this._localScale;
		this._scale=value;
		this._scaleUpdate=false;
	});

	/**
	*设置局部空间的旋转角度。
	*@param 欧拉角的旋转值，顺序为x、y、z。
	*/
	__getset(0,__proto,'rotationEuler',null,function(value){
		Quaternion.createFromYawPitchRoll(value.y,value.x,value.z,this._rotation);
		this.rotation=this._rotation;
	});

	/**
	*获取向前方向。
	*@return 向前方向。
	*/
	__getset(0,__proto,'forward',function(){
		var worldMatElem=this.worldMatrix.elements;
		this._forward.elements[0]=-worldMatElem[8];
		this._forward.elements[1]=-worldMatElem[9];
		this._forward.elements[2]=-worldMatElem[10];
		return this._forward;
	});

	/**
	*获取向上方向。
	*@return 向上方向。
	*/
	__getset(0,__proto,'up',function(){
		var worldMatElem=this.worldMatrix.elements;
		this._up.elements[0]=worldMatElem[4];
		this._up.elements[1]=worldMatElem[5];
		this._up.elements[2]=worldMatElem[6];
		return this._up;
	});

	/**
	*获取向右方向。
	*@return 向右方向。
	*/
	__getset(0,__proto,'right',function(){
		var worldMatElem=this.worldMatrix.elements;
		this._right.elements[0]=worldMatElem[0];
		this._right.elements[1]=worldMatElem[1];
		this._right.elements[2]=worldMatElem[2];
		return this._right;
	});

	/**
	*设置父3D变换。
	*@param value 父3D变换。
	*/
	/**
	*获取父3D变换。
	*@return 父3D变换。
	*/
	__getset(0,__proto,'parent',function(){
		return this._parent;
		},function(value){
		if (this._parent!==value){
			if (this._parent){
				var parentChilds=this._parent._childs;
				var index=parentChilds.indexOf(this);
				parentChilds.splice(index,1);
			}
			if (value){
				value._childs.push(this);
				(value)&& (this._onWorldTransform());
			}
			this._parent=value;
		}
	});

	__static(Transform3D,
	['_tempVector30',function(){return this._tempVector30=new Vector3();},'_tempVector31',function(){return this._tempVector31=new Vector3();},'_tempVector32',function(){return this._tempVector32=new Vector3();},'_tempVector33',function(){return this._tempVector33=new Vector3();},'_tempQuaternion0',function(){return this._tempQuaternion0=new Quaternion();},'_tempMatrix0',function(){return this._tempMatrix0=new Matrix4x4();},'_angleToRandin',function(){return this._angleToRandin=180 / Math.PI;}
	]);
	return Transform3D;
})(EventDispatcher)


/**
*<code>TransformUV</code> 类用于实现UV变换。
*/
//class laya.d3.core.TransformUV extends laya.events.EventDispatcher
var TransformUV=(function(_super){
	function TransformUV(){
		/**@private */
		this._rotation=0;
		/**@private */
		//this._tiling=null;
		/**@private */
		this._matNeedUpdte=false;
		TransformUV.__super.call(this);
		this._matrix=new Matrix4x4();
		this._offset=new Vector2();
		this._tiling=new Vector2(1.0,1.0);
	}

	__class(TransformUV,'laya.d3.core.TransformUV',_super);
	var __proto=TransformUV.prototype;
	Laya.imps(__proto,{"laya.d3.core.IClone":true})
	/**
	*@private
	*/
	__proto._updateMatrix=function(){
		TransformUV._tempOffsetV3.elements[0]=this._offset.x;
		TransformUV._tempOffsetV3.elements[1]=this._offset.y;
		Quaternion.createFromYawPitchRoll(0,0,this._rotation,TransformUV._tempRotationQua);
		TransformUV._tempTitlingV3.elements[0]=this._tiling.x;
		TransformUV._tempTitlingV3.elements[1]=this._tiling.y;
		Matrix4x4.createAffineTransformation(TransformUV._tempOffsetV3,TransformUV._tempRotationQua,TransformUV._tempTitlingV3,this._matrix);
	}

	/**
	*克隆。
	*@param destObject 克隆源。
	*/
	__proto.cloneTo=function(destObject){
		destObject._matrix=this._matrix.clone();
		destObject._offset=this._offset.clone();
		destObject._rotation=this._rotation;
		destObject._tiling=this._tiling.clone();
	}

	/**
	*克隆。
	*@return 克隆副本。
	*/
	__proto.clone=function(){
		var dest=/*__JS__ */new this.constructor();
		this.cloneTo(dest);
		return dest;
	}

	/**
	*获取变换矩阵。
	*@return 变换矩阵。
	*/
	__getset(0,__proto,'matrix',function(){
		if (this._matNeedUpdte){
			this._updateMatrix();
			this._matNeedUpdte=false;
		}
		return this._matrix;
	});

	/**
	*设置平铺次数。
	*@param value 平铺次数。
	*/
	/**
	*获取平铺次数。
	*@return 平铺次数。
	*/
	__getset(0,__proto,'tiling',function(){
		return this._tiling;
		},function(value){
		this._tiling=value;
		this._matNeedUpdte=true;
	});

	/**
	*设置偏移。
	*@param value 偏移。
	*/
	/**
	*获取偏移。
	*@return 偏移。
	*/
	__getset(0,__proto,'offset',function(){
		return this._offset;
		},function(value){
		this._offset=value;
		this._matNeedUpdte=true;
	});

	/**
	*设置旋转。
	*@param value 旋转。
	*/
	/**
	*获取旋转。
	*@return 旋转。
	*/
	__getset(0,__proto,'rotation',function(){
		return this._rotation;
		},function(value){
		this._rotation=value;
		this._matNeedUpdte=true;
	});

	__static(TransformUV,
	['_tempOffsetV3',function(){return this._tempOffsetV3=new Vector3(0,0,0);},'_tempRotationQua',function(){return this._tempRotationQua=new Quaternion();},'_tempTitlingV3',function(){return this._tempTitlingV3=new Vector3(1,1,1);}
	]);
	return TransformUV;
})(EventDispatcher)


/**
*<code>CollsionManager</code> 类用于碰撞管理器。
*/
//class laya.d3.utils.CollisionManager extends laya.events.EventDispatcher
var CollisionManager=(function(_super){
	/**
	*创建一个新的 <code>CollsionManager</code> 实例。
	*/
	function CollisionManager(){
		CollisionManager.__super.call(this);
	}

	__class(CollisionManager,'laya.d3.utils.CollisionManager',_super);
	CollisionManager._onTrigger=function(rigidCol,receiveCol,rigidScripts,receiveScripts,bothRigid){
		var i=0,n=0;
		var rigidID=rigidCol.id;
		var receiveID=receiveCol.id;
		if (!rigidCol._ignoreCollisonMap[receiveID]){
			var colMan=Physics.collisionManager;
			var needTest=rigidCol._runtimeCollisonTestMap[receiveID];
			if (needTest !=null){
				if (needTest){
					if (rigidCol._collisonTo(receiveCol)){
						if (rigidCol._runtimeCollisonMap[receiveID]){
							for (i=0,n=rigidScripts.length;i < n;i++)
							rigidScripts[i].onTriggerStay(receiveCol);
							for (i=0,n=receiveScripts.length;i < n;i++)
							receiveScripts[i].onTriggerStay(rigidCol);
							colMan.event(/*laya.events.Event.TRIGGER_STAY*/"triggerstay",[rigidCol,receiveCol]);
							}else {
							rigidCol._runtimeCollisonMap[receiveID]=receiveCol;
							rigidCol._runtimeCollisonTestMap[receiveID]=false;
							receiveCol._runtimeCollisonMap[rigidID]=rigidCol;
							if (bothRigid)
								receiveCol._runtimeCollisonTestMap[rigidID]=false;
							for (i=0,n=rigidScripts.length;i < n;i++)
							rigidScripts[i].onTriggerEnter(receiveCol);
							for (i=0,n=receiveScripts.length;i < n;i++)
							receiveScripts[i].onTriggerEnter(rigidCol);
							colMan.event(/*laya.events.Event.TRIGGER_ENTER*/"triggerenter",[rigidCol,receiveCol]);
						}
						}else {
						var rigidMap=rigidCol._runtimeCollisonMap;
						if (rigidMap[receiveID]){
							delete rigidMap[receiveID];
							delete rigidCol._runtimeCollisonTestMap[receiveID];
							delete receiveCol._runtimeCollisonMap[rigidID];
							if (bothRigid)
								delete receiveCol._runtimeCollisonTestMap[rigidID];
							for (i=0,n=rigidScripts.length;i < n;i++)
							rigidScripts[i].onTriggerExit(receiveCol);
							for (i=0,n=receiveScripts.length;i < n;i++)
							receiveScripts[i].onTriggerExit(rigidCol);
							colMan.event(/*laya.events.Event.TRIGGER_EXIT*/"triggerexit",[rigidCol,receiveCol]);
						}
					}
					}else {
					for (i=0,n=rigidScripts.length;i < n;i++)
					rigidScripts[i].onTriggerStay(receiveCol);
					for (i=0,n=receiveScripts.length;i < n;i++)
					receiveScripts[i].onTriggerStay(rigidCol);
					colMan.event(/*laya.events.Event.TRIGGER_STAY*/"triggerstay",[rigidCol,receiveCol]);
				}
				}else {
				if (rigidCol._collisonTo(receiveCol)){
					rigidCol._runtimeCollisonMap[receiveID]=receiveCol;
					rigidCol._runtimeCollisonTestMap[receiveID]=false;
					receiveCol._runtimeCollisonMap[rigidID]=rigidCol;
					if (bothRigid)
						receiveCol._runtimeCollisonTestMap[rigidID]=false;
					for (i=0,n=rigidScripts.length;i < n;i++)
					rigidScripts[i].onTriggerEnter(receiveCol);
					for (i=0,n=receiveScripts.length;i < n;i++)
					receiveScripts[i].onTriggerEnter(rigidCol);
					colMan.event(/*laya.events.Event.TRIGGER_ENTER*/"triggerenter",[rigidCol,receiveCol]);
				}
			}
		}
	}

	CollisionManager._triggerCollision=function(){
		var colList=Layer._collsionTestList;
		var colCount=colList.length;
		var colMat=Physics._layerCollsionMatrix;
		for (var i=0;i < colCount;i++){
			var row=colList[i];
			var rowLayer=Layer.getLayerByNumber(row);
			var rowColliders=rowLayer._colliders;
			var rowRigOffset=rowLayer._nonRigidbodyOffset;
			for (var j=colCount-1;j >=i;j--){
				var col=colList[j];
				var test=colMat[row][(/*laya.d3.core.Layer.maxCount*/31-1)-col];
				if (test){
					var k=0,c=0,x=0,z=0;
					var rowCol,colCol,rowScripts;
					var colLayer=Layer.getLayerByNumber(col);
					var colColliders=colLayer._colliders;
					var colRigOffset=colLayer._nonRigidbodyOffset;
					if (rowLayer!==colLayer){
						for (k=0;k < rowRigOffset;k++){
							rowCol=rowColliders[k];
							if (rowCol.enable){
								rowScripts=rowCol.owner._scripts;
								for (x=0,z=colRigOffset;x < z;x++){
									colCol=colColliders[x];
									(colCol.enable)&& (CollisionManager._onTrigger(rowCol,colCol,rowScripts,colCol.owner._scripts,true));
								}
								for (x=colRigOffset,z=colColliders.length;x < z;x++){
									colCol=colColliders[x];
									(colCol.enable)&& (CollisionManager._onTrigger(rowCol,colCol,rowScripts,colCol.owner._scripts,false));
								}
							}
						}
						for (k=rowRigOffset,c=rowColliders.length;k < c;k++){
							rowCol=rowColliders[k];
							if (rowCol.enable){
								rowScripts=rowCol.owner._scripts;
								for (x=0,z=colLayer._nonRigidbodyOffset;x < z;x++){
									colCol=colColliders[x];
									(colCol.enable)&& (CollisionManager._onTrigger(colCol,rowCol,rowScripts,colCol.owner._scripts,false));
								}
							}
						}
						}else {
						for (k=0;k < rowRigOffset;k++){
							rowCol=rowColliders[k];
							if (rowCol.enable){
								rowScripts=rowCol.owner._scripts;
								for (x=k+1,z=rowRigOffset;x < z;x++){
									colCol=colColliders[x];
									(colCol.enable)&& (CollisionManager._onTrigger(rowCol,colCol,rowScripts,colCol.owner._scripts,true));
								}
								for (x=rowRigOffset,z=rowColliders.length;x < z;x++){
									colCol=colColliders[x];
									(colCol.enable)&& (CollisionManager._onTrigger(rowCol,colCol,rowScripts,colCol.owner._scripts,false));
								}
							}
						}
					}
				}
			}
		}
	}

	return CollisionManager;
})(EventDispatcher)


/**
*<code>SplineCurvePosition</code> 类用于通过顶点创建闪光插值。
*/
//class laya.d3.core.glitter.SplineCurvePosition extends laya.d3.core.glitter.SplineCurvePositionVelocity
var SplineCurvePosition=(function(_super){
	/**
	*创建一个 <code>SplineCurvePosition</code> 实例。
	*/
	function SplineCurvePosition(){
		SplineCurvePosition.__super.call(this);
	}

	__class(SplineCurvePosition,'laya.d3.core.glitter.SplineCurvePosition',_super);
	var __proto=SplineCurvePosition.prototype;
	/**
	*@private
	*计算速度。
	*/
	__proto._CalcVelocity=function(left,right,out){
		Vector3.subtract(left,right,out);
		Vector3.scale(out,0.5,out);
	}

	/**
	*初始化插值所需信息。
	*@param lastPosition0 顶点0的上次位置。
	*@param position0 顶点0的位置。
	*@param lastPosition1 顶点1的上次位置。
	*@param position1 顶点1的位置。
	*/
	__proto.Init=function(lastPosition0,position0,lastPosition1,position1){
		this._CalcVelocity(position0,lastPosition0,this._tempVector30);
		this._CalcVelocity(position1,lastPosition1,this._tempVector31);
		_super.prototype.Init.call(this,position0,this._tempVector30,position1,this._tempVector31);
	}

	return SplineCurvePosition;
})(SplineCurvePositionVelocity)


/**
*<code>BoxShape</code> 类用于创建球形粒子形状。
*/
//class laya.d3.core.particleShuriKen.module.shape.BoxShape extends laya.d3.core.particleShuriKen.module.shape.BaseShape
var BoxShape=(function(_super){
	function BoxShape(){
		/**发射器X轴长度。*/
		this.x=NaN;
		/**发射器Y轴长度。*/
		this.y=NaN;
		/**发射器Z轴长度。*/
		this.z=NaN;
		BoxShape.__super.call(this);
		this.x=1.0;
		this.y=1.0;
		this.z=1.0;
		this.randomDirection=false;
	}

	__class(BoxShape,'laya.d3.core.particleShuriKen.module.shape.BoxShape',_super);
	var __proto=BoxShape.prototype;
	/**
	*@inheritDoc
	*/
	__proto._getShapeBoundBox=function(boundBox){
		var minE=boundBox.min.elements;
		minE[0]=-this.x *0.5;
		minE[1]=-this.y *0.5;
		minE[2]=-this.z *0.5;
		var maxE=boundBox.max.elements;
		maxE[0]=this.x *0.5;
		maxE[1]=this.y *0.5;
		maxE[2]=this.z *0.5;
	}

	/**
	*@inheritDoc
	*/
	__proto._getSpeedBoundBox=function(boundBox){
		var minE=boundBox.min.elements;
		minE[0]=0.0;
		minE[1]=0.0;
		minE[2]=0.0;
		var maxE=boundBox.max.elements;
		maxE[0]=0.0;
		maxE[1]=1.0;
		maxE[2]=0.0;
	}

	/**
	*用于生成粒子初始位置和方向。
	*@param position 粒子位置。
	*@param direction 粒子方向。
	*/
	__proto.generatePositionAndDirection=function(position,direction,rand,randomSeeds){
		var rpE=position.elements;
		var rdE=direction.elements;
		if (rand){
			rand.seed=randomSeeds[16];
			ShapeUtils._randomPointInsideHalfUnitBox(position,rand);
			randomSeeds[16]=rand.seed;
			}else {
			ShapeUtils._randomPointInsideHalfUnitBox(position);
		}
		rpE[0]=this.x *rpE[0];
		rpE[1]=this.y *rpE[1];
		rpE[2]=this.z *rpE[2];
		if (this.randomDirection){
			if (rand){
				rand.seed=randomSeeds[17];
				ShapeUtils._randomPointUnitSphere(direction,rand);
				randomSeeds[17]=rand.seed;
				}else {
				ShapeUtils._randomPointUnitSphere(direction);
			}
			}else {
			rdE[0]=0.0;
			rdE[1]=0.0;
			rdE[2]=1.0;
		}
	}

	__proto.cloneTo=function(destObject){
		_super.prototype.cloneTo.call(this,destObject);
		var destShape=destObject;
		destShape.x=this.x;
		destShape.y=this.y;
		destShape.z=this.z;
		destShape.randomDirection=this.randomDirection;
	}

	return BoxShape;
})(BaseShape)


/**
*<code>CircleShape</code> 类用于创建环形粒子形状。
*/
//class laya.d3.core.particleShuriKen.module.shape.CircleShape extends laya.d3.core.particleShuriKen.module.shape.BaseShape
var CircleShape=(function(_super){
	function CircleShape(){
		/**发射器半径。*/
		this.radius=NaN;
		/**环形弧度。*/
		this.arc=NaN;
		/**从边缘发射。*/
		this.emitFromEdge=false;
		CircleShape.__super.call(this);
		this.radius=1.0;
		this.arc=360.0 / 180.0 *Math.PI;
		this.emitFromEdge=false;
		this.randomDirection=false;
	}

	__class(CircleShape,'laya.d3.core.particleShuriKen.module.shape.CircleShape',_super);
	var __proto=CircleShape.prototype;
	/**
	*@inheritDoc
	*/
	__proto._getShapeBoundBox=function(boundBox){
		var minE=boundBox.min.elements;
		minE[0]=minE[2]=-this.radius;
		minE[1]=0;
		var maxE=boundBox.max.elements;
		maxE[0]=maxE[2]=this.radius;
		maxE[1]=0;
	}

	/**
	*@inheritDoc
	*/
	__proto._getSpeedBoundBox=function(boundBox){
		var minE=boundBox.min.elements;
		minE[0]=minE[1]=-1;
		minE[2]=0;
		var maxE=boundBox.max.elements;
		maxE[0]=maxE[1]=1;
		maxE[2]=0;
	}

	/**
	*用于生成粒子初始位置和方向。
	*@param position 粒子位置。
	*@param direction 粒子方向。
	*/
	__proto.generatePositionAndDirection=function(position,direction,rand,randomSeeds){
		var rpE=position.elements;
		var positionPointE=CircleShape._tempPositionPoint.elements;
		if (rand){
			rand.seed=randomSeeds[16];
			if (this.emitFromEdge)
				ShapeUtils._randomPointUnitArcCircle(this.arc,CircleShape._tempPositionPoint,rand);
			else
			ShapeUtils._randomPointInsideUnitArcCircle(this.arc,CircleShape._tempPositionPoint,rand);
			randomSeeds[16]=rand.seed;
			}else {
			if (this.emitFromEdge)
				ShapeUtils._randomPointUnitArcCircle(this.arc,CircleShape._tempPositionPoint);
			else
			ShapeUtils._randomPointInsideUnitArcCircle(this.arc,CircleShape._tempPositionPoint);
		}
		rpE[0]=-positionPointE[0];
		rpE[1]=positionPointE[1];
		rpE[2]=0;
		Vector3.scale(position,this.radius,position);
		if (this.randomDirection){
			if (rand){
				rand.seed=randomSeeds[17];
				ShapeUtils._randomPointUnitSphere(direction,rand);
				randomSeeds[17]=rand.seed;
				}else {
				ShapeUtils._randomPointUnitSphere(direction);
			}
			}else {
			position.cloneTo(direction);
		}
	}

	__proto.cloneTo=function(destObject){
		_super.prototype.cloneTo.call(this,destObject);
		var destShape=destObject;
		destShape.radius=this.radius;
		destShape.arc=this.arc;
		destShape.emitFromEdge=this.emitFromEdge;
		destShape.randomDirection=this.randomDirection;
	}

	__static(CircleShape,
	['_tempPositionPoint',function(){return this._tempPositionPoint=new Vector2();}
	]);
	return CircleShape;
})(BaseShape)


/**
*<code>ConeShape</code> 类用于创建锥形粒子形状。
*/
//class laya.d3.core.particleShuriKen.module.shape.ConeShape extends laya.d3.core.particleShuriKen.module.shape.BaseShape
var ConeShape=(function(_super){
	function ConeShape(){
		/**发射角度。*/
		this.angle=NaN;
		/**发射器半径。*/
		this.radius=NaN;
		/**椎体长度。*/
		this.length=NaN;
		/**发射类型,0为Base,1为BaseShell,2为Volume,3为VolumeShell。*/
		this.emitType=0;
		ConeShape.__super.call(this);
		this.angle=25.0 / 180.0 *Math.PI;
		this.radius=1.0;
		this.length=5.0;
		this.emitType=0;
		this.randomDirection=false;
	}

	__class(ConeShape,'laya.d3.core.particleShuriKen.module.shape.ConeShape',_super);
	var __proto=ConeShape.prototype;
	/**
	*@inheritDoc
	*/
	__proto._getShapeBoundBox=function(boundBox){
		var coneRadius2=this.radius+this.length *Math.sin(this.angle);
		var coneLength=this.length *Math.cos(this.angle);
		var minE=boundBox.min.elements;
		minE[0]=minE[1]=-coneRadius2;
		minE[2]=0;
		var maxE=boundBox.max.elements;
		maxE[0]=maxE[1]=coneRadius2;
		maxE[2]=coneLength;
	}

	/**
	*@inheritDoc
	*/
	__proto._getSpeedBoundBox=function(boundBox){
		var sinA=Math.sin(this.angle);
		var minE=boundBox.min.elements;
		minE[0]=minE[1]=-sinA;
		minE[2]=0;
		var maxE=boundBox.max.elements;
		maxE[0]=minE[1]=sinA;
		maxE[2]=1;
	}

	/**
	*用于生成粒子初始位置和方向。
	*@param position 粒子位置。
	*@param direction 粒子方向。
	*/
	__proto.generatePositionAndDirection=function(position,direction,rand,randomSeeds){
		var rpE=position.elements;
		var rdE=direction.elements;
		var positionPointE=ConeShape._tempPositionPoint.elements;
		var positionX=NaN;
		var positionY=NaN;
		var directionPointE;
		var dirCosA=Math.cos(this.angle);
		var dirSinA=Math.sin(this.angle);
		switch (this.emitType){
			case 0:
				if (rand){
					rand.seed=randomSeeds[16];
					ShapeUtils._randomPointInsideUnitCircle(ConeShape._tempPositionPoint,rand);
					randomSeeds[16]=rand.seed;
					}else {
					ShapeUtils._randomPointInsideUnitCircle(ConeShape._tempPositionPoint);
				}
				positionX=positionPointE[0];
				positionY=positionPointE[1];
				rpE[0]=positionX *this.radius;
				rpE[1]=positionY *this.radius;
				rpE[2]=0;
				if (this.randomDirection){
					if (rand){
						rand.seed=randomSeeds[17];
						ShapeUtils._randomPointInsideUnitCircle(ConeShape._tempDirectionPoint,rand);
						randomSeeds[17]=rand.seed;
						}else {
						ShapeUtils._randomPointInsideUnitCircle(ConeShape._tempDirectionPoint);
					}
					directionPointE=ConeShape._tempDirectionPoint.elements;
					rdE[0]=directionPointE[0] *dirSinA;
					rdE[1]=directionPointE[1] *dirSinA;
					}else {
					rdE[0]=positionX *dirSinA;
					rdE[1]=positionY *dirSinA;
				}
				rdE[2]=dirCosA;
				break ;
			case 1:
				if (rand){
					rand.seed=randomSeeds[16];
					ShapeUtils._randomPointUnitCircle(ConeShape._tempPositionPoint,rand);
					randomSeeds[16]=rand.seed;
					}else {
					ShapeUtils._randomPointUnitCircle(ConeShape._tempPositionPoint);
				}
				positionX=positionPointE[0];
				positionY=positionPointE[1];
				rpE[0]=positionX *this.radius;
				rpE[1]=positionY *this.radius;
				rpE[2]=0;
				if (this.randomDirection){
					if (rand){
						rand.seed=randomSeeds[17];
						ShapeUtils._randomPointInsideUnitCircle(ConeShape._tempDirectionPoint,rand);
						randomSeeds[17]=rand.seed;
						}else {
						ShapeUtils._randomPointInsideUnitCircle(ConeShape._tempDirectionPoint);
					}
					directionPointE=ConeShape._tempDirectionPoint.elements;
					rdE[0]=directionPointE[0] *dirSinA;
					rdE[1]=directionPointE[1] *dirSinA;
					}else {
					rdE[0]=positionX *dirSinA;
					rdE[1]=positionY *dirSinA;
				}
				rdE[2]=dirCosA;
				break ;
			case 2:
				if (rand){
					rand.seed=randomSeeds[16];
					ShapeUtils._randomPointInsideUnitCircle(ConeShape._tempPositionPoint,rand);
					}else {
					ShapeUtils._randomPointInsideUnitCircle(ConeShape._tempPositionPoint);
				}
				positionX=positionPointE[0];
				positionY=positionPointE[1];
				rpE[0]=positionX *this.radius;
				rpE[1]=positionY *this.radius;
				rpE[2]=0;
				rdE[0]=positionX *dirSinA;
				rdE[1]=positionY *dirSinA;
				rdE[2]=dirCosA;
				Vector3.normalize(direction,direction);
				if (rand){
					Vector3.scale(direction,this.length *rand.getFloat(),direction);
					randomSeeds[16]=rand.seed;
					}else {
					Vector3.scale(direction,this.length *Math.random(),direction);
				}
				Vector3.add(position,direction,position);
				if (this.randomDirection){
					if (rand){
						rand.seed=randomSeeds[17];
						ShapeUtils._randomPointUnitSphere(direction,rand);
						randomSeeds[17]=rand.seed;
						}else {
						ShapeUtils._randomPointUnitSphere(direction);
					}
				}
				break ;
			case 3:
				if (rand){
					rand.seed=randomSeeds[16];
					ShapeUtils._randomPointUnitCircle(ConeShape._tempPositionPoint,rand);
					}else {
					ShapeUtils._randomPointUnitCircle(ConeShape._tempPositionPoint);
				}
				positionX=positionPointE[0];
				positionY=positionPointE[1];
				rpE[0]=positionX *this.radius;
				rpE[1]=positionY *this.radius;
				rpE[2]=0;
				rdE[0]=positionX *dirSinA;
				rdE[1]=positionY *dirSinA;
				rdE[2]=dirCosA;
				Vector3.normalize(direction,direction);
				if (rand){
					Vector3.scale(direction,this.length *rand.getFloat(),direction);
					randomSeeds[16]=rand.seed;
					}else {
					Vector3.scale(direction,this.length *Math.random(),direction);
				}
				Vector3.add(position,direction,position);
				if (this.randomDirection){
					if (rand){
						rand.seed=randomSeeds[17];
						ShapeUtils._randomPointUnitSphere(direction,rand);
						randomSeeds[17]=rand.seed;
						}else {
						ShapeUtils._randomPointUnitSphere(direction);
					}
				}
				break ;
			default :
				throw new Error("ConeShape:emitType is invalid.");
			}
	}

	__proto.cloneTo=function(destObject){
		_super.prototype.cloneTo.call(this,destObject);
		var destShape=destObject;
		destShape.angle=this.angle;
		destShape.radius=this.radius;
		destShape.length=this.length;
		destShape.emitType=this.emitType;
		destShape.randomDirection=this.randomDirection;
	}

	__static(ConeShape,
	['_tempPositionPoint',function(){return this._tempPositionPoint=new Vector2();},'_tempDirectionPoint',function(){return this._tempDirectionPoint=new Vector2();}
	]);
	return ConeShape;
})(BaseShape)


/**
*<code>HemisphereShape</code> 类用于创建半球形粒子形状。
*/
//class laya.d3.core.particleShuriKen.module.shape.HemisphereShape extends laya.d3.core.particleShuriKen.module.shape.BaseShape
var HemisphereShape=(function(_super){
	function HemisphereShape(){
		/**发射器半径。*/
		this.radius=NaN;
		/**从外壳发射。*/
		this.emitFromShell=false;
		HemisphereShape.__super.call(this);
		this.radius=1.0;
		this.emitFromShell=false;
		this.randomDirection=false;
	}

	__class(HemisphereShape,'laya.d3.core.particleShuriKen.module.shape.HemisphereShape',_super);
	var __proto=HemisphereShape.prototype;
	/**
	*@inheritDoc
	*/
	__proto._getShapeBoundBox=function(boundBox){
		var minE=boundBox.min.elements;
		minE[0]=minE[1]=minE[2]=-this.radius;
		var maxE=boundBox.max.elements;
		maxE[0]=maxE[1]=this.radius;
		maxE[2]=0;
	}

	/**
	*@inheritDoc
	*/
	__proto._getSpeedBoundBox=function(boundBox){
		var minE=boundBox.min.elements;
		minE[0]=minE[1]=-1;
		minE[2]=0;
		var maxE=boundBox.max.elements;
		maxE[0]=maxE[1]=maxE[2]=1;
	}

	/**
	*用于生成粒子初始位置和方向。
	*@param position 粒子位置。
	*@param direction 粒子方向。
	*/
	__proto.generatePositionAndDirection=function(position,direction,rand,randomSeeds){
		var rpE=position.elements;
		if (rand){
			rand.seed=randomSeeds[16];
			if (this.emitFromShell)
				ShapeUtils._randomPointUnitSphere(position,rand);
			else
			ShapeUtils._randomPointInsideUnitSphere(position,rand);
			randomSeeds[16]=rand.seed;
			}else {
			if (this.emitFromShell)
				ShapeUtils._randomPointUnitSphere(position);
			else
			ShapeUtils._randomPointInsideUnitSphere(position);
		}
		Vector3.scale(position,this.radius,position);
		var z=rpE[2];
		(z < 0.0)&& (rpE[2]=z *-1.0);
		if (this.randomDirection){
			if (rand){
				rand.seed=randomSeeds[17];
				ShapeUtils._randomPointUnitSphere(direction,rand);
				randomSeeds[17]=rand.seed;
				}else {
				ShapeUtils._randomPointUnitSphere(direction);
			}
			}else {
			position.cloneTo(direction);
		}
	}

	__proto.cloneTo=function(destObject){
		_super.prototype.cloneTo.call(this,destObject);
		var destShape=destObject;
		destShape.radius=this.radius;
		destShape.emitFromShell=this.emitFromShell;
		destShape.randomDirection=this.randomDirection;
	}

	return HemisphereShape;
})(BaseShape)


/**
*<code>SphereShape</code> 类用于创建球形粒子形状。
*/
//class laya.d3.core.particleShuriKen.module.shape.SphereShape extends laya.d3.core.particleShuriKen.module.shape.BaseShape
var SphereShape=(function(_super){
	function SphereShape(){
		/**发射器半径。*/
		this.radius=NaN;
		/**从外壳发射。*/
		this.emitFromShell=false;
		SphereShape.__super.call(this);
		this.radius=1.0;
		this.emitFromShell=false;
		this.randomDirection=false;
	}

	__class(SphereShape,'laya.d3.core.particleShuriKen.module.shape.SphereShape',_super);
	var __proto=SphereShape.prototype;
	/**
	*@inheritDoc
	*/
	__proto._getShapeBoundBox=function(boundBox){
		var minE=boundBox.min.elements;
		minE[0]=minE[1]=minE[2]=-this.radius;
		var maxE=boundBox.max.elements;
		maxE[0]=maxE[1]=maxE[2]=this.radius;
	}

	/**
	*@inheritDoc
	*/
	__proto._getSpeedBoundBox=function(boundBox){
		var minE=boundBox.min.elements;
		minE[0]=minE[1]=minE[2]=-1;
		var maxE=boundBox.max.elements;
		maxE[0]=maxE[1]=maxE[2]=1;
	}

	/**
	*用于生成粒子初始位置和方向。
	*@param position 粒子位置。
	*@param direction 粒子方向。
	*/
	__proto.generatePositionAndDirection=function(position,direction,rand,randomSeeds){
		if (rand){
			rand.seed=randomSeeds[16];
			if (this.emitFromShell)
				ShapeUtils._randomPointUnitSphere(position,rand);
			else
			ShapeUtils._randomPointInsideUnitSphere(position,rand);
			randomSeeds[16]=rand.seed;
			}else {
			if (this.emitFromShell)
				ShapeUtils._randomPointUnitSphere(position);
			else
			ShapeUtils._randomPointInsideUnitSphere(position);
		}
		Vector3.scale(position,this.radius,position);
		if (this.randomDirection){
			if (rand){
				rand.seed=randomSeeds[17];
				ShapeUtils._randomPointUnitSphere(direction,rand);
				randomSeeds[17]=rand.seed;
				}else {
				ShapeUtils._randomPointUnitSphere(direction);
			}
			}else {
			position.cloneTo(direction);
		}
	}

	__proto.cloneTo=function(destObject){
		_super.prototype.cloneTo.call(this,destObject);
		var destShape=destObject;
		destShape.radius=this.radius;
		destShape.emitFromShell=this.emitFromShell;
		destShape.randomDirection=this.randomDirection;
	}

	return SphereShape;
})(BaseShape)


/**
*@private
*/
//class laya.d3.core.render.SubMeshRenderElement extends laya.d3.core.render.RenderElement
var SubMeshRenderElement=(function(_super){
	function SubMeshRenderElement(){
		/**@private */
		this._batchIndexStart=0;
		/**@private */
		this._batchIndexEnd=0;
		/**@private */
		this._skinAnimationDatas=null;
		SubMeshRenderElement.__super.call(this);
	}

	__class(SubMeshRenderElement,'laya.d3.core.render.SubMeshRenderElement',_super);
	return SubMeshRenderElement;
})(RenderElement)


/**
*@private
*<code>ShaderCompile</code> 类用于创建Shader编译类型。
*/
//class laya.d3.shader.ShaderCompile3D extends laya.webgl.utils.ShaderCompile
var ShaderCompile3D=(function(_super){
	function ShaderCompile3D(name,vs,ps,attributeMap,uniformMap,includeFiles){
		/**@private */
		this._name=NaN;
		/**@private */
		this._attributeMap=null;
		/**@private */
		this._renderElementUniformMap=null;
		/**@private */
		this._materialUniformMap=null;
		/**@private */
		this._spriteUniformMap=null;
		/**@private */
		this._cameraUniformMap=null;
		/**@private */
		this._sceneUniformMap=null;
		this.sharders=null;
		/**@private */
		this._spriteDefineCounter=3;
		/**@private */
		this._spriteInt2name=[];
		/**@private */
		this._spriteName2Int={};
		/**@private */
		this._materialDefineCounter=1;
		/**@private */
		this._materialInt2name=[];
		/**@private */
		this._materialName2Int={};
		this._conchShader=null;
		this._name=name;
		this._renderElementUniformMap={};
		this._materialUniformMap={};
		this._spriteUniformMap={};
		this._cameraUniformMap={};
		this._sceneUniformMap={};
		this.sharders=[];
		this._spriteInt2name[ParallelSplitShadowMap.SHADERDEFINE_RECEIVE_SHADOW]="RECEIVESHADOW";
		this._spriteInt2name[RenderableSprite3D.SHADERDEFINE_SCALEOFFSETLIGHTINGMAPUV]="SCALEOFFSETLIGHTINGMAPUV";
		this._spriteInt2name[RenderableSprite3D.SAHDERDEFINE_LIGHTMAP]="LIGHTMAP";
		this._spriteInt2name[SkinnedMeshSprite3D.SHADERDEFINE_BONE]="BONE";
		this._materialInt2name[BaseMaterial.SHADERDEFINE_ALPHATEST]="ALPHATEST";
		var defineMap={};
		ShaderCompile3D.__super.call(this,name,vs,ps,null,defineMap);
		this._attributeMap=attributeMap;
		var renderElementUnifCount=0,materialUnifCount=0,spriteUnifCount=0;
		var key;
		for (key in uniformMap){
			var uniformParam=uniformMap[key];
			switch (uniformParam[1]){
				case /*laya.d3.shader.Shader3D.PERIOD_RENDERELEMENT*/0:
					this._renderElementUniformMap[key]=uniformParam[0];
					break ;
				case /*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1:
					this._materialUniformMap[key]=uniformParam[0];
					break ;
				case /*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2:
					this._spriteUniformMap[key]=uniformParam[0];
					break ;
				case /*laya.d3.shader.Shader3D.PERIOD_CAMERA*/3:
					this._cameraUniformMap[key]=uniformParam[0];
					break ;
				case /*laya.d3.shader.Shader3D.PERIOD_SCENE*/4:
					this._sceneUniformMap[key]=uniformParam[0];
					break ;
				default :
					throw new Error("ShaderCompile3D: period is unkonw.");
				}
		}
	}

	__class(ShaderCompile3D,'laya.d3.shader.ShaderCompile3D',_super);
	var __proto=ShaderCompile3D.prototype;
	/**
	*@private
	*/
	__proto._definesToNameDic=function(value,int2Name){
		var o={};
		var d=1;
		for (var i=0;i < 32;i++){
			d=1 << i;
			if (d > value)break ;
			if (value & d){
				var name=int2Name[d];
				name && (o[name]="");
			}
		}
		return o;
	}

	/**
	*根据宏动态生成shader文件，支持#include?COLOR_FILTER "parts/ColorFilter_ps_logic.glsl";条件嵌入文件
	*@param name
	*@param vs
	*@param ps
	*@param define 宏定义，格式:{name:value...}
	*@return
	*/
	__proto.withCompile=function(publicDefine,spriteDefine,materialDefine){
		var shader;
		var spriteDefShaders,materialDefShaders;
		spriteDefShaders=this.sharders[publicDefine];
		if (spriteDefShaders){
			materialDefShaders=spriteDefShaders[spriteDefine];
			if (materialDefShaders){
				shader=materialDefShaders[materialDefine];
				if (shader)
					return shader;
				}else {
				materialDefShaders=spriteDefShaders[spriteDefine]=[];
			}
			}else {
			spriteDefShaders=this.sharders[publicDefine]=[];
			materialDefShaders=spriteDefShaders[spriteDefine]=[];
		};
		var publicDefGroup=this._definesToNameDic(publicDefine,ShaderCompile3D._globalInt2name);
		var spriteDefGroup=this._definesToNameDic(spriteDefine,this._spriteInt2name);
		var materialDefGroup=this._definesToNameDic(materialDefine,this._materialInt2name);
		var key;
		if (laya.d3.shader.ShaderCompile3D.debugMode){
			var publicDefGroupStr="";
			for (key in publicDefGroup)
			publicDefGroupStr+=key+" ";
			var spriteDefGroupStr="";
			for (key in spriteDefGroup)
			spriteDefGroupStr+=key+" ";
			var materialDefGroupStr="";
			for (key in materialDefGroup)
			materialDefGroupStr+=key+" ";
			console.log("ShaderCompile3DDebugMode---(Name:"+Shader3D.nameKey.getName(this._name)+" PublicDefine:"+publicDefine+" SpriteDefine:"+spriteDefine+" MaterialDefine:"+materialDefine+" PublicDefineGroup:"+publicDefGroupStr+" SpriteDefineGroup:"+spriteDefGroupStr+"MaterialDefineGroup: "+materialDefGroupStr+")---ShaderCompile3DDebugMode");
		};
		var defMap={};
		var defineStr="";
		if (publicDefGroup){
			for (key in publicDefGroup){
				defineStr+="#define "+key+"\n";
				defMap[key]=true;
			}
		}
		if (spriteDefGroup){
			for (key in spriteDefGroup){
				defineStr+="#define "+key+"\n";
				defMap[key]=true;
			}
		}
		if (materialDefGroup){
			for (key in materialDefGroup){
				defineStr+="#define "+key+"\n";
				defMap[key]=true;
			}
		};
		var vs=this._VS.toscript(defMap,[]);
		var ps=this._PS.toscript(defMap,[]);
		shader=Shader3D.create(defineStr+vs.join('\n'),defineStr+ps.join('\n'),this._attributeMap,this._sceneUniformMap,this._cameraUniformMap,this._spriteUniformMap,this._materialUniformMap,this._renderElementUniformMap);
		materialDefShaders[materialDefine]=shader;
		return shader;
	}

	/**
	*通过宏定义预编译shader。
	*@param spriteIntToNameDic 精灵宏定义数组。
	*@param publicDefine 公共宏定义值。
	*@param spriteDefine 精灵宏定义值。
	*@param materialDefine 材质宏定义值。
	*/
	__proto.precompileShaderWithShaderDefine=function(publicDefine,spriteDefine,materialDefine){
		this.withCompile(publicDefine,spriteDefine,materialDefine);
	}

	/**
	*注册材质宏定义。
	*@param name 宏定义名称。
	*@return
	*/
	__proto.addMaterialDefines=function(shaderdefines){
		var defines=shaderdefines.defines;
		for (var k in defines){
			var name=defines[k];
			var i=parseInt(k);
			this._materialInt2name[i]=name;
			this._materialName2Int[name]=i;
		}
	}

	/**
	*注册精灵宏定义。
	*@param name 宏定义名称。
	*@return
	*/
	__proto.addSpriteDefines=function(shaderdefines){
		var defines=shaderdefines.defines;
		for (var k in defines){
			var name=defines[k];
			var i=parseInt(k);
			this._spriteInt2name[i]=name;
			this._spriteName2Int[name]=i;
		}
	}

	/**
	*通过名称获取宏定义值。
	*@param name 名称。
	*@return 宏定义值。
	*/
	__proto.getMaterialDefineByName=function(name){
		return this._materialName2Int[name];
	}

	/**
	*注册材质宏定义。
	*@param name 宏定义名称。
	*@return
	*/
	__proto.registerMaterialDefine=function(name){
		var value=Math.pow(2,this._materialDefineCounter++);
		this._materialInt2name[value]=name;
		this._materialName2Int[name]=value;
		return value;
	}

	/**
	*注册精灵宏定义。
	*@param name 宏定义名称。
	*@return
	*/
	__proto.registerSpriteDefine=function(name){
		var value=Math.pow(2,this._spriteDefineCounter++);
		this._spriteInt2name[value]=name;
		this._spriteName2Int[name]=value;
		return value;
	}

	ShaderCompile3D._globalRegDefine=function(name,value){
		ShaderCompile3D._globalInt2name[value]=name;
	}

	ShaderCompile3D.add=function(nameID,vs,ps,attributeMap,uniformMap){
		return laya.d3.shader.ShaderCompile3D._preCompileShader[nameID]=new ShaderCompile3D(nameID,vs,ps,attributeMap,uniformMap,ShaderCompile.includes);
	}

	ShaderCompile3D.get=function(name){
		return laya.d3.shader.ShaderCompile3D._preCompileShader[Shader3D.nameKey.getID(name)];
	}

	ShaderCompile3D._preCompileShader={};
	ShaderCompile3D._globalInt2name=[];
	ShaderCompile3D.debugMode=false;
	ShaderCompile3D.SHADERDEFINE_HIGHPRECISION=0x1;
	ShaderCompile3D.SHADERDEFINE_FOG=0x4;
	ShaderCompile3D.SHADERDEFINE_DIRECTIONLIGHT=0x8;
	ShaderCompile3D.SHADERDEFINE_POINTLIGHT=0x10;
	ShaderCompile3D.SHADERDEFINE_SPOTLIGHT=0x20;
	ShaderCompile3D.SHADERDEFINE_UV0=0x40;
	ShaderCompile3D.SHADERDEFINE_COLOR=0x80;
	ShaderCompile3D.SHADERDEFINE_UV1=0x100;
	ShaderCompile3D.SAHDERDEFINE_DEPTHFOG=0x20000;
	return ShaderCompile3D;
})(ShaderCompile)


/**
*@private
*<code>MeshSprite3DStaticBatchManager</code> 类用于网格精灵静态批处理管理。
*/
//class laya.d3.graphics.MeshSprite3DStaticBatchManager extends laya.d3.graphics.StaticBatchManager
var MeshSprite3DStaticBatchManager=(function(_super){
	/**i
	*创建一个 <code>MeshSprite3DStaticBatchManager</code> 实例。
	*/
	function MeshSprite3DStaticBatchManager(){
		MeshSprite3DStaticBatchManager.__super.call(this);
	}

	__class(MeshSprite3DStaticBatchManager,'laya.d3.graphics.MeshSprite3DStaticBatchManager',_super);
	var __proto=MeshSprite3DStaticBatchManager.prototype;
	/**
	*@private
	*/
	__proto._getStaticBatch=function(rootOwner,vertexDeclaration,material,number){
		var staticBatch;
		var key;
		if (rootOwner)
			key=rootOwner.id.toString()+material.id.toString()+vertexDeclaration.id.toString()+number.toString();
		else
		key=material.id.toString()+vertexDeclaration.id.toString()+number.toString();
		if (!this._staticBatches[key])
			this._staticBatches[key]=staticBatch=new SubMeshStaticBatch(key,this,rootOwner,vertexDeclaration,material);
		else
		staticBatch=this._staticBatches[key];
		return staticBatch;
	}

	/**
	*@inheritDoc
	*/
	__proto._initStaticBatchs=function(rootOwner){
		this._initBatchRenderElements.sort(MeshSprite3DStaticBatchManager._sortPrepareStaticBatch);
		var lastMaterial;
		var lastVertexDeclaration;
		var lastCanMerage=false;
		var curStaticBatch;
		var batchNumber=0;
		for (var i=0,n=this._initBatchRenderElements.length;i < n;i++){
			var renderElement=this._initBatchRenderElements[i];
			var vb=renderElement.renderObj._getVertexBuffer(0);
			var originalOwner=renderElement._sprite3D;
			if ((lastVertexDeclaration===vb.vertexDeclaration)&& (lastMaterial===renderElement._material)){
				var oldStaticBatch;
				if (!lastCanMerage){
					var lastRenderObj=this._initBatchRenderElements[i-1];
					var lastRenderElement=lastRenderObj.renderObj;
					var curRenderElement=renderElement.renderObj;
					if (((lastRenderElement._getVertexBuffer().vertexCount+curRenderElement._getVertexBuffer().vertexCount)> /*laya.d3.graphics.StaticBatch.maxBatchVertexCount*/65535)){
						lastCanMerage=false;
						}else {
						curStaticBatch=this._getStaticBatch(rootOwner,lastVertexDeclaration,lastMaterial,batchNumber);
						oldStaticBatch=lastRenderObj._staticBatch;
						if (oldStaticBatch!==curStaticBatch){
							(oldStaticBatch)&& (oldStaticBatch._deleteCombineBatchRenderObj(lastRenderObj));
							curStaticBatch._addCombineBatchRenderObj(lastRenderObj);
						}
						oldStaticBatch=renderElement._staticBatch;
						if (oldStaticBatch!==curStaticBatch){
							(oldStaticBatch)&& (oldStaticBatch._deleteCombineBatchRenderObj(renderElement));
							curStaticBatch._addCombineBatchRenderObj(renderElement);
						}
						lastCanMerage=true;
					}
					}else {
					if (!curStaticBatch._addCombineBatchRenderObjTest(renderElement)){
						lastCanMerage=false;
						batchNumber++;
						}else {
						oldStaticBatch=renderElement._staticBatch;
						if (oldStaticBatch!==curStaticBatch){
							(oldStaticBatch)&& (oldStaticBatch._deleteCombineBatchRenderObj(renderElement));
							curStaticBatch._addCombineBatchRenderObj(renderElement)
						}
					}
				}
				}else {
				lastCanMerage=false;
				batchNumber=0;
			}
			lastMaterial=renderElement._material;
			lastVertexDeclaration=vb.vertexDeclaration;
		}
	}

	MeshSprite3DStaticBatchManager._sortPrepareStaticBatch=function(a,b){
		var aRender=a._render,bRender=b._render;
		var lightMapIndexOffset=aRender.lightmapIndex-bRender.lightmapIndex;
		if (lightMapIndexOffset===0){
			var receiveShadowValue=/*__JS__ */aRender.receiveShadow-bRender.receiveShadow;
			if (receiveShadowValue===0){
				var mainID=a._mainSortID-b._mainSortID;
				if (mainID===0){
					return a.renderObj.triangleCount-b.renderObj.triangleCount;
					}else {
					return mainID;
				}
				}else {
				return receiveShadowValue;
			}
			}else {
			return lightMapIndexOffset;
		}
	}

	return MeshSprite3DStaticBatchManager;
})(StaticBatchManager)


/**
*<code>SubMeshStaticBatch</code> 类用于网格静态合并。
*/
//class laya.d3.graphics.SubMeshStaticBatch extends laya.d3.graphics.StaticBatch
var SubMeshStaticBatch=(function(_super){
	function SubMeshStaticBatch(key,manager,rootOwner,vertexDeclaration,material){
		/**@private */
		this._batchOwnerIndices=null;
		/**@private */
		this._batchOwners=null;
		/**@private */
		this._needFinishCombine=false;
		/**@private */
		this._currentCombineVertexCount=0;
		/**@private */
		this._currentCombineIndexCount=0;
		/**@private */
		this._vertexDeclaration=null;
		/**@private */
		this._vertexBuffer=null;
		/**@private */
		this._indexBuffer=null;
		SubMeshStaticBatch.__super.call(this,key,manager,rootOwner);
		this._batchOwnerIndices=[];
		this._batchOwners=[];
		this._needFinishCombine=false;
		this._currentCombineVertexCount=0;
		this._currentCombineIndexCount=0;
		this._vertexDeclaration=vertexDeclaration;
		this._material=material;
	}

	__class(SubMeshStaticBatch,'laya.d3.graphics.SubMeshStaticBatch',_super);
	var __proto=SubMeshStaticBatch.prototype;
	/**
	*@inheritDoc
	*/
	__proto._compareBatchRenderElement=function(a,b){
		return (a)._batchIndexStart > (b)._batchIndexStart;
	}

	/**
	*@private
	*/
	__proto._addCombineBatchRenderObjTest=function(renderElement){
		var vertexCount=0;
		var subMeshVertexCount=(renderElement.renderObj)._vertexCount;
		if (subMeshVertexCount > 0)
			vertexCount=this._currentCombineVertexCount+subMeshVertexCount;
		else
		vertexCount=this._currentCombineVertexCount+renderElement.renderObj._getVertexBuffer().vertexCount;
		if (vertexCount > 65535)
			return false;
		return true;
	}

	/**
	*@private
	*/
	__proto._addCombineBatchRenderObj=function(renderElement){
		var subMesh=renderElement.renderObj;
		var subMeshVertexCount=subMesh._vertexCount;
		this._initBatchRenderElements.push(renderElement);
		renderElement._staticBatch=this;
		if (subMeshVertexCount > 0){
			this._currentCombineIndexCount+=subMesh._indexCount;
			this._currentCombineVertexCount+=subMeshVertexCount;
			}else {
			this._currentCombineIndexCount=this._currentCombineIndexCount+subMesh._getIndexBuffer().indexCount;
			this._currentCombineVertexCount=this._currentCombineVertexCount+subMesh._getVertexBuffer().vertexCount;
		}
		this._needFinishCombine=true;
	}

	/**
	*@private
	*/
	__proto._deleteCombineBatchRenderObj=function(renderElement){
		var subMesh=renderElement.renderObj;
		var index=this._initBatchRenderElements.indexOf(renderElement);
		if (index!==-1){
			this._initBatchRenderElements.splice(index,1);
			renderElement._staticBatch=null;
			var subMeshVertexCount=subMesh._vertexCount;
			if (subMeshVertexCount > 0){
				this._currentCombineIndexCount=this._currentCombineIndexCount-subMesh._indexCount;
				this._currentCombineVertexCount=this._currentCombineVertexCount-subMeshVertexCount;
				}else {
				this._currentCombineIndexCount=this._currentCombineIndexCount-subMesh._getIndexBuffer().indexCount;
				this._currentCombineVertexCount=this._currentCombineVertexCount-subMesh._getVertexBuffer().vertexCount;
			}
			this._needFinishCombine=true;
		}
	}

	/**
	*@inheritDoc
	*/
	__proto._finishInit=function(){
		if (this._needFinishCombine){
			var curMerVerCount=0;
			var curIndexCount=0;
			if (this._initBatchRenderElements[0]._sprite3D._render.lightmapIndex >=0){
				this._vertexDeclaration=this._getVertexDecLightMap(this._vertexDeclaration);
				}else {
				if ((this._material instanceof laya.d3.core.material.StandardMaterial )){
					if ((this._material).ambientTexture)
						this._vertexDeclaration=this._getVertexDecLightMap(this._vertexDeclaration);
				}
			};
			var vertexDatas=new Float32Array(this._vertexDeclaration.vertexStride / 4 *this._currentCombineVertexCount);
			var indexDatas=new Uint16Array(this._currentCombineIndexCount);
			if (this._vertexBuffer){
				this._vertexBuffer.destroy();
				this._indexBuffer.destroy();
			}
			this._vertexBuffer=VertexBuffer3D.create(this._vertexDeclaration,this._currentCombineVertexCount,/*laya.webgl.WebGLContext.STATIC_DRAW*/0x88E4);
			this._indexBuffer=IndexBuffer3D.create(/*laya.d3.graphics.IndexBuffer3D.INDEXTYPE_USHORT*/"ushort",this._currentCombineIndexCount,/*laya.webgl.WebGLContext.STATIC_DRAW*/0x88E4);
			for (var i=0,n=this._initBatchRenderElements.length;i < n;i++){
				var renderElement=this._initBatchRenderElements [i];
				var subMesh=renderElement.renderObj;
				var subVertexDatas=subMesh._getStaticBatchBakedVertexs(this._rootOwner ? this._rootOwner._transform :null,renderElement._sprite3D);
				var subIndexDatas=subMesh.getIndices();
				var isInvert=renderElement._sprite3D.transform._isFrontFaceInvert;
				var indexOffset=curMerVerCount / (this._vertexDeclaration.vertexStride / 4)-subMesh._vertexStart;
				var indexStart=curIndexCount;
				var indexEnd=indexStart+subIndexDatas.length;
				renderElement._batchIndexStart=indexStart;
				renderElement._batchIndexEnd=indexEnd;
				indexDatas.set(subIndexDatas,curIndexCount);
				var k=0;
				if (isInvert){
					for (k=indexStart;k < indexEnd;k+=3){
						indexDatas[k]=indexOffset+indexDatas[k];
						var index1=indexDatas[k+1];
						var index2=indexDatas[k+2];
						indexDatas[k+1]=indexOffset+index2;
						indexDatas[k+2]=indexOffset+index1;
					}
					}else {
					for (k=indexStart;k < indexEnd;k+=3){
						indexDatas[k]=indexOffset+indexDatas[k];
						indexDatas[k+1]=indexOffset+indexDatas[k+1];
						indexDatas[k+2]=indexOffset+indexDatas[k+2];
					}
				}
				curIndexCount+=subIndexDatas.length;
				vertexDatas.set(subVertexDatas,curMerVerCount);
				curMerVerCount+=subVertexDatas.length;
			}
			this._vertexBuffer.setData(vertexDatas);
			this._indexBuffer.setData(indexDatas);
			this._needFinishCombine=false;
		}
	}

	/**
	*@inheritDoc
	*/
	__proto._getCombineRenderElementFromPool=function(){
		var renderElement=this._combineRenderElementPool[this._combineRenderElementPoolIndex++];
		return renderElement || (this._combineRenderElementPool[this._combineRenderElementPoolIndex-1]=new SubMeshRenderElement());
	}

	/**
	*@inheritDoc
	*/
	__proto._getRenderElement=function(renderQueueElements,scene,projectionView){
		var lastRenderElement,renderElement;
		var count=this._batchRenderElements.length;
		var canMerge=true;
		for (var i=0;i < count;i++){
			renderElement=this._batchRenderElements [i];
			var render=renderElement._sprite3D._render;
			var lastRender;
			if (i!==0){
				lastRenderElement=this._batchRenderElements [i-1];
				lastRender=lastRenderElement._sprite3D._render;
				canMerge=(lastRender.lightmapIndex!==render.lightmapIndex || lastRender.receiveShadow!==render.receiveShadow || lastRenderElement._batchIndexEnd!==renderElement._batchIndexStart);
			};
			var merageElement;
			if (canMerge){
				merageElement=this._getCombineRenderElementFromPool();
				merageElement.renderObj=this;
				merageElement._material=this._material;
				merageElement._batchIndexStart=(renderElement)._batchIndexStart;
				merageElement._batchIndexEnd=(renderElement)._batchIndexEnd;
				var lightMapIndex=render.lightmapIndex;
				var cacheLightMapIndex=lightMapIndex+1;
				var lightMapBatchOwnerIndices=this._batchOwnerIndices[cacheLightMapIndex];
				(lightMapBatchOwnerIndices)|| (lightMapBatchOwnerIndices=this._batchOwnerIndices[cacheLightMapIndex]=[]);
				var batchOwnerIndex=lightMapBatchOwnerIndices[renderElement._render.receiveShadow ? 1 :0];
				var batchOwner;
				if (batchOwnerIndex===undefined){
					lightMapBatchOwnerIndices[render.receiveShadow ? 1 :0]=this._batchOwners.length;
					batchOwner=new MeshSprite3D(null,"StaticBatchMeshSprite3D");
					batchOwner._scene=scene;
					batchOwner._transform=this._rootOwner ? this._rootOwner._transform :null;
					batchOwner._render.lightmapIndex=lightMapIndex;
					batchOwner._render.receiveShadow=renderElement._render.receiveShadow;
					this._batchOwners.push(batchOwner);
					}else {
					batchOwner=this._batchOwners[batchOwnerIndex];
				}
				batchOwner._render._renderUpdate(projectionView);
				merageElement._sprite3D=batchOwner;
				renderQueueElements.push(merageElement);
				}else {
				merageElement._batchIndexEnd=(renderElement)._batchIndexEnd;
			}
		}
	}

	/**
	*@inheritDoc
	*/
	__proto._beforeRender=function(state){
		this._vertexBuffer._bind();
		this._indexBuffer._bind();
		return true;
	}

	/**
	*@inheritDoc
	*/
	__proto._render=function(state){
		var renderElement=state.renderElement;
		var batchIndexStart=renderElement._batchIndexStart;
		var indexCount=renderElement._batchIndexEnd-batchIndexStart;
		WebGL.mainContext.drawElements(/*laya.webgl.WebGLContext.TRIANGLES*/0x0004,indexCount,/*laya.webgl.WebGLContext.UNSIGNED_SHORT*/0x1403,batchIndexStart *2);
		Stat.drawCall++;
		Stat.trianglesFaces+=indexCount / 3;
	}

	/**
	*@inheritDoc
	*/
	__proto.dispose=function(){
		this._batchOwnerIndices=null;
		this._batchOwners=null;
		this._vertexDeclaration=null;
		this._vertexBuffer.destroy();
		this._indexBuffer.destroy();
	}

	//..................临时.................................
	__proto._getVertexBuffer=function(index){
		(index===void 0)&& (index=0);
		return this._vertexBuffer;
	}

	return SubMeshStaticBatch;
})(StaticBatch)


/**
*<code>Sky</code> 类用于创建天空盒。
*/
//class laya.d3.resource.models.SkyBox extends laya.d3.resource.models.Sky
var SkyBox=(function(_super){
	function SkyBox(){
		/**@private */
		//this._numberVertices=0;
		/**@private */
		//this._numberIndices=0;
		/**@private 天空立方体纹理。 */
		//this._textureCube=null;
		SkyBox.__super.call(this);
		SkyBox._nameNumber++;
		this.loadShaderParams();
		this.createResource();
		this.alphaBlending=1;
		this.colorIntensity=1;
	}

	__class(SkyBox,'laya.d3.resource.models.SkyBox',_super);
	var __proto=SkyBox.prototype;
	/**
	*@private
	*/
	__proto._getShader=function(state){
		var shaderDefineValue=state.scene._shaderDefineValue;
		this._shader=this._shaderCompile.withCompile(shaderDefineValue,0,0);
		return this._shader;
	}

	/**
	*@private
	*/
	__proto.createResource=function(){
		this._numberVertices=36;
		this._numberIndices=36;
		var indices=new Uint16Array(this._numberIndices);
		var vertexFloatStride=SkyBox._vertexDeclaration.vertexStride / 4;
		var vertices=new Float32Array(this._numberVertices *vertexFloatStride);
		var width=1.0;
		var height=1.0;
		var depth=1.0;
		var halfWidth=width / 2.0;
		var halfHeight=height / 2.0;
		var halfDepth=depth / 2.0;
		var topLeftFront=new Vector3(-halfWidth,halfHeight,halfDepth);
		var bottomLeftFront=new Vector3(-halfWidth,-halfHeight,halfDepth);
		var topRightFront=new Vector3(halfWidth,halfHeight,halfDepth);
		var bottomRightFront=new Vector3(halfWidth,-halfHeight,halfDepth);
		var topLeftBack=new Vector3(-halfWidth,halfHeight,-halfDepth);
		var topRightBack=new Vector3(halfWidth,halfHeight,-halfDepth);
		var bottomLeftBack=new Vector3(-halfWidth,-halfHeight,-halfDepth);
		var bottomRightBack=new Vector3(halfWidth,-halfHeight,-halfDepth);
		var vertexCount=0;
		vertexCount=this._addVertex(vertices,vertexCount,topLeftFront);
		vertexCount=this._addVertex(vertices,vertexCount,bottomLeftFront);
		vertexCount=this._addVertex(vertices,vertexCount,topRightFront);
		vertexCount=this._addVertex(vertices,vertexCount,bottomLeftFront);
		vertexCount=this._addVertex(vertices,vertexCount,bottomRightFront);
		vertexCount=this._addVertex(vertices,vertexCount,topRightFront);
		vertexCount=this._addVertex(vertices,vertexCount,topLeftBack);
		vertexCount=this._addVertex(vertices,vertexCount,topRightBack);
		vertexCount=this._addVertex(vertices,vertexCount,bottomLeftBack);
		vertexCount=this._addVertex(vertices,vertexCount,bottomLeftBack);
		vertexCount=this._addVertex(vertices,vertexCount,topRightBack);
		vertexCount=this._addVertex(vertices,vertexCount,bottomRightBack);
		vertexCount=this._addVertex(vertices,vertexCount,topLeftFront);
		vertexCount=this._addVertex(vertices,vertexCount,topRightBack);
		vertexCount=this._addVertex(vertices,vertexCount,topLeftBack);
		vertexCount=this._addVertex(vertices,vertexCount,topLeftFront);
		vertexCount=this._addVertex(vertices,vertexCount,topRightFront);
		vertexCount=this._addVertex(vertices,vertexCount,topRightBack);
		vertexCount=this._addVertex(vertices,vertexCount,bottomLeftFront);
		vertexCount=this._addVertex(vertices,vertexCount,bottomLeftBack);
		vertexCount=this._addVertex(vertices,vertexCount,bottomRightBack);
		vertexCount=this._addVertex(vertices,vertexCount,bottomLeftFront);
		vertexCount=this._addVertex(vertices,vertexCount,bottomRightBack);
		vertexCount=this._addVertex(vertices,vertexCount,bottomRightFront);
		vertexCount=this._addVertex(vertices,vertexCount,topLeftFront);
		vertexCount=this._addVertex(vertices,vertexCount,bottomLeftBack);
		vertexCount=this._addVertex(vertices,vertexCount,bottomLeftFront);
		vertexCount=this._addVertex(vertices,vertexCount,topLeftBack);
		vertexCount=this._addVertex(vertices,vertexCount,bottomLeftBack);
		vertexCount=this._addVertex(vertices,vertexCount,topLeftFront);
		vertexCount=this._addVertex(vertices,vertexCount,topRightFront);
		vertexCount=this._addVertex(vertices,vertexCount,bottomRightFront);
		vertexCount=this._addVertex(vertices,vertexCount,bottomRightBack);
		vertexCount=this._addVertex(vertices,vertexCount,topRightBack);
		vertexCount=this._addVertex(vertices,vertexCount,topRightFront);
		vertexCount=this._addVertex(vertices,vertexCount,bottomRightBack);
		for (var i=0;i < 36;i++)
		indices[i]=i;
		this._vertexBuffer=new VertexBuffer3D(SkyBox._vertexDeclaration,this._numberVertices,/*laya.webgl.WebGLContext.STATIC_DRAW*/0x88E4,true);
		this._indexBuffer=new IndexBuffer3D(/*laya.d3.graphics.IndexBuffer3D.INDEXTYPE_USHORT*/"ushort",this._numberIndices,/*laya.webgl.WebGLContext.STATIC_DRAW*/0x88E4,true);
		this._vertexBuffer.setData(vertices);
		this._indexBuffer.setData(indices);
	}

	/**
	*@private
	*/
	__proto._addVertex=function(vertices,index,position){
		var posE=position.elements;
		vertices[index+0]=posE[0];
		vertices[index+1]=posE[1];
		vertices[index+2]=posE[2];
		return index+3;
	}

	/**
	*@private
	*/
	__proto.loadShaderParams=function(){
		this._sharderNameID=Shader3D.nameKey.getID("SkyBox");
		this._shaderCompile=ShaderCompile3D._preCompileShader[this._sharderNameID];
	}

	__proto._render=function(state){
		if (this._textureCube && this._textureCube.loaded){
			this._vertexBuffer._bind();
			this._indexBuffer._bind();
			this._shader=this._getShader(state);
			this._shader.bind();
			state.camera.transform.worldMatrix.cloneTo(SkyBox._tempMatrix4x40);
			SkyBox._tempMatrix4x40.transpose();
			Matrix4x4.multiply(state._projectionMatrix,SkyBox._tempMatrix4x40,SkyBox._tempMatrix4x41);
			state.camera._shaderValues.setValue(/*laya.d3.core.BaseCamera.VPMATRIX_NO_TRANSLATE*/4,SkyBox._tempMatrix4x41.elements);
			this._shader.uploadCameraUniforms(state.camera._shaderValues.data);
			this._shaderValue.setValue(1,this._colorIntensity);
			this._shaderValue.setValue(2,this._alphaBlending);
			this._shaderValue.setValue(3,this.textureCube);
			this._shader.uploadAttributes(SkyBox._vertexDeclaration.shaderValues.data,null);
			this._shader.uploadMaterialUniforms(this._shaderValue.data);
			WebGL.mainContext.drawElements(/*laya.webgl.WebGLContext.TRIANGLES*/0x0004,36,/*laya.webgl.WebGLContext.UNSIGNED_SHORT*/0x1403,0);
			Stat.trianglesFaces+=12;
			Stat.drawCall++;
		}
	}

	/**
	*@inheritDoc
	*/
	__proto.destroy=function(){
		_super.prototype.destroy.call(this);
		(this._textureCube)&& (this._textureCube._removeReference(),this._textureCube=null);
	}

	/**
	*设置天空立方体纹理。
	*@param value 天空立方体纹理。
	*/
	/**
	*获取天空立方体纹理。
	*@return 天空立方体纹理。
	*/
	__getset(0,__proto,'textureCube',function(){
		return this._textureCube;
		},function(value){
		if (this._textureCube!==value){
			(this._textureCube)&& (this._textureCube._removeReference());
			this._textureCube=value;
			(value)&& (value._addReference());
		}
	});

	SkyBox._nameNumber=1;
	__static(SkyBox,
	['_tempMatrix4x40',function(){return this._tempMatrix4x40=new Matrix4x4();},'_tempMatrix4x41',function(){return this._tempMatrix4x41=new Matrix4x4();},'_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(12,[new VertexElement(0,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.POSITION0*/0)]);}
	]);
	return SkyBox;
})(Sky)


/**
*<code>Sky</code> 类用于创建天空盒。
*/
//class laya.d3.resource.models.SkyDome extends laya.d3.resource.models.Sky
var SkyDome=(function(_super){
	function SkyDome(){
		/**@private */
		//this._numberVertices=0;
		/**@private */
		//this._numberIndices=0;
		/**@private 天空立方体纹理。 */
		//this._texture=null;
		this._stacks=16;
		this._slices=16;
		this._radius=1;
		SkyDome.__super.call(this);
		SkyDome._nameNumber++;
		this.loadShaderParams();
		this.recreateResource();
		this.alphaBlending=1;
		this.colorIntensity=1;
	}

	__class(SkyDome,'laya.d3.resource.models.SkyDome',_super);
	var __proto=SkyDome.prototype;
	/**
	*@private
	*/
	__proto._getShader=function(state){
		var shaderDefineValue=state.scene._shaderDefineValue;
		this._shader=this._shaderCompile.withCompile(shaderDefineValue,0,0);
		return this._shader;
	}

	/**
	*@private
	*/
	__proto.recreateResource=function(){
		this._numberVertices=(this._stacks+1)*(this._slices+1);
		this._numberIndices=(3 *this._stacks *(this._slices+1))*2;
		var indices=new Uint16Array(this._numberIndices);
		var vertexFloatStride=SkyDome._vertexDeclaration.vertexStride / 4;
		var vertices=new Float32Array(this._numberVertices *vertexFloatStride);
		var stackAngle=Math.PI / this._stacks;
		var sliceAngle=(Math.PI *2.0)/ this._slices;
		var vertexIndex=0;
		var vertexCount=0;
		var indexCount=0;
		for (var stack=0;stack < (this._stacks+1);stack++){
			var r=Math.sin(stack *stackAngle);
			var y=Math.cos(stack *stackAngle);
			for (var slice=0;slice < (this._slices+1);slice++){
				var x=r *Math.sin(slice *sliceAngle);
				var z=r *Math.cos(slice *sliceAngle);
				vertices[vertexCount+0]=x *this._radius;
				vertices[vertexCount+1]=y *this._radius;
				vertices[vertexCount+2]=z *this._radius;
				vertices[vertexCount+3]=-(slice / this._slices)+0.75;
				vertices[vertexCount+4]=stack / this._stacks;
				vertexCount+=vertexFloatStride;
				if (stack !=(this._stacks-1)){
					indices[indexCount++]=vertexIndex+1;
					indices[indexCount++]=vertexIndex;
					indices[indexCount++]=vertexIndex+(this._slices+1);
					indices[indexCount++]=vertexIndex+(this._slices+1);
					indices[indexCount++]=vertexIndex;
					indices[indexCount++]=vertexIndex+(this._slices);
					vertexIndex++;
				}
			}
		}
		this._vertexBuffer=new VertexBuffer3D(SkyDome._vertexDeclaration,this._numberVertices,/*laya.webgl.WebGLContext.STATIC_DRAW*/0x88E4);
		this._indexBuffer=new IndexBuffer3D(/*laya.d3.graphics.IndexBuffer3D.INDEXTYPE_USHORT*/"ushort",this._numberIndices,/*laya.webgl.WebGLContext.STATIC_DRAW*/0x88E4);
		this._vertexBuffer.setData(vertices);
		this._indexBuffer.setData(indices);
	}

	/**
	*@private
	*/
	__proto.loadShaderParams=function(){
		this._sharderNameID=Shader3D.nameKey.getID("SkyDome");
		this._shaderCompile=ShaderCompile3D._preCompileShader[this._sharderNameID];
	}

	__proto._render=function(state){
		if (this._texture && this._texture.loaded){
			this._vertexBuffer._bind();
			this._indexBuffer._bind();
			this._shader=this._getShader(state);
			this._shader.bind();
			state.camera.transform.worldMatrix.cloneTo(SkyDome._tempMatrix4x40);
			SkyDome._tempMatrix4x40.transpose();
			Matrix4x4.multiply(state._projectionMatrix,SkyDome._tempMatrix4x40,SkyDome._tempMatrix4x41);
			state.camera._shaderValues.setValue(/*laya.d3.core.BaseCamera.VPMATRIX_NO_TRANSLATE*/4,SkyDome._tempMatrix4x41.elements);
			this._shader.uploadCameraUniforms(state.camera._shaderValues.data);
			this._shaderValue.setValue(1,this._colorIntensity);
			this._shaderValue.setValue(2,this._alphaBlending);
			this._shaderValue.setValue(3,this.texture);
			this._shader.uploadAttributes(SkyDome._vertexDeclaration.shaderValues.data,null);
			this._shader.uploadMaterialUniforms(this._shaderValue.data);
			WebGL.mainContext.drawElements(/*laya.webgl.WebGLContext.TRIANGLES*/0x0004,this._indexBuffer.indexCount,/*laya.webgl.WebGLContext.UNSIGNED_SHORT*/0x1403,0);
			Stat.trianglesFaces+=this._numberIndices / 3;
			Stat.drawCall++;
		}
	}

	__proto.onEnvDescLoaded=function(envInfoFile){
		var envPath='';
		var ppos=Math.max(envInfoFile.lastIndexOf('/'),envInfoFile.lastIndexOf('\\'));
		if (ppos > 0){
			envPath=envInfoFile.substr(0,ppos+1);
		};
		var envinfoobj=Laya.loader.getRes(envInfoFile);
		if (envinfoobj.ev !=undefined && this.__ownerCamera)
			this.__ownerCamera._shaderValues.setValue(/*laya.d3.core.BaseCamera.HDREXPOSURE*/13,Math.pow(2,envinfoobj.ev));
		else
		this.__ownerCamera._shaderValues.setValue(/*laya.d3.core.BaseCamera.HDREXPOSURE*/13,Math.pow(2,0.0));
		this.texture=Texture2D.load(envPath+envinfoobj.skytex);
		this.environmentSpecular=DataTexture2D.load(envPath+envinfoobj.prefiltedEnv);
		var irrdMat=new Float32Array(envinfoobj.IrradianceMat);
		this.envDiffuseSHRed=irrdMat.slice(0,16);
		this.envDiffuseSHGreen=irrdMat.slice(16,32);
		this.envDiffuseSHBlue=irrdMat.slice(32,48);
	}

	__proto.loadEnvInfo=function(envInfo){
		Laya.loader.load(envInfo,Handler.create(this,this.onEnvDescLoaded,[envInfo]));
	}

	/**
	*@inheritDoc
	*/
	__proto.destroy=function(){
		_super.prototype.destroy.call(this);
		(this._texture)&& (this._texture._removeReference(),this._texture=null);
	}

	/**
	*设置天空纹理。
	*@param value 天空纹理。
	*/
	/**
	*获取天空立方体纹理。
	*@return 天空立方体纹理。
	*/
	__getset(0,__proto,'texture',function(){
		return this._texture;
		},function(value){
		if (this._texture!==value){
			(this._texture)&& (this._texture._removeReference());
			this._texture=value;
			(value)&& (value._addReference());
		}
	});

	SkyDome._nameNumber=1;
	__static(SkyDome,
	['_tempMatrix4x40',function(){return this._tempMatrix4x40=new Matrix4x4();},'_tempMatrix4x41',function(){return this._tempMatrix4x41=new Matrix4x4();},'_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(20,[new VertexElement(0,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.POSITION0*/0),new VertexElement(12,/*laya.d3.graphics.VertexElementFormat.Vector2*/"vector2",/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE0*/2)]);}
	]);
	return SkyDome;
})(Sky)


/**
*@private
*<code>ComponentNode</code> 类用于实现组件精灵,该类为抽象类。
*/
//class laya.d3.core.ComponentNode extends laya.display.Node
var ComponentNode=(function(_super){
	function ComponentNode(){
		/**@private */
		this._componentsMap=null;
		/**@private */
		this._typeComponentsIndices=null;
		/**@private */
		this._components=null;
		/**@private */
		this._scripts=null;
		ComponentNode.__super.call(this);
		this._componentsMap=[];
		this._typeComponentsIndices=[];
		this._components=[];
		this._scripts=[];
	}

	__class(ComponentNode,'laya.d3.core.ComponentNode',_super);
	var __proto=ComponentNode.prototype;
	/**
	*添加指定类型组件。
	*@param type 组件类型。
	*@return 组件。
	*/
	__proto.addComponent=function(type){
		var typeComponentIndex;
		var index=this._componentsMap.indexOf(type);
		if (index===-1){
			typeComponentIndex=[];
			this._componentsMap.push(type);
			this._typeComponentsIndices.push(typeComponentIndex);
			}else {
			typeComponentIndex=this._typeComponentsIndices[index];
			if (this._components[typeComponentIndex[0]].isSingleton)
				throw new Error("无法单实例创建"+type+"组件"+"，"+type+"组件已存在！");
		};
		var component=ClassUtils.getInstance(type);
		typeComponentIndex.push(this._components.length);
		this._components.push(component);
		if ((component instanceof laya.d3.component.Script ))
			this._scripts.push(component);
		component._initialize(this);
		return component;
	}

	/**
	*@private
	*/
	__proto._removeComponent=function(mapIndex,index){
		var componentIndices=this._typeComponentsIndices[mapIndex];
		var componentIndex=componentIndices[index];
		var component=this._components[componentIndex];
		this._components.splice(componentIndex,1);
		if ((component instanceof laya.d3.component.Script ))
			this._scripts.splice(this._scripts.indexOf(component),1);
		componentIndices.splice(index,1);
		(componentIndices.length===0)&& (this._typeComponentsIndices.splice(mapIndex,1),this._componentsMap.splice(mapIndex,1));
		for (var i=0,n=this._componentsMap.length;i < n;i++){
			componentIndices=this._typeComponentsIndices[i];
			for (var j=componentIndices.length-1;j >=0;j--){
				var oldComponentIndex=componentIndices[j];
				if (oldComponentIndex > componentIndex)
					componentIndices[j]=--oldComponentIndex;
				else
				break ;
			}
		}
		component._destroy();
	}

	/**
	*通过指定类型和类型索引获得组件。
	*@param type 组件类型。
	*@param typeIndex 类型索引。
	*@return 组件。
	*/
	__proto.getComponentByType=function(type,typeIndex){
		(typeIndex===void 0)&& (typeIndex=0);
		var mapIndex=this._componentsMap.indexOf(type);
		if (mapIndex===-1)
			return null;
		return this._components[this._typeComponentsIndices[mapIndex][typeIndex]];
	}

	/**
	*通过指定类型获得所有组件。
	*@param type 组件类型。
	*@param components 组件输出队列。
	*/
	__proto.getComponentsByType=function(type,components){
		var index=this._componentsMap.indexOf(type);
		if (index===-1){
			components.length=0;
			return;
		};
		var typeComponents=this._typeComponentsIndices[index];
		var count=typeComponents.length;
		components.length=count;
		for (var i=0;i < count;i++)
		components[i]=this._components[typeComponents[i]];
	}

	/**
	*通过指定索引获得组件。
	*@param index 索引。
	*@return 组件。
	*/
	__proto.getComponentByIndex=function(index){
		return this._components[index];
	}

	/**
	*通过指定类型和类型索引移除组件。
	*@param type 组件类型。
	*@param typeIndex 类型索引。
	*/
	__proto.removeComponentByType=function(type,typeIndex){
		(typeIndex===void 0)&& (typeIndex=0);
		var mapIndex=this._componentsMap.indexOf(type);
		if (mapIndex===-1)
			return;
		this._removeComponent(mapIndex,typeIndex);
	}

	/**
	*通过指定类型移除所有组件。
	*@param type 组件类型。
	*/
	__proto.removeComponentsByType=function(type){
		var mapIndex=this._componentsMap.indexOf(type);
		if (mapIndex===-1)
			return;
		var componentIndices=this._typeComponentsIndices[mapIndex];
		for (var i=0,n=componentIndices.length;i < n;componentIndices.length < n ? n--:i++)
		this._removeComponent(mapIndex,i);
	}

	/**
	*移除全部组件。
	*/
	__proto.removeAllComponent=function(){
		for (var i=0,n=this._componentsMap.length;i < n;this._componentsMap.length < n ? n--:i++)
		this.removeComponentsByType(this._componentsMap[i]);
	}

	/**
	*@private
	*/
	__proto._updateComponents=function(state){
		for (var i=0,n=this._components.length;i < n;i++){
			var component=this._components[i];
			(!component.started)&& (component._start(state),component.started=true);
			(component.enable)&& (component._update(state));
		}
	}

	/**
	*@private
	*/
	__proto._lateUpdateComponents=function(state){
		for (var i=0;i < this._components.length;i++){
			var component=this._components[i];
			(!component.started)&& (component._start(state),component.started=true);
			(component.enable)&& (component._lateUpdate(state));
		}
	}

	/**
	*@private
	*/
	__proto._preRenderUpdateComponents=function(state){
		for (var i=0;i < this._components.length;i++){
			var component=this._components[i];
			(!component.started)&& (component._start(state),component.started=true);
			(component.enable)&& (component._preRenderUpdate(state));
		}
	}

	/**
	*@private
	*/
	__proto._postRenderUpdateComponents=function(state){
		for (var i=0;i < this._components.length;i++){
			var component=this._components[i];
			(!component.started)&& (component._start(state),component.started=true);
			(component.enable)&& (component._postRenderUpdate(state));
		}
	}

	return ComponentNode;
})(Node)


/**
*<code>AnimationClip</code> 类用于动画片段资源。
*/
//class laya.d3.animation.AnimationClip extends laya.resource.Resource
var AnimationClip=(function(_super){
	function AnimationClip(){
		/**@private */
		this._realTimeCurrentFrameIndexes=null;
		/**@private */
		this._realTimeCurrentTimes=null;
		/**@private */
		this._fullKeyframeIndicesCache=null;
		/**@private */
		this._animationDatasCache=null;
		/**@private */
		this._avatarDatasCache=null;
		/**@private */
		this._skinnedDatasCache=null;
		/**@private */
		this._version=null;
		/**@private */
		this._nodes=null;
		/**@private */
		this._nodesMap=null;
		/**@private */
		this._cachePropertyMap=null;
		/**@private */
		this._nodeToCachePropertyMap=null;
		/**@private */
		this._unCachePropertyMap=null;
		/**@private */
		this._duration=NaN;
		/**@private */
		this._frameRate=0;
		/**@private */
		this._animationEvents=null;
		/**@private */
		this._publicClipDatas=null;
		/**是否循环。*/
		this.islooping=false;
		AnimationClip.__super.call(this);
		this._fullKeyframeIndicesCache={};
		this._animationDatasCache=[];
		this._avatarDatasCache=[];
		this._skinnedDatasCache=[];
		this._animationEvents=[];
	}

	__class(AnimationClip,'laya.d3.animation.AnimationClip',_super);
	var __proto=AnimationClip.prototype;
	/**
	*获取动画片段时长。
	*/
	__proto.duration=function(){
		return this._duration;
	}

	/**
	*@private
	*/
	__proto._hermiteInterpolate=function(frame,t,dur,out){
		var p0=frame.data;
		var tan0=frame.outTangent;
		var nextFrame=frame.next;
		var p1=nextFrame.data;
		var tan1=nextFrame.inTangent;
		var isComputeParams=false;
		var a=NaN,b=NaN,c=NaN,d=NaN;
		for (var i=0,n=out.length;i < n;i++){
			var t0=tan0[i],t1=tan1[i];
			if (/*__JS__ */Number.isFinite(t0)&& Number.isFinite(t1)){
				if (!isComputeParams){
					var t2=t *t;
					var t3=t2 *t;
					a=2.0 *t3-3.0 *t2+1.0;
					b=t3-2.0 *t2+t;
					c=t3-t2;
					d=-2.0 *t3+3.0 *t2;
					isComputeParams=true;
				}
				out[i]=a *p0[i]+b *t0 *dur+c *t1 *dur+d *p1[i];
			}else
			out[i]=p0[i];
		}
	}

	/**
	*@private
	*/
	__proto._getFullKeyframeIndicesWithCache=function(cacheInterval){
		return this._fullKeyframeIndicesCache[cacheInterval];
	}

	/**
	*@private
	*/
	__proto._cacheFullKeyframeIndices=function(cacheInterval,datas){
		this._fullKeyframeIndicesCache[cacheInterval]=datas;
	}

	/**
	*@private
	*/
	__proto._getAnimationDataWithCache=function(cacheRate,frameIndex){
		var cacheDatas=this._animationDatasCache[cacheRate];
		if (!cacheDatas)
			return null;
		else {
			return cacheDatas[frameIndex];
		}
	}

	/**
	*@private
	*/
	__proto._cacheAnimationData=function(cacheRate,frameIndex,datas){
		var aniDatasCache=(this._animationDatasCache[cacheRate])|| (this._animationDatasCache[cacheRate]=[]);
		aniDatasCache[frameIndex]=datas;
	}

	/**
	*@private
	*/
	__proto._getAvatarDataWithCache=function(avatar,cacheRate,frameIndex){
		var clipCache=this._avatarDatasCache[avatar.id];
		if (!clipCache){
			return null;
			}else {
			var rateCache=clipCache[cacheRate];
			if (!rateCache)
				return null;
			else {
				return rateCache[frameIndex];
			}
		}
	}

	/**
	*@private
	*/
	__proto._cacheAvatarData=function(avatar,cacheRate,frameIndex,datas){
		var clipCache=(this._avatarDatasCache[avatar.id])|| (this._avatarDatasCache[avatar.id]=[]);
		var rateCache=(clipCache[cacheRate])|| (clipCache[cacheRate]=[]);
		rateCache[frameIndex]=datas;
	}

	/**
	*@private
	*/
	__proto._evaluateAnimationlDatasCacheMode=function(nodeOwners,nodesFrameIndices,animator,clipDatas,propertyMap){
		var j=0,m=0;
		for (var i=0,n=propertyMap ? propertyMap.length :this._nodes.length;i < n;i++){
			var nodeIndex=propertyMap ? propertyMap[i] :i;
			var node=this._nodes[nodeIndex];
			var cacheProperty=node._cacheProperty;
			if (!nodeOwners[nodeIndex])
				continue ;
			var frameIndices=nodesFrameIndices[nodeIndex];
			var realFrameIndex=frameIndices[animator.currentFrameIndex];
			var outDatas;
			var lastFrameIndex=0;
			if (realFrameIndex!==-1){
				var frame=node.keyFrames[realFrameIndex];
				var nextKeyFrame=frame.next;
				if (nextKeyFrame){
					if (propertyMap && !cacheProperty){
						outDatas=clipDatas[nodeIndex];
						(outDatas)|| (outDatas=clipDatas[nodeIndex]=new Float32Array(node.keyFrameWidth));
						}else {
						outDatas=new Float32Array(node.keyFrameWidth);
						clipDatas[i]=outDatas;
					};
					var t=NaN;
					var d=frame.duration;
					if (d!==0)
						t=(animator.currentFrameTime-frame.startTime)/ d;
					else
					t=0;
					this._hermiteInterpolate(frame,t,d,outDatas);
					}else {
					if (propertyMap && !cacheProperty){
						outDatas=clipDatas[nodeIndex];
						(outDatas)|| (outDatas=clipDatas[nodeIndex]=new Float32Array(node.keyFrameWidth));
						}else {
						lastFrameIndex=animator._lastFrameIndex;
						if (lastFrameIndex!==-1 && frameIndices[lastFrameIndex]===realFrameIndex)
							continue ;
						outDatas=new Float32Array(node.keyFrameWidth);
						clipDatas[i]=outDatas;
					};
					var frameData=frame.data;
					for (j=0,m=outDatas.length;j < m;j++)
					outDatas[j]=frameData[j];
				}
				}else {
				if (propertyMap && !cacheProperty){
					outDatas=clipDatas[nodeIndex];
					(outDatas)|| (outDatas=clipDatas[nodeIndex]=new Float32Array(node.keyFrameWidth));
					}else {
					lastFrameIndex=animator._lastFrameIndex;
					if (lastFrameIndex!==-1 && frameIndices[lastFrameIndex]===realFrameIndex)
						continue ;
					outDatas=new Float32Array(node.keyFrameWidth);
					clipDatas[i]=outDatas;
				};
				var firstFrameDatas=node.keyFrames[0].data;
				for (j=0,m=outDatas.length;j < m;j++)
				outDatas[j]=firstFrameDatas[j];
			}
		}
	}

	/**
	*@private
	*/
	__proto._evaluateAnimationlDatasRealTime=function(nodeOwners,playCurTime,outAnimationDatas,propertyMap){
		var i=0,n=0;
		var nodes=this._nodes;
		if (!this._realTimeCurrentFrameIndexes){
			this._realTimeCurrentFrameIndexes=new Int32Array(nodes.length);
			for (i=0,n=nodes.length;i < n;i++)
			this._realTimeCurrentFrameIndexes[i]=-1;
			this._realTimeCurrentTimes=new Float32Array(nodes.length);
		}
		for (i=0,n=propertyMap ? propertyMap.length :this._nodes.length;i < n;i++){
			var index=propertyMap ? propertyMap[i] :i;
			var node=nodes[index];
			if (playCurTime < this._realTimeCurrentTimes[index])
				this._realTimeCurrentFrameIndexes[index]=-1;
			this._realTimeCurrentTimes[index]=playCurTime;
			var nextFrameIndex=this._realTimeCurrentFrameIndexes[index]+1;
			var keyFrames=node.keyFrames;
			var keyFramesCount=keyFrames.length;
			while (nextFrameIndex < keyFramesCount){
				if (keyFrames[nextFrameIndex].startTime > playCurTime){
					this._realTimeCurrentFrameIndexes[index]=nextFrameIndex-1;
					break ;
				}
				nextFrameIndex++;
			}
			(nextFrameIndex===keyFramesCount)&& (this._realTimeCurrentFrameIndexes[index]=keyFramesCount-1);
			var j=0,m=0;
			var outDatas=outAnimationDatas[index];
			(outDatas)|| (outDatas=outAnimationDatas[index]=new Float32Array(node.keyFrameWidth));
			var frame=keyFrames[this._realTimeCurrentFrameIndexes[index]];
			if (frame){
				var nextFarme=frame.next;
				if (nextFarme){
					var d=frame.duration;
					var t=NaN;
					if (d!==0)
						t=(playCurTime-frame.startTime)/ d;
					else
					t=0;
					this._hermiteInterpolate(frame,t,d,outDatas);
					}else {
					var frameData=frame.data;
					for (j=0,m=outDatas.length;j < m;j++)
					outDatas[j]=frameData[j];
				}
				}else {
				var firstFrameDatas=node.keyFrames[0].data;
				for (j=0,m=outDatas.length;j < m;j++)
				outDatas[j]=firstFrameDatas[j];
			};
			var owner=nodeOwners[index];
			if (owner){
				if (propertyMap)
					AnimationNode._propertySetFuncs[node.propertyNameID](owner,null,outDatas);
				else
				AnimationNode._propertySetFuncs[node.propertyNameID](null,owner,outDatas);
			}
		}
	}

	/**
	*@private
	*/
	__proto._binarySearchEventIndex=function(time){
		var start=0;
		var end=this._animationEvents.length-1;
		var mid=0;
		while (start <=end){
			mid=Math.floor((start+end)/ 2);
			var midValue=this._animationEvents[mid].time;
			if (midValue==time)
				return mid;
			else if (midValue > time)
			end=mid-1;
			else
			start=mid+1;
		}
		return start;
	}

	/**
	*添加动画事件。
	*/
	__proto.addEvent=function(event){
		var index=this._binarySearchEventIndex(event.time);
		this._animationEvents.splice(index,0,event);
	}

	/**
	*@inheritDoc
	*/
	__proto.onAsynLoaded=function(url,data,params){
		var reader=new Byte(data);
		this._version=reader.readUTFString();
		switch (this._version){
			case "LAYAANIMATION:01":
				AnimationClipParser01.parse(this,reader);
				break ;
			case "LAYAANIMATION:02":
				AnimationClipParser02.parse(this,reader);
				break ;
			}
		this.completeCreate();
		this._endLoaded();
	}

	/**
	*@inheritDoc
	*/
	__proto.disposeResource=function(){
		this._realTimeCurrentFrameIndexes=null;
		this._realTimeCurrentTimes=null;
		this._fullKeyframeIndicesCache=null;
		this._animationDatasCache=null;
		this._avatarDatasCache=null;
		this._skinnedDatasCache=null;
		this._version=null;
		this._nodes=null;
		this._nodesMap=null;
		this._cachePropertyMap=null;
		this._nodeToCachePropertyMap=null;
		this._unCachePropertyMap=null;
		this._publicClipDatas=null;
	}

	AnimationClip.load=function(url){
		return Laya.loader.create(url,null,null,AnimationClip);
	}

	return AnimationClip;
})(Resource)


/**
*<code>Avatar</code> 类用于创建Avatar。
*/
//class laya.d3.core.Avatar extends laya.resource.Resource
var Avatar=(function(_super){
	function Avatar(){
		/**@private */
		//this._version=null;
		/**@private */
		//this._rootNode=null;
		Avatar.__super.call(this);
	}

	__class(Avatar,'laya.d3.core.Avatar',_super);
	var __proto=Avatar.prototype;
	Laya.imps(__proto,{"laya.d3.core.IClone":true})
	/**
	*@private
	*/
	__proto._initCloneToAnimator=function(destNode,destAnimator){
		destAnimator._avatarNodeMap[destNode.name]=destNode;
		destAnimator._avatarNodes.push(destNode);
		for (var i=0,n=destNode.getChildCount();i < n;i++)
		this._initCloneToAnimator(destNode.getChildByIndex(i),destAnimator);
	}

	/**
	*@private
	*/
	__proto._parseNode=function(nodaData,node){
		var name=nodaData.props.name;
		node.name=name;
		if (node._parent){
			var customProps=nodaData.customProps;
			var transform=node.transform;
			transform._localRotationEuler=new Float32Array(3);
			transform.setLocalPosition(new Float32Array(customProps.translate));
			transform.setLocalRotation(new Float32Array(customProps.rotation));
			transform.setLocalScale(new Float32Array(customProps.scale));
			transform._setWorldMatrixAndUpdate(new Float32Array(16));
		};
		var childrenData=nodaData.child;
		for (var i=0,n=childrenData.length;i < n;i++){
			var childData=childrenData[i];
			var childBone=new AnimationNode();
			node.addChild(childBone);
			this._parseNode(childData,childBone);
		}
	}

	/**
	*@inheritDoc
	*/
	__proto.onAsynLoaded=function(url,data,params){
		this._rootNode=new AnimationNode();
		if (data.version){
			this._version=data.version;
			var rootNode=data.rootNode;
			(rootNode)&& (this._parseNode(rootNode,this._rootNode));
			}else {
			this._parseNode(data,this._rootNode);
		}
		this._endLoaded();
	}

	/**
	*克隆数据到Avatr。
	*@param destObject 克隆源。
	*/
	__proto._cloneDatasToAnimator=function(destAnimator){
		var destRoot=this._rootNode.clone();
		destRoot.transform._setWorldMatrixIgnoreUpdate(null);
		var avatarNodes=[];
		destAnimator._avatarNodeMap={};
		destAnimator._avatarNodes=avatarNodes;
		this._initCloneToAnimator(destRoot,destAnimator);
	}

	/**
	*克隆。
	*@param destObject 克隆源。
	*/
	__proto.cloneTo=function(destObject){
		var destAvatar=destObject;
		var destRoot=this._rootNode.clone();
		destAvatar._rootNode=destRoot;
	}

	/**
	*克隆。
	*@return 克隆副本。
	*/
	__proto.clone=function(){
		var dest=/*__JS__ */new this.constructor();
		this.cloneTo(dest);
		return dest;
	}

	Avatar.load=function(url){
		return Laya.loader.create(url,null,null,Avatar);
	}

	return Avatar;
})(Resource)


/**
*<code>BaseMaterial</code> 类用于创建材质,抽象类,不允许实例。
*/
//class laya.d3.core.material.BaseMaterial extends laya.resource.Resource
var BaseMaterial=(function(_super){
	function BaseMaterial(){
		/**@private */
		//this._shader=null;
		/**@private */
		//this._shaderCompile=null;
		/**@private */
		//this._shaderDefineValue=0;
		/**@private */
		//this._disablePublicShaderDefine=0;
		/**@private */
		//this._alphaTest=false;
		/**@private */
		//this._shaderValues=null;
		/**@private */
		//this._values=null;
		/**渲染剔除状态。*/
		//this.cull=0;
		/**透明混合。*/
		//this.blend=0;
		/**源混合参数,在blend为BLEND_ENABLE_ALL时生效。*/
		//this.srcBlend=0;
		/**目标混合参数,在blend为BLEND_ENABLE_ALL时生效。*/
		//this.dstBlend=0;
		/**RGB源混合参数,在blend为BLEND_ENABLE_SEPERATE时生效。*/
		//this.srcBlendRGB=0;
		/**RGB目标混合参数,在blend为BLEND_ENABLE_SEPERATE时生效。*/
		//this.dstBlendRGB=0;
		/**Alpha源混合参数,在blend为BLEND_ENABLE_SEPERATE时生效。*/
		//this.srcBlendAlpha=0;
		/**Alpha目标混合参数,在blend为BLEND_ENABLE_SEPERATE时生效。*/
		//this.dstBlendAlpha=0;
		/**混合常量颜色。*/
		//this.blendConstColor=null;
		/**混合方程。*/
		//this.blendEquation=0;
		/**RGB混合方程。*/
		//this.blendEquationRGB=0;
		/**Alpha混合方程。*/
		//this.blendEquationAlpha=0;
		/**深度测试函数。*/
		//this.depthTest=0;
		/**是否深度写入。*/
		//this.depthWrite=false;
		/**所属渲染队列. */
		//this.renderQueue=0;
		/**@private */
		//this._conchMaterial=null;
		BaseMaterial.__super.call(this);
		this._shaderDefineValue=0;
		this._disablePublicShaderDefine=0;
		this._shaderValues=new ValusArray();
		this._values=[];
		this.renderQueue=/*CLASS CONST:laya.d3.core.material.BaseMaterial.RENDERQUEUE_OPAQUE*/2000;
		this._alphaTest=false;
		this.cull=2;
		this.blend=0;
		this.srcBlend=1;
		this.dstBlend=0;
		this.srcBlendRGB=1;
		this.dstBlendRGB=0;
		this.srcBlendAlpha=1;
		this.dstBlendAlpha=0;
		this.blendConstColor=new Vector4(1,1,1,1);
		this.blendEquation=0;
		this.blendEquationRGB=0;
		this.blendEquationAlpha=0;
		this.depthTest=0x0201;
		this.depthWrite=true;
	}

	__class(BaseMaterial,'laya.d3.core.material.BaseMaterial',_super);
	var __proto=BaseMaterial.prototype;
	Laya.imps(__proto,{"laya.d3.core.IClone":true})
	/**
	*增加Shader宏定义。
	*@param value 宏定义。
	*/
	__proto._addShaderDefine=function(value){
		this._shaderDefineValue |=value;
	}

	/**
	*移除Shader宏定义。
	*@param value 宏定义。
	*/
	__proto._removeShaderDefine=function(value){
		this._shaderDefineValue &=~value;
	}

	/**
	*增加禁用宏定义。
	*@param value 宏定义。
	*/
	__proto._addDisablePublicShaderDefine=function(value){
		this._disablePublicShaderDefine |=value;
	}

	/**
	*移除禁用宏定义。
	*@param value 宏定义。
	*/
	__proto._removeDisablePublicShaderDefine=function(value){
		this._disablePublicShaderDefine &=~value;
	}

	/**
	*设置Buffer。
	*@param shaderIndex shader索引。
	*@param buffer buffer数据。
	*/
	__proto._setBuffer=function(shaderIndex,buffer){
		var shaderValue=this._shaderValues;
		shaderValue.setValue(shaderIndex,buffer);
		this._values[shaderIndex]=buffer;
	}

	/**
	*获取Buffer。
	*@param shaderIndex shader索引。
	*@return
	*/
	__proto._getBuffer=function(shaderIndex){
		return this._values[shaderIndex];
	}

	/**
	*设置矩阵。
	*@param shaderIndex shader索引。
	*@param matrix4x4 矩阵。
	*/
	__proto._setMatrix4x4=function(shaderIndex,matrix4x4){
		this._shaderValues.setValue(shaderIndex,matrix4x4 ? matrix4x4.elements :null);
		this._values[shaderIndex]=matrix4x4;
	}

	/**
	*获取矩阵。
	*@param shaderIndex shader索引。
	*@return 矩阵。
	*/
	__proto._getMatrix4x4=function(shaderIndex){
		return this._values[shaderIndex];
	}

	/**
	*设置整型。
	*@param shaderIndex shader索引。
	*@param i 整形。
	*/
	__proto._setInt=function(shaderIndex,i){
		var shaderValue=this._shaderValues;
		shaderValue.setValue(shaderIndex,i);
		this._values[shaderIndex]=i;
	}

	/**
	*获取整形。
	*@param shaderIndex shader索引。
	*@return 整形。
	*/
	__proto._getInt=function(shaderIndex){
		return this._values[shaderIndex];
	}

	/**
	*设置浮点。
	*@param shaderIndex shader索引。
	*@param i 浮点。
	*/
	__proto._setNumber=function(shaderIndex,number){
		var shaderValue=this._shaderValues;
		shaderValue.setValue(shaderIndex,number);
		this._values[shaderIndex]=number;
	}

	/**
	*获取浮点。
	*@param shaderIndex shader索引。
	*@return 浮点。
	*/
	__proto._getNumber=function(shaderIndex){
		return this._values[shaderIndex];
	}

	/**
	*设置布尔。
	*@param shaderIndex shader索引。
	*@param b 布尔。
	*/
	__proto._setBool=function(shaderIndex,b){
		var shaderValue=this._shaderValues;
		shaderValue.setValue(shaderIndex,b);
		this._values[shaderIndex]=b;
	}

	/**
	*获取布尔。
	*@param shaderIndex shader索引。
	*@return 布尔。
	*/
	__proto._getBool=function(shaderIndex){
		return this._values[shaderIndex];
	}

	/**
	*设置二维向量。
	*@param shaderIndex shader索引。
	*@param vector2 二维向量。
	*/
	__proto._setVector2=function(shaderIndex,vector2){
		var shaderValue=this._shaderValues;
		shaderValue.setValue(shaderIndex,vector2 ? vector2.elements :null);
		this._values[shaderIndex]=vector2;
	}

	/**
	*获取二维向量。
	*@param shaderIndex shader索引。
	*@return 二维向量。
	*/
	__proto._getVector2=function(shaderIndex){
		return this._values[shaderIndex];
	}

	/**
	*设置颜色。
	*@param shaderIndex shader索引。
	*@param color 颜色向量。
	*/
	__proto._setColor=function(shaderIndex,color){
		var shaderValue=this._shaderValues;
		shaderValue.setValue(shaderIndex,color ? color.elements :null);
		this._values[shaderIndex]=color;
	}

	/**
	*获取颜色。
	*@param shaderIndex shader索引。
	*@return 颜色向量。
	*/
	__proto._getColor=function(shaderIndex){
		return this._values[shaderIndex];
	}

	/**
	*设置纹理。
	*@param shaderIndex shader索引。
	*@param texture 纹理。
	*/
	__proto._setTexture=function(shaderIndex,texture){
		var lastValue=this._values[shaderIndex];
		this._values[shaderIndex]=texture;
		this._shaderValues.setValue(shaderIndex,texture);
		if (this.referenceCount > 0){
			(lastValue)&& (lastValue._removeReference());
			(texture)&& (texture._addReference());
		}
	}

	/**
	*获取纹理。
	*@param shaderIndex shader索引。
	*@return 纹理。
	*/
	__proto._getTexture=function(shaderIndex){
		return this._values[shaderIndex];
	}

	/**
	*上传材质。
	*@param state 相关渲染状态。
	*@param bufferUsageShader Buffer相关绑定。
	*@param shader 着色器。
	*@return 是否成功。
	*/
	__proto._upload=function(){
		this._shader.uploadMaterialUniforms(this._shaderValues.data);
	}

	/**
	*@private
	*/
	__proto._getShader=function(sceneDefineValue,vertexDefineValue,spriteDefineValue){
		var publicDefineValue=(sceneDefineValue | vertexDefineValue)& (~this._disablePublicShaderDefine);
		this._shader=this._shaderCompile.withCompile(publicDefineValue,spriteDefineValue,this._shaderDefineValue);
		return this._shader;
	}

	/**
	*设置渲染相关状态。
	*/
	__proto._setRenderStateBlendDepth=function(){
		var gl=WebGL.mainContext;
		WebGLContext.setDepthMask(gl,this.depthWrite);
		if (this.depthTest===0)
			WebGLContext.setDepthTest(gl,false);
		else {
			WebGLContext.setDepthTest(gl,true);
			WebGLContext.setDepthFunc(gl,this.depthTest);
		}
		switch (this.blend){
			case 0:
				WebGLContext.setBlend(gl,false);
				break ;
			case 1:
				WebGLContext.setBlend(gl,true);
				WebGLContext.setBlendFunc(gl,this.srcBlend,this.dstBlend);
				break ;
			case 2:
				WebGLContext.setBlend(gl,true);
				break ;
			}
	}

	/**
	*设置渲染相关状态。
	*/
	__proto._setRenderStateFrontFace=function(isTarget,transform){
		var gl=WebGL.mainContext;
		var forntFace=0;
		switch (this.cull){
			case 0:
				WebGLContext.setCullFace(gl,false);
				break ;
			case 1:
				WebGLContext.setCullFace(gl,true);
				if (isTarget){
					if (transform && transform._isFrontFaceInvert)
						forntFace=/*laya.webgl.WebGLContext.CCW*/0x0901;
					else
					forntFace=/*laya.webgl.WebGLContext.CW*/0x0900;
					}else {
					if (transform && transform._isFrontFaceInvert)
						forntFace=/*laya.webgl.WebGLContext.CW*/0x0900;
					else
					forntFace=/*laya.webgl.WebGLContext.CCW*/0x0901;
				}
				WebGLContext.setFrontFace(gl,forntFace);
				break ;
			case 2:
				WebGLContext.setCullFace(gl,true);
				if (isTarget){
					if (transform && transform._isFrontFaceInvert)
						forntFace=/*laya.webgl.WebGLContext.CW*/0x0900;
					else
					forntFace=/*laya.webgl.WebGLContext.CCW*/0x0901;
					}else {
					if (transform && transform._isFrontFaceInvert)
						forntFace=/*laya.webgl.WebGLContext.CCW*/0x0901;
					else
					forntFace=/*laya.webgl.WebGLContext.CW*/0x0900;
				}
				WebGLContext.setFrontFace(gl,forntFace);
				break ;
			}
	}

	/**
	*@inheritDoc
	*/
	__proto.onAsynLoaded=function(url,data,params){
		var jsonData=data[0];
		var textureMap=data[1];
		switch (jsonData.version){
			case "LAYAMATERIAL:01":;
				var i=0,n=0;
				var props=jsonData.props;
				for (var key in props){
				switch (key){
					case "vectors":;
						var vectors=props[key];
						for (i=0,n=vectors.length;i < n;i++){
							var vector=vectors[i];
							var vectorValue=vector.value;
						switch (vectorValue.length){
							case 2:
								this[vector.name]=new Vector2(vectorValue[0],vectorValue[1]);
								break ;
							case 3:
								this[vector.name]=new Vector3(vectorValue[0],vectorValue[1],vectorValue[2]);
								break ;
							case 4:
								this[vector.name]=new Vector4(vectorValue[0],vectorValue[1],vectorValue[2],vectorValue[3]);
								break ;
							default :
								throw new Error("BaseMaterial:unkonwn color length.");
							}
					}
					break ;
					case "textures":;
					var textures=props[key];
					for (i=0,n=textures.length;i < n;i++){
						var texture=textures[i];
						var path=texture.path;
						(path)&& (this[texture.name]=Loader.getRes(textureMap[path]));
					}
					break ;
					case "defines":;
					var defineNames=props[key];
					for (i=0,n=defineNames.length;i < n;i++){
						var define=this._shaderCompile.getMaterialDefineByName(defineNames[i]);
						this._addShaderDefine(define);
					}
					break ;
					case "cull":
					case "blend":
					case "srcBlend":
					case "dstBlend":
					case "depthWrite":
					this[key]=props[key];
					break ;
					case "renderQueue":;
					var queue=props[key];
					switch (queue){
						case 1:
							this.renderQueue=2000;
							break ;
						case 2:
							this.renderQueue=3000;
							break ;
						default :
						}
					break ;
					default :
					this[key]=props[key];
				}
			}
			break ;
			case "LAYAMATERIAL:02":
			props=jsonData.props;
			for (key in props){
				switch (key){
					case "vectors":
						vectors=props[key];
						for (i=0,n=vectors.length;i < n;i++){
							vector=vectors[i];
							vectorValue=vector.value;
						switch (vectorValue.length){
							case 2:
								this[vector.name]=new Vector2(vectorValue[0],vectorValue[1]);
								break ;
							case 3:
								this[vector.name]=new Vector3(vectorValue[0],vectorValue[1],vectorValue[2]);
								break ;
							case 4:
								this[vector.name]=new Vector4(vectorValue[0],vectorValue[1],vectorValue[2],vectorValue[3]);
								break ;
							default :
								throw new Error("BaseMaterial:unkonwn color length.");
							}
					}
					break ;
					case "textures":
					textures=props[key];
					for (i=0,n=textures.length;i < n;i++){
						texture=textures[i];
						path=texture.path;
						(path)&& (this[texture.name]=Loader.getRes(textureMap[path]));
					}
					break ;
					case "defines":
					defineNames=props[key];
					for (i=0,n=defineNames.length;i < n;i++){
						define=this._shaderCompile.getMaterialDefineByName(defineNames[i]);
						this._addShaderDefine(define);
					}
					break ;
					default :
					this[key]=props[key];
				}
			}
			break ;
			default :
			throw new Error("BaseMaterial:unkonwn version.");
		}
		this._endLoaded();
	}

	/**
	*@inheritDoc
	*/
	__proto._addReference=function(){
		_super.prototype._addReference.call(this);
		var valueCount=this._values.length;
		for (var i=0,n=valueCount;i < n;i++){
			var value=this._values[i];
			if (value && (value instanceof laya.d3.resource.BaseTexture ))
				(value)._addReference();
		}
	}

	/**
	*@inheritDoc
	*/
	__proto._removeReference=function(){
		_super.prototype._removeReference.call(this);
		var valueCount=this._values.length;
		for (var i=0,n=valueCount;i < n;i++){
			var value=this._values[i];
			if (value && (value instanceof laya.d3.resource.BaseTexture ))
				(value)._removeReference();
		}
	}

	/**
	*@inheritDoc
	*/
	__proto.disposeResource=function(){
		this.blendConstColor=null;
		this._shader=null;
		this._shaderValues=null;
		var valueCount=this._values.length;
		for (var i=0,n=valueCount;i < n;i++){
			var value=this._values[i];
			if (value && (value instanceof laya.d3.resource.BaseTexture ))
				(value)._removeReference();
		}
		this._values=null;
	}

	/**
	*设置使用Shader名字。
	*@param name 名称。
	*/
	__proto.setShaderName=function(name){
		var nameID=Shader3D.nameKey.getID(name);
		if (nameID===-1)
			throw new Error("BaseMaterial: unknown shader name.");
		this._shaderCompile=ShaderCompile3D._preCompileShader[nameID];
	}

	/**
	*克隆。
	*@param destObject 克隆源。
	*/
	__proto.cloneTo=function(destObject){
		var destBaseMaterial=destObject;
		destBaseMaterial.name=this.name;
		destBaseMaterial.cull=this.cull;
		destBaseMaterial.blend=this.blend;
		destBaseMaterial.srcBlend=this.srcBlend;
		destBaseMaterial.dstBlend=this.dstBlend;
		destBaseMaterial.srcBlendRGB=this.srcBlendRGB;
		destBaseMaterial.dstBlendRGB=this.dstBlendRGB;
		destBaseMaterial.srcBlendAlpha=this.srcBlendAlpha;
		destBaseMaterial.dstBlendAlpha=this.dstBlendAlpha;
		this.blendConstColor.cloneTo(destBaseMaterial.blendConstColor);
		destBaseMaterial.blendEquation=this.blendEquation;
		destBaseMaterial.blendEquationRGB=this.blendEquationRGB;
		destBaseMaterial.blendEquationAlpha=this.blendEquationAlpha;
		destBaseMaterial.depthTest=this.depthTest;
		destBaseMaterial.depthWrite=this.depthWrite;
		destBaseMaterial.renderQueue=this.renderQueue;
		destBaseMaterial._shader=this._shader;
		destBaseMaterial._disablePublicShaderDefine=this._disablePublicShaderDefine;
		destBaseMaterial._shaderDefineValue=this._shaderDefineValue;
		var i=0,n=0;
		var destShaderValues=destBaseMaterial._shaderValues;
		destBaseMaterial._shaderValues.data.length=this._shaderValues.data.length;
		var valueCount=this._values.length;
		var destValues=destBaseMaterial._values;
		destValues.length=valueCount;
		for (i=0,n=valueCount;i < n;i++){
			var value=this._values[i];
			if (value){
				if ((typeof value=='number')){
					destValues[i]=value;
					destShaderValues.data[i]=value;
					}else if (((typeof value=='number')&& Math.floor(value)==value)){
					destValues[i]=value;
					destShaderValues.data[i]=value;
					}else if ((typeof value=='boolean')){
					destValues[i]=value;
					destShaderValues.data[i]=value;
					}else if ((value instanceof laya.d3.math.Vector2 )){
					var v2=(destValues[i])|| (destValues[i]=new Vector2());
					(value).cloneTo(v2);
					destShaderValues.data[i]=v2.elements;
					}else if ((value instanceof laya.d3.math.Vector3 )){
					var v3=(destValues[i])|| (destValues[i]=new Vector3());
					(value).cloneTo(v3);
					destShaderValues.data[i]=v3.elements;
					}else if ((value instanceof laya.d3.math.Vector4 )){
					var v4=(destValues[i])|| (destValues[i]=new Vector4());
					(value).cloneTo(v4);
					destShaderValues.data[i]=v4.elements;
					}else if ((value instanceof laya.d3.math.Matrix4x4 )){
					var mat=(destValues[i])|| (destValues[i]=new Matrix4x4());
					(value).cloneTo(mat);
					destShaderValues.data[i]=mat.elements;
					}else if ((value instanceof laya.d3.resource.BaseTexture )){
					destValues[i]=value;
					destShaderValues.data[i]=value;
				}
			}
		}
	}

	/**
	*克隆。
	*@return 克隆副本。
	*/
	__proto.clone=function(){
		var destBaseMaterial=/*__JS__ */new this.constructor();
		this.cloneTo(destBaseMaterial);
		return destBaseMaterial;
	}

	/**
	*设置透明测试模式裁剪值。
	*@param value 透明测试模式裁剪值。
	*/
	/**
	*获取透明测试模式裁剪值。
	*@return 透明测试模式裁剪值。
	*/
	__getset(0,__proto,'alphaTestValue',function(){
		return this._getNumber(0);
		},function(value){
		this._setNumber(0,value);
	});

	/**
	*设置是否透明裁剪。
	*@param value 是否透明裁剪。
	*/
	/**
	*获取是否透明裁剪。
	*@return 是否透明裁剪。
	*/
	__getset(0,__proto,'alphaTest',function(){
		return this._alphaTest;
		},function(value){
		this._alphaTest=value;
		if (value)
			this._addShaderDefine(laya.d3.core.material.BaseMaterial.SHADERDEFINE_ALPHATEST);
		else
		this._removeShaderDefine(laya.d3.core.material.BaseMaterial.SHADERDEFINE_ALPHATEST);
	});

	BaseMaterial.__init__=function(){
		BaseMaterial.SHADERDEFINE_ALPHATEST=BaseMaterial.shaderDefines.registerDefine("ALPHATEST");
	}

	BaseMaterial.RENDERQUEUE_OPAQUE=2000;
	BaseMaterial.RENDERQUEUE_ALPHATEST=2450;
	BaseMaterial.RENDERQUEUE_TRANSPARENT=3000;
	BaseMaterial.CULL_NONE=0;
	BaseMaterial.CULL_FRONT=1;
	BaseMaterial.CULL_BACK=2;
	BaseMaterial.BLEND_DISABLE=0;
	BaseMaterial.BLEND_ENABLE_ALL=1;
	BaseMaterial.BLEND_ENABLE_SEPERATE=2;
	BaseMaterial.BLENDPARAM_ZERO=0;
	BaseMaterial.BLENDPARAM_ONE=1;
	BaseMaterial.BLENDPARAM_SRC_COLOR=0x0300;
	BaseMaterial.BLENDPARAM_ONE_MINUS_SRC_COLOR=0x0301;
	BaseMaterial.BLENDPARAM_DST_COLOR=0x0306;
	BaseMaterial.BLENDPARAM_ONE_MINUS_DST_COLOR=0x0307;
	BaseMaterial.BLENDPARAM_SRC_ALPHA=0x0302;
	BaseMaterial.BLENDPARAM_ONE_MINUS_SRC_ALPHA=0x0303;
	BaseMaterial.BLENDPARAM_DST_ALPHA=0x0304;
	BaseMaterial.BLENDPARAM_ONE_MINUS_DST_ALPHA=0x0305;
	BaseMaterial.BLENDPARAM_SRC_ALPHA_SATURATE=0x0308;
	BaseMaterial.BLENDEQUATION_ADD=0;
	BaseMaterial.BLENDEQUATION_SUBTRACT=1;
	BaseMaterial.BLENDEQUATION_REVERSE_SUBTRACT=2;
	BaseMaterial.DEPTHTEST_OFF=0;
	BaseMaterial.DEPTHTEST_NEVER=0x0200;
	BaseMaterial.DEPTHTEST_LESS=0x0201;
	BaseMaterial.DEPTHTEST_EQUAL=0x0202;
	BaseMaterial.DEPTHTEST_LEQUAL=0x0203;
	BaseMaterial.DEPTHTEST_GREATER=0x0204;
	BaseMaterial.DEPTHTEST_NOTEQUAL=0x0205;
	BaseMaterial.DEPTHTEST_GEQUAL=0x0206;
	BaseMaterial.DEPTHTEST_ALWAYS=0x0207;
	BaseMaterial.SHADERDEFINE_ALPHATEST=0x1;
	BaseMaterial.ALPHATESTVALUE=0;
	__static(BaseMaterial,
	['shaderDefines',function(){return this.shaderDefines=new ShaderDefines$1();}
	]);
	return BaseMaterial;
})(Resource)


/**
*<code>BaseTexture</code> 纹理的父类，抽象类，不允许实例。
*/
//class laya.d3.resource.BaseTexture extends laya.resource.Resource
var BaseTexture=(function(_super){
	function BaseTexture(){
		/**@private */
		this._type=0;
		/**@private */
		this._width=0;
		/**@private */
		this._height=0;
		/**@private */
		this._size=null;
		/**@private */
		this._repeat=false;
		/**@private */
		this._mipmap=false;
		/**@private */
		this._minFifter=0;
		/**@private */
		this._magFifter=0;
		/**@private */
		this._format=0;
		/**@private */
		this._source=null;
		/**@private */
		this._conchTexture=null;
		/**@private */
		this._wrapModeU=0;
		/**@private */
		this._wrapModeV=0;
		BaseTexture.__super.call(this);
		this._repeat=true;
		this.mipmap=true;
		this.minFifter=-1;
		this.magFifter=-1;
	}

	__class(BaseTexture,'laya.d3.resource.BaseTexture',_super);
	var __proto=BaseTexture.prototype;
	/**
	*获取宽度。
	*/
	__getset(0,__proto,'width',function(){
		return this._width;
	});

	/**
	*是否使用重复模式纹理寻址
	*/
	/**
	*是否使用重复模式纹理寻址
	*/
	__getset(0,__proto,'repeat',function(){
		return this._repeat;
		},function(value){
		if (this._repeat!==value){
			this._repeat=value;
			if (this._source){
				var gl=WebGL.mainContext;
				WebGLContext.bindTexture(gl,this._type,this._source);
				var isPot=Arith.isPOT(this._width,this._height);
				if (isPot && this._repeat){
					gl.texParameteri(this._type,/*laya.webgl.WebGLContext.TEXTURE_WRAP_S*/0x2802,/*laya.webgl.WebGLContext.REPEAT*/0x2901);
					gl.texParameteri(this._type,/*laya.webgl.WebGLContext.TEXTURE_WRAP_T*/0x2803,/*laya.webgl.WebGLContext.REPEAT*/0x2901);
					}else {
					gl.texParameteri(this._type,/*laya.webgl.WebGLContext.TEXTURE_WRAP_S*/0x2802,/*laya.webgl.WebGLContext.CLAMP_TO_EDGE*/0x812F);
					gl.texParameteri(this._type,/*laya.webgl.WebGLContext.TEXTURE_WRAP_T*/0x2803,/*laya.webgl.WebGLContext.CLAMP_TO_EDGE*/0x812F);
				}
			}
		}
	});

	/**
	*获取高度。
	*/
	__getset(0,__proto,'height',function(){
		return this._height;
	});

	/**
	*放大过滤器
	*/
	/**
	*放大过滤器
	*/
	__getset(0,__proto,'magFifter',function(){
		return this._magFifter;
		},function(value){
		this._magFifter=value;
		if (value !=this._magFifter){
			this._conchTexture && this._conchTexture.setMaxFifter(value);
		}
	});

	/**
	*获取纹理纵向循环模式。
	*/
	__getset(0,__proto,'wrapModeV',function(){
		return this._wrapModeV;
	});

	/**
	*获取尺寸。
	*/
	__getset(0,__proto,'size',function(){
		return this._size;
	});

	/**
	*获取纹理横向循环模式。
	*/
	__getset(0,__proto,'wrapModeU',function(){
		return this._wrapModeU;
	});

	/**
	*是否使用mipLevel
	*/
	/**
	*是否使用mipLevel
	*/
	__getset(0,__proto,'mipmap',function(){
		return this._mipmap;
		},function(value){
		this._mipmap=value;
		if (this._mipmap !=value){
			this._conchTexture && this._conchTexture.setMipMap(value);
		}
	});

	/**
	*缩小过滤器
	*/
	/**
	*缩小过滤器
	*/
	__getset(0,__proto,'minFifter',function(){
		return this._minFifter;
		},function(value){
		this._minFifter=value;
		if (this._minFifter !=value){
			this._conchTexture && this._conchTexture.setMinFifter(value);
		}
	});

	/**
	*纹理格式
	*/
	__getset(0,__proto,'format',function(){
		return this._format;
	});

	/**
	*获取纹理资源。
	*/
	__getset(0,__proto,'source',function(){
		this.activeResource();
		return this._source;
	});

	/**
	*获取纹理资源。
	*/
	__getset(0,__proto,'defaulteTexture',function(){
		return SolidColorTexture2D.grayTexture;
	});

	BaseTexture.WARPMODE_REPEAT=0;
	BaseTexture.WARPMODE_CLAMP=1;
	return BaseTexture;
})(Resource)


/**
*<code>BaseMesh</code> 类用于创建网格,抽象类,不允许实例。
*/
//class laya.d3.resource.models.BaseMesh extends laya.resource.Resource
var BaseMesh=(function(_super){
	function BaseMesh(){
		/**@private */
		this._subMeshCount=0;
		/**@private */
		this._boundingBox=null;
		/**@private */
		this._boundingSphere=null;
		/**@private */
		this._boundingBoxCorners=null;
		/**@private 只读,不允许修改。*/
		this._positions=null;
		BaseMesh.__super.call(this);
		this._boundingBoxCorners=__newvec(8,null);
	}

	__class(BaseMesh,'laya.d3.resource.models.BaseMesh',_super);
	var __proto=BaseMesh.prototype;
	/**
	*获取网格顶点,请重载此方法。
	*@return 网格顶点。
	*/
	__proto._getPositions=function(){
		throw new Error("未Override,请重载该属性！");
	}

	/**
	*@private
	*/
	__proto._generateBoundingObject=function(){
		this._boundingSphere=new BoundSphere(new Vector3(),0);
		BoundSphere.createfromPoints(this._positions,this._boundingSphere);
		this._boundingBox=new BoundBox(new Vector3(),new Vector3());
		BoundBox.createfromPoints(this._positions,this._boundingBox);
		this._boundingBox.getCorners(this._boundingBoxCorners);
	}

	/**
	*获取渲染单元数量,请重载此方法。
	*@return 渲染单元数量。
	*/
	__proto.getRenderElementsCount=function(){
		throw new Error("未Override,请重载该属性！");
	}

	/**
	*获取渲染单元,请重载此方法。
	*@param index 索引。
	*@return 渲染单元。
	*/
	__proto.getRenderElement=function(index){
		throw new Error("未Override,请重载该属性！");
	}

	/**
	*获取SubMesh的个数。
	*@return SubMesh的个数。
	*/
	__getset(0,__proto,'subMeshCount',function(){
		return this._subMeshCount;
	});

	/**
	*获取AABB包围盒,禁止修改其数据。
	*@return AABB包围盒。
	*/
	__getset(0,__proto,'boundingBox',function(){
		return this._boundingBox;
	});

	/**
	*获取包围球顶点,禁止修改其数据。
	*@return 包围球。
	*/
	__getset(0,__proto,'boundingBoxCorners',function(){
		return this._boundingBoxCorners;
	});

	/**
	*获取包围球,禁止修改其数据。
	*@return 包围球。
	*/
	__getset(0,__proto,'boundingSphere',function(){
		return this._boundingSphere;
	});

	return BaseMesh;
})(Resource)


/**
*<code>TerrainHeightData</code> 类用于描述地形高度信息。
*/
//class laya.d3.terrain.TerrainHeightData extends laya.resource.Resource
var TerrainHeightData=(function(_super){
	function TerrainHeightData(){
		this._terrainHeightData=null;
		this._width=0;
		this._height=0;
		this._bitType=0;
		this._value=NaN;
		TerrainHeightData.__super.call(this);
	}

	__class(TerrainHeightData,'laya.d3.terrain.TerrainHeightData',_super);
	var __proto=TerrainHeightData.prototype;
	/**
	*异步回调
	*/
	__proto.onAsynLoaded=function(url,data,params){
		this._width=params[0];
		this._height=params[1];
		this._bitType=params[2];
		this._value=params[3];
		var buffer;
		var ratio=NaN;
		if (this._bitType==8){
			buffer=new Uint8Array(data);
			ratio=1.0 / 255.0;
		}
		else if (this._bitType==16){
			buffer=new Int16Array(data);
			ratio=1.0 / 32766.0;
		}
		this._terrainHeightData=new Float32Array(this._height *this._width);
		for (var i=0,n=this._height *this._width;i < n;i++){
			this._terrainHeightData[i]=(buffer[i] *ratio *this._value)/2;
		}
		this._endLoaded();
	}

	TerrainHeightData.load=function(url,widht,height,bitType,value){
		return Laya.loader.create(url,null,null,TerrainHeightData,[widht,height,bitType,value],1,false);
	}

	return TerrainHeightData;
})(Resource)


/**
*<code>TerrainRes</code> 类用于描述地形信息。
*/
//class laya.d3.terrain.TerrainRes extends laya.resource.Resource
var TerrainRes=(function(_super){
	function TerrainRes(){
		this._version=NaN;
		this._cameraCoordinateInverse=false;
		this._gridSize=NaN;
		this._chunkNumX=0;
		this._chunkNumZ=0;
		this._heightDataX=0;
		this._heightDataZ=0;
		this._heightDataBitType=0;
		this._heightDataValue=NaN;
		this._heightDataUrl=null;
		this._detailTextureInfos=null;
		this._chunkInfos=null;
		this._heightData=null;
		this._materialInfo=null;
		this._alphaMaps=null;
		this._normalMaps=null;
		TerrainRes.__super.call(this);
	}

	__class(TerrainRes,'laya.d3.terrain.TerrainRes',_super);
	var __proto=TerrainRes.prototype;
	__proto.parseData=function(data){
		var json=data[0];
		var resouMap=data[1];
		this._version=json.version;
		if (this._version==1.0){
			this._cameraCoordinateInverse=json.cameraCoordinateInverse;
			this._gridSize=json.gridSize;
			this._chunkNumX=json.chunkNumX;
			this._chunkNumZ=json.chunkNumZ;
			var heightData=json.heightData;
			this._heightDataX=heightData.numX;
			this._heightDataZ=heightData.numZ;
			this._heightDataBitType=heightData.bitType;
			this._heightDataValue=heightData.value;
			this._heightDataUrl=resouMap[heightData.url];
			this._materialInfo=new MaterialInfo();
			if (json.material){
				var ambient=json.material.ambient;
				var diffuse=json.material.diffuse;
				var specular=json.material.specular;
				this._materialInfo.ambientColor=new Vector3(ambient[0],ambient[1],ambient[2]);
				this._materialInfo.diffuseColor=new Vector3(diffuse[0],diffuse[1],diffuse[2]);
				this._materialInfo.specularColor=new Vector4(specular[0],specular[1],specular[2],specular[3]);
			};
			var detailTextures=json.detailTexture;
			this._detailTextureInfos=__newvec(detailTextures.length);
			for (var i=0;i < detailTextures.length;i++){
				var detail=detailTextures[i];
				var info=new DetailTextureInfo();
				info.diffuseTexture=resouMap[detail.diffuse];
				info.normalTexture=detail.normal ? resouMap[detail.normal] :null;
				if (detail.scale){
					info.scale=new Vector2(detail.scale[0],detail.scale[1]);
					}else {
					info.scale=new Vector2(1,1);
				}
				if (detail.offset){
					info.offset=new Vector2(detail.offset[0],detail.offset[1]);
					}else {
					info.offset=new Vector2(0,0);
				}
				this._detailTextureInfos[i]=info;
			};
			var alphaMaps=json.alphaMap;
			this._alphaMaps=__newvec(alphaMaps.length);
			for (i=0;i < this._alphaMaps.length;i++){
				this._alphaMaps[i]=json.alphaMap[i];
			};
			var normalMaps=json.normalMap;
			this._normalMaps=__newvec(normalMaps.length);
			for (i=0;i < this._normalMaps.length;i++){
				this._normalMaps[i]=json.normalMap[i];
			};
			var jchunks=json.chunkInfo;
			if (this._chunkNumX *this._chunkNumZ !=jchunks.length){
				alert("terrain data error");
				return false;
			}
			this._chunkInfos=__newvec(jchunks.length);
			for (i=0;i < jchunks.length;i++){
				var jchunk=jchunks[i];
				var chunkinfo=new ChunkInfo();
				var nAlphaMapNum=jchunk.alphaMap.length;
				var nDetailIDNum=jchunk.detailID.length;
				if (nAlphaMapNum !=nDetailIDNum){
					alert("terrain chunk data error");
					return false;
				}
				chunkinfo.alphaMap=__newvec(nAlphaMapNum);
				chunkinfo.detailID=__newvec(nDetailIDNum);
				chunkinfo.normalMap=resouMap[this._normalMaps[jchunk.normalMap]];
				for (var j=0;j < nAlphaMapNum;j++){
					chunkinfo.alphaMap[j]=resouMap[this._alphaMaps[jchunk.alphaMap[j]]];
					var jid=jchunk.detailID[j];
					var nIDNum=jid.length;
					chunkinfo.detailID[j]=new Uint8Array(nIDNum);
					for (var k=0;k < nIDNum;k++){
						chunkinfo.detailID[j][k]=jid[k];
					}
				}
				this._chunkInfos[i]=chunkinfo;
			}
			this._heightData=Loader.getRes(this._heightDataUrl);
			this.onLoadTerrainComplete(this._heightData);
		}
		return true;
	}

	__proto.onLoadTerrainComplete=function(heightData){
		this._endLoaded();
	}

	/**
	*异步回调
	*/
	__proto.onAsynLoaded=function(url,data,params){
		this.parseData(data);
	}

	TerrainRes.load=function(url){
		return Laya.loader.create(url,null,null,TerrainRes,null,1,false);
	}

	return TerrainRes;
})(Resource)


/**
*<code>KeyframeAnimation</code> 类用于帧动画组件的父类。
*/
//class laya.d3.component.animation.KeyframeAnimations extends laya.d3.component.Component3D
var KeyframeAnimations=(function(_super){
	function KeyframeAnimations(){
		/**动画播放器。*/
		this._player=null;
		/**@private */
		this._templet=null;
		KeyframeAnimations.__super.call(this);
		this._player=new AnimationPlayer();
	}

	__class(KeyframeAnimations,'laya.d3.component.animation.KeyframeAnimations',_super);
	var __proto=KeyframeAnimations.prototype;
	/**
	*@private
	*/
	__proto._updateAnimtionPlayer=function(){
		this._player._update(Laya.timer.delta);
	}

	/**
	*@private
	*/
	__proto._addUpdatePlayerToTimer=function(){
		Laya.timer.frameLoop(1,this,this._updateAnimtionPlayer);
	}

	/**
	*@private
	*/
	__proto._removeUpdatePlayerToTimer=function(){
		Laya.timer.clear(this,this._updateAnimtionPlayer);
	}

	/**
	*@private
	*/
	__proto._onOwnerActiveHierarchyChanged=function(active){
		if ((this._owner).displayedInStage){
			if (active)
				this._addUpdatePlayerToTimer();
			else
			this._removeUpdatePlayerToTimer();
		}
	}

	/**
	*@private
	*载入组件时执行
	*/
	__proto._load=function(owner){
		((owner).activeInHierarchy)&& (this._addUpdatePlayerToTimer());
		owner.on(/*laya.events.Event.ACTIVE_IN_HIERARCHY_CHANGED*/"activeinhierarchychanged",this,this._onOwnerActiveHierarchyChanged);
	}

	/**
	*@private
	*卸载组件时执行
	*/
	__proto._unload=function(owner){
		_super.prototype._unload.call(this,owner);
		((owner).activeInHierarchy)&& (this._removeUpdatePlayerToTimer());
		owner.off(/*laya.events.Event.ACTIVE_IN_HIERARCHY_CHANGED*/"activeinhierarchychanged",this,this._onOwnerActiveHierarchyChanged);
		this._player._destroy();
		this._player=null;
		this._templet=null;
	}

	/**
	*设置url地址。
	*@param value 地址。
	*/
	__getset(0,__proto,'url',null,function(value){
		console.log("Warning: discard property,please use templet property instead.");
		var templet=Laya.loader.create(value,null,null,AnimationTemplet);
		if (this._templet!==templet){
			if (this._player.state!==/*laya.ani.AnimationState.stopped*/0)
				this._player.stop(true);
			this._templet=templet;
			this._player.templet=templet;
			this.event(/*laya.events.Event.ANIMATION_CHANGED*/"animationchanged",this);
		}
	});

	/**
	*获取动画播放器。
	*@return 动画播放器。
	*/
	__getset(0,__proto,'player',function(){
		return this._player;
	});

	/**
	*设置动画模板。
	*@param value 设置动画模板。
	*/
	/**
	*获取动画模板。
	*@return value 动画模板。
	*/
	__getset(0,__proto,'templet',function(){
		return this._templet;
		},function(value){
		if (this._templet!==value){
			if (this._player.state!==/*laya.ani.AnimationState.stopped*/0)
				this._player.stop(true);
			this._templet=value;
			this._player.templet=value;
			this.event(/*laya.events.Event.ANIMATION_CHANGED*/"animationchanged",this);
		}
	});

	/**
	*获取播放器帧数。
	*@return 播放器帧数。
	*/
	__getset(0,__proto,'currentFrameIndex',function(){
		return this._player.currentKeyframeIndex;
	});

	/**
	*获取播放器的动画索引。
	*@return 动画索引。
	*/
	__getset(0,__proto,'currentAnimationClipIndex',function(){
		return this._player.currentAnimationClipIndex;
	});

	/**
	*获取播放器当前动画的节点数量。
	*@return 节点数量。
	*/
	__getset(0,__proto,'nodeCount',function(){
		return this._templet.getNodeCount(this._player.currentAnimationClipIndex);
	});

	return KeyframeAnimations;
})(Component3D)


/**
*<code>Animations</code> 类用于创建动画组件。
*/
//class laya.d3.component.Animator extends laya.d3.component.Component3D
var Animator=(function(_super){
	function Animator(){
		/**@private */
		//this._updateTransformPropertyLoopCount=0;
		/**@private */
		//this._cacheFrameRateInterval=NaN;
		/**@private */
		//this._cacheFrameRate=0;
		/**@private */
		//this._cachePlayRate=NaN;
		/**@private */
		//this._currentPlayClip=null;
		/**@private */
		//this._currentPlayClipIndex=0;
		/**@private */
		//this._stoped=false;
		/**@private */
		//this._currentTime=NaN;
		/**@private */
		//this._currentFrameTime=NaN;
		/**@private */
		//this._currentFrameIndex=0;
		/**@private */
		//this._elapsedPlaybackTime=NaN;
		/**@private */
		//this._startUpdateLoopCount=NaN;
		/**@private */
		//this._clipNames=null;
		/**@private */
		//this._clips=null;
		/**@private */
		//this._playStartFrames=null;
		/**@private */
		//this._playEndFrames=null;
		/**@private */
		//this._playEventIndex=0;
		/**@private */
		//this._defaultClipIndex=0;
		/**@private */
		//this._avatar=null;
		/**@private */
		//this._cacheNodesDefaultlValues=null;
		/**@private 无Avatar时缓存场景树中的精灵节点。*/
		//this._cacheNodesSpriteOwners=null;
		/**@private 有Avatar时缓存Avatar树中的AnimationNode节点。*/
		//this._cacheNodesAvatarOwners=null;
		/**@private */
		//this._lastPlayAnimationClip=null;
		/**@private */
		//this._lastPlayAnimationClipIndex=0;
		/**@private */
		//this._publicClipsDatas=null;
		/**@private */
		//this._publicAvatarNodeDatas=null;
		/**@private */
		//this._curAvatarNodeDatas=null;
		/**@private */
		//this._cacheNodesToSpriteMap=null;
		/**@private */
		//this._cacheSpriteToNodesMap=null;
		/**@private */
		//this._cacheFullFrames=null;
		/**@private */
		//this._linkSpritesData=null;
		/**@private */
		//this._avatarNodeMap=null;
		/**@private */
		//this._avatarNodes=null;
		/**@private */
		//this._canCache=false;
		/**@private */
		//this._lastFrameIndex=0;
		/**是否为缓存模式*/
		//this.isCache=false;
		/**播放速率*/
		//this.playbackRate=NaN;
		/**激活时是否自动播放*/
		//this.playOnWake=false;
		Animator.__super.call(this);
		this._clipNames=[];
		this._clips=[];
		this._playStartFrames=[];
		this._playEndFrames=[];
		this._cacheNodesSpriteOwners=[];
		this._cacheNodesAvatarOwners=[];
		this._cacheNodesDefaultlValues=[];
		this._cacheNodesToSpriteMap=[];
		this._cacheSpriteToNodesMap=[];
		this._cacheFullFrames=[];
		this._publicClipsDatas=[];
		this._playEventIndex=-1;
		this._updateTransformPropertyLoopCount=-1;
		this._lastFrameIndex=-1;
		this._defaultClipIndex=-1;
		this._cachePlayRate=1.0;
		this._currentPlayClip=null;
		this._currentFrameIndex=-1;
		this._currentTime=0.0;
		this._elapsedPlaybackTime=0;
		this._startUpdateLoopCount=-1;
		this.isCache=true;
		this.cacheFrameRate=60;
		this.playbackRate=1.0;
		this.playOnWake=true;
	}

	__class(Animator,'laya.d3.component.Animator',_super);
	var __proto=Animator.prototype;
	Laya.imps(__proto,{"laya.resource.IDestroy":true})
	/**
	*@private
	*/
	__proto._getAvatarOwnersByClip=function(clipIndex){
		var frameNodes=this._clips[clipIndex]._nodes;
		var frameNodesCount=frameNodes.length;
		var owners=this._cacheNodesAvatarOwners[clipIndex];
		owners.length=frameNodesCount;
		var defaultValues=this._cacheNodesDefaultlValues[clipIndex];
		defaultValues.length=frameNodesCount;
		for (var i=0;i < frameNodesCount;i++){
			var nodeOwner=this._avatarNodes[0];
			var node=frameNodes[i];
			var path=node.path;
			for (var j=0,m=path.length;j < m;j++){
				var p=path[j];
				if (p===""){
					break ;
					}else {
					nodeOwner=nodeOwner.getChildByName(p);
					if (!nodeOwner)
						break ;
				}
			}
			if (!nodeOwner)
				continue ;
			owners[i]=nodeOwner;
			var datas=AnimationNode._propertyGetFuncs[node.propertyNameID](nodeOwner);
			if (datas){
				var cacheDatas=new Float32Array(node.keyFrameWidth);
				defaultValues[i]=cacheDatas;
				for (j=0,m=datas.length;j < m;j++)
				cacheDatas[j]=datas[j];
			}
		}
	}

	/**
	*@private
	*/
	__proto._handleSpriteOwnersByClip=function(clipIndex){
		var frameNodes=this._clips[clipIndex]._nodes;
		var frameNodesCount=frameNodes.length;
		var owners=this._cacheNodesSpriteOwners[clipIndex];
		owners.length=frameNodesCount;
		var defaultValues=this._cacheNodesDefaultlValues[clipIndex];
		defaultValues.length=frameNodesCount;
		for (var i=0;i < frameNodesCount;i++){
			var nodeOwner=this._owner;
			var node=frameNodes[i];
			var path=node.path;
			var j=0,m=0;
			for (j=0,m=path.length;j < m;j++){
				var p=path[j];
				if (p===""){
					break ;
					}else {
					nodeOwner=nodeOwner.getChildByName(p);
					if (!nodeOwner)
						break ;
				}
			}
			if (nodeOwner){
				owners[i]=nodeOwner;
				var datas=AnimationNode._propertyGetFuncs[node.propertyNameID](null,nodeOwner);
				if (datas){
					var cacheDatas=new Float32Array(node.keyFrameWidth);
					defaultValues[i]=cacheDatas;
					for (j=0,m=datas.length;j < m;j++)
					cacheDatas[j]=datas[j];
				}
			}
		}
	}

	/**
	*@private
	*/
	__proto._offClipAndAvatarRelateEvent=function(avatar,clip){
		if (avatar.loaded){
			if (!clip.loaded)
				clip.off(/*laya.events.Event.LOADED*/"loaded",this,this._getAvatarOwnersByClip);
			}else {
			avatar.off(/*laya.events.Event.LOADED*/"loaded",this,this._getAvatarOwnersAndInitDatasAsync);
		}
	}

	/**
	*@private
	*/
	__proto._getAvatarOwnersByClipAsync=function(clipIndex,clip){
		if (clip.loaded)
			this._getAvatarOwnersByClip(clipIndex);
		else
		clip.once(/*laya.events.Event.LOADED*/"loaded",this,this._getAvatarOwnersByClip,[clipIndex]);
	}

	/**
	*@private
	*/
	__proto._offGetSpriteOwnersByClipAsyncEvent=function(clip){
		if (!clip.loaded)
			clip.off(/*laya.events.Event.LOADED*/"loaded",this,this._getSpriteOwnersByClipAsync);
	}

	/**
	*@private
	*/
	__proto._getSpriteOwnersByClipAsync=function(clipIndex,clip){
		if (clip.loaded)
			this._handleSpriteOwnersByClip(clipIndex);
		else
		clip.once(/*laya.events.Event.LOADED*/"loaded",this,this._handleSpriteOwnersByClip,[clipIndex]);
	}

	/**
	*@private
	*/
	__proto._getAvatarOwnersAndInitDatasAsync=function(){
		for (var i=0,n=this._clips.length;i < n;i++)
		this._getAvatarOwnersByClipAsync(i,this._clips[i]);
		this._avatar._cloneDatasToAnimator(this);
		for (i=0,n=this._avatarNodes.length;i < n;i++)
		this._checkAnimationNode(this._avatarNodes[i],this._owner);
	}

	/**
	*@private
	*/
	__proto._offGetClipCacheFullKeyframeIndicesEvent=function(clip){
		(clip.loaded)|| (clip.off(/*laya.events.Event.LOADED*/"loaded",this,this._computeCacheFullKeyframeIndices));
	}

	/**
	*@private
	*/
	__proto._computeCacheFullKeyframeIndices=function(clipIndex){
		var clip=this._clips[clipIndex];
		var cacheInterval=this._cacheFrameRateInterval *this._cachePlayRate;
		var clipCacheFullFrames=clip._getFullKeyframeIndicesWithCache(cacheInterval);
		if (clipCacheFullFrames){
			this._cacheFullFrames[clipIndex]=clipCacheFullFrames;
			return;
			}else {
			clipCacheFullFrames=this._cacheFullFrames[clipIndex]=[];
			var nodes=clip._nodes;
			var nodeCount=nodes.length;
			clipCacheFullFrames.length=nodeCount;
			var frameCount=Math.ceil(clip._duration / cacheInterval-0.00001)+1;
			for (var i=0;i < nodeCount;i++){
				var node=nodes[i];
				var nodeFullFrames=new Int32Array(frameCount);
				(nodeFullFrames).fill(-1);
				var keyFrames=node.keyFrames;
				for (var j=0,n=keyFrames.length;j < n;j++){
					var keyFrame=keyFrames[j];
					var startTime=keyFrame.startTime;
					var endTime=startTime+keyFrame.duration;
					while (startTime <=endTime){
						var frameIndex=Math.ceil(startTime / cacheInterval-0.00001);
						nodeFullFrames[frameIndex]=j;
						startTime+=cacheInterval;
					}
				}
				clipCacheFullFrames[i]=nodeFullFrames;
			}
			clip._cacheFullKeyframeIndices(cacheInterval,clipCacheFullFrames);
		}
	}

	/**
	*@private
	*/
	__proto._updateAnimtionPlayer=function(){
		this._updatePlayer(Laya.timer.delta / 1000.0);
	}

	/**
	*@private
	*/
	__proto._onOwnerActiveHierarchyChanged=function(){
		var owner=this._owner;
		if (owner.activeInHierarchy){
			Laya.timer.frameLoop(1,this,this._updateAnimtionPlayer);
			(this.playOnWake && this.clip)&& (this.play());
			}else {
			(this.playState!==/*laya.ani.AnimationState.stopped*/0)&& (this._stoped=true);
			Laya.timer.clear(this,this._updateAnimtionPlayer);
		}
	}

	/**
	*@private
	*/
	__proto._eventScript=function(from,to){
		var events=this._currentPlayClip._animationEvents;
		for (var n=events.length;this._playEventIndex < n;this._playEventIndex++){
			var eve=events[this._playEventIndex];
			var eventTime=eve.time;
			if (from <=eventTime && eventTime < to){
				var scripts=this._owner._scripts;
				for (var j=0,m=scripts.length;j < m;j++){
					var script=scripts[j];
					var fun=script[eve.eventName];
					(fun)&& (fun.apply(script,eve.params));
				}
				}else {
				break ;
			}
		}
	}

	/**
	*@private
	*/
	__proto._setPlayParams=function(time,cacheFrameInterval){
		var lastTime=this._currentTime;
		this._currentTime=time;
		this._currentFrameIndex=Math.max(Math.floor(this.currentPlayTime / cacheFrameInterval-0.00001),0);
		this._currentFrameTime=this._currentFrameIndex *cacheFrameInterval;
		this._eventScript(lastTime,time);
	}

	/**
	*@private
	*/
	__proto._setPlayParamsWhenStop=function(aniClipPlayDuration,cacheFrameInterval){
		var lastTime=this._currentTime;
		this._currentTime=aniClipPlayDuration;
		this._currentFrameIndex=Math.max(Math.floor(aniClipPlayDuration / cacheFrameInterval-0.00001),0);
		this._currentFrameTime=this._currentFrameIndex *cacheFrameInterval;
		this._eventScript(lastTime,aniClipPlayDuration);
		this._currentPlayClip=null;
	}

	/**
	*@private
	*/
	__proto._revertKeyframeNodes=function(clip,clipIndex){
		var originalValues=this._cacheNodesDefaultlValues[clipIndex];
		var frameNodes=clip._nodes;
		if (this._avatar){
			var avatarOwners=this._cacheNodesAvatarOwners[clipIndex];
			for (var i=0,n=avatarOwners.length;i < n;i++){
				var avatarOwner=avatarOwners[i];
				(avatarOwner)&& (AnimationNode._propertySetFuncs[frameNodes[i].propertyNameID](avatarOwner,null,originalValues[i]));
			}
			}else {
			var spriteOwners=this._cacheNodesSpriteOwners[clipIndex];
			for (i=0,n=spriteOwners.length;i < n;i++){
				var spriteOwner=spriteOwners[i];
				(spriteOwner)&& (AnimationNode._propertySetFuncs[frameNodes[i].propertyNameID](null,spriteOwner,originalValues[i]));
			}
		}
	}

	/**
	*@private
	*/
	__proto._onAnimationStop=function(){
		var i=0,n=0;
		var frameNode,keyFrames,endKeyframeData;
		this._lastFrameIndex=-1;
		var frameNodes=this._currentPlayClip._nodes;
		if (this._avatar){
			var avatarOwners=this._cacheNodesAvatarOwners[this._currentPlayClipIndex];
			for (i=0,n=avatarOwners.length;i < n;i++){
				var nodeOwner=avatarOwners[i];
				frameNode=frameNodes[i];
				keyFrames=frameNode.keyFrames;
				endKeyframeData=keyFrames[keyFrames.length-1].data;
				(nodeOwner)&& (AnimationNode._propertySetFuncs[frameNode.propertyNameID](nodeOwner,null,endKeyframeData));
			}
			}else {
			var spriteOwners=this._cacheNodesSpriteOwners[this._currentPlayClipIndex];
			for (i=0,n=spriteOwners.length;i < n;i++){
				var spriteOwner=spriteOwners[i];
				frameNode=frameNodes[i];
				keyFrames=frameNode.keyFrames;
				endKeyframeData=keyFrames[keyFrames.length-1].data;
				(spriteOwner)&& (AnimationNode._propertySetFuncs[frameNode.propertyNameID](null,spriteOwner,endKeyframeData));
			}
		}
	}

	/**
	*@private
	*/
	__proto._setAnimationClipPropertyToAnimationNode=function(nodeOwners,propertyMap,clipDatas){
		for (var i=0,n=propertyMap.length;i < n;i++){
			var nodexIndex=propertyMap[i];
			var owner=nodeOwners[nodexIndex];
			if (owner){
				var ketframeNode=this._currentPlayClip._nodes[nodexIndex];
				var datas=clipDatas[nodexIndex];
				(datas)&& (AnimationNode._propertySetFuncs[ketframeNode.propertyNameID](owner,null,datas));
			}
		}
	}

	/**
	*@private
	*/
	__proto._setAnimationClipPropertyToSprite3D=function(nodeOwners,curClipAnimationDatas){
		for (var i=0,n=nodeOwners.length;i < n;i++){
			var owner=nodeOwners[i];
			if (owner){
				var ketframeNode=this._currentPlayClip._nodes[i];
				var datas=curClipAnimationDatas[i];
				(datas)&& (AnimationNode._propertySetFuncs[ketframeNode.propertyNameID](null,owner,datas));
			}
		}
	}

	/**
	*@private
	*/
	__proto._handleSpriteOwnersBySprite=function(clipIndex,isLink,path,sprite){
		var clip=this._clips[clipIndex];
		var nodePath=path.join("/");
		var ownersNodes=clip._nodesMap[nodePath];
		if (ownersNodes){
			var owners=this._cacheNodesSpriteOwners[clipIndex];
			var nodes=clip._nodes;
			var defaultValues=this._cacheNodesDefaultlValues[clipIndex];
			for (var i=0,n=ownersNodes.length;i < n;i++){
				var node=ownersNodes[i];
				var index=nodes.indexOf(node);
				if (isLink){
					owners[index]=sprite;
					var datas=AnimationNode._propertyGetFuncs[node.propertyNameID](null,sprite);
					if (datas){
						var cacheDatas=defaultValues[index];
						(cacheDatas)|| (defaultValues[index]=cacheDatas=new Float32Array(node.keyFrameWidth));
						for (var j=0,m=datas.length;j < m;j++)
						cacheDatas[j]=datas[j];
					}
					}else {
					owners[index]=null;
				}
			}
		}
	}

	/**
	*@private
	*/
	__proto._evaluateAvatarNodesCacheMode=function(avatarOwners,clip,publicClipDatas,avatarNodeDatas,unCacheMap){
		clip._evaluateAnimationlDatasCacheMode(avatarOwners,this._cacheFullFrames[this._currentPlayClipIndex],this,publicClipDatas,unCacheMap);
		this._setAnimationClipPropertyToAnimationNode(avatarOwners,unCacheMap,publicClipDatas);
		for (var i=0,n=this._avatarNodes.length;i < n;i++){
			var node=this._avatarNodes[i];
			var nodeTransform=node.transform;
			if (nodeTransform._worldUpdate){
				var nodeMatrix=new Float32Array(16);
				avatarNodeDatas[i]=nodeMatrix;
				nodeTransform._setWorldMatrixAndUpdate(nodeMatrix);
				}else {
				var mat=nodeTransform.getWorldMatrix();
				avatarNodeDatas[i]=mat ? mat :Animator.deafaultMatrix;
			}
		}
	}

	/**
	*@private
	*/
	__proto._evaluateAvatarNodesRealTime=function(avatarOwners,clip,publicClipDatas,avatarNodeDatas,unCacheMap){
		clip._evaluateAnimationlDatasRealTime(avatarOwners,this.currentPlayTime,publicClipDatas,unCacheMap);
		this._setAnimationClipPropertyToAnimationNode(avatarOwners,unCacheMap,publicClipDatas);
		for (var i=0,n=this._avatarNodes.length;i < n;i++){
			var transform=this._avatarNodes[i].transform;
			if (transform._worldUpdate)
				transform._setWorldMatrixNoUpdate(avatarNodeDatas[i]);
			else
			avatarNodeDatas[i]=Animator.deafaultMatrix;
		}
	}

	/**
	*@private
	*/
	__proto._updateAvatarNodesToSpriteCacheMode=function(clip,avatarNodeDatas){
		for (var i=0,n=this._cacheSpriteToNodesMap.length;i < n;i++){
			var nodeIndex=this._cacheSpriteToNodesMap[i];
			var nodeMatrix=avatarNodeDatas[nodeIndex];
			if (nodeMatrix!==Animator.deafaultMatrix){
				var spriteTransform=this._avatarNodes[nodeIndex].transform._entity;
				var spriteWorldMatrix=spriteTransform.worldMatrix;
				Utils3D.matrix4x4MultiplyMFM((this._owner)._transform.worldMatrix,nodeMatrix,spriteWorldMatrix);
				spriteTransform.worldMatrix=spriteWorldMatrix;
			}
		}
	}

	/**
	*@private
	*/
	__proto._updateAvatarNodesToSpriteRealTime=function(){
		for (var i=0,n=this._cacheSpriteToNodesMap.length;i < n;i++){
			var node=this._avatarNodes[this._cacheSpriteToNodesMap[i]];
			var spriteTransform=node.transform._entity;
			var nodeTransform=node.transform;
			if (nodeTransform._worldUpdate){
				var nodeMatrix=Animator._tempMatrix4x40;
				nodeTransform._setWorldMatrixAndUpdate(nodeMatrix);
				var spriteWorldMatrix=spriteTransform.worldMatrix;
				Utils3D.matrix4x4MultiplyMFM((this._owner)._transform.worldMatrix,nodeMatrix,spriteWorldMatrix);
				spriteTransform.worldMatrix=spriteWorldMatrix;
			}
		}
	}

	/**
	*@private
	*/
	__proto._updatePlayer=function(elapsedTime){
		if (this._currentPlayClip==null || this._stoped || !this._currentPlayClip.loaded)
			return;
		var cacheFrameInterval=this._cacheFrameRateInterval *this._cachePlayRate;
		var time=0;
		(this._startUpdateLoopCount!==Stat.loopCount)&& (time=elapsedTime *this.playbackRate,this._elapsedPlaybackTime+=time);
		var frameRate=this._currentPlayClip._frameRate;
		var playStart=this._playStartFrames[this._currentPlayClipIndex] / frameRate;
		var playEnd=Math.min(this._playEndFrames[this._currentPlayClipIndex] / frameRate,this._currentPlayClip._duration);
		var aniClipPlayDuration=playEnd-playStart;
		if ((!this._currentPlayClip.islooping && this._elapsedPlaybackTime >=aniClipPlayDuration)){
			this._onAnimationStop();
			this._setPlayParamsWhenStop(aniClipPlayDuration,cacheFrameInterval);
			this.event(/*laya.events.Event.STOPPED*/"stopped");
			return;
		}
		time+=this._currentTime;
		if (aniClipPlayDuration > 0){
			if (time >=aniClipPlayDuration){
				do {
					time-=aniClipPlayDuration;
					if (time < aniClipPlayDuration){
						this._setPlayParams(time,cacheFrameInterval);
						this.event(/*laya.events.Event.COMPLETE*/"complete");
					}
					this._playEventIndex=0;
					this._eventScript(0,time);
				}while (time >=aniClipPlayDuration)
				}else {
				this._setPlayParams(time,cacheFrameInterval);
			}
			}else {
			this._currentTime=this._currentFrameTime=this._currentFrameIndex=this._playEventIndex=0;
			this.event(/*laya.events.Event.COMPLETE*/"complete");
		}
	}

	/**
	*@private
	*更新蒙皮动画组件。
	*@param state 渲染状态参数。
	*/
	__proto._update=function(state){
		var clip=this._currentPlayClip;
		if (this.playState!==/*laya.ani.AnimationState.playing*/2 || !clip || !clip.loaded)
			return;
		var rate=this.playbackRate *Laya.timer.scale;
		var cacheRate=this._cachePlayRate;
		this._canCache=this.isCache && rate >=cacheRate;
		var frameIndex=-1;
		var clipDatas;
		if (this._canCache){
			frameIndex=this._currentFrameIndex;
			if (this._lastFrameIndex===frameIndex)
				return;
			clipDatas=clip._getAnimationDataWithCache(cacheRate,frameIndex);
			if (this._avatar){
				var avatarOwners=this._cacheNodesAvatarOwners[this._currentPlayClipIndex];
				var cacheMap=clip._cachePropertyMap;
				var cacheMapCount=cacheMap.length;
				if (cacheMapCount > 0){
					if (!clipDatas){
						clipDatas=[];
						clipDatas.length=cacheMapCount;
						clip._cacheAnimationData(cacheRate,frameIndex,clipDatas);
						clip._evaluateAnimationlDatasCacheMode(avatarOwners,this._cacheFullFrames[this._currentPlayClipIndex],this,clipDatas,cacheMap);
					}
					this._setAnimationClipPropertyToAnimationNode(avatarOwners,cacheMap,clipDatas);
				}
				this._curAvatarNodeDatas=clip._getAvatarDataWithCache(this._avatar,this._cachePlayRate,frameIndex);
				if (!this._curAvatarNodeDatas){
					this._curAvatarNodeDatas=[];
					this._curAvatarNodeDatas.length=this._avatarNodes.length;
					clip._cacheAvatarData(this._avatar,this._cachePlayRate,frameIndex,this._curAvatarNodeDatas);
					this._evaluateAvatarNodesCacheMode(avatarOwners,clip,clip._publicClipDatas,this._curAvatarNodeDatas,clip._unCachePropertyMap);
				}
				this._updateAvatarNodesToSpriteCacheMode(clip,this._curAvatarNodeDatas);
				}else {
				var spriteOwners=this._cacheNodesSpriteOwners[this._currentPlayClipIndex];
				if (!clipDatas){
					clipDatas=[];
					clipDatas.length=this._currentPlayClip._nodes.length;
					clip._evaluateAnimationlDatasCacheMode(spriteOwners,this._cacheFullFrames[this._currentPlayClipIndex],this,clipDatas,null);
					clip._cacheAnimationData(cacheRate,frameIndex,clipDatas);
				}
				this._setAnimationClipPropertyToSprite3D(spriteOwners,clipDatas);
			}
			}else {
			clipDatas=clip._publicClipDatas;
			if (this._avatar){
				clip._evaluateAnimationlDatasRealTime(this._cacheNodesAvatarOwners[this._currentPlayClipIndex],this.currentPlayTime,clipDatas,clip._cachePropertyMap);
				if (!this._publicAvatarNodeDatas){
					this._publicAvatarNodeDatas=[];
					var nodeCount=this._avatarNodes.length;
					this._publicAvatarNodeDatas.length=nodeCount;
					for (var i=1;i < nodeCount;i++)
					this._publicAvatarNodeDatas[i]=new Float32Array(16);
				}
				this._curAvatarNodeDatas=this._publicAvatarNodeDatas;
				this._evaluateAvatarNodesRealTime(this._cacheNodesAvatarOwners[this._currentPlayClipIndex],clip,clipDatas,this._curAvatarNodeDatas,clip._unCachePropertyMap);
				this._updateAvatarNodesToSpriteRealTime();
				}else {
				clip._evaluateAnimationlDatasRealTime(this._cacheNodesSpriteOwners[this._currentPlayClipIndex],this.currentPlayTime,clipDatas,null);
			}
		}
		this._lastFrameIndex=frameIndex;
	}

	/**
	*@private
	*/
	__proto._checkAnimationNode=function(node,sprite){
		if (node.name===sprite.name && !sprite._transform.dummy)
			sprite._isLinkSpriteToAnimationNode(this,node,true);
		for (var i=0,n=sprite._childs.length;i < n;i++)
		this._checkAnimationNode(node,sprite.getChildAt(i));
	}

	/**
	*@inheritDoc
	*/
	__proto._load=function(owner){
		((owner).activeInHierarchy)&& (Laya.timer.frameLoop(1,this,this._updateAnimtionPlayer));
		this._owner.on(/*laya.events.Event.ACTIVE_IN_HIERARCHY_CHANGED*/"activeinhierarchychanged",this,this._onOwnerActiveHierarchyChanged);
	}

	/**
	*@inheritDoc
	*/
	__proto._unload=function(owner){
		_super.prototype._unload.call(this,owner);
		((owner).activeInHierarchy)&& (Laya.timer.clear(this,this._updateAnimtionPlayer));
		this._owner.off(/*laya.events.Event.ACTIVE_IN_HIERARCHY_CHANGED*/"activeinhierarchychanged",this,this._onOwnerActiveHierarchyChanged);
		this._curAvatarNodeDatas=null;
	}

	/**
	*@private
	*/
	__proto._destroy=function(){
		_super.prototype._destroy.call(this);
		for (var i=0,n=this._clips.length;i < n;i++)
		this._clips[i]._removeReference();
		this._currentPlayClip=null;
		this._clipNames=null;
		this._cacheNodesSpriteOwners=null;
		this._cacheNodesAvatarOwners=null;
		this._cacheNodesDefaultlValues=null;
		this._clips=null;
		this._cacheFullFrames=null;
	}

	/**
	*@private
	*/
	__proto._cloneTo=function(dest){
		var animator=dest;
		animator.avatar=this.avatar;
		var clipCount=this._clips.length;
		for (var i=0,n=this._clips.length;i < n;i++)
		animator.addClip(this._clips[i]);
		if (this.clip){
			animator.clip=this.clip;
		}
		if (this._linkSpritesData){
			animator._linkSpritesData={};
			for (var k in this._linkSpritesData)
			animator._linkSpritesData[k]=this._linkSpritesData[k].slice();
		}
	}

	/**
	*添加动画片段。
	*@param clip 动画片段。
	*@param playName 动画片段播放名称，如果为null,则使用clip.name作为播放名称。
	*@param 开始帧率。
	*@param 结束帧率。
	*/
	__proto.addClip=function(clip,playName,startFrame,endFrame){
		(startFrame===void 0)&& (startFrame=0);
		(endFrame===void 0)&& (endFrame=4294967295);
		playName=playName || clip.name;
		var index=this._clipNames.indexOf(playName);
		if (index!==-1){
			if (this._clips[index]!==clip)
				throw new Error("Animation:this playName has exist with another clip.");
			}else {
			var clipIndex=this._clips.indexOf(clip);
			if (startFrame < 0 || endFrame < 0)
				throw new Error("Animator:startFrame and endFrame must large than zero.");
			if (startFrame > endFrame)
				throw new Error("Animator:startFrame must less than endFrame.");
			this._clipNames.push(playName);
			this._clips.push(clip);
			this._playStartFrames.push(startFrame);
			this._playEndFrames.push(endFrame);
			this._cacheNodesSpriteOwners.push([]);
			this._cacheNodesAvatarOwners.push([]);
			this._cacheNodesDefaultlValues.push([]);
			this._publicClipsDatas.push([]);
			clip._addReference();
			clipIndex=this._clips.length-1;
			if (this._avatar){
				if (this._avatar.loaded)
					this._getAvatarOwnersByClipAsync(clipIndex,clip);
				else
				this._avatar.once(/*laya.events.Event.LOADED*/"loaded",this,this._getAvatarOwnersByClipAsync,[clipIndex,clip]);
				}else {
				this._getSpriteOwnersByClipAsync(clipIndex,clip);
			}
			if (clip.loaded)
				this._computeCacheFullKeyframeIndices(clipIndex);
			else
			clip.once(/*laya.events.Event.LOADED*/"loaded",this,this._computeCacheFullKeyframeIndices,[clipIndex]);
		}
	}

	/**
	*移除动画片段。
	*@param clip 动画片段。
	*/
	__proto.removeClip=function(clip){
		var index=this._clips.indexOf(clip);
		if (index!==-1){
			if (this._avatar)
				this._offClipAndAvatarRelateEvent(this._avatar,clip)
			else
			this._offGetSpriteOwnersByClipAsyncEvent(clip);
			this._offGetClipCacheFullKeyframeIndicesEvent(clip);
			this._clipNames.splice(index,1);
			this._clips.splice(index,1);
			this._playStartFrames.splice(index,1);
			this._playEndFrames.splice(index,1);
			this._cacheNodesSpriteOwners.splice(index,1);
			this._cacheNodesAvatarOwners.splice(index,1);
			this._cacheNodesDefaultlValues.splice(index,1);
			this._publicClipsDatas.splice(index,1);
			clip._removeReference();
		}
	}

	/**
	*通过播放名字移除动画片段。
	*@param playName 播放名字。
	*/
	__proto.removeClipByName=function(playName){
		var index=this._clipNames.indexOf(playName);
		if (index!==-1){
			var clip=this._clips[index];
			if (this._avatar)
				this._offClipAndAvatarRelateEvent(this._avatar,clip);
			else
			this._offGetSpriteOwnersByClipAsyncEvent(clip);
			this._offGetClipCacheFullKeyframeIndicesEvent(clip);
			this._clipNames.splice(index,1);
			this._clips.splice(index,1);
			this._playStartFrames.splice(index,1);
			this._playEndFrames.splice(index,1);
			this._cacheNodesSpriteOwners.splice(index,1);
			this._cacheNodesAvatarOwners.splice(index,1);
			this._cacheNodesDefaultlValues.splice(index,1);
			this._publicClipsDatas.splice(index,1);
		}
	}

	/**
	*通过播放名字获取动画片段。
	*@param playName 播放名字。
	*@return 动画片段。
	*/
	__proto.getClip=function(playName){
		var index=this._clipNames.indexOf(playName);
		if (index!==-1){
			return this._clips[index];
			}else {
			return null;
		}
	}

	/**
	*获取动画片段个数。
	*@return 动画个数。
	*/
	__proto.getClipCount=function(){
		return this._clips.length;
	}

	/**
	*播放动画。
	*@param name 如果为null则播放默认动画，否则按名字播放动画片段。
	*@param playbackRate 播放速率。
	*@param startFrame 开始帧率。
	*@param endFrame 结束帧率.-1表示为最大结束帧率。
	*/
	__proto.play=function(name,playbackRate){
		(playbackRate===void 0)&& (playbackRate=1.0);
		if (!name && this._defaultClipIndex==-1)
			throw new Error("Animator:must have  default clip value,please set clip property.");
		if (name){
			this._currentPlayClipIndex=this._clipNames.indexOf(name);
			this._currentPlayClip=this._clips[this._currentPlayClipIndex];
			}else {
			this._currentPlayClipIndex=this._defaultClipIndex;
			this._currentPlayClip=this._clips[this._defaultClipIndex];
		}
		this._currentTime=0;
		this._currentFrameTime=0;
		this._elapsedPlaybackTime=0;
		this._playEventIndex=0;
		this.playbackRate=playbackRate;
		this._stoped=false;
		this._currentFrameIndex=0;
		this._startUpdateLoopCount=Stat.loopCount;
		if (this._lastPlayAnimationClip)
			(this._lastPlayAnimationClip!==this._currentPlayClip)&& (this._revertKeyframeNodes(this._lastPlayAnimationClip,this._lastPlayAnimationClipIndex));
		this._updatePlayer(0);
		this._lastPlayAnimationClip=this._currentPlayClip;
		this._lastPlayAnimationClipIndex=this._currentPlayClipIndex;
	}

	/**
	*停止播放当前动画
	*/
	__proto.stop=function(){
		if (this.playState!==/*laya.ani.AnimationState.stopped*/0){
			this._stoped=true;
			this.event(/*laya.events.Event.STOPPED*/"stopped");
		}
	}

	/**
	*@private
	*/
	__proto._getLinkSpritePath=function(sprite3D,path){
		path.unshift(sprite3D.name);
		var parent=sprite3D._parent;
		if (parent._hierarchyAnimator===this)
			this._getLinkSpritePath(parent,path);
		else
		path.shift();
	}

	/**
	*关联精灵节点到Avatar节点,此Animator必须有Avatar文件。
	*@param nodeName 关联节点的名字。
	*@param sprite3D 精灵节点。
	*@return 是否关联成功。
	*/
	__proto.linkSprite3DToAvatarNode=function(nodeName,sprite3D){
		if (sprite3D._hierarchyAnimator===this){
			if (this._avatar){
				var node=this._avatarNodeMap[nodeName];
				if (node){this._linkSpritesData=this._linkSpritesData|| {};
					var path=[];
					this._getLinkSpritePath(sprite3D,path);
					this._linkSpritesData[nodeName]=path;
					sprite3D._isLinkSpriteToAnimationNode(this,node,true);
					return true;
					}else {
					return false;
				}
				}else {
				return false;
			}
			}else {
			throw("Animator:sprite3D must belong to this Animator");
			return false;
		}
	}

	/**
	*解除精灵节点到Avatar节点的关联,此Animator必须有Avatar文件。
	*@param sprite3D 精灵节点。
	*@return 是否解除关联成功。
	*/
	__proto.unLinkSprite3DToAvatarNode=function(sprite3D){
		if (this._avatar){
			var dummy=sprite3D.transform.dummy;
			if (dummy){
				var node=this._avatarNodeMap[dummy._owner.name];
				sprite3D._isLinkSpriteToAnimationNode(this,node,false);
				return true;
				}else {
				return false;
			}
			}else {
			return false;
		}
	}

	/**
	*获取当前播放状态
	*@return 当前播放状态
	*/
	__getset(0,__proto,'playState',function(){
		if (this._currentPlayClip==null)
			return /*laya.ani.AnimationState.stopped*/0;
		if (this._stoped)
			return /*laya.ani.AnimationState.stopped*/0;
		return /*laya.ani.AnimationState.playing*/2;
	});

	/**
	*设置avatar。
	*@param value avatar。
	*/
	/**
	*获取avatar。
	*@return avator。
	*/
	__getset(0,__proto,'avatar',function(){
		return this._avatar;
		},function(value){
		if (this._avatar!==value){
			var lastAvatar=this._avatar;
			this._avatar=value;
			var clipLength=this._clips.length;
			for (var i=0;i < clipLength;i++)
			this._offClipAndAvatarRelateEvent(lastAvatar,this._clips[i]);
			if (value){
				if (value.loaded)
					this._getAvatarOwnersAndInitDatasAsync();
				else
				value.once(/*laya.events.Event.LOADED*/"loaded",this,this._getAvatarOwnersAndInitDatasAsync);
			}
		}
	});

	/**
	*设置缓存播放帧率，缓存模式下生效。注意：修改此值会有计算开销。*
	*@return value 缓存播放帧率
	*/
	/**
	*获取缓存播放帧，缓存模式下生效。
	*@return value 缓存播放帧率。
	*/
	__getset(0,__proto,'cacheFrameRate',function(){
		return this._cacheFrameRate;
		},function(value){
		if (this._cacheFrameRate!==value){
			this._cacheFrameRate=value;
			this._cacheFrameRateInterval=1.0 / this._cacheFrameRate;
			for (var i=0,n=this._clips.length;i < n;i++)
			(this._clips[i].loaded)&& (this._computeCacheFullKeyframeIndices(i));
		}
	});

	/**
	*设置默认动画片段,AnimationClip名称为默认playName。
	*@param value 默认动画片段。
	*/
	/**
	*获取默认动画片段。
	*@return 默认动画片段。
	*/
	__getset(0,__proto,'clip',function(){
		return this._clips[this._defaultClipIndex];
		},function(value){
		var index=value ? this._clips.indexOf(value):-1;
		if (this._defaultClipIndex!==index){
			(this._defaultClipIndex!==-1)&& (this.removeClip(this._clips[this._defaultClipIndex]));
			(index!==-1)&& (this.addClip(value,value.name));
			this._defaultClipIndex=index;
		}
	});

	/**
	*获取当前帧数
	*@return 当前帧数
	*/
	__getset(0,__proto,'currentFrameIndex',function(){
		return this._currentFrameIndex;
	});

	/**
	*设置缓存播放速率，缓存模式下生效。注意：修改此值会有计算开销。*
	*@return value 缓存播放速率。
	*/
	/**
	*获取缓存播放速率，缓存模式下生效。*
	*@return 缓存播放速率。
	*/
	__getset(0,__proto,'cachePlayRate',function(){
		return this._cachePlayRate;
		},function(value){
		if (this._cachePlayRate!==value){
			this._cachePlayRate=value;
			for (var i=0,n=this._clips.length;i < n;i++)
			(this._clips[i].loaded)&& (this._computeCacheFullKeyframeIndices(i));
		}
	});

	/**
	*获取当前帧时间，不包括重播时间
	*@return value 当前时间
	*/
	__getset(0,__proto,'currentFrameTime',function(){
		return this._currentFrameTime;
	});

	/**
	*获取当前动画索引
	*@return value 当前动画索引
	*/
	__getset(0,__proto,'currentPlayClip',function(){
		return this._currentPlayClip;
	});

	/**
	*获取当前精确时间，不包括重播时间
	*@return value 当前时间
	*/
	__getset(0,__proto,'currentPlayTime',function(){
		return this._currentTime+(this._playStartFrames[this._currentPlayClipIndex] / this._currentPlayClip._frameRate);
	});

	/**
	*设置当前播放位置
	*@param value 当前时间
	*/
	__getset(0,__proto,'playbackTime',null,function(value){
		if (this._currentPlayClip==null || !this._currentPlayClip || !this._currentPlayClip.loaded)
			return;
		this._startUpdateLoopCount=Stat.loopCount;
		var cacheFrameInterval=this._cacheFrameRateInterval *this._cachePlayRate;
		this._currentTime=value;
		this._currentFrameIndex=Math.floor(this.currentPlayTime / cacheFrameInterval);
		this._currentFrameTime=this._currentFrameIndex *cacheFrameInterval;
	});

	/**
	*设置是否暂停
	*@param value 是否暂停
	*/
	/**
	*获取当前是否暂停
	*@return 是否暂停
	*/
	__getset(0,__proto,'paused',function(){
		return this._stoped;
		},function(value){
		this._stoped=value;
		value && this.event(/*laya.events.Event.PAUSED*/"paused");
	});

	__static(Animator,
	['deafaultMatrix',function(){return this.deafaultMatrix=new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]);},'_tempMatrix4x40',function(){return this._tempMatrix4x40=new Float32Array(16);}
	]);
	return Animator;
})(Component3D)


/**
*<code>AttachPoint</code> 类用于创建挂点组件。
*/
//class laya.d3.component.AttachPoint extends laya.d3.component.Component3D
var AttachPoint=(function(_super){
	function AttachPoint(){
		/**@private */
		this._attachSkeleton=null;
		/**@private */
		this._extenData=null;
		/**挂点骨骼的名称。*/
		this.attachBones=null;
		/**挂点骨骼的变换矩阵。*/
		this.matrixs=null;
		AttachPoint.__super.call(this);
		this.attachBones=[];
		this.matrixs=[];
	}

	__class(AttachPoint,'laya.d3.component.AttachPoint',_super);
	var __proto=AttachPoint.prototype;
	/**
	*@private
	*初始化载入挂点组件。
	*@param owner 所属精灵对象。
	*/
	__proto._load=function(owner){
		_super.prototype._load.call(this,owner);
		this._attachSkeleton=(owner).getComponentByType(SkinAnimations);
	}

	/**
	*@private
	*更新挂点组件。
	*@param state 渲染状态。
	*/
	__proto._update=function(state){
		if (!this._attachSkeleton||this._attachSkeleton.destroyed || this._attachSkeleton.player.state===/*laya.ani.AnimationState.stopped*/0 || !this._attachSkeleton.curBonesDatas)
			return;
		var player=this._attachSkeleton.player;
		var templet=this._attachSkeleton.templet;
		this.matrixs.length=this.attachBones.length;
		var boneDatas=this._attachSkeleton.curBonesDatas;
		var worldMatrix=(this.owner).transform.worldMatrix;
		for (var i=0,n=this.attachBones.length;i < n;i++){
			var startIndex=templet.getNodeIndexWithName(player.currentAnimationClipIndex,this.attachBones[i])*16;
			var matrix=this.matrixs[i];
			matrix || (matrix=this.matrixs[i]=new Matrix4x4());
			var matrixE=matrix.elements;
			for (var j=0;j < 16;j++)
			matrixE[j]=boneDatas[startIndex+j];
			Matrix4x4.multiply(worldMatrix,matrix,matrix);
		}
		this.event(/*laya.events.Event.COMPLETE*/"complete");
	}

	return AttachPoint;
})(Component3D)


/**
*<code>Collider</code> 类用于创建碰撞器的父类，抽象类，不允许实例。
*/
//class laya.d3.component.physics.Collider extends laya.d3.component.Component3D
var Collider=(function(_super){
	function Collider(){
		/**@private */
		//this._needUpdate=false;
		/**@private 只读，不允许修改。*/
		//this._isRigidbody=false;
		/**@private */
		//this._runtimeCollisonMap=null;
		/**@private */
		//this._runtimeCollisonTestMap=null;
		/**@private */
		//this._ignoreCollisonMap=null;
		/**是否为触发器。*/
		//this.isTrigger=false;
		Collider.__super.call(this);
		this._isRigidbody=false;
		this._runtimeCollisonMap={};
		this._runtimeCollisonTestMap={};
		this._ignoreCollisonMap={};
		this.isTrigger=true;
	}

	__class(Collider,'laya.d3.component.physics.Collider',_super);
	var __proto=Collider.prototype;
	/**
	*@private
	*/
	__proto._clearCollsionMap=function(){
		for (var k in this._runtimeCollisonMap){
			var otherCollider=this._runtimeCollisonMap[k];
			delete otherCollider._runtimeCollisonMap[this.id];
			if (otherCollider._isRigidbody)
				delete otherCollider._runtimeCollisonTestMap[this.id];
			var otherID=otherCollider.id;
			delete this._runtimeCollisonMap[otherID];
			if (this._isRigidbody)
				delete this._runtimeCollisonTestMap[otherID];
		}
	}

	/**
	*@inheritDoc
	*/
	__proto._unload=function(owner){
		for (var k in this._runtimeCollisonMap){
			var otherCollider=this._runtimeCollisonMap[k];
			delete otherCollider._runtimeCollisonMap[this.id];
			if (otherCollider._isRigidbody)
				delete otherCollider._runtimeCollisonTestMap[this.id];
			delete this._ignoreCollisonMap[k]._ignoreCollisonMap[this.id];
		}
	}

	/**
	*@private
	*/
	__proto._setIsRigidbody=function(value){
		if (this._isRigidbody!==value){
			this._isRigidbody=value;
			var owner=this._owner;
			if (owner.displayedInStage){
				var layer=owner.layer;
				layer._removeCollider(this);
				layer._addCollider(this);
			}
		}
	}

	/**
	*@private
	*/
	__proto._getType=function(){
		return-1;
	}

	/**
	*@private
	*/
	__proto._collisonTo=function(other){
		return false;
	}

	/**
	*在场景中投下可与球体碰撞器碰撞的一条光线,获取发生碰撞的球体碰撞器信息。
	*@param ray 射线
	*@param outHitInfo 与该射线发生碰撞球体碰撞器的碰撞信息
	*@param distance 射线长度,默认为最大值
	*/
	__proto.raycast=function(ray,hitInfo,maxDistance){
		(maxDistance===void 0)&& (maxDistance=1.79e+308);
		throw new Error("Collider:Must override it.");
	}

	/**
	*@inheritDoc
	*/
	__getset(0,__proto,'enable',_super.prototype._$get_enable,function(value){
		if (this._enable!==value){
			var owner=this._owner;
			if (owner.displayedInStage)
				(value)|| (this._clearCollsionMap());
			this._enable=value;
			this.event(/*laya.events.Event.ENABLE_CHANGED*/"enablechanged",this._enable);
		}
	});

	/**
	*@inheritDoc
	*/
	__getset(0,__proto,'isSingleton',function(){
		return Collider._isSingleton;
	});

	Collider._isSingleton=false;
	return Collider;
})(Component3D)


/**
*<code>Rigidbody</code> 类用于创建动画组件。
*/
//class laya.d3.component.Rigidbody extends laya.d3.component.Component3D
var Rigidbody=(function(_super){
	/**
	*创建一个 <code>Rigidbody</code> 实例。
	*/
	function Rigidbody(){
		Rigidbody.__super.call(this);
	}

	__class(Rigidbody,'laya.d3.component.Rigidbody',_super);
	var __proto=Rigidbody.prototype;
	/**
	*@inheritDoc
	*/
	__getset(0,__proto,'enable',_super.prototype._$get_enable,function(value){
		if (this._enable!==value){
			var colliders=(this._owner)._colliders;
			for (var i=0,n=colliders.length;i < n;i++){
				var collider=colliders[i];
				collider._setIsRigidbody(value);
				var runtimeCollisonMap=collider._runtimeCollisonMap;
				var runtimeCollisonTestMap=collider._runtimeCollisonTestMap;
				if (!value){
					for (var k in runtimeCollisonMap)
					delete runtimeCollisonTestMap[k];
				}
			}
			this._enable=value;
			this.event(/*laya.events.Event.ENABLE_CHANGED*/"enablechanged",this._enable);
		}
	});

	return Rigidbody;
})(Component3D)


/**
*<code>Script</code> 类用于创建脚本的父类。
*/
//class laya.d3.component.Script extends laya.d3.component.Component3D
var Script=(function(_super){
	/**
	*创建一个新的 <code>Script</code> 实例。
	*/
	function Script(){
		Script.__super.call(this);
	}

	__class(Script,'laya.d3.component.Script',_super);
	var __proto=Script.prototype;
	/**
	*当其他碰撞器进入时触发。
	*/
	__proto.onTriggerEnter=function(other){}
	/**
	*当其他碰撞器退出时触发。
	*/
	__proto.onTriggerExit=function(other){}
	/**
	*当其他碰撞器保持进入状态时逐帧触发。
	*/
	__proto.onTriggerStay=function(other){}
	/**
	*@inheritDoc
	*/
	__getset(0,__proto,'isSingleton',function(){
		return Script._isSingleton;
	});

	Script._isSingleton=false;
	return Script;
})(Component3D)


/**
*...
*@author ...
*/
//class laya.d3.core.GlitterRender extends laya.d3.core.render.BaseRender
var GlitterRender=(function(_super){
	function GlitterRender(owner){
		GlitterRender.__super.call(this,owner);
	}

	__class(GlitterRender,'laya.d3.core.GlitterRender',_super);
	var __proto=GlitterRender.prototype;
	__proto._calculateBoundingBox=function(){
		var minE=this._boundingBox.min.elements;
		minE[0]=-Number.MAX_VALUE;
		minE[1]=-Number.MAX_VALUE;
		minE[2]=-Number.MAX_VALUE;
		var maxE=this._boundingBox.min.elements;
		maxE[0]=Number.MAX_VALUE;
		maxE[1]=Number.MAX_VALUE;
		maxE[2]=Number.MAX_VALUE;
	}

	__proto._calculateBoundingSphere=function(){
		var centerE=this._boundingSphere.center.elements;
		centerE[0]=0;
		centerE[1]=0;
		centerE[2]=0;
		this._boundingSphere.radius=Number.MAX_VALUE;
	}

	/**
	*@private
	*/
	__proto._renderUpdate=function(projectionView){
		this._setShaderValueMatrix4x4(/*laya.d3.core.Sprite3D.WORLDMATRIX*/0,this._owner.transform.worldMatrix);
		var projViewWorld=this._owner.getProjectionViewWorldMatrix(projectionView);
		this._setShaderValueMatrix4x4(/*laya.d3.core.Sprite3D.MVPMATRIX*/1,projViewWorld);
		var templet=(this._owner).templet;
		this._setShaderValueNumber(/*laya.d3.core.glitter.Glitter.DURATION*/3,templet.lifeTime);
		this._setShaderValueNumber(/*laya.d3.core.glitter.Glitter.CURRENTTIME*/2,templet._currentTime);
		return true;
	}

	return GlitterRender;
})(BaseRender)


/**
*<code>MeshFilter</code> 类用于创建网格过滤器。
*/
//class laya.d3.core.MeshFilter extends laya.d3.core.GeometryFilter
var MeshFilter=(function(_super){
	function MeshFilter(owner){
		/**@private */
		this._owner=null;
		/**@private */
		this._sharedMesh=null;
		MeshFilter.__super.call(this);
		this._owner=owner;
	}

	__class(MeshFilter,'laya.d3.core.MeshFilter',_super);
	var __proto=MeshFilter.prototype;
	/**
	*@private
	*/
	__proto._sharedMeshLoaded=function(){
		this.event(/*laya.events.Event.LOADED*/"loaded");
	}

	/**
	*@inheritDoc
	*/
	__proto._destroy=function(){
		_super.prototype._destroy.call(this);
		this._owner=null;
		(this._sharedMesh)&& (this._sharedMesh._removeReference(),this._sharedMesh=null);
	}

	/**
	*设置共享网格。
	*@return value 共享网格。
	*/
	/**
	*获取共享网格。
	*@return 共享网格。
	*/
	__getset(0,__proto,'sharedMesh',function(){
		return this._sharedMesh;
		},function(value){
		var lastValue=this._sharedMesh;
		(lastValue)&& (lastValue._removeReference());
		this._sharedMesh=value;
		value._addReference();
		this.event(/*laya.events.Event.MESH_CHANGED*/"meshchanged",[this,lastValue,value]);
		if (!value.loaded){
			this._sharedMesh.once(/*laya.events.Event.LOADED*/"loaded",this,this._sharedMeshLoaded);
		}
	});

	/**
	*@inheritDoc
	*/
	__getset(0,__proto,'_isAsyncLoaded',function(){
		return this._sharedMesh.loaded;
	});

	/**
	*@inheritDoc
	*/
	__getset(0,__proto,'_originalBoundingBoxCorners',function(){
		return this._sharedMesh.boundingBoxCorners;
	});

	/**
	*@inheritDoc
	*/
	__getset(0,__proto,'_originalBoundingSphere',function(){
		return this._sharedMesh.boundingSphere;
	});

	/**
	*@inheritDoc
	*/
	__getset(0,__proto,'_originalBoundingBox',function(){
		return this._sharedMesh.boundingBox;
	});

	return MeshFilter;
})(GeometryFilter)


/**
*<code>MeshRender</code> 类用于网格渲染器。
*/
//class laya.d3.core.MeshRender extends laya.d3.core.render.BaseRender
var MeshRender=(function(_super){
	/**
	*创建一个新的 <code>MeshRender</code> 实例。
	*/
	function MeshRender(owner){
		MeshRender.__super.call(this,owner);
		(owner).meshFilter.on(/*laya.events.Event.MESH_CHANGED*/"meshchanged",this,this._onMeshChanged);
	}

	__class(MeshRender,'laya.d3.core.MeshRender',_super);
	var __proto=MeshRender.prototype;
	/**
	*@private
	*/
	__proto._onMeshChanged=function(meshFilter,oldMesh,mesh){
		if (mesh.loaded){
			this._boundingSphereNeedChange=this._boundingBoxNeedChange=this._boundingBoxCenterNeedChange=this._octreeNodeNeedChange=true;
			}else {
			mesh.once(/*laya.events.Event.LOADED*/"loaded",this,this._onMeshLoaed);
		}
	}

	/**
	*@private
	*/
	__proto._onMeshLoaed=function(sender,enable){
		this._boundingSphereNeedChange=this._boundingBoxNeedChange=this._boundingBoxCenterNeedChange=this._octreeNodeNeedChange=true;
	}

	/**
	*@private
	*/
	__proto._calculateBoundingSphereByInitSphere=function(boundSphere){
		var maxScale=NaN;
		var transform=this._owner.transform;
		var scaleE=transform.scale.elements;
		var scaleX=Math.abs(scaleE[0]);
		var scaleY=Math.abs(scaleE[1]);
		var scaleZ=Math.abs(scaleE[2]);
		if (scaleX >=scaleY && scaleX >=scaleZ)
			maxScale=scaleX;
		else
		maxScale=scaleY >=scaleZ ? scaleY :scaleZ;
		Vector3.transformCoordinate(boundSphere.center,transform.worldMatrix,this._boundingSphere.center);
		this._boundingSphere.radius=boundSphere.radius *maxScale;
	}

	/**
	*@private
	*/
	__proto._calculateBoundBoxByInitCorners=function(corners){
		var worldMat=(this._owner).transform.worldMatrix;
		for (var i=0;i < 8;i++)
		Vector3.transformCoordinate(corners[i],worldMat,BaseRender._tempBoundBoxCorners[i]);
		BoundBox.createfromPoints(BaseRender._tempBoundBoxCorners,this._boundingBox);
	}

	/**
	*@inheritDoc
	*/
	__proto._calculateBoundingSphere=function(){
		var sharedMesh=(this._owner).meshFilter.sharedMesh;
		if (sharedMesh==null || sharedMesh.boundingSphere==null)
			this._boundingSphere.toDefault();
		else
		this._calculateBoundingSphereByInitSphere(sharedMesh.boundingSphere);
	}

	/**
	*@inheritDoc
	*/
	__proto._calculateBoundingBox=function(){
		var sharedMesh=(this._owner).meshFilter.sharedMesh;
		if (sharedMesh==null || sharedMesh.boundingBox==null)
			this._boundingBox.toDefault();
		else
		this._calculateBoundBoxByInitCorners(sharedMesh.boundingBoxCorners);
	}

	/**
	*@private
	*/
	__proto._renderUpdate=function(projectionView){
		var transform=this._owner.transform;
		if (transform){
			this._setShaderValueMatrix4x4(/*laya.d3.core.Sprite3D.WORLDMATRIX*/0,transform.worldMatrix);
			var projViewWorld=this._owner.getProjectionViewWorldMatrix(projectionView);
			this._setShaderValueMatrix4x4(/*laya.d3.core.Sprite3D.MVPMATRIX*/1,projViewWorld);
			}else {
			this._setShaderValueMatrix4x4(/*laya.d3.core.Sprite3D.WORLDMATRIX*/0,Matrix4x4.DEFAULT);
			this._setShaderValueMatrix4x4(/*laya.d3.core.Sprite3D.MVPMATRIX*/1,projectionView);
		}
		if (Laya3D.debugMode)
			this._renderRenderableBoundBox();
		return true;
	}

	return MeshRender;
})(BaseRender)


/**
*<code>ShurikenParticleSystem</code> 类用于创建3D粒子数据模板。
*/
//class laya.d3.core.particleShuriKen.ShurikenParticleSystem extends laya.d3.core.GeometryFilter
var ShurikenParticleSystem=(function(_super){
	function ShurikenParticleSystem(owner){
		/**@private */
		//this._boundingSphere=null;
		/**@private */
		//this._boundingBox=null;
		/**@private */
		//this._boundingBoxCorners=null;
		/**@private */
		//this._owner=null;
		/**@private */
		//this._ownerRender=null;
		/**@private */
		//this._vertices=null;
		/**@private */
		//this._floatCountPerVertex=0;
		/**@private */
		//this._startLifeTimeIndex=0;
		/**@private */
		//this._timeIndex=0;
		/**@private */
		//this._simulateUpdate=false;
		/**@private */
		//this._firstActiveElement=0;
		/**@private */
		//this._firstNewElement=0;
		/**@private */
		//this._firstFreeElement=0;
		/**@private */
		//this._firstRetiredElement=0;
		/**@private */
		//this._drawCounter=0;
		/**@private */
		//this._vertexBuffer=null;
		/**@private */
		//this._indexBuffer=null;
		/**@private */
		//this._bufferMaxParticles=0;
		/**@private */
		//this._emission=null;
		/**@private */
		//this._shape=null;
		/**@private */
		//this._isEmitting=false;
		/**@private */
		//this._isPlaying=false;
		/**@private */
		//this._isPaused=false;
		/**@private */
		//this._playStartDelay=NaN;
		/**@private 发射的累计时间。*/
		//this._frameRateTime=NaN;
		/**@private 一次循环内的累计时间。*/
		//this._emissionTime=NaN;
		/**@private */
		//this._totalDelayTime=NaN;
		/**@private */
		//this._burstsIndex=0;
		/**@private */
		//this._velocityOverLifetime=null;
		/**@private */
		//this._colorOverLifetime=null;
		/**@private */
		//this._sizeOverLifetime=null;
		/**@private */
		//this._rotationOverLifetime=null;
		/**@private */
		//this._textureSheetAnimation=null;
		/**@private */
		//this._startLifetimeType=0;
		/**@private */
		//this._startLifetimeConstant=NaN;
		/**@private */
		//this._startLifeTimeGradient=null;
		/**@private */
		//this._startLifetimeConstantMin=NaN;
		/**@private */
		//this._startLifetimeConstantMax=NaN;
		/**@private */
		//this._startLifeTimeGradientMin=null;
		/**@private */
		//this._startLifeTimeGradientMax=null;
		/**@private */
		//this._maxStartLifetime=NaN;
		/**@private */
		//this._vertexStride=0;
		/**@private */
		//this._indexStride=0;
		/**@private */
		//this._currentTime=NaN;
		/**@private */
		//this._startUpdateLoopCount=0;
		/**@private */
		//this._rand=null;
		/**@private */
		//this._randomSeeds=null;
		/**粒子运行的总时长，单位为秒。*/
		//this.duration=NaN;
		/**是否循环。*/
		//this.looping=false;
		/**是否预热。暂不支持*/
		//this.prewarm=false;
		/**开始延迟类型，0为常量模式,1为随机随机双常量模式，不能和prewarm一起使用。*/
		//this.startDelayType=0;
		/**开始播放延迟，不能和prewarm一起使用。*/
		//this.startDelay=NaN;
		/**开始播放最小延迟，不能和prewarm一起使用。*/
		//this.startDelayMin=NaN;
		/**开始播放最大延迟，不能和prewarm一起使用。*/
		//this.startDelayMax=NaN;
		/**开始速度模式，0为恒定速度，2为两个恒定速度的随机插值。缺少1、3模式*/
		//this.startSpeedType=0;
		/**开始速度,0模式。*/
		//this.startSpeedConstant=NaN;
		/**最小开始速度,1模式。*/
		//this.startSpeedConstantMin=NaN;
		/**最大开始速度,1模式。*/
		//this.startSpeedConstantMax=NaN;
		/**开始尺寸是否为3D模式。*/
		//this.threeDStartSize=false;
		/**开始尺寸模式,0为恒定尺寸，2为两个恒定尺寸的随机插值。缺少1、3模式和对应的二种3D模式*/
		//this.startSizeType=0;
		/**开始尺寸，0模式。*/
		//this.startSizeConstant=NaN;
		/**开始三维尺寸，0模式。*/
		//this.startSizeConstantSeparate=null;
		/**最小开始尺寸，2模式。*/
		//this.startSizeConstantMin=NaN;
		/**最大开始尺寸，2模式。*/
		//this.startSizeConstantMax=NaN;
		/**最小三维开始尺寸，2模式。*/
		//this.startSizeConstantMinSeparate=null;
		/**最大三维开始尺寸，2模式。*/
		//this.startSizeConstantMaxSeparate=null;
		/**3D开始旋转，暂不支持*/
		//this.threeDStartRotation=false;
		/**开始旋转模式,0为恒定尺寸，2为两个恒定旋转的随机插值,缺少2种模式,和对应的四种3D模式。*/
		//this.startRotationType=0;
		/**开始旋转，0模式。*/
		//this.startRotationConstant=NaN;
		/**开始三维旋转，0模式。*/
		//this.startRotationConstantSeparate=null;
		/**最小开始旋转，1模式。*/
		//this.startRotationConstantMin=NaN;
		/**最大开始旋转，1模式。*/
		//this.startRotationConstantMax=NaN;
		/**最小开始三维旋转，1模式。*/
		//this.startRotationConstantMinSeparate=null;
		/**最大开始三维旋转，1模式。*/
		//this.startRotationConstantMaxSeparate=null;
		/**随机旋转方向，范围为0.0到1.0*/
		//this.randomizeRotationDirection=NaN;
		/**开始颜色模式，0为恒定颜色，2为两个恒定颜色的随机插值,缺少2种模式。*/
		//this.startColorType=0;
		/**开始颜色，0模式。*/
		//this.startColorConstant=null;
		/**最小开始颜色，1模式。*/
		//this.startColorConstantMin=null;
		/**最大开始颜色，1模式。*/
		//this.startColorConstantMax=null;
		/**重力敏感度。*/
		//this.gravityModifier=NaN;
		/**模拟器空间,0为World,1为Local。暂不支持Custom。*/
		//this.simulationSpace=0;
		/**缩放模式，0为Hiercachy,1为Local,2为World。暂不支持1,2*/
		//this.scaleMode=0;
		/**激活时是否自动播放。*/
		//this.playOnAwake=false;
		/**随机种子,注:play()前设置有效。*/
		//this.randomSeed=null;
		/**是否使用随机种子。 */
		//this.autoRandomSeed=false;
		/**是否为性能模式,性能模式下会延迟粒子释放。*/
		//this.isPerformanceMode=false;
		ShurikenParticleSystem.__super.call(this);
		this._tempRotationMatrix=new Matrix4x4();
		this._uvLength=new Vector2();
		this._firstActiveElement=0;
		this._firstNewElement=0;
		this._firstFreeElement=0;
		this._firstRetiredElement=0;
		this._owner=owner;
		this._ownerRender=owner.particleRender;
		this._boundingBoxCorners=__newvec(8,null);
		this._boundingSphere=new BoundSphere(new Vector3(),Number.MAX_VALUE);
		this._boundingBox=new BoundBox(new Vector3(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE),new Vector3(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE));
		this._currentTime=0;
		this._isEmitting=false;
		this._isPlaying=false;
		this._isPaused=false;
		this._burstsIndex=0;
		this._frameRateTime=0;
		this._emissionTime=0;
		this._totalDelayTime=0;
		this._simulateUpdate=false;
		this._bufferMaxParticles=1;
		this.duration=5.0;
		this.looping=true;
		this.prewarm=false;
		this.startDelayType=0;
		this.startDelay=0.0;
		this.startDelayMin=0.0;
		this.startDelayMax=0.0;
		this._startLifetimeType=0;
		this._startLifetimeConstant=5.0;
		this._startLifeTimeGradient=new GradientDataNumber();
		this._startLifetimeConstantMin=0.0;
		this._startLifetimeConstantMax=5.0;
		this._startLifeTimeGradientMin=new GradientDataNumber();
		this._startLifeTimeGradientMax=new GradientDataNumber();
		this._maxStartLifetime=5.0;
		this.startSpeedType=0;
		this.startSpeedConstant=5.0;
		this.startSpeedConstantMin=0.0;
		this.startSpeedConstantMax=5.0;
		this.threeDStartSize=false;
		this.startSizeType=0;
		this.startSizeConstant=1;
		this.startSizeConstantSeparate=new Vector3(1,1,1);
		this.startSizeConstantMin=0;
		this.startSizeConstantMax=1;
		this.startSizeConstantMinSeparate=new Vector3(0,0,0);
		this.startSizeConstantMaxSeparate=new Vector3(1,1,1);
		this.threeDStartRotation=false;
		this.startRotationType=0;
		this.startRotationConstant=0;
		this.startRotationConstantSeparate=new Vector3(0,0,0);
		this.startRotationConstantMin=0.0;
		this.startRotationConstantMax=0.0;
		this.startRotationConstantMinSeparate=new Vector3(0,0,0);
		this.startRotationConstantMaxSeparate=new Vector3(0,0,0);
		this.randomizeRotationDirection=0.0;
		this.startColorType=0;
		this.startColorConstant=new Vector4(1,1,1,1);
		this.startColorConstantMin=new Vector4(1,1,1,1);
		this.startColorConstantMax=new Vector4(1,1,1,1);
		this.gravityModifier=0.0;
		this.simulationSpace=1;
		this.scaleMode=0;
		this.playOnAwake=true;
		this._rand=new Rand(0);
		this.autoRandomSeed=true;
		this.randomSeed=new Uint32Array(1);
		this._randomSeeds=new Uint32Array(ShurikenParticleSystem._RANDOMOFFSET.length);
		this.isPerformanceMode=true;
		this._emission=new Emission();
		this._emission.enbale=true;
		this._owner.on(/*laya.events.Event.ACTIVE_IN_HIERARCHY_CHANGED*/"activeinhierarchychanged",this,this._onOwnerActiveHierarchyChanged);
	}

	__class(ShurikenParticleSystem,'laya.d3.core.particleShuriKen.ShurikenParticleSystem',_super);
	var __proto=ShurikenParticleSystem.prototype;
	Laya.imps(__proto,{"laya.d3.core.render.IRenderable":true,"laya.d3.core.IClone":true})
	__proto._getVertexBuffer=function(index){
		(index===void 0)&& (index=0);
		if (index===0)
			return this._vertexBuffer;
		else
		return null;
	}

	__proto._getIndexBuffer=function(){
		return this._indexBuffer;
	}

	/**
	*@private
	*/
	__proto._generateBoundingSphere=function(){
		var centerE=this._boundingSphere.center.elements;
		centerE[0]=0;
		centerE[1]=0;
		centerE[2]=0;
		this._boundingSphere.radius=Number.MAX_VALUE;
	}

	/**
	*@private
	*/
	__proto._generateBoundingBox=function(){
		var particle=this._owner;
		var particleRender=particle.particleRender;
		var boundMin=this._boundingBox.min;
		var boundMax=this._boundingBox.max;
		var i=0,n=0;
		var maxStartLifeTime=NaN;
		switch (this.startLifetimeType){
			case 0:
				maxStartLifeTime=this.startLifetimeConstant;
				break ;
			case 1:
				maxStartLifeTime=-Number.MAX_VALUE;
				var startLifeTimeGradient=startLifeTimeGradient;
				for (i=0,n=startLifeTimeGradient.gradientCount;i < n;i++)
				maxStartLifeTime=Math.max(maxStartLifeTime,startLifeTimeGradient.getValueByIndex(i));
				break ;
			case 2:
				maxStartLifeTime=Math.max(this.startLifetimeConstantMin,this.startLifetimeConstantMax);
				break ;
			case 3:
				maxStartLifeTime=-Number.MAX_VALUE;
				var startLifeTimeGradientMin=startLifeTimeGradientMin;
				for (i=0,n=startLifeTimeGradientMin.gradientCount;i < n;i++)
				maxStartLifeTime=Math.max(maxStartLifeTime,startLifeTimeGradientMin.getValueByIndex(i));
				var startLifeTimeGradientMax=startLifeTimeGradientMax;
				for (i=0,n=startLifeTimeGradientMax.gradientCount;i < n;i++)
				maxStartLifeTime=Math.max(maxStartLifeTime,startLifeTimeGradientMax.getValueByIndex(i));
				break ;
			};
		var minStartSpeed=NaN,maxStartSpeed=NaN;
		switch (this.startSpeedType){
			case 0:
				minStartSpeed=maxStartSpeed=this.startSpeedConstant;
				break ;
			case 1:
				break ;
			case 2:
				minStartSpeed=this.startLifetimeConstantMin;
				maxStartSpeed=this.startLifetimeConstantMax;
				break ;
			case 3:
				break ;
			};
		var minPosition,maxPosition,minDirection,maxDirection;
		if (this._shape && this._shape.enable){
			}else {
			minPosition=maxPosition=Vector3.ZERO;
			minDirection=Vector3.ZERO;
			maxDirection=Vector3.UnitZ;
		};
		var startMinVelocity=new Vector3(minDirection.x *minStartSpeed,minDirection.y *minStartSpeed,minDirection.z *minStartSpeed);
		var startMaxVelocity=new Vector3(maxDirection.x *maxStartSpeed,maxDirection.y *maxStartSpeed,maxDirection.z *maxStartSpeed);
		if (this._velocityOverLifetime && this._velocityOverLifetime.enbale){
			var lifeMinVelocity;
			var lifeMaxVelocity;
			var velocity=this._velocityOverLifetime.velocity;
			switch (velocity.type){
				case 0:
					lifeMinVelocity=lifeMaxVelocity=velocity.constant;
					break ;
				case 1:
					lifeMinVelocity=lifeMaxVelocity=new Vector3(velocity.gradientX.getAverageValue(),velocity.gradientY.getAverageValue(),velocity.gradientZ.getAverageValue());
					break ;
				case 2:
					lifeMinVelocity=velocity.constantMin;
					lifeMaxVelocity=velocity.constantMax;
					break ;
				case 3:
					lifeMinVelocity=new Vector3(velocity.gradientXMin.getAverageValue(),velocity.gradientYMin.getAverageValue(),velocity.gradientZMin.getAverageValue());
					lifeMaxVelocity=new Vector3(velocity.gradientXMax.getAverageValue(),velocity.gradientYMax.getAverageValue(),velocity.gradientZMax.getAverageValue());
					break ;
				}
		};
		var positionScale,velocityScale;
		var transform=this._owner.transform;
		var worldPosition=transform.position;
		var sizeScale=ShurikenParticleSystem._tempVector39;
		var sizeScaleE=sizeScale.elements;
		var renderMode=particleRender.renderMode;
		switch (this.scaleMode){
			case 0:;
				var scale=transform.scale;
				positionScale=scale;
				sizeScaleE[0]=scale.x;
				sizeScaleE[1]=scale.z;
				sizeScaleE[2]=scale.y;
				(renderMode===1)&& (velocityScale=scale);
				break ;
			case 1:;
				var localScale=transform.localScale;
				positionScale=localScale;
				sizeScaleE[0]=localScale.x;
				sizeScaleE[1]=localScale.z;
				sizeScaleE[2]=localScale.y;
				(renderMode===1)&& (velocityScale=localScale);
				break ;
			case 2:
				positionScale=transform.scale;
				sizeScaleE[0]=sizeScaleE[1]=sizeScaleE[2]=1;
				(renderMode===1)&& (velocityScale=Vector3.ONE);
				break ;
			};
		var minStratPosition,maxStratPosition;
		if (this._velocityOverLifetime && this._velocityOverLifetime.enbale){
			}else {
			minStratPosition=new Vector3(startMinVelocity.x *maxStartLifeTime,startMinVelocity.y *maxStartLifeTime,startMinVelocity.z *maxStartLifeTime);
			maxStratPosition=new Vector3(startMaxVelocity.x *maxStartLifeTime,startMaxVelocity.y *maxStartLifeTime,startMaxVelocity.z *maxStartLifeTime);
			if (this.scaleMode !=2){
				Vector3.add(minPosition,minStratPosition,boundMin);
				Vector3.multiply(positionScale,boundMin,boundMin);
				Vector3.add(maxPosition,maxStratPosition,boundMax);
				Vector3.multiply(positionScale,boundMax,boundMax);
				}else {
				Vector3.multiply(positionScale,minPosition,boundMin);
				Vector3.add(boundMin,minStratPosition,boundMin);
				Vector3.multiply(positionScale,maxPosition,boundMax);
				Vector3.add(boundMax,maxStratPosition,boundMax);
			}
		}
		switch (this.simulationSpace){
			case 0:
				break ;
			case 1:
				Vector3.add(boundMin,worldPosition,boundMin);
				Vector3.add(boundMax,worldPosition,boundMax);
				break ;
			};
		var maxSize=NaN,maxSizeY=NaN;
		switch (this.startSizeType){
			case 0:
				if (this.threeDStartSize){
					var startSizeConstantSeparate=startSizeConstantSeparate;
					maxSize=Math.max(startSizeConstantSeparate.x,startSizeConstantSeparate.y);
					if (renderMode===1)
						maxSizeY=startSizeConstantSeparate.y;
					}else {
					maxSize=this.startSizeConstant;
					if (renderMode===1)
						maxSizeY=this.startSizeConstant;
				}
				break ;
			case 1:
				break ;
			case 2:
				if (this.threeDStartSize){
					var startSizeConstantMaxSeparate=startSizeConstantMaxSeparate;
					maxSize=Math.max(startSizeConstantMaxSeparate.x,startSizeConstantMaxSeparate.y);
					if (renderMode===1)
						maxSizeY=startSizeConstantMaxSeparate.y;
					}else {
					maxSize=this.startSizeConstantMax;
					if (renderMode===1)
						maxSizeY=this.startSizeConstantMax;
				}
				break ;
			case 3:
				break ;
			}
		if (this._sizeOverLifetime && this._sizeOverLifetime.enbale){
			var size=this._sizeOverLifetime.size;
			maxSize *=this._sizeOverLifetime.size.getMaxSizeInGradient();
		};
		var threeDMaxSize=ShurikenParticleSystem._tempVector30;
		var threeDMaxSizeE=threeDMaxSize.elements;
		var rotSize=NaN,nonRotSize=NaN;
		switch (renderMode){
			case 0:
				rotSize=maxSize *ShurikenParticleSystem.halfKSqrtOf2;
				Vector3.scale(sizeScale,maxSize,threeDMaxSize);
				Vector3.subtract(boundMin,threeDMaxSize,boundMin);
				Vector3.add(boundMax,threeDMaxSize,boundMax);
				break ;
			case 1:;
				var maxStretchPosition=ShurikenParticleSystem._tempVector31;
				var maxStretchVelocity=ShurikenParticleSystem._tempVector32;
				var minStretchVelocity=ShurikenParticleSystem._tempVector33;
				var minStretchPosition=ShurikenParticleSystem._tempVector34;
				if (this._velocityOverLifetime && this._velocityOverLifetime.enbale){
					}else {
					Vector3.multiply(velocityScale,startMaxVelocity,maxStretchVelocity);
					Vector3.multiply(velocityScale,startMinVelocity,minStretchVelocity);
				};
				var sizeStretch=maxSizeY *particleRender.stretchedBillboardLengthScale;
				var maxStretchLength=Vector3.scalarLength(maxStretchVelocity)*particleRender.stretchedBillboardSpeedScale+sizeStretch;
				var minStretchLength=Vector3.scalarLength(minStretchVelocity)*particleRender.stretchedBillboardSpeedScale+sizeStretch;
				var norMaxStretchVelocity=ShurikenParticleSystem._tempVector35;
				var norMinStretchVelocity=ShurikenParticleSystem._tempVector36;
				Vector3.normalize(maxStretchVelocity,norMaxStretchVelocity);
				Vector3.scale(norMaxStretchVelocity,maxStretchLength,minStretchPosition);
				Vector3.subtract(maxStratPosition,minStretchPosition,minStretchPosition);
				Vector3.normalize(minStretchVelocity,norMinStretchVelocity);
				Vector3.scale(norMinStretchVelocity,minStretchLength,maxStretchPosition);
				Vector3.add(minStratPosition,maxStretchPosition,maxStretchPosition);
				rotSize=maxSize *ShurikenParticleSystem.halfKSqrtOf2;
				Vector3.scale(sizeScale,rotSize,threeDMaxSize);
				var halfNorMaxStretchVelocity=ShurikenParticleSystem._tempVector37;
				var halfNorMinStretchVelocity=ShurikenParticleSystem._tempVector38;
				Vector3.scale(norMaxStretchVelocity,0.5,halfNorMaxStretchVelocity);
				Vector3.scale(norMinStretchVelocity,0.5,halfNorMinStretchVelocity);
				Vector3.multiply(halfNorMaxStretchVelocity,sizeScale,halfNorMaxStretchVelocity);
				Vector3.multiply(halfNorMinStretchVelocity,sizeScale,halfNorMinStretchVelocity);
				Vector3.add(boundMin,halfNorMinStretchVelocity,boundMin);
				Vector3.min(boundMin,minStretchPosition,boundMin);
				Vector3.subtract(boundMin,threeDMaxSize,boundMin);
				Vector3.subtract(boundMax,halfNorMaxStretchVelocity,boundMax);
				Vector3.max(boundMax,maxStretchPosition,boundMax);
				Vector3.add(boundMax,threeDMaxSize,boundMax);
				break ;
			case 2:
				maxSize *=Math.cos(0.78539816339744830961566084581988);
				nonRotSize=maxSize *0.5;
				threeDMaxSizeE[0]=sizeScale.x *nonRotSize;
				threeDMaxSizeE[1]=sizeScale.z *nonRotSize;
				Vector3.subtract(boundMin,threeDMaxSize,boundMin);
				Vector3.add(boundMax,threeDMaxSize,boundMax);
				break ;
			case 3:
				maxSize *=Math.cos(0.78539816339744830961566084581988);
				nonRotSize=maxSize *0.5;
				Vector3.scale(sizeScale,nonRotSize,threeDMaxSize);
				Vector3.subtract(boundMin,threeDMaxSize,boundMin);
				Vector3.add(boundMax,threeDMaxSize,boundMax);
				break ;
			}
		this._boundingBox.getCorners(this._boundingBoxCorners);
	}

	/**
	*@private
	*/
	__proto._updateEmission=function(){
		if (!Laya.stage.isVisibility||!this.isAlive)
			return;
		if (this._simulateUpdate){
			this._simulateUpdate=false;
		}
		else{
			var elapsedTime=(this._startUpdateLoopCount!==Stat.loopCount && !this._isPaused)?Laya.timer.delta / 1000.0:0;
			elapsedTime=Math.min(ShurikenParticleSystem._maxElapsedTime,elapsedTime);
			this._updateParticles(elapsedTime);
		}
	}

	/**
	*@private
	*/
	__proto._updateParticles=function(elapsedTime){
		if (this._ownerRender.renderMode===4 && !this._ownerRender.mesh)
			return;
		this._currentTime+=elapsedTime;
		this._retireActiveParticles();
		this._freeRetiredParticles();
		this._totalDelayTime+=elapsedTime;
		if (this._totalDelayTime < this._playStartDelay){
			return;
		}
		if (this._emission.enbale&&this._isEmitting &&!this._isPaused)
			this._advanceTime(elapsedTime,this._currentTime);
	}

	/**
	*@private
	*/
	__proto._updateParticlesSimulationRestart=function(time){
		this._firstActiveElement=0;
		this._firstNewElement=0;
		this._firstFreeElement=0;
		this._firstRetiredElement=0;
		this._burstsIndex=0;
		this._frameRateTime=time;
		this._emissionTime=0;
		this._totalDelayTime=0;
		this._currentTime=time;
		var delayTime=time;
		if (delayTime < this._playStartDelay){
			this._totalDelayTime=delayTime;
			return;
		}
		if (this._emission.enbale)
			this._advanceTime(time,time);
	}

	/**
	*@private
	*/
	__proto._addUpdateEmissionToTimer=function(){
		Laya.timer.frameLoop(1,this,this._updateEmission);
	}

	/**
	*@private
	*/
	__proto._removeUpdateEmissionToTimer=function(){
		Laya.timer.clear(this,this._updateEmission);
	}

	/**
	*@private
	*/
	__proto._onOwnerActiveHierarchyChanged=function(active){
		if (this._owner.displayedInStage){
			if (active)
				this._addUpdateEmissionToTimer();
			else
			this._removeUpdateEmissionToTimer();
		}
	}

	/**
	*@private
	*/
	__proto._retireActiveParticles=function(){
		var epsilon=0.0001;
		while (this._firstActiveElement !=this._firstNewElement){
			var index=this._firstActiveElement *this._floatCountPerVertex *this._vertexStride;
			var timeIndex=index+this._timeIndex;
			var particleAge=this._currentTime-this._vertices[timeIndex];
			if (particleAge+epsilon < this._vertices[index+this._startLifeTimeIndex])
				break ;
			this._vertices[timeIndex]=this._drawCounter;
			this._firstActiveElement++;
			if (this._firstActiveElement >=this._bufferMaxParticles)
				this._firstActiveElement=0;
		}
	}

	/**
	*@private
	*/
	__proto._freeRetiredParticles=function(){
		while (this._firstRetiredElement !=this._firstActiveElement){
			var age=this._drawCounter-this._vertices[this._firstRetiredElement *this._floatCountPerVertex *this._vertexStride+this._timeIndex];
			if (this.isPerformanceMode)
				if (age < 3)
			break ;
			this._firstRetiredElement++;
			if (this._firstRetiredElement >=this._bufferMaxParticles)
				this._firstRetiredElement=0;
		}
	}

	/**
	*@private
	*/
	__proto._burst=function(fromTime,toTime){
		var totalEmitCount=0;
		var bursts=this._emission._bursts;
		for (var n=bursts.length;this._burstsIndex < n;this._burstsIndex++){
			var burst=bursts[this._burstsIndex];
			var burstTime=burst.time;
			if (fromTime<=burstTime && burstTime < toTime){
				var emitCount=0;
				if (this.autoRandomSeed){
					emitCount=MathUtil.lerp(burst.minCount,burst.maxCount,Math.random());
					}else {
					this._rand.seed=this._randomSeeds[0];
					emitCount=MathUtil.lerp(burst.minCount,burst.maxCount,this._rand.getFloat());
					this._randomSeeds[0]=this._rand.seed;
				}
				totalEmitCount+=emitCount;
				}else {
				break ;
			}
		}
		return totalEmitCount;
	}

	/**
	*@private
	*/
	__proto._advanceTime=function(elapsedTime,emitTime){
		var i=0;
		var lastEmissionTime=this._emissionTime;
		this._emissionTime+=elapsedTime;
		var totalEmitCount=0;
		if (this._emissionTime > this.duration){
			if (this.looping){
				totalEmitCount+=this._burst(lastEmissionTime,this._emissionTime);
				this._emissionTime-=this.duration;
				this.event(/*laya.events.Event.COMPLETE*/"complete");
				this._burstsIndex=0;
				totalEmitCount+=this._burst(0,this._emissionTime);
				}else {
				totalEmitCount=Math.min(this.maxParticles-this.aliveParticleCount,totalEmitCount);
				for (i=0;i < totalEmitCount;i++)
				this.emit(emitTime);
				this._isPlaying=false;
				this.stop();
				return;
			}
			}else {
			totalEmitCount+=this._burst(lastEmissionTime,this._emissionTime);
		}
		totalEmitCount=Math.min(this.maxParticles-this.aliveParticleCount,totalEmitCount);
		for (i=0;i < totalEmitCount;i++)
		this.emit(emitTime);
		var emissionRate=this.emission.emissionRate;
		if (emissionRate>0){
			var minEmissionTime=1/emissionRate;
			this._frameRateTime+=minEmissionTime;
			this._frameRateTime=this._currentTime-(this._currentTime-this._frameRateTime)% this._maxStartLifetime;
			while (this._frameRateTime <=emitTime){
				if (this.emit(this._frameRateTime))
					this._frameRateTime+=minEmissionTime;
				else
				break ;
			}
			this._frameRateTime=Math.floor(emitTime / minEmissionTime)*minEmissionTime;
		}
	}

	/**
	*@private
	*/
	__proto._initBufferDatas=function(){
		if (this._vertexBuffer){
			this._vertexBuffer.destroy();
			this._indexBuffer.destroy();
		};
		var render=this._ownerRender;
		var renderMode=render.renderMode;
		if (renderMode!==-1 && this.maxParticles > 0){
			var indices,i=0,j=0,m=0,indexOffset=0,perPartOffset=0,vertexDeclaration;;
			var mesh=render.mesh;
			if (renderMode===4){
				if(mesh){
					var vertexBufferCount=mesh._vertexBuffers.length;
					if (vertexBufferCount > 1){
						throw new Error("ShurikenParticleSystem: submesh Count mesh be One or all subMeshes have the same vertexDeclaration.");
						}else {
						vertexDeclaration=VertexShurikenParticleMesh.vertexDeclaration;
						this._floatCountPerVertex=vertexDeclaration.vertexStride/4;
						this._startLifeTimeIndex=12;
						this._timeIndex=16;
						this._vertexStride=mesh._vertexBuffers[0].vertexCount;
						var totalVertexCount=this._bufferMaxParticles *this._vertexStride;
						var vbCount=Math.floor(totalVertexCount / 65535)+1;
						var lastVBVertexCount=totalVertexCount % 65535;
						if (vbCount > 1){
							throw new Error("ShurikenParticleSystem:the maxParticleCount multiply mesh vertexCount is large than 65535.");
						}
						this._vertexBuffer=VertexBuffer3D.create(vertexDeclaration,lastVBVertexCount,/*laya.webgl.WebGLContext.DYNAMIC_DRAW*/0x88E8);
						this._vertices=new Float32Array(this._floatCountPerVertex *lastVBVertexCount);
						this._indexStride=mesh._indexBuffer.indexCount;
						var indexDatas=mesh._indexBuffer.getData();
						var indexCount=this._bufferMaxParticles *this._indexStride;
						this._indexBuffer=IndexBuffer3D.create(/*laya.d3.graphics.IndexBuffer3D.INDEXTYPE_USHORT*/"ushort",indexCount,/*laya.webgl.WebGLContext.STATIC_DRAW*/0x88E4);
						indices=new Uint16Array(indexCount);
						indexOffset=0;
						for (i=0;i < this._bufferMaxParticles;i++){
							var indexValueOffset=i *this._vertexStride;
							for (j=0,m=indexDatas.length;j < m;j++)
							indices[indexOffset++]=indexValueOffset+indexDatas[j];
						}
						this._indexBuffer.setData(indices);
					}
				}
				}else {
				vertexDeclaration=VertexShurikenParticleBillboard.vertexDeclaration;
				this._floatCountPerVertex=vertexDeclaration.vertexStride/4;
				this._startLifeTimeIndex=7;
				this._timeIndex=11;
				this._vertexStride=4;
				this._vertexBuffer=VertexBuffer3D.create(vertexDeclaration,this._bufferMaxParticles *this._vertexStride,/*laya.webgl.WebGLContext.DYNAMIC_DRAW*/0x88E8);
				this._vertices=new Float32Array(this._floatCountPerVertex *this._bufferMaxParticles *this._vertexStride);
				for (i=0;i < this._bufferMaxParticles;i++){
					perPartOffset=i *this._floatCountPerVertex *this._vertexStride;
					this._vertices[perPartOffset]=-0.5;
					this._vertices[perPartOffset+1]=-0.5;
					this._vertices[perPartOffset+2]=0;
					this._vertices[perPartOffset+3]=1;
					perPartOffset+=this._floatCountPerVertex;
					this._vertices[perPartOffset]=0.5;
					this._vertices[perPartOffset+1]=-0.5;
					this._vertices[perPartOffset+2]=1;
					this._vertices[perPartOffset+3]=1;
					perPartOffset+=this._floatCountPerVertex
					this._vertices[perPartOffset]=0.5;
					this._vertices[perPartOffset+1]=0.5;
					this._vertices[perPartOffset+2]=1;
					this._vertices[perPartOffset+3]=0;
					perPartOffset+=this._floatCountPerVertex
					this._vertices[perPartOffset]=-0.5;
					this._vertices[perPartOffset+1]=0.5;
					this._vertices[perPartOffset+2]=0;
					this._vertices[perPartOffset+3]=0;
				}
				this._indexStride=6;
				this._indexBuffer=IndexBuffer3D.create(/*laya.d3.graphics.IndexBuffer3D.INDEXTYPE_USHORT*/"ushort",this._bufferMaxParticles *6,/*laya.webgl.WebGLContext.STATIC_DRAW*/0x88E4);
				indices=new Uint16Array(this._bufferMaxParticles *6);
				for (i=0;i < this._bufferMaxParticles;i++){
					indexOffset=i *6;
					var firstVertex=i *this._vertexStride,secondVertex=firstVertex+2;
					indices[indexOffset++]=firstVertex;
					indices[indexOffset++]=secondVertex;
					indices[indexOffset++]=firstVertex+1;
					indices[indexOffset++]=firstVertex;
					indices[indexOffset++]=firstVertex+3;
					indices[indexOffset++]=secondVertex;
				}
				this._indexBuffer.setData(indices);
			}
		}
	}

	/**
	*@private
	*/
	__proto._destroy=function(){
		_super.prototype._destroy.call(this);
		(this._owner.activeInHierarchy)&& (this._removeUpdateEmissionToTimer());
		this._vertexBuffer.destroy();
		this._indexBuffer.destroy();
		this._emission._destroy();
		this._owner=null;
		this._vertices=null;
		this._vertexBuffer=null;
		this._indexBuffer=null;
		this._emission=null;
		this._shape=null;
		this.startLifeTimeGradient=null;
		this.startLifeTimeGradientMin=null;
		this.startLifeTimeGradientMax=null;
		this.startSizeConstantSeparate=null;
		this.startSizeConstantMinSeparate=null;
		this.startSizeConstantMaxSeparate=null;
		this.startRotationConstantSeparate=null;
		this.startRotationConstantMinSeparate=null;
		this.startRotationConstantMaxSeparate=null;
		this.startColorConstant=null;
		this.startColorConstantMin=null;
		this.startColorConstantMax=null;
		this._velocityOverLifetime=null;
		this._colorOverLifetime=null;
		this._sizeOverLifetime=null;
		this._rotationOverLifetime=null;
		this._textureSheetAnimation=null;
	}

	/**
	*发射一个粒子。
	*/
	__proto.emit=function(time){
		var position=ShurikenParticleSystem._tempPosition;
		var direction=ShurikenParticleSystem._tempDirection;
		if (this._shape&&this._shape.enable){
			if (this.autoRandomSeed)
				this._shape.generatePositionAndDirection(position,direction);
			else
			this._shape.generatePositionAndDirection(position,direction,this._rand,this._randomSeeds);
			}else {
			var positionE=position.elements;
			var directionE=direction.elements;
			positionE[0]=positionE[1]=positionE[2]=0;
			directionE[0]=directionE[1]=0;
			directionE[2]=1;
		}
		return this.addParticle(position,direction,time);
	}

	//TODO:提前判断优化
	__proto.addParticle=function(position,direction,time){
		Vector3.normalize(direction,direction);
		var nextFreeParticle=this._firstFreeElement+1;
		if (nextFreeParticle >=this._bufferMaxParticles)
			nextFreeParticle=0;
		if (nextFreeParticle===this._firstRetiredElement)
			return false;
		ShurikenParticleData.create(this,this._ownerRender,this._owner.transform);
		var particleAge=this._currentTime-time;
		if (particleAge >=ShurikenParticleData.startLifeTime)
			return true;
		var randomVelocityX=NaN,randomVelocityY=NaN,randomVelocityZ=NaN,randomColor=NaN,randomSize=NaN,randomRotation=NaN,randomTextureAnimation=NaN;
		var needRandomVelocity=this._velocityOverLifetime && this._velocityOverLifetime.enbale;
		if (needRandomVelocity){
			var velocityType=this._velocityOverLifetime.velocity.type;
			if (velocityType===2 || velocityType===3){
				if (this.autoRandomSeed){
					randomVelocityX=Math.random();
					randomVelocityY=Math.random();
					randomVelocityZ=Math.random();
					}else {
					this._rand.seed=this._randomSeeds[9];
					randomVelocityX=this._rand.getFloat();
					randomVelocityY=this._rand.getFloat();
					randomVelocityZ=this._rand.getFloat();
					this._randomSeeds[9]=this._rand.seed;
				}
				}else {
				needRandomVelocity=false;
			}
			}else {
			needRandomVelocity=false;
		};
		var needRandomColor=this._colorOverLifetime && this._colorOverLifetime.enbale;
		if (needRandomColor){
			var colorType=this._colorOverLifetime.color.type;
			if (colorType===3){
				if (this.autoRandomSeed){
					randomColor=Math.random();
					}else {
					this._rand.seed=this._randomSeeds[10];
					randomColor=this._rand.getFloat();
					this._randomSeeds[10]=this._rand.seed;
				}
				}else {
				needRandomColor=false;
			}
			}else {
			needRandomColor=false;
		};
		var needRandomSize=this._sizeOverLifetime && this._sizeOverLifetime.enbale;
		if (needRandomSize){
			var sizeType=this._sizeOverLifetime.size.type;
			if (sizeType===3){
				if (this.autoRandomSeed){
					randomSize=Math.random();
					}else {
					this._rand.seed=this._randomSeeds[11];
					randomSize=this._rand.getFloat();
					this._randomSeeds[11]=this._rand.seed;
				}
				}else {
				needRandomSize=false;
			}
			}else {
			needRandomSize=false;
		};
		var needRandomRotation=this._rotationOverLifetime && this._rotationOverLifetime.enbale;
		if (needRandomRotation){
			var rotationType=this._rotationOverLifetime.angularVelocity.type;
			if (rotationType===2 || rotationType===3){
				if (this.autoRandomSeed){
					randomRotation=Math.random();
					}else {
					this._rand.seed=this._randomSeeds[12];
					randomRotation=this._rand.getFloat();
					this._randomSeeds[12]=this._rand.seed;
				}
				}else {
				needRandomRotation=false;
			}
			}else {
			needRandomRotation=false;
		};
		var needRandomTextureAnimation=this._textureSheetAnimation && this._textureSheetAnimation.enable;
		if (needRandomTextureAnimation){
			var textureAnimationType=this._textureSheetAnimation.frame.type;
			if (textureAnimationType===3){
				if (this.autoRandomSeed){
					randomTextureAnimation=Math.random();
					}else {
					this._rand.seed=this._randomSeeds[15];
					randomTextureAnimation=this._rand.getFloat();
					this._randomSeeds[15]=this._rand.seed;
				}
				}else {
				needRandomTextureAnimation=false;
			}
			}else {
			needRandomTextureAnimation=false;
		};
		var startIndex=this._firstFreeElement *this._floatCountPerVertex *this._vertexStride;
		var subU=ShurikenParticleData.startUVInfo[0];
		var subV=ShurikenParticleData.startUVInfo[1];
		var startU=ShurikenParticleData.startUVInfo[2];
		var startV=ShurikenParticleData.startUVInfo[3];
		var positionE=position.elements;
		var directionE=direction.elements;
		var meshVertices,meshVertexStride=0,meshPosOffset=0,meshCorOffset=0,meshUVOffset=0,meshVertexIndex=0;
		var render=this._ownerRender;
		if (render.renderMode===4){
			var meshVB=render.mesh._vertexBuffers[0];
			meshVertices=meshVB.getData();
			var meshVertexDeclaration=meshVB.vertexDeclaration;
			meshPosOffset=meshVertexDeclaration.getVertexElementByUsage(/*laya.d3.graphics.VertexElementUsage.POSITION0*/0).offset / 4;
			var colorElement=meshVertexDeclaration.getVertexElementByUsage(/*laya.d3.graphics.VertexElementUsage.COLOR0*/1);
			meshCorOffset=colorElement?colorElement.offset / 4:-1;
			var uvElement=meshVertexDeclaration.getVertexElementByUsage(/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE0*/2);
			meshUVOffset=uvElement?uvElement.offset / 4:-1;
			meshVertexStride=meshVertexDeclaration.vertexStride / 4;
			meshVertexIndex=0;
			}else {
			this._vertices[startIndex+2]=startU;
			this._vertices[startIndex+3]=startV+subV;
			var secondOffset=startIndex+this._floatCountPerVertex;
			this._vertices[secondOffset+2]=startU+subU;
			this._vertices[secondOffset+3]=startV+subV;
			var thirdOffset=secondOffset+this._floatCountPerVertex;
			this._vertices[thirdOffset+2]=startU+subU;
			this._vertices[thirdOffset+3]=startV;
			var fourthOffset=thirdOffset+this._floatCountPerVertex;
			this._vertices[fourthOffset+2]=startU;
			this._vertices[fourthOffset+3]=startV;
		}
		for (var i=startIndex,n=startIndex+this._floatCountPerVertex *this._vertexStride;i < n;i+=this._floatCountPerVertex){
			var offset=0;
			if (render.renderMode===4){
				offset=i;
				var vertexOffset=meshVertexStride *(meshVertexIndex++);
				var meshOffset=vertexOffset+meshPosOffset;
				this._vertices[offset++]=meshVertices[meshOffset++];
				this._vertices[offset++]=meshVertices[meshOffset++];
				this._vertices[offset++]=meshVertices[meshOffset];
				if (meshCorOffset===-1){
					this._vertices[offset++]=1.0;
					this._vertices[offset++]=1.0;
					this._vertices[offset++]=1.0;
					this._vertices[offset++]=1.0;
				}
				else{
					meshOffset=vertexOffset+meshCorOffset;
					this._vertices[offset++]=meshVertices[meshOffset++];
					this._vertices[offset++]=meshVertices[meshOffset++];
					this._vertices[offset++]=meshVertices[meshOffset++];
					this._vertices[offset++]=meshVertices[meshOffset];
				}
				if (meshUVOffset===-1){
					this._vertices[offset++]=0.0;
					this._vertices[offset++]=0.0;
				}
				else{
					meshOffset=vertexOffset+meshUVOffset;
					this._vertices[offset++]=startU+meshVertices[meshOffset++] *subU;
					this._vertices[offset++]=startV+meshVertices[meshOffset] *subV;
				}
				}else {
				offset=i+4;
			}
			this._vertices[offset++]=positionE[0];
			this._vertices[offset++]=positionE[1];
			this._vertices[offset++]=positionE[2];
			this._vertices[offset++]=ShurikenParticleData.startLifeTime;
			this._vertices[offset++]=directionE[0];
			this._vertices[offset++]=directionE[1];
			this._vertices[offset++]=directionE[2];
			this._vertices[offset++]=time;
			this._vertices[offset++]=ShurikenParticleData.startColor[0];
			this._vertices[offset++]=ShurikenParticleData.startColor[1];
			this._vertices[offset++]=ShurikenParticleData.startColor[2];
			this._vertices[offset++]=ShurikenParticleData.startColor[3];
			this._vertices[offset++]=ShurikenParticleData.startSize[0];
			this._vertices[offset++]=ShurikenParticleData.startSize[1];
			this._vertices[offset++]=ShurikenParticleData.startSize[2];
			this._vertices[offset++]=ShurikenParticleData.startRotation[0];
			this._vertices[offset++]=ShurikenParticleData.startRotation[1];
			this._vertices[offset++]=ShurikenParticleData.startRotation[2];
			this._vertices[offset++]=ShurikenParticleData.startSpeed;
			needRandomColor && (this._vertices[offset+1]=randomColor);
			needRandomSize && (this._vertices[offset+2]=randomSize);
			needRandomRotation && (this._vertices[offset+3]=randomRotation);
			needRandomTextureAnimation && (this._vertices[offset+4]=randomTextureAnimation);
			if (needRandomVelocity){
				this._vertices[offset+5]=randomVelocityX;
				this._vertices[offset+6]=randomVelocityY;
				this._vertices[offset+7]=randomVelocityZ;
			}
			switch(this.simulationSpace){
				case 0:
					offset+=8;
					this._vertices[offset++]=ShurikenParticleData.simulationWorldPostion[0];
					this._vertices[offset++]=ShurikenParticleData.simulationWorldPostion[1];
					this._vertices[offset++]=ShurikenParticleData.simulationWorldPostion[2];
					this._vertices[offset++]=ShurikenParticleData.simulationWorldRotation[0];
					this._vertices[offset++]=ShurikenParticleData.simulationWorldRotation[1];
					this._vertices[offset++]=ShurikenParticleData.simulationWorldRotation[2];
					this._vertices[offset++]=ShurikenParticleData.simulationWorldRotation[3];
					break ;
				case 1:
					break ;
				default :
					throw new Error("ShurikenParticleMaterial: SimulationSpace value is invalid.");
				}
		}
		this._firstFreeElement=nextFreeParticle;
		return true;
	}

	__proto.addNewParticlesToVertexBuffer=function(){
		var start=0;
		if (this._firstNewElement < this._firstFreeElement){
			start=this._firstNewElement *this._vertexStride *this._floatCountPerVertex;
			this._vertexBuffer.setData(this._vertices,start,start,(this._firstFreeElement-this._firstNewElement)*this._vertexStride *this._floatCountPerVertex);
			}else {
			start=this._firstNewElement *this._vertexStride *this._floatCountPerVertex;
			this._vertexBuffer.setData(this._vertices,start,start,(this._bufferMaxParticles-this._firstNewElement)*this._vertexStride *this._floatCountPerVertex);
			if (this._firstFreeElement > 0){
				this._vertexBuffer.setData(this._vertices,0,0,this._firstFreeElement *this._vertexStride *this._floatCountPerVertex);
			}
		}
		this._firstNewElement=this._firstFreeElement;
	}

	__proto._beforeRender=function(state){
		if (this._firstNewElement !=this._firstFreeElement)
			this.addNewParticlesToVertexBuffer();
		this._drawCounter++;
		if (this._firstActiveElement !=this._firstFreeElement){
			this._vertexBuffer._bind();
			this._indexBuffer._bind();
			return true;
		}
		return false;
	}

	/**
	*@private
	*/
	__proto._render=function(state){
		var indexCount=0;
		var gl=WebGL.mainContext;
		if (this._firstActiveElement < this._firstFreeElement){
			indexCount=(this._firstFreeElement-this._firstActiveElement)*this._indexStride;
			gl.drawElements(/*laya.webgl.WebGLContext.TRIANGLES*/0x0004,indexCount,/*laya.webgl.WebGLContext.UNSIGNED_SHORT*/0x1403,2 *this._firstActiveElement *this._indexStride);
			Stat.trianglesFaces+=indexCount / 3;
			Stat.drawCall++;
			}else {
			indexCount=(this._bufferMaxParticles-this._firstActiveElement)*this._indexStride;
			gl.drawElements(/*laya.webgl.WebGLContext.TRIANGLES*/0x0004,indexCount,/*laya.webgl.WebGLContext.UNSIGNED_SHORT*/0x1403,2 *this._firstActiveElement *this._indexStride);
			Stat.trianglesFaces+=indexCount / 3;
			Stat.drawCall++;
			if (this._firstFreeElement > 0){
				indexCount=this._firstFreeElement *this._indexStride;
				gl.drawElements(/*laya.webgl.WebGLContext.TRIANGLES*/0x0004,indexCount,/*laya.webgl.WebGLContext.UNSIGNED_SHORT*/0x1403,0);
				Stat.trianglesFaces+=indexCount / 3;
				Stat.drawCall++;
			}
		}
	}

	/**
	*开始发射粒子。
	*/
	__proto.play=function(){
		this._burstsIndex=0;
		this._isEmitting=true;
		this._isPlaying=true;
		this._isPaused=false;
		this._emissionTime=0;
		this._totalDelayTime=0;
		if (!this.autoRandomSeed){
			for (var i=0,n=this._randomSeeds.length;i < n;i++)
			this._randomSeeds[i]=this.randomSeed[0]+ShurikenParticleSystem._RANDOMOFFSET[i];
		}
		switch (this.startDelayType){
			case 0:
				this._playStartDelay=this.startDelay;
				break ;
			case 1:
				if (this.autoRandomSeed){
					this._playStartDelay=MathUtil.lerp(this.startDelayMin,this.startDelayMax,Math.random());
					}else {
					this._rand.seed=this._randomSeeds[2];
					this._playStartDelay=MathUtil.lerp(this.startDelayMin,this.startDelayMax,this._rand.getFloat());
					this._randomSeeds[2]=this._rand.seed;
				}
				break ;
			default :
				throw new Error("Utils3D: startDelayType is invalid.");
			}
		this._frameRateTime=this._currentTime+this._playStartDelay;
		this._startUpdateLoopCount=Stat.loopCount;
		this.event(/*laya.events.Event.PLAYED*/"played");
	}

	/**
	*暂停发射粒子。
	*/
	__proto.pause=function(){
		this._isPaused=true;
		this.event(/*laya.events.Event.PAUSED*/"paused");
	}

	/**
	*通过指定时间增加粒子播放进度，并暂停播放。
	*@param time 进度时间.如果restart为true,粒子播放时间会归零后再更新进度。
	*@param restart 是否重置播放状态。
	*/
	__proto.simulate=function(time,restart){
		(restart===void 0)&& (restart=true);
		this._simulateUpdate=true;
		if (restart){
			this._updateParticlesSimulationRestart(time);
		}
		else{
			this._isPaused=false;
			this._updateParticles(time);
		}
		this.pause();
	}

	/**
	*停止发射粒子。
	*/
	__proto.stop=function(){
		this._burstsIndex=0;
		this._isEmitting=false;
		this._emissionTime=0;
		this.event(/*laya.events.Event.STOPPED*/"stopped");
	}

	/**
	*克隆。
	*@param destObject 克隆源。
	*/
	__proto.cloneTo=function(destObject){
		var dest=destObject;
		dest.duration=this.duration;
		dest.looping=this.looping;
		dest.prewarm=this.prewarm;
		dest.startDelayType=this.startDelayType;
		dest.startDelay=this.startDelay;
		dest.startDelayMin=this.startDelayMin;
		dest.startDelayMax=this.startDelayMax;
		dest._maxStartLifetime=this._maxStartLifetime;
		dest.startLifetimeType=this.startLifetimeType;
		dest.startLifetimeConstant=this.startLifetimeConstant;
		this.startLifeTimeGradient.cloneTo(dest.startLifeTimeGradient);
		dest.startLifetimeConstantMin=this.startLifetimeConstantMin;
		dest.startLifetimeConstantMax=this.startLifetimeConstantMax;
		this.startLifeTimeGradientMin.cloneTo(dest.startLifeTimeGradientMin);
		this.startLifeTimeGradientMax.cloneTo(dest.startLifeTimeGradientMax);
		dest.startSpeedType=this.startSpeedType;
		dest.startSpeedConstant=this.startSpeedConstant;
		dest.startSpeedConstantMin=this.startSpeedConstantMin;
		dest.startSpeedConstantMax=this.startSpeedConstantMax;
		dest.threeDStartSize=this.threeDStartSize;
		dest.startSizeType=this.startSizeType;
		dest.startSizeConstant=this.startSizeConstant;
		this.startSizeConstantSeparate.cloneTo(dest.startSizeConstantSeparate);
		dest.startSizeConstantMin=this.startSizeConstantMin;
		dest.startSizeConstantMax=this.startSizeConstantMax;
		this.startSizeConstantMinSeparate.cloneTo(dest.startSizeConstantMinSeparate);
		this.startSizeConstantMaxSeparate.cloneTo(dest.startSizeConstantMaxSeparate);
		dest.threeDStartRotation=this.threeDStartRotation;
		dest.startRotationType=this.startRotationType;
		dest.startRotationConstant=this.startRotationConstant;
		this.startRotationConstantSeparate.cloneTo(dest.startRotationConstantSeparate);
		dest.startRotationConstantMin=this.startRotationConstantMin;
		dest.startRotationConstantMax=this.startRotationConstantMax;
		this.startRotationConstantMinSeparate.cloneTo(dest.startRotationConstantMinSeparate);
		this.startRotationConstantMaxSeparate.cloneTo(dest.startRotationConstantMaxSeparate);
		dest.randomizeRotationDirection=this.randomizeRotationDirection;
		dest.startColorType=this.startColorType;
		this.startColorConstant.cloneTo(dest.startColorConstant);
		this.startColorConstantMin.cloneTo(dest.startColorConstantMin);
		this.startColorConstantMax.cloneTo(dest.startColorConstantMax);
		dest.gravityModifier=this.gravityModifier;
		dest.simulationSpace=this.simulationSpace;
		dest.scaleMode=this.scaleMode;
		dest.playOnAwake=this.playOnAwake;
		dest.maxParticles=this.maxParticles;
		(this._emission)&& (dest._emission=this._emission.clone());
		(this.shape)&& (dest.shape=this.shape.clone());
		(this.velocityOverLifetime)&& (dest.velocityOverLifetime=this.velocityOverLifetime.clone());
		(this.colorOverLifetime)&& (dest.colorOverLifetime=this.colorOverLifetime.clone());
		(this.sizeOverLifetime)&& (dest.sizeOverLifetime=this.sizeOverLifetime.clone());
		(this.rotationOverLifetime)&& (dest.rotationOverLifetime=this.rotationOverLifetime.clone());
		(this.textureSheetAnimation)&& (dest.textureSheetAnimation=this.textureSheetAnimation.clone());
		dest.isPerformanceMode=this.isPerformanceMode;
		dest._isEmitting=this._isEmitting;
		dest._isPlaying=this._isPlaying;
		dest._isPaused=this._isPaused;
		dest._playStartDelay=this._playStartDelay;
		dest._frameRateTime=this._frameRateTime;
		dest._emissionTime=this._emissionTime;
		dest._totalDelayTime=this._totalDelayTime;
		dest._burstsIndex=this._burstsIndex;
	}

	/**
	*克隆。
	*@return 克隆副本。
	*/
	__proto.clone=function(){
		var dest=/*__JS__ */new this.constructor();
		this.cloneTo(dest);
		return dest;
	}

	/**
	*@private
	*/
	__proto._getVertexBuffers=function(){
		return null;
	}

	/**设置最大粒子数,注意:谨慎修改此属性，有性能损耗。*/
	/**获取最大粒子数。*/
	__getset(0,__proto,'maxParticles',function(){
		return this._bufferMaxParticles-1;
		},function(value){
		var newMaxParticles=value+1;
		if (newMaxParticles!==this._bufferMaxParticles){
			this._bufferMaxParticles=newMaxParticles;
			this._initBufferDatas();
		}
	});

	/**
	*是否正在发射。
	*/
	__getset(0,__proto,'isEmitting',function(){
		return this._isEmitting;
	});

	/**
	*是否存活。
	*/
	__getset(0,__proto,'isAlive',function(){
		if (this._isPlaying || this.aliveParticleCount > 0)
			return true;
		return false;
	});

	/**
	*设置形状。
	*/
	/**
	*获取形状。
	*/
	__getset(0,__proto,'shape',function(){
		return this._shape;
		},function(value){
		if (this._shape!==value){
			if (value&&value.enable)
				this._ownerRender._addShaderDefine(ShuriKenParticle3D.SHADERDEFINE_SHAPE);
			else
			this._ownerRender._removeShaderDefine(ShuriKenParticle3D.SHADERDEFINE_SHAPE);
			this._shape=value;
		}
	});

	/**
	*设置生命周期旋转,注意:如修改该值的某些属性,需重新赋值此属性才可生效。
	*@param value 生命周期旋转。
	*/
	/**
	*获取生命周期旋转,注意:如修改该值的某些属性,需重新赋值此属性才可生效。
	*@return 生命周期旋转。
	*/
	__getset(0,__proto,'rotationOverLifetime',function(){
		return this._rotationOverLifetime;
		},function(value){
		var render=this._ownerRender;
		if (value){
			var rotation=value.angularVelocity;
			if (!rotation)
				return;
			var rotationSeparate=rotation.separateAxes;
			var rotationType=rotation.type;
			if (value.enbale){
				if (rotationSeparate)
					render._addShaderDefine(ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMESEPERATE);
				else
				render._addShaderDefine(ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIME);
				switch (rotationType){
					case 0:
						render._addShaderDefine(ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMECONSTANT);
						break ;
					case 1:
						render._addShaderDefine(ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMECURVE);
						break ;
					case 2:
						render._addShaderDefine(ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCONSTANTS);
						break ;
					case 3:
						render._addShaderDefine(ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCURVES);
						break ;
					}
				}else {
				render._removeShaderDefine(ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIME);
				render._removeShaderDefine(ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMESEPERATE);
				render._removeShaderDefine(ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMECONSTANT);
				render._removeShaderDefine(ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMECURVE);
				render._removeShaderDefine(ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCONSTANTS);
				render._removeShaderDefine(ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCURVES);
			}
			switch (rotationType){
				case 0:
					if (rotationSeparate){
						render._setShaderValueColor(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.ROLANGULARVELOCITYCONSTSEPRARATE*/35,rotation.constantSeparate);
						}else {
						render._setShaderValueNumber(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.ROLANGULARVELOCITYCONST*/34,rotation.constant);
					}
					break ;
				case 1:
					if (rotationSeparate){
						render._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTX*/37,rotation.gradientX._elements);
						render._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTY*/38,rotation.gradientY._elements);
						render._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTZ*/39,rotation.gradientZ._elements);
						render._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTW*/40,rotation.gradientW._elements);
						}else {
						render._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENT*/36,rotation.gradient._elements);
					}
					break ;
				case 2:
					if (rotationSeparate){
						render._setShaderValueColor(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.ROLANGULARVELOCITYCONSTSEPRARATE*/35,rotation.constantMinSeparate);
						render._setShaderValueColor(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.ROLANGULARVELOCITYCONSTMAXSEPRARATE*/42,rotation.constantMaxSeparate);
						}else {
						render._setShaderValueNumber(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.ROLANGULARVELOCITYCONST*/34,rotation.constantMin);
						render._setShaderValueNumber(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.ROLANGULARVELOCITYCONSTMAX*/41,rotation.constantMax);
					}
					break ;
				case 3:
					if (rotationSeparate){
						render._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTX*/37,rotation.gradientXMin._elements);
						render._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTXMAX*/44,rotation.gradientXMax._elements);
						render._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTY*/38,rotation.gradientYMin._elements);
						render._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTYMAX*/45,rotation.gradientYMax._elements);
						render._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTZ*/39,rotation.gradientZMin._elements);
						render._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTZMAX*/46,rotation.gradientZMax._elements);
						render._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTW*/40,rotation.gradientWMin._elements);
						render._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTWMAX*/47,rotation.gradientWMax._elements);
						}else {
						render._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENT*/36,rotation.gradientMin._elements);
						render._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTMAX*/43,rotation.gradientMax._elements);
					}
					break ;
				}
			}else {
			render._removeShaderDefine(ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIME);
			render._removeShaderDefine(ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMESEPERATE);
			render._removeShaderDefine(ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMECONSTANT);
			render._removeShaderDefine(ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMECURVE);
			render._removeShaderDefine(ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCONSTANTS);
			render._removeShaderDefine(ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCURVES);
			render._setShaderValueColor(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.ROLANGULARVELOCITYCONSTSEPRARATE*/35,null);
			render._setShaderValueColor(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.ROLANGULARVELOCITYCONSTMAXSEPRARATE*/42,null);
			render._setShaderValueNumber(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.ROLANGULARVELOCITYCONST*/34,undefined);
			render._setShaderValueNumber(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.ROLANGULARVELOCITYCONSTMAX*/41,undefined);
			render._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTX*/37,null);
			render._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTXMAX*/44,null);
			render._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTY*/38,null);
			render._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTYMAX*/45,null);
			render._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTZ*/39,null);
			render._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTZMAX*/46,null);
			render._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTW*/40,null);
			render._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTWMAX*/47,null);
			render._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENT*/36,null);
			render._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTMAX*/43,null);
		}
		this._rotationOverLifetime=value;
	});

	/**
	*获取发射器。
	*/
	__getset(0,__proto,'emission',function(){
		return this._emission;
	});

	/**
	*获取一次循环内的累计时间。
	*@return 一次循环内的累计时间。
	*/
	__getset(0,__proto,'emissionTime',function(){
		return this._emissionTime > this.duration ? this.duration :this._emissionTime;
	});

	/**
	*粒子存活个数。
	*/
	__getset(0,__proto,'aliveParticleCount',function(){
		if (this._firstNewElement >=this._firstRetiredElement)
			return this._firstNewElement-this._firstRetiredElement;
		else
		return this._bufferMaxParticles-this._firstRetiredElement+this._firstNewElement;
	});

	/**
	*是否正在播放。
	*/
	__getset(0,__proto,'isPlaying',function(){
		return this._isPlaying;
	});

	/**
	*是否已暂停。
	*/
	__getset(0,__proto,'isPaused',function(){
		return this._isPaused;
	});

	/**
	*设置开始生命周期模式,0为固定时间，1为渐变时间，2为两个固定之间的随机插值,3为两个渐变时间的随机插值。
	*/
	/**
	*获取开始生命周期模式,0为固定时间，1为渐变时间，2为两个固定之间的随机插值,3为两个渐变时间的随机插值。
	*/
	__getset(0,__proto,'startLifetimeType',function(){
		return this._startLifetimeType;
		},function(value){
		var i=0,n=0;
		switch (this.startLifetimeType){
			case 0:
				this._maxStartLifetime=this.startLifetimeConstant;
				break ;
			case 1:
				this._maxStartLifetime=-Number.MAX_VALUE;
				var startLifeTimeGradient=startLifeTimeGradient;
				for (i=0,n=startLifeTimeGradient.gradientCount;i < n;i++)
				this._maxStartLifetime=Math.max(this._maxStartLifetime,startLifeTimeGradient.getValueByIndex(i));
				break ;
			case 2:
				this._maxStartLifetime=Math.max(this.startLifetimeConstantMin,this.startLifetimeConstantMax);
				break ;
			case 3:
				this._maxStartLifetime=-Number.MAX_VALUE;
				var startLifeTimeGradientMin=startLifeTimeGradientMin;
				for (i=0,n=startLifeTimeGradientMin.gradientCount;i < n;i++)
				this._maxStartLifetime=Math.max(this._maxStartLifetime,startLifeTimeGradientMin.getValueByIndex(i));
				var startLifeTimeGradientMax=startLifeTimeGradientMax;
				for (i=0,n=startLifeTimeGradientMax.gradientCount;i < n;i++)
				this._maxStartLifetime=Math.max(this._maxStartLifetime,startLifeTimeGradientMax.getValueByIndex(i));
				break ;
			}
		this._startLifetimeType=value;
	});

	/**
	*@inheritDoc
	*/
	__getset(0,__proto,'_originalBoundingSphere',function(){
		return this._boundingSphere;
	});

	/**
	*设置开始生命周期，0模式,单位为秒。
	*/
	/**
	*获取开始生命周期，0模式,单位为秒。
	*/
	__getset(0,__proto,'startLifetimeConstant',function(){
		return this._startLifetimeConstant;
		},function(value){
		if(this._startLifetimeType===0)
			this._maxStartLifetime=value;
		this._startLifetimeConstant=value;
	});

	/**
	*设置最小开始生命周期，2模式,单位为秒。
	*/
	/**
	*获取最小开始生命周期，2模式,单位为秒。
	*/
	__getset(0,__proto,'startLifetimeConstantMin',function(){
		return this._startLifetimeConstantMin;
		},function(value){
		if (this._startLifetimeType===2)
			this._maxStartLifetime=Math.max(value,this._startLifetimeConstantMax);
		this._startLifetimeConstantMin=value;
	});

	/**
	*设置开始渐变生命周期，1模式,单位为秒。
	*/
	/**
	*获取开始渐变生命周期，1模式,单位为秒。
	*/
	__getset(0,__proto,'startLifeTimeGradient',function(){
		return this._startLifeTimeGradient;
		},function(value){
		if (this._startLifetimeType===1){
			this._maxStartLifetime=-Number.MAX_VALUE;
			for (var i=0,n=value.gradientCount;i < n;i++)
			this._maxStartLifetime=Math.max(this._maxStartLifetime,value.getValueByIndex(i));
		}
		this._startLifeTimeGradient=value;
	});

	/**
	*设置最大开始生命周期，2模式,单位为秒。
	*/
	/**
	*获取最大开始生命周期，2模式,单位为秒。
	*/
	__getset(0,__proto,'startLifetimeConstantMax',function(){
		return this._startLifetimeConstantMax;
		},function(value){
		if (this._startLifetimeType===2)
			this._maxStartLifetime=Math.max(this._startLifetimeConstantMin,value);
		this._startLifetimeConstantMax=value;
	});

	/**
	*设置开始渐变最小生命周期，3模式,单位为秒。
	*/
	/**
	*获取开始渐变最小生命周期，3模式,单位为秒。
	*/
	__getset(0,__proto,'startLifeTimeGradientMin',function(){
		return this._startLifeTimeGradientMin;
		},function(value){
		if (this._startLifetimeType===3){
			var i=0,n=0;
			this._maxStartLifetime=-Number.MAX_VALUE;
			for (i=0,n=value.gradientCount;i < n;i++)
			this._maxStartLifetime=Math.max(this._maxStartLifetime,value.getValueByIndex(i));
			for (i=0,n=this._startLifeTimeGradientMax.gradientCount;i < n;i++)
			this._maxStartLifetime=Math.max(this._maxStartLifetime,this._startLifeTimeGradientMax.getValueByIndex(i));
		}
		this._startLifeTimeGradientMin=value;
	});

	/**
	*设置开始渐变最大生命周期，3模式,单位为秒。
	*/
	/**
	*获取开始渐变最大生命周期，3模式,单位为秒。
	*/
	__getset(0,__proto,'startLifeTimeGradientMax',function(){
		return this._startLifeTimeGradientMax;
		},function(value){
		if (this._startLifetimeType===3){
			var i=0,n=0;
			this._maxStartLifetime=-Number.MAX_VALUE;
			for (i=0,n=this._startLifeTimeGradientMin.gradientCount;i < n;i++)
			this._maxStartLifetime=Math.max(this._maxStartLifetime,this._startLifeTimeGradientMin.getValueByIndex(i));
			for (i=0,n=value.gradientCount;i < n;i++)
			this._maxStartLifetime=Math.max(this._maxStartLifetime,value.getValueByIndex(i));
		}
		this._startLifeTimeGradientMax=value;
	});

	/**
	*设置生命周期速度,注意:如修改该值的某些属性,需重新赋值此属性才可生效。
	*@param value 生命周期速度.
	*/
	/**
	*获取生命周期速度,注意:如修改该值的某些属性,需重新赋值此属性才可生效。
	*@return 生命周期速度.
	*/
	__getset(0,__proto,'velocityOverLifetime',function(){
		return this._velocityOverLifetime;
		},function(value){
		var render=this._ownerRender;
		if (value){
			var velocity=value.velocity;
			var velocityType=velocity.type;
			if (value.enbale){
				switch (velocityType){
					case 0:
						render._addShaderDefine(ShuriKenParticle3D.SHADERDEFINE_VELOCITYOVERLIFETIMECONSTANT);
						break ;
					case 1:
						render._addShaderDefine(ShuriKenParticle3D.SHADERDEFINE_VELOCITYOVERLIFETIMECURVE);
						break ;
					case 2:
						render._addShaderDefine(ShuriKenParticle3D.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCONSTANT);
						break ;
					case 3:
						render._addShaderDefine(ShuriKenParticle3D.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCURVE);
						break ;
					}
				}else {
				render._removeShaderDefine(ShuriKenParticle3D.SHADERDEFINE_VELOCITYOVERLIFETIMECONSTANT);
				render._removeShaderDefine(ShuriKenParticle3D.SHADERDEFINE_VELOCITYOVERLIFETIMECURVE);
				render._removeShaderDefine(ShuriKenParticle3D.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCONSTANT);
				render._removeShaderDefine(ShuriKenParticle3D.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCURVE);
			}
			switch (velocityType){
				case 0:
					render._setShaderValueColor(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.VOLVELOCITYCONST*/13,velocity.constant);
					break ;
				case 1:
					render._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.VOLVELOCITYGRADIENTX*/14,velocity.gradientX._elements);
					render._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.VOLVELOCITYGRADIENTY*/15,velocity.gradientY._elements);
					render._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.VOLVELOCITYGRADIENTZ*/16,velocity.gradientZ._elements);
					break ;
				case 2:
					render._setShaderValueColor(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.VOLVELOCITYCONST*/13,velocity.constantMin);
					render._setShaderValueColor(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.VOLVELOCITYCONSTMAX*/17,velocity.constantMax);
					break ;
				case 3:
					render._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.VOLVELOCITYGRADIENTX*/14,velocity.gradientXMin._elements);
					render._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.VOLVELOCITYGRADIENTXMAX*/18,velocity.gradientXMax._elements);
					render._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.VOLVELOCITYGRADIENTY*/15,velocity.gradientYMin._elements);
					render._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.VOLVELOCITYGRADIENTYMAX*/19,velocity.gradientYMax._elements);
					render._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.VOLVELOCITYGRADIENTZ*/16,velocity.gradientZMin._elements);
					render._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.VOLVELOCITYGRADIENTZMAX*/20,velocity.gradientZMax._elements);
					break ;
				}
			render._setShaderValueInt(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.VOLSPACETYPE*/21,value.space);
			}else {
			render._removeShaderDefine(ShuriKenParticle3D.SHADERDEFINE_VELOCITYOVERLIFETIMECONSTANT);
			render._removeShaderDefine(ShuriKenParticle3D.SHADERDEFINE_VELOCITYOVERLIFETIMECURVE);
			render._removeShaderDefine(ShuriKenParticle3D.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCONSTANT);
			render._removeShaderDefine(ShuriKenParticle3D.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCURVE);
			render._setShaderValueColor(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.VOLVELOCITYCONST*/13,null);
			render._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.VOLVELOCITYGRADIENTX*/14,null);
			render._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.VOLVELOCITYGRADIENTY*/15,null);
			render._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.VOLVELOCITYGRADIENTZ*/16,null);
			render._setShaderValueColor(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.VOLVELOCITYCONST*/13,null);
			render._setShaderValueColor(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.VOLVELOCITYCONSTMAX*/17,null);
			render._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.VOLVELOCITYGRADIENTX*/14,null);
			render._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.VOLVELOCITYGRADIENTXMAX*/18,null);
			render._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.VOLVELOCITYGRADIENTY*/15,null);
			render._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.VOLVELOCITYGRADIENTYMAX*/19,null);
			render._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.VOLVELOCITYGRADIENTZ*/16,null);
			render._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.VOLVELOCITYGRADIENTZMAX*/20,null);
			render._setShaderValueInt(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.VOLSPACETYPE*/21,undefined);
		}
		this._velocityOverLifetime=value;
	});

	/**
	*设置生命周期颜色,注意:如修改该值的某些属性,需重新赋值此属性才可生效。
	*@param value 生命周期颜色
	*/
	/**
	*获取生命周期颜色,注意:如修改该值的某些属性,需重新赋值此属性才可生效。
	*@return 生命周期颜色
	*/
	__getset(0,__proto,'colorOverLifetime',function(){
		return this._colorOverLifetime;
		},function(value){
		var render=this._ownerRender;
		if (value){
			var color=value.color;
			if (value.enbale){
				switch (color.type){
					case 1:
						render._addShaderDefine(ShuriKenParticle3D.SHADERDEFINE_COLOROVERLIFETIME);
						break ;
					case 3:
						render._addShaderDefine(ShuriKenParticle3D.SHADERDEFINE_RANDOMCOLOROVERLIFETIME);
						break ;
					}
				}else {
				render._removeShaderDefine(ShuriKenParticle3D.SHADERDEFINE_COLOROVERLIFETIME);
				render._removeShaderDefine(ShuriKenParticle3D.SHADERDEFINE_RANDOMCOLOROVERLIFETIME);
			}
			switch (color.type){
				case 1:;
					var gradientColor=color.gradient;
					render._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.COLOROVERLIFEGRADIENTALPHAS*/22,gradientColor._alphaElements);
					render._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.COLOROVERLIFEGRADIENTCOLORS*/23,gradientColor._rgbElements);
					break ;
				case 3:;
					var minGradientColor=color.gradientMin;
					var maxGradientColor=color.gradientMax;
					render._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.COLOROVERLIFEGRADIENTALPHAS*/22,minGradientColor._alphaElements);
					render._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.COLOROVERLIFEGRADIENTCOLORS*/23,minGradientColor._rgbElements);
					render._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.MAXCOLOROVERLIFEGRADIENTALPHAS*/24,maxGradientColor._alphaElements);
					render._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.MAXCOLOROVERLIFEGRADIENTCOLORS*/25,maxGradientColor._rgbElements);
					break ;
				}
			}else {
			render._removeShaderDefine(ShuriKenParticle3D.SHADERDEFINE_COLOROVERLIFETIME);
			render._removeShaderDefine(ShuriKenParticle3D.SHADERDEFINE_RANDOMCOLOROVERLIFETIME);
			render._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.COLOROVERLIFEGRADIENTALPHAS*/22,gradientColor._alphaElements);
			render._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.COLOROVERLIFEGRADIENTCOLORS*/23,gradientColor._rgbElements);
			render._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.COLOROVERLIFEGRADIENTALPHAS*/22,minGradientColor._alphaElements);
			render._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.COLOROVERLIFEGRADIENTCOLORS*/23,minGradientColor._rgbElements);
			render._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.MAXCOLOROVERLIFEGRADIENTALPHAS*/24,maxGradientColor._alphaElements);
			render._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.MAXCOLOROVERLIFEGRADIENTCOLORS*/25,maxGradientColor._rgbElements);
		}
		this._colorOverLifetime=value;
	});

	/**
	*设置生命周期尺寸,注意:如修改该值的某些属性,需重新赋值此属性才可生效。
	*@param value 生命周期尺寸
	*/
	/**
	*获取生命周期尺寸,注意:如修改该值的某些属性,需重新赋值此属性才可生效。
	*@return 生命周期尺寸
	*/
	__getset(0,__proto,'sizeOverLifetime',function(){
		return this._sizeOverLifetime;
		},function(value){
		var render=this._ownerRender;
		if (value){
			var size=value.size;
			var sizeSeparate=size.separateAxes;
			var sizeType=size.type;
			if (value.enbale){
				switch (sizeType){
					case 0:
						if (sizeSeparate)
							render._addShaderDefine(ShuriKenParticle3D.SHADERDEFINE_SIZEOVERLIFETIMECURVESEPERATE);
						else
						render._addShaderDefine(ShuriKenParticle3D.SHADERDEFINE_SIZEOVERLIFETIMECURVE);
						break ;
					case 2:
						if (sizeSeparate)
							render._addShaderDefine(ShuriKenParticle3D.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVESSEPERATE);
						else
						render._addShaderDefine(ShuriKenParticle3D.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVES);
						break ;
					}
				}else {
				render._removeShaderDefine(ShuriKenParticle3D.SHADERDEFINE_SIZEOVERLIFETIMECURVE);
				render._removeShaderDefine(ShuriKenParticle3D.SHADERDEFINE_SIZEOVERLIFETIMECURVESEPERATE);
				render._removeShaderDefine(ShuriKenParticle3D.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVES);
				render._removeShaderDefine(ShuriKenParticle3D.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVESSEPERATE);
			}
			switch (sizeType){
				case 0:
					if (sizeSeparate){
						render._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.SOLSIZEGRADIENTX*/27,size.gradientX._elements);
						render._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.SOLSIZEGRADIENTY*/28,size.gradientY._elements);
						render._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.SOLSizeGradientZ*/29,size.gradientZ._elements);
						}else {
						render._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.SOLSIZEGRADIENT*/26,size.gradient._elements);
					}
					break ;
				case 2:
					if (sizeSeparate){
						render._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.SOLSIZEGRADIENTX*/27,size.gradientXMin._elements);
						render._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.SOLSIZEGRADIENTXMAX*/31,size.gradientXMax._elements);
						render._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.SOLSIZEGRADIENTY*/28,size.gradientYMin._elements);
						render._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.SOLSIZEGRADIENTYMAX*/32,size.gradientYMax._elements);
						render._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.SOLSizeGradientZ*/29,size.gradientZMin._elements);
						render._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.SOLSizeGradientZMAX*/33,size.gradientZMax._elements);
						}else {
						render._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.SOLSIZEGRADIENT*/26,size.gradientMin._elements);
						render._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.SOLSizeGradientMax*/30,size.gradientMax._elements);
					}
					break ;
				}
			}else {
			render._removeShaderDefine(ShuriKenParticle3D.SHADERDEFINE_SIZEOVERLIFETIMECURVE);
			render._removeShaderDefine(ShuriKenParticle3D.SHADERDEFINE_SIZEOVERLIFETIMECURVESEPERATE);
			render._removeShaderDefine(ShuriKenParticle3D.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVES);
			render._removeShaderDefine(ShuriKenParticle3D.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVESSEPERATE);
			render._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.SOLSIZEGRADIENTX*/27,null);
			render._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.SOLSIZEGRADIENTXMAX*/31,null);
			render._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.SOLSIZEGRADIENTY*/28,null);
			render._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.SOLSIZEGRADIENTYMAX*/32,null);
			render._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.SOLSizeGradientZ*/29,null);
			render._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.SOLSizeGradientZMAX*/33,null);
			render._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.SOLSIZEGRADIENT*/26,null);
			render._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.SOLSizeGradientMax*/30,null);
		}
		this._sizeOverLifetime=value;
	});

	/**
	*设置生命周期纹理动画,注意:如修改该值的某些属性,需重新赋值此属性才可生效。
	*@param value 生命周期纹理动画。
	*/
	/**
	*获取生命周期纹理动画,注意:如修改该值的某些属性,需重新赋值此属性才可生效。
	*@return 生命周期纹理动画。
	*/
	__getset(0,__proto,'textureSheetAnimation',function(){
		return this._textureSheetAnimation;
		},function(value){
		var render=this._ownerRender;
		if (value){
			var frameOverTime=value.frame;
			var textureAniType=frameOverTime.type;
			if (value.enable){
				switch (textureAniType){
					case 1:
						render._addShaderDefine(ShuriKenParticle3D.SHADERDEFINE_TEXTURESHEETANIMATIONCURVE);
						break ;
					case 3:
						render._addShaderDefine(ShuriKenParticle3D.SHADERDEFINE_TEXTURESHEETANIMATIONRANDOMCURVE);
						break ;
					}
				}else {
				render._removeShaderDefine(ShuriKenParticle3D.SHADERDEFINE_TEXTURESHEETANIMATIONCURVE);
				render._removeShaderDefine(ShuriKenParticle3D.SHADERDEFINE_TEXTURESHEETANIMATIONRANDOMCURVE);
			}
			if (textureAniType===1 || textureAniType===3){
				render._setShaderValueInt(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.TEXTURESHEETANIMATIONCYCLES*/48,value.cycles);
				var title=value.tiles;
				var _uvLengthE=this._uvLength.elements;
				_uvLengthE[0]=1.0 / title.x;
				_uvLengthE[1]=1.0 / title.y;
				render._setShaderValueVector2(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.TEXTURESHEETANIMATIONSUBUVLENGTH*/49,this._uvLength);
			}
			switch (textureAniType){
				case 1:
					render._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.TEXTURESHEETANIMATIONGRADIENTUVS*/50,frameOverTime.frameOverTimeData._elements);
					break ;
				case 3:
					render._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.TEXTURESHEETANIMATIONGRADIENTUVS*/50,frameOverTime.frameOverTimeDataMin._elements);
					render._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.TEXTURESHEETANIMATIONGRADIENTMAXUVS*/51,frameOverTime.frameOverTimeDataMax._elements);
					break ;
				}
			}else {
			render._removeShaderDefine(ShuriKenParticle3D.SHADERDEFINE_TEXTURESHEETANIMATIONCURVE);
			render._removeShaderDefine(ShuriKenParticle3D.SHADERDEFINE_TEXTURESHEETANIMATIONRANDOMCURVE);
			render._setShaderValueInt(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.TEXTURESHEETANIMATIONCYCLES*/48,undefined);
			render._setShaderValueVector2(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.TEXTURESHEETANIMATIONSUBUVLENGTH*/49,null);
			render._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.TEXTURESHEETANIMATIONGRADIENTUVS*/50,null);
			render._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.TEXTURESHEETANIMATIONGRADIENTMAXUVS*/51,null);
		}
		this._textureSheetAnimation=value;
	});

	__getset(0,__proto,'_vertexBufferCount',function(){
		return 1;
	});

	__getset(0,__proto,'triangleCount',function(){
		return this._indexBuffer?this._indexBuffer.indexCount / 3:0;
	});

	/**
	*@inheritDoc
	*/
	__getset(0,__proto,'_originalBoundingBox',function(){
		return this._boundingBox;
	});

	/**
	*@inheritDoc
	*/
	__getset(0,__proto,'_originalBoundingBoxCorners',function(){
		return this._boundingBoxCorners;
	});

	ShurikenParticleSystem.halfKSqrtOf2=1.42 *0.5;
	__static(ShurikenParticleSystem,
	['_RANDOMOFFSET',function(){return this._RANDOMOFFSET=new Uint32Array([0x23571a3e,0xc34f56fe,0x13371337,0x12460f3b,0x6aed452e,0xdec4aea1,0x96aa4de3,0x8d2c8431,0xf3857f6f,0xe0fbd834,0x13740583,0x591bc05c,0x40eb95e4,0xbc524e5f,0xaf502044,0xa614b381,0x1034e524,0xfc524e5f]);},'_maxElapsedTime',function(){return this._maxElapsedTime=1.0 / 3.0;},'_tempVector30',function(){return this._tempVector30=new Vector3();},'_tempVector31',function(){return this._tempVector31=new Vector3();},'_tempVector32',function(){return this._tempVector32=new Vector3();},'_tempVector33',function(){return this._tempVector33=new Vector3();},'_tempVector34',function(){return this._tempVector34=new Vector3();},'_tempVector35',function(){return this._tempVector35=new Vector3();},'_tempVector36',function(){return this._tempVector36=new Vector3();},'_tempVector37',function(){return this._tempVector37=new Vector3();},'_tempVector38',function(){return this._tempVector38=new Vector3();},'_tempVector39',function(){return this._tempVector39=new Vector3();},'_tempPosition',function(){return this._tempPosition=new Vector3();},'_tempDirection',function(){return this._tempDirection=new Vector3();}
	]);
	return ShurikenParticleSystem;
})(GeometryFilter)


/**
*<code>ShurikenParticleRender</code> 类用于创建3D粒子渲染器。
*/
//class laya.d3.core.particleShuriKen.ShurikenParticleRender extends laya.d3.core.render.BaseRender
var ShurikenParticleRender=(function(_super){
	function ShurikenParticleRender(owner){
		/**@private */
		//this._defaultBoundBox=null;
		/**@private */
		//this._renderMode=0;
		/**@private */
		//this._mesh=null;
		/**拉伸广告牌模式摄像机速度缩放,暂不支持。*/
		//this.stretchedBillboardCameraSpeedScale=NaN;
		/**拉伸广告牌模式速度缩放。*/
		//this.stretchedBillboardSpeedScale=NaN;
		/**拉伸广告牌模式长度缩放。*/
		//this.stretchedBillboardLengthScale=NaN;
		this._finalGravity=new Vector3();
		this._tempRotationMatrix=new Matrix4x4();
		ShurikenParticleRender.__super.call(this,owner);
		this._defaultBoundBox=new BoundBox(new Vector3(),new Vector3());
		this._renderMode=-1;
		this.stretchedBillboardCameraSpeedScale=0.0;
		this.stretchedBillboardSpeedScale=0.0;
		this.stretchedBillboardLengthScale=1.0;
	}

	__class(ShurikenParticleRender,'laya.d3.core.particleShuriKen.ShurikenParticleRender',_super);
	var __proto=ShurikenParticleRender.prototype;
	/**
	*@inheritDoc
	*/
	__proto._calculateBoundingBox=function(){
		var minE=this._boundingBox.min.elements;
		minE[0]=-Number.MAX_VALUE;
		minE[1]=-Number.MAX_VALUE;
		minE[2]=-Number.MAX_VALUE;
		var maxE=this._boundingBox.min.elements;
		maxE[0]=Number.MAX_VALUE;
		maxE[1]=Number.MAX_VALUE;
		maxE[2]=Number.MAX_VALUE;
	}

	/**
	*@inheritDoc
	*/
	__proto._calculateBoundingSphere=function(){
		var oriBoundSphere=(this._owner).particleSystem._boundingSphere;
		var maxScale=NaN;
		var transform=this._owner.transform;
		var scaleE=transform.scale.elements;
		var scaleX=Math.abs(scaleE[0]);
		var scaleY=Math.abs(scaleE[1]);
		var scaleZ=Math.abs(scaleE[2]);
		if (scaleX >=scaleY && scaleX >=scaleZ)
			maxScale=scaleX;
		else
		maxScale=scaleY >=scaleZ ? scaleY :scaleZ;
		Vector3.transformCoordinate(oriBoundSphere.center,transform.worldMatrix,this._boundingSphere.center);
		this._boundingSphere.radius=oriBoundSphere.radius *maxScale;
	}

	/**
	*@inheritDoc
	*/
	__proto._renderUpdate=function(projectionView){
		var particleSystem=(this._owner).particleSystem;
		if (!Laya.stage.isVisibility||!particleSystem.isAlive)
			return false;
		var transform=this._owner.transform;
		switch (particleSystem.simulationSpace){
			case 0:
				break ;
			case 1:
				this._setShaderValueColor(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.WORLDPOSITION*/0,transform.position);
				this._setShaderValueColor(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.WORLDROTATION*/1,transform.rotation);
				break ;
			default :
				throw new Error("ShurikenParticleMaterial: SimulationSpace value is invalid.");
			}
		switch (particleSystem.scaleMode){
			case 0:;
				var scale=transform.scale;
				this._setShaderValueColor(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.POSITIONSCALE*/4,scale);
				this._setShaderValueColor(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.SIZESCALE*/5,scale);
				break ;
			case 1:;
				var localScale=transform.localScale;
				this._setShaderValueColor(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.POSITIONSCALE*/4,localScale);
				this._setShaderValueColor(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.SIZESCALE*/5,localScale);
				break ;
			case 2:
				this._setShaderValueColor(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.POSITIONSCALE*/4,transform.scale);
				this._setShaderValueColor(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.SIZESCALE*/5,Vector3.ONE);
				break ;
			};
		var finalGravityE=this._finalGravity.elements;
		var gravityE=Physics.gravity.elements;
		var gravityModifier=particleSystem.gravityModifier;
		finalGravityE[0]=gravityE[0] *gravityModifier;
		finalGravityE[1]=gravityE[1] *gravityModifier;
		finalGravityE[2]=gravityE[2] *gravityModifier;
		this._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.GRAVITY*/7,finalGravityE);
		this._setShaderValueInt(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.SIMULATIONSPACE*/11,particleSystem.simulationSpace);
		this._setShaderValueBool(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.THREEDSTARTROTATION*/8,particleSystem.threeDStartRotation);
		this._setShaderValueInt(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.SCALINGMODE*/6,particleSystem.scaleMode);
		this._setShaderValueInt(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.STRETCHEDBILLBOARDLENGTHSCALE*/9,this.stretchedBillboardLengthScale);
		this._setShaderValueInt(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.STRETCHEDBILLBOARDSPEEDSCALE*/10,this.stretchedBillboardSpeedScale);
		this._setShaderValueNumber(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.CURRENTTIME*/12,particleSystem._currentTime);
		if (Laya3D.debugMode)
			this._renderRenderableBoundBox();
		return true;
	}

	/**
	*@inheritDoc
	*/
	__proto._destroy=function(){
		_super.prototype._destroy.call(this);
		(this._mesh)&& (this._mesh._removeReference(),this._mesh=null);
	}

	/**
	*@inheritDoc
	*/
	__getset(0,__proto,'boundingBox',function(){
		if (!(this._owner).particleSystem.isAlive){
			return this._defaultBoundBox;
			}else {
			if (this._boundingBoxNeedChange){
				this._calculateBoundingBox();
				this._boundingBoxNeedChange=false;
			}
			return this._boundingBox;
		}
	});

	/**
	*设置渲染模式,0为BILLBOARD、1为STRETCHEDBILLBOARD、2为HORIZONTALBILLBOARD、3为VERTICALBILLBOARD、4为MESH。
	*@param value 渲染模式。
	*/
	/**
	*获取渲染模式。
	*@return 渲染模式。
	*/
	__getset(0,__proto,'renderMode',function(){
		return this._renderMode;
		},function(value){
		if (this._renderMode!==value){
			switch (this._renderMode){
				case 0:
					this._removeShaderDefine(ShuriKenParticle3D.SHADERDEFINE_RENDERMODE_BILLBOARD);
					break ;
				case 1:
					this._removeShaderDefine(ShuriKenParticle3D.SHADERDEFINE_RENDERMODE_STRETCHEDBILLBOARD);
					break ;
				case 2:
					this._removeShaderDefine(ShuriKenParticle3D.SHADERDEFINE_RENDERMODE_HORIZONTALBILLBOARD);
					break ;
				case 3:
					this._removeShaderDefine(ShuriKenParticle3D.SHADERDEFINE_RENDERMODE_VERTICALBILLBOARD);
					break ;
				case 4:
					this._removeShaderDefine(ShuriKenParticle3D.SHADERDEFINE_RENDERMODE_MESH);
					break ;
				}
			this._renderMode=value;
			switch (value){
				case 0:
					this._addShaderDefine(ShuriKenParticle3D.SHADERDEFINE_RENDERMODE_BILLBOARD);
					break ;
				case 1:
					this._addShaderDefine(ShuriKenParticle3D.SHADERDEFINE_RENDERMODE_STRETCHEDBILLBOARD);
					break ;
				case 2:
					this._addShaderDefine(ShuriKenParticle3D.SHADERDEFINE_RENDERMODE_HORIZONTALBILLBOARD);
					break ;
				case 3:
					this._addShaderDefine(ShuriKenParticle3D.SHADERDEFINE_RENDERMODE_VERTICALBILLBOARD);
					break ;
				case 4:
					this._addShaderDefine(ShuriKenParticle3D.SHADERDEFINE_RENDERMODE_MESH);
					break ;
				default :
					throw new Error("ShurikenParticleRender: unknown renderMode Value.");
				}
			(this._owner).particleSystem._initBufferDatas();
		}
	});

	/**
	*设置网格渲染模式所使用的Mesh,rendderMode为4时生效。
	*@param value 网格模式所使用Mesh。
	*/
	/**
	*获取网格渲染模式所使用的Mesh,rendderMode为4时生效。
	*@return 网格模式所使用Mesh。
	*/
	__getset(0,__proto,'mesh',function(){
		return this._mesh
		},function(value){
		if (this._mesh!==value){
			(this._mesh)&& (this._mesh._removeReference());
			this._mesh=value;
			(value)&& (value._addReference());
			(this._owner).particleSystem._initBufferDatas();
		}
	});

	return ShurikenParticleRender;
})(BaseRender)


/**
*...
*@author ...
*/
//class laya.d3.core.trail.TrailFilter extends laya.d3.core.GeometryFilter
var TrailFilter=(function(_super){
	function TrailFilter(owner){
		this._owner=null;
		this._trailRenderElements=null;
		this._minVertexDistance=NaN;
		this._widthMultiplier=NaN;
		this._time=NaN;
		this._widthCurve=null;
		this._colorGradient=null;
		this._textureMode=0;
		this._curtime=0;
		this._curSubTrailFinishCurTime=0;
		this._curSubTrailFinished=false;
		this._hasLifeSubTrail=false;
		this._trailTotalLength=0;
		this._trailSupplementLength=0;
		this._trailDeadLength=0;
		this._isStart=false;
		this._trailRenderElementIndex=0;
		TrailFilter.__super.call(this);
		this._curSubTrailFinishPosition=new Vector3();
		this._curSubTrailFinishDirection=new Vector3();
		this._owner=owner;
		this._trailRenderElements=[];
		this.addRenderElement();
	}

	__class(TrailFilter,'laya.d3.core.trail.TrailFilter',_super);
	var __proto=TrailFilter.prototype;
	__proto.getRenderElementsCount=function(){
		return this._trailRenderElements.length;
	}

	__proto.addRenderElement=function(){
		for (var i=0;i < this._trailRenderElements.length;i++){
			if (this._trailRenderElements[i]._isDead==true){
				this._trailRenderElements[i].reActivate();
				return i;
			}
		};
		var _trailRenderElement=new TrailRenderElement(this);
		this._trailRenderElements.push(_trailRenderElement);
		return this._trailRenderElements.length-1;
	}

	__proto.getRenderElement=function(index){
		return this._trailRenderElements[index];
	}

	__proto._update=function(state){
		this._curtime+=state.elapsedTime / 1000;
		this._owner._render._setShaderValueNumber(/*laya.d3.core.trail.TrailSprite3D.CURTIME*/3,this._curtime);
		if (this._curSubTrailFinished){
			this._curSubTrailFinished=false;
			this._trailRenderElementIndex=this.addRenderElement();
			this.event(/*laya.events.Event.TRAIL_FILTER_CHANGE*/"trailfilterchange",[this._trailRenderElementIndex,this._trailRenderElements[this._trailRenderElementIndex]]);
		}
	}

	__proto.reset=function(){
		for (var i=0;i < this._trailRenderElements.length;i++){
			this._trailRenderElements[i].reActivate();
		}
		this._isStart=false;
		this._hasLifeSubTrail=false;
		this._curSubTrailFinished=false;
		this._curSubTrailFinishCurTime=0;
		this._trailTotalLength=0;
		this._trailSupplementLength=0;
		this._trailDeadLength=0;
	}

	/**
	*@private
	*/
	__proto._destroy=function(){
		_super.prototype._destroy.call(this);
		for (var i=0;i < this._trailRenderElements.length;i++){
			this._trailRenderElements[i]._destroy();
		}
		this._trailRenderElements=null;
		this._widthCurve=null;
		this._colorGradient=null;
		this._curSubTrailFinishPosition=null;
		this._curSubTrailFinishDirection=null;
	}

	/**
	*设置宽度倍数。
	*@param value 宽度倍数。
	*/
	/**
	*获取宽度倍数。
	*@return 宽度倍数。
	*/
	__getset(0,__proto,'widthMultiplier',function(){
		return this._widthMultiplier;
		},function(value){
		this._widthMultiplier=value;
	});

	/**
	*设置淡出时间。
	*@param value 淡出时间。
	*/
	/**
	*获取淡出时间。
	*@return 淡出时间。
	*/
	__getset(0,__proto,'time',function(){
		return this._time;
		},function(value){
		this._time=value;
		this._owner._render._setShaderValueNumber(/*laya.d3.core.trail.TrailSprite3D.LIFETIME*/4,value);
	});

	/**
	*设置宽度曲线。
	*@param value 宽度曲线。
	*/
	/**
	*获取宽度曲线。
	*@return 宽度曲线。
	*/
	__getset(0,__proto,'widthCurve',function(){
		return this._widthCurve;
		},function(value){
		this._widthCurve=value;
		var widthCurveFloatArray=new Float32Array(value.length *4);
		var i=0,j=0,index=0;
		for (i=0,j=value.length;i < j;i++){
			widthCurveFloatArray[index++]=value[i].time;
			widthCurveFloatArray[index++]=value[i].inTangent;
			widthCurveFloatArray[index++]=value[i].outTangent;
			widthCurveFloatArray[index++]=value[i].value;
		}
		this._owner._render._setShaderValueBuffer(/*laya.d3.core.trail.TrailSprite3D.WIDTHCURVE*/5,widthCurveFloatArray);
		this._owner._render._setShaderValueInt(/*laya.d3.core.trail.TrailSprite3D.WIDTHCURVEKEYLENGTH*/6,value.length);
	});

	/**
	*设置新旧顶点之间最小距离。
	*@param value 新旧顶点之间最小距离。
	*/
	/**
	*获取新旧顶点之间最小距离。
	*@return 新旧顶点之间最小距离。
	*/
	__getset(0,__proto,'minVertexDistance',function(){
		return this._minVertexDistance;
		},function(value){
		this._minVertexDistance=value;
	});

	/**
	*设置颜色梯度。
	*@param value 颜色梯度。
	*/
	/**
	*获取颜色梯度。
	*@return 颜色梯度。
	*/
	__getset(0,__proto,'colorGradient',function(){
		return this._colorGradient;
		},function(value){
		this._colorGradient=value;
		this._owner._render._setShaderValueBuffer(/*laya.d3.core.trail.TrailSprite3D.GRADIENTCOLORKEY*/7,value._colorKeyData);
		this._owner._render._setShaderValueBuffer(/*laya.d3.core.trail.TrailSprite3D.GRADIENTALPHAKEY*/8,value._alphaKeyData);
		if (value.mode==/*laya.d3.core.trail.module.GradientMode.Blend*/0){
			this._owner._render._addShaderDefine(TrailSprite3D.SHADERDEFINE_GRADIENTMODE_BLEND);
		}
		else{
			this._owner._render._removeShaderDefine(TrailSprite3D.SHADERDEFINE_GRADIENTMODE_BLEND);
		}
	});

	/**
	*设置纹理模式。
	*@param value 纹理模式。
	*/
	/**
	*获取纹理模式。
	*@return 纹理模式。
	*/
	__getset(0,__proto,'textureMode',function(){
		return this._textureMode;
		},function(value){
		this._textureMode=value;
	});

	return TrailFilter;
})(GeometryFilter)


/**
*...
*@author ...
*/
//class laya.d3.core.trail.TrailRenderer extends laya.d3.core.render.BaseRender
var TrailRenderer=(function(_super){
	function TrailRenderer(owner){
		TrailRenderer.__super.call(this,owner);
	}

	__class(TrailRenderer,'laya.d3.core.trail.TrailRenderer',_super);
	var __proto=TrailRenderer.prototype;
	__proto._calculateBoundingBox=function(){
		var minE=this._boundingBox.min.elements;
		minE[0]=-Number.MAX_VALUE;
		minE[1]=-Number.MAX_VALUE;
		minE[2]=-Number.MAX_VALUE;
		var maxE=this._boundingBox.min.elements;
		maxE[0]=Number.MAX_VALUE;
		maxE[1]=Number.MAX_VALUE;
		maxE[2]=Number.MAX_VALUE;
	}

	__proto._calculateBoundingSphere=function(){
		var centerE=this._boundingSphere.center.elements;
		centerE[0]=0;
		centerE[1]=0;
		centerE[2]=0;
		this._boundingSphere.radius=Number.MAX_VALUE;
	}

	__proto._renderUpdate=function(projectionView){
		return true;
	}

	return TrailRenderer;
})(BaseRender)


/**
*@private
*<code>GlitterTemplet</code> 类用于创建闪光数据模板。
*/
//class laya.d3.resource.tempelet.GlitterTemplet extends laya.d3.core.GeometryFilter
var GlitterTemplet=(function(_super){
	function GlitterTemplet(owner){
		this._floatCountPerVertex=6;
		//顶点结构为Position(3个float)+UV(2个float)+Time(1个float)
		this._owner=null;
		this._vertices=null;
		this._vertexBuffer=null;
		this._firstActiveElement=0;
		this._firstNewElement=0;
		this._firstFreeElement=0;
		this._firstRetiredElement=0;
		this._currentTime=NaN;
		this._drawCounter=0;
		this.scLeft=null;
		this.scRight=null;
		this._numPositionMode=0;
		this._numPositionVelocityMode=0;
		this._lastTime=NaN;
		this._needPatch=false;
		this._lastPatchAddPos0=null;
		this._lastPatchAddPos1=null;
		this._lastPatchAddTime=NaN;
		/**声明周期。 */
		this.lifeTime=NaN;
		/**最小分段距离。 */
		this.minSegmentDistance=NaN;
		/**最小插值距离。 */
		this.minInterpDistance=NaN;
		/**最大插值数量。 */
		this.maxSlerpCount=0;
		/**最大段数。 */
		this._maxSegments=0;
		GlitterTemplet.__super.call(this);
		this._tempVector0=new Vector3();
		this._tempVector1=new Vector3();
		this._tempVector2=new Vector3();
		this._tempVector3=new Vector3();
		this._posModeLastPosition0=new Vector3();
		this._posModeLastPosition1=new Vector3();
		this._posModePosition0=new Vector3();
		this._posModePosition1=new Vector3();
		this._posVelModePosition0=new Vector3();
		this._posVelModeVelocity0=new Vector3();
		this._posVelModePosition1=new Vector3();
		this._posVelModeVelocity1=new Vector3();
		this._owner=owner;
		this._lastTime=0
		this._firstActiveElement=0;
		this._firstNewElement=0;
		this._firstFreeElement=0;
		this._firstRetiredElement=0;
		this._currentTime=0;
		this._drawCounter=0;
		this._needPatch=false;
		this._lastPatchAddPos0=new Vector3();
		this._lastPatchAddPos1=new Vector3();
		this.scLeft=new SplineCurvePositionVelocity();
		this.scRight=new SplineCurvePositionVelocity();
		this.lifeTime=0.5;
		this.minSegmentDistance=0.1;
		this.minInterpDistance=0.6;
		this.maxSlerpCount=128;
		this._maxSegments=200;
		this._owner.on(/*laya.events.Event.ACTIVE_IN_HIERARCHY_CHANGED*/"activeinhierarchychanged",this,this._onActiveHierarchyChanged);
	}

	__class(GlitterTemplet,'laya.d3.resource.tempelet.GlitterTemplet',_super);
	var __proto=GlitterTemplet.prototype;
	Laya.imps(__proto,{"laya.d3.core.render.IRenderable":true})
	__proto._getVertexBuffer=function(index){
		(index===void 0)&& (index=0);
		if (index===0)
			return this._vertexBuffer;
		else
		return null;
	}

	__proto._getIndexBuffer=function(){
		return null;
	}

	/**
	*@private
	*/
	__proto._initialize=function(){
		this._vertexBuffer=VertexBuffer3D.create(VertexGlitter.vertexDeclaration,this.maxSegments *2,/*laya.webgl.WebGLContext.DYNAMIC_DRAW*/0x88E8);
		this._vertices=new Float32Array(this.maxSegments *this._floatCountPerVertex *2);
	}

	__proto._onActiveHierarchyChanged=function(active){
		if (!active){
			this._numPositionMode=0;
			this._numPositionVelocityMode=0;
			this._firstActiveElement=0;
			this._firstNewElement=0;
			this._firstFreeElement=0;
			this._firstRetiredElement=0;
			this._currentTime=0;
			this._drawCounter=0;
		}
	}

	/**
	*@private
	*/
	__proto._updateTextureCoordinates=function(){
		if (this._firstActiveElement < this._firstFreeElement){
			this._updateSubTextureCoordinates(this._firstActiveElement,(this._firstFreeElement-this._firstActiveElement)*2);
			}else {
			this._updateSubTextureCoordinates(this._firstActiveElement,(this.maxSegments-this._firstActiveElement)*2);
			if (this._firstFreeElement > 0)
				this._updateSubTextureCoordinates(0,this._firstFreeElement *2);
		}
	}

	/**
	*@private
	*/
	__proto._updateSubTextureCoordinates=function(start,count){
		var startOffset=start *2;
		for (var i=0;i < count;i+=2){
			var vertexOffset=startOffset+i;
			var upVertexOffset=vertexOffset *this._floatCountPerVertex;
			var downVertexOffset=(vertexOffset+1)*this._floatCountPerVertex;
			this._vertices[upVertexOffset+3]=this._vertices[downVertexOffset+3]=(this._vertices[upVertexOffset+5]-this._currentTime)/ this.lifeTime;
		}
	}

	/**
	*@private
	*/
	__proto._retireActiveGlitter=function(){
		var particleDuration=this.lifeTime;
		var _floatCountOneSegement=this._floatCountPerVertex *2;
		while (this._firstActiveElement !=this._firstNewElement){
			var index=this._firstActiveElement *_floatCountOneSegement+5;
			var particleAge=this._currentTime-this._vertices[index];
			if (particleAge < particleDuration)
				break ;
			this._vertices[index]=this._drawCounter;
			this._firstActiveElement++;
			if (this._firstActiveElement >=this.maxSegments)
				this._firstActiveElement=0;
		}
	}

	/**
	*@private
	*/
	__proto._freeRetiredGlitter=function(){
		var _floatCountOneSegement=this._floatCountPerVertex *2;
		while (this._firstRetiredElement !=this._firstActiveElement){
			var age=this._drawCounter-this._vertices[this._firstRetiredElement *_floatCountOneSegement+5];
			if (age < 3)
				break ;
			this._firstRetiredElement++;
			if (this._firstRetiredElement >=this.maxSegments)
				this._firstRetiredElement=0;
		}
	}

	/**
	*@private
	*/
	__proto._calcVelocity=function(left,right,out){
		Vector3.subtract(left,right,out);
		Vector3.scale(out,0.5,out);
	}

	/**
	*@private
	*/
	__proto._addNewGlitterSegementToVertexBuffer=function(){
		var start=0;
		if (this._firstActiveElement < this._firstFreeElement){
			start=this._firstActiveElement *2 *this._floatCountPerVertex;
			this._vertexBuffer.setData(this._vertices,start,start,(this._firstFreeElement-this._firstActiveElement)*2 *this._floatCountPerVertex);
			}else {
			start=this._firstActiveElement *2 *this._floatCountPerVertex;
			this._vertexBuffer.setData(this._vertices,start,start,(this.maxSegments-this._firstActiveElement)*2 *this._floatCountPerVertex);
			if (this._firstFreeElement > 0){
				this._vertexBuffer.setData(this._vertices,0,0,this._firstFreeElement *2 *this._floatCountPerVertex);
			}
		}
		this._firstNewElement=this._firstFreeElement;
	}

	/**
	*@private
	*/
	__proto._addGlitter=function(position0,position1,time){
		if (this._needPatch){
			this._needPatch=false;
			this._addGlitter(this._lastPatchAddPos0,this._lastPatchAddPos1,this._lastPatchAddTime);
		};
		var nextFreeParticle=this._firstFreeElement+1;
		if (nextFreeParticle >=this.maxSegments){
			nextFreeParticle=0;
			position0.cloneTo(this._lastPatchAddPos0);
			position1.cloneTo(this._lastPatchAddPos1);
			this._lastPatchAddTime=time;
			this._needPatch=true;
		}
		if (nextFreeParticle===this._firstRetiredElement)
			console.log("GlitterTemplet:current segement count have large than maxSegments,please adjust the  value of maxSegments or add Glitter Vertex Frequency.");
		var position0e=position0.elements;
		var position1e=position1.elements;
		var j=0;
		var positionIndex=this._firstFreeElement *this._floatCountPerVertex *2;
		for (j=0;j < 3;j++)
		this._vertices[positionIndex+j]=position0e[j];
		this._vertices[positionIndex+3]=0.0;
		this._vertices[positionIndex+4]=0.0;
		this._vertices[positionIndex+5]=time;
		var nextPositionIndex=positionIndex+this._floatCountPerVertex;
		for (j=0;j < 3;j++)
		this._vertices[nextPositionIndex+j]=position1e[j];
		this._vertices[nextPositionIndex+3]=0.0;
		this._vertices[nextPositionIndex+4]=1.0;
		this._vertices[nextPositionIndex+5]=time;
		this._firstFreeElement=nextFreeParticle;
	}

	/**
	*@private
	*更新闪光。
	*@param elapsedTime 间隔时间
	*/
	__proto._update=function(elapsedTime){
		this._currentTime+=elapsedTime / 1000;
		this._retireActiveGlitter();
		this._freeRetiredGlitter();
		if (this._firstActiveElement==this._firstFreeElement)
			this._currentTime=0;
		if (this._firstRetiredElement==this._firstActiveElement)
			this._drawCounter=0;
		this._updateTextureCoordinates();
	}

	//实时更新纹理坐标
	__proto._beforeRender=function(state){
		if (this._firstNewElement !=this._firstFreeElement){
			this._addNewGlitterSegementToVertexBuffer();
		}
		this._drawCounter++;
		if (this._firstActiveElement !=this._firstFreeElement){
			this._vertexBuffer.bindWithIndexBuffer(null);
			return true;
		}
		return false;
	}

	/**
	*@private
	*渲染闪光。
	*@param state 相关渲染状态
	*/
	__proto._render=function(state){
		var drawVertexCount=0;
		var glContext=WebGL.mainContext;
		if (this._firstActiveElement < this._firstFreeElement){
			drawVertexCount=(this._firstFreeElement-this._firstActiveElement)*2;
			glContext.drawArrays(/*laya.webgl.WebGLContext.TRIANGLE_STRIP*/0x0005,this._firstActiveElement *2,drawVertexCount);
			Stat.trianglesFaces+=drawVertexCount-2;
			Stat.drawCall++;
			}else {
			drawVertexCount=(this.maxSegments-this._firstActiveElement)*2;
			glContext.drawArrays(/*laya.webgl.WebGLContext.TRIANGLE_STRIP*/0x0005,this._firstActiveElement *2,drawVertexCount);
			Stat.trianglesFaces+=drawVertexCount-2;
			Stat.drawCall++;
			if (this._firstFreeElement > 0){
				drawVertexCount=this._firstFreeElement *2;
				glContext.drawArrays(/*laya.webgl.WebGLContext.TRIANGLE_STRIP*/0x0005,0,drawVertexCount);
				Stat.trianglesFaces+=drawVertexCount-2;
				Stat.drawCall++;
			}
		}
	}

	/**
	*通过位置添加刀光。
	*@param position0 位置0。
	*@param position1 位置1。
	*/
	__proto.addVertexPosition=function(position0,position1){
		if (this._owner.activeInHierarchy){
			if (this._numPositionMode < 2){
				if (this._numPositionMode===0){
					position0.cloneTo(this._posModeLastPosition0);
					position1.cloneTo(this._posModeLastPosition1);
					}else {
					position0.cloneTo(this._posModePosition0);
					position1.cloneTo(this._posModePosition1);
				}
				this._numPositionMode++;
				}else {
				var v0=this._tempVector2;
				this._calcVelocity(position0,this._posModeLastPosition0,v0);
				var v1=this._tempVector3;
				this._calcVelocity(position1,this._posModeLastPosition1,v1);
				this.addVertexPositionVelocity(this._posModePosition0,v0,this._posModePosition1,v1);
				this._posModePosition0.cloneTo(this._posModeLastPosition0);
				this._posModePosition1.cloneTo(this._posModeLastPosition1);
				position0.cloneTo(this._posModePosition0);
				position1.cloneTo(this._posModePosition1);
			}
		}
	}

	/**
	*通过位置和速度添加刀光。
	*@param position0 位置0。
	*@param velocity0 速度0。
	*@param position1 位置1。
	*@param velocity1 速度1。
	*/
	__proto.addVertexPositionVelocity=function(position0,velocity0,position1,velocity1){
		if (this._owner.activeInHierarchy){
			if (this._numPositionVelocityMode===0){
				this._numPositionVelocityMode++;
				}else {
				var d=this._tempVector0;
				Vector3.subtract(position0,this._posVelModePosition0,d);
				var distance0=Vector3.scalarLength(d);
				Vector3.subtract(position1,this._posVelModePosition1,d);
				var distance1=Vector3.scalarLength(d);
				var slerpCount=0;
				var minSegmentDistance=minSegmentDistance;
				if (distance0 < minSegmentDistance && distance1 < minSegmentDistance)
					return;
				slerpCount=1+Math.floor(Math.max(distance0,distance1)/ this.minInterpDistance);
				if (slerpCount===1){
					this._addGlitter(position0,position1,this._currentTime);
					}else {
					slerpCount=Math.min(slerpCount,this.maxSlerpCount);
					this.scLeft.Init(this._posVelModePosition0,this._posVelModeVelocity0,position0,velocity0);
					this.scRight.Init(this._posVelModePosition1,this._posVelModeVelocity1,position1,velocity1);
					var segment=1.0 / slerpCount;
					var addSegment=segment;
					var timeOffset=this._currentTime-this._lastTime;
					for (var i=1;i <=slerpCount;i++){
						var pos0=this._tempVector0;
						this.scLeft.Slerp(addSegment,pos0);
						var pos1=this._tempVector1;
						this.scRight.Slerp(addSegment,pos1);
						var time=this._lastTime+timeOffset *i / slerpCount;
						this._addGlitter(pos0,pos1,time);
						addSegment+=segment;
					}
				}
			}
			this._lastTime=this._currentTime;
			position0.cloneTo(this._posVelModePosition0);
			velocity0.cloneTo(this._posVelModeVelocity0);
			position1.cloneTo(this._posVelModePosition1);
			velocity1.cloneTo(this._posVelModeVelocity1);
		}
	}

	__proto._destroy=function(){
		_super.prototype._destroy.call(this);
		this._tempVector0=null;
		this._tempVector1=null;
		this._tempVector2=null;
		this._tempVector3=null;
		this._owner=null;
		this._vertices=null;
		this._vertexBuffer.destroy();
		this._vertexBuffer=null;
		this.scLeft=null;
		this.scRight=null;
		this._posModeLastPosition0=null;
		this._posModeLastPosition1=null;
		this._posModePosition0=null;
		this._posModePosition1=null;
		this._posVelModePosition0=null;
		this._posVelModeVelocity0=null;
		this._posVelModePosition1=null;
		this._posVelModeVelocity1=null;
		this._lastPatchAddPos0=null;
		this._lastPatchAddPos1=null;
	}

	/**
	*@private
	*/
	__proto._getVertexBuffers=function(){
		return null;
	}

	/**设置最大分段数,注意:谨慎修改此属性，有性能损耗。*/
	/**获取最大分段数。*/
	__getset(0,__proto,'maxSegments',function(){
		return this._maxSegments-1;
		},function(value){
		var newMaxSegments=value+1;
		if (newMaxSegments!==this._maxSegments){
			this._maxSegments=newMaxSegments;
			if (this._vertexBuffer){
				this._vertexBuffer.destroy();
			}
			this._initialize();
		}
	});

	__getset(0,__proto,'_vertexBufferCount',function(){
		return 1;
	});

	__getset(0,__proto,'triangleCount',function(){
		var drawVertexCount=0;
		if (this._firstActiveElement < this._firstFreeElement){
			drawVertexCount=(this._firstFreeElement-this._firstActiveElement)*2-2;
			}else {
			drawVertexCount=(this.maxSegments-this._firstActiveElement)*2-2;
			drawVertexCount+=this._firstFreeElement *2-2;
		}
		return drawVertexCount;
	});

	/**
	*@inheritDoc
	*/
	__getset(0,__proto,'_originalBoundingSphere',function(){
		return Laya.superGet(GeometryFilter,this,'_originalBoundingSphere');
	});

	/**
	*@inheritDoc
	*/
	__getset(0,__proto,'_originalBoundingBox',function(){
		return Laya.superGet(GeometryFilter,this,'_originalBoundingBox');
	});

	return GlitterTemplet;
})(GeometryFilter)


/**
*<code>TerrainFilter</code> 类用于创建TerrainFilter过滤器。
*/
//class laya.d3.terrain.TerrainFilter extends laya.d3.core.GeometryFilter
var TerrainFilter=(function(_super){
	function TerrainFilter(owner,chunkOffsetX,chunkOffsetZ,gridSize,terrainHeightData,heightDataWidth,heightDataHeight,cameraCoordinateInverse){
		this._owner=null;
		this._gridSize=NaN;
		this.memorySize=0;
		this._numberVertices=0;
		this._maxNumberIndices=0;
		this._currentNumberIndices=0;
		this._numberTriangle=0;
		this._vertexBuffer=null;
		this._indexBuffer=null;
		this._boundingSphere=null;
		this._boundingBox=null;
		this._indexArrayBuffer=null;
		this._boundingBoxCorners=null;
		this._leafs=null;
		this._leafNum=0;
		this._terrainHeightData=null;
		this._terrainHeightDataWidth=0;
		this._terrainHeightDataHeight=0;
		this._chunkOffsetX=0;
		this._chunkOffsetZ=0;
		this._cameraCoordinateInverse=false;
		this._cameraPos=null;
		this._currentLOD=0;
		//LOD级别 4个叶子节点 第1个叶子的level<<24+第2个叶子的level<<16+第3个叶子的level<<8+第4个叶子的level
		this._perspectiveFactor=NaN;
		this._LODTolerance=0;
		TerrainFilter.__super.call(this);
		this._owner=owner;
		this._cameraPos=new Vector3();
		this._chunkOffsetX=chunkOffsetX;
		this._chunkOffsetZ=chunkOffsetZ;
		this._gridSize=gridSize;
		this._terrainHeightData=terrainHeightData;
		this._terrainHeightDataWidth=heightDataWidth;
		this._terrainHeightDataHeight=heightDataHeight;
		this._leafNum=(TerrainLeaf.CHUNK_GRID_NUM / TerrainLeaf.LEAF_GRID_NUM)*(TerrainLeaf.CHUNK_GRID_NUM / TerrainLeaf.LEAF_GRID_NUM);
		this._leafs=__newvec(this._leafNum);
		this._cameraCoordinateInverse=cameraCoordinateInverse;
		for (var i=0;i < this._leafNum;i++){
			this._leafs[i]=new TerrainLeaf();
		}
		this.recreateResource();
	}

	__class(TerrainFilter,'laya.d3.terrain.TerrainFilter',_super);
	var __proto=TerrainFilter.prototype;
	Laya.imps(__proto,{"laya.d3.core.render.IRenderable":true})
	/**
	*@inheritDoc
	*/
	__proto._destroy=function(){
		_super.prototype._destroy.call(this);
		this._owner=null;
		if (this._vertexBuffer)this._vertexBuffer.destroy();
		if (this._indexBuffer)this._indexBuffer.destroy();
	}

	__proto.recreateResource=function(){
		this._currentNumberIndices=0;
		this._numberTriangle=0;
		var nLeafVertexCount=TerrainLeaf.LEAF_VERTEXT_COUNT;
		var nLeafIndexCount=TerrainLeaf.LEAF_MAX_INDEX_COUNT;
		this._numberVertices=nLeafVertexCount *this._leafNum;
		this._maxNumberIndices=nLeafIndexCount *this._leafNum;
		this._indexArrayBuffer=new Uint16Array(this._maxNumberIndices);
		var vertexDeclaration=VertexPositionTerrain.vertexDeclaration;
		var vertexFloatStride=vertexDeclaration.vertexStride / 4;
		var vertices=new Float32Array(this._numberVertices *vertexFloatStride);
		var nNum=TerrainLeaf.CHUNK_GRID_NUM / TerrainLeaf.LEAF_GRID_NUM;
		var i=0,x=0,z=0;
		for (i=0;i < this._leafNum;i++){
			x=i % nNum;
			z=Math.floor(i / nNum);
			this._leafs[i].calcVertextBuffer(this._chunkOffsetX,this._chunkOffsetZ,x *TerrainLeaf.LEAF_GRID_NUM,z *TerrainLeaf.LEAF_GRID_NUM,this._gridSize,vertices,i *TerrainLeaf.LEAF_PLANE_VERTEXT_COUNT,vertexFloatStride,this._terrainHeightData,this._terrainHeightDataWidth,this._terrainHeightDataHeight,this._cameraCoordinateInverse);
		}
		for (i=0;i < this._leafNum;i++){
			x=i % nNum;
			z=Math.floor(i / nNum);
			this._leafs[i].calcSkirtVertextBuffer(this._chunkOffsetX,this._chunkOffsetZ,x *TerrainLeaf.LEAF_GRID_NUM,z *TerrainLeaf.LEAF_GRID_NUM,this._gridSize,vertices,this._leafNum *TerrainLeaf.LEAF_PLANE_VERTEXT_COUNT+i *TerrainLeaf.LEAF_SKIRT_VERTEXT_COUNT,vertexFloatStride,this._terrainHeightData,this._terrainHeightDataWidth,this._terrainHeightDataHeight);
		}
		this.assembleIndexInit();
		this._vertexBuffer=new VertexBuffer3D(vertexDeclaration,this._numberVertices,/*laya.webgl.WebGLContext.STATIC_DRAW*/0x88E4,false);
		this._indexBuffer=new IndexBuffer3D(/*laya.d3.graphics.IndexBuffer3D.INDEXTYPE_USHORT*/"ushort",this._maxNumberIndices,/*laya.webgl.WebGLContext.STATIC_DRAW*/0x88E4,false);
		this._vertexBuffer.setData(vertices);
		this._indexBuffer.setData(this._indexArrayBuffer);
		this.memorySize=(this._vertexBuffer._byteLength+this._indexBuffer._byteLength)*2;
		this.calcOriginalBoudingBoxAndSphere();
	}

	__proto.setLODLevel=function(leafsLODLevel){
		if (leafsLODLevel.length !=4)return true;
		var nLOD=((leafsLODLevel[0]+1)<< 24)+((leafsLODLevel[1]+1)<< 16)+((leafsLODLevel[2]+1)<< 8)+(leafsLODLevel[3]+1);
		if (this._currentLOD==nLOD){
			return false;
		}
		this._currentLOD=nLOD;
		return true;
	}

	__proto.assembleIndexInit=function(){
		this._currentNumberIndices=0;
		this._numberTriangle=0;
		var nOffsetIndex=0;
		for (var i=0;i < this._leafNum;i++){
			var planeLODIndex=TerrainLeaf.getPlaneLODIndex(i,0);
			this._indexArrayBuffer.set(planeLODIndex,nOffsetIndex);
			nOffsetIndex+=planeLODIndex.length;
			var skirtLODIndex=TerrainLeaf.getSkirtLODIndex(i,0);
			this._indexArrayBuffer.set(skirtLODIndex,nOffsetIndex);
			nOffsetIndex+=skirtLODIndex.length;
			this._currentNumberIndices+=(planeLODIndex.length+skirtLODIndex.length);
		}
		this._numberTriangle=this._currentNumberIndices / 3;
	}

	__proto.isNeedAssemble=function(camera,cameraPostion){
		var perspectiveFactor=Math.min(camera.viewport.width,camera.viewport.height)/ (2 *Math.tan(Math.PI *camera.fieldOfView / 180.0));
		if (this._perspectiveFactor !=perspectiveFactor){
			this._perspectiveFactor=perspectiveFactor;
			return 1;
		}
		if (this._LODTolerance !=Terrain.LOD_TOLERANCE_VALUE){
			this._LODTolerance=Terrain.LOD_TOLERANCE_VALUE;
			return 1;
		}
		if (Vector3.equals(cameraPostion,this._cameraPos)==false){
			this._cameraPos.x=cameraPostion.x;
			this._cameraPos.y=cameraPostion.y;
			this._cameraPos.z=cameraPostion.z;
			return 2;
		}
		return 0;
	}

	__proto.assembleIndex=function(camera,cameraPostion){
		var nNeedType=this.isNeedAssemble(camera,cameraPostion);
		if (nNeedType > 0){
			for (var i=0;i < this._leafNum;i++){
				TerrainFilter._TEMP_ARRAY_BUFFER[i]=this._leafs[i].determineLod(cameraPostion,this._perspectiveFactor,Terrain.LOD_TOLERANCE_VALUE,nNeedType==1);
			}
			if (this.setLODLevel(TerrainFilter._TEMP_ARRAY_BUFFER)){
				this._currentNumberIndices=0;
				this._numberTriangle=0;
				var nOffsetIndex=0;
				for (i=0;i < this._leafNum;i++){
					var nLODLevel=TerrainFilter._TEMP_ARRAY_BUFFER[i];
					var planeLODIndex=TerrainLeaf.getPlaneLODIndex(i,nLODLevel);
					this._indexArrayBuffer.set(planeLODIndex,nOffsetIndex);
					nOffsetIndex+=planeLODIndex.length;
					var skirtLODIndex=TerrainLeaf.getSkirtLODIndex(i,nLODLevel);
					this._indexArrayBuffer.set(skirtLODIndex,nOffsetIndex);
					nOffsetIndex+=skirtLODIndex.length;
					this._currentNumberIndices+=(planeLODIndex.length+skirtLODIndex.length);
				}
				this._numberTriangle=this._currentNumberIndices / 3;
				return true;
			}
		}
		return false;
	}

	__proto.calcOriginalBoudingBoxAndSphere=function(){
		var sizeOfY=new Vector2(2147483647,-2147483647);
		for (var i=0;i < this._leafNum;i++){
			sizeOfY.x=this._leafs[i]._sizeOfY.x < sizeOfY.x ? this._leafs[i]._sizeOfY.x :sizeOfY.x;
			sizeOfY.y=this._leafs[i]._sizeOfY.y > sizeOfY.y ? this._leafs[i]._sizeOfY.y :sizeOfY.y;
		};
		var min=new Vector3(this._chunkOffsetX *TerrainLeaf.CHUNK_GRID_NUM *this._gridSize,sizeOfY.x,this._chunkOffsetZ *TerrainLeaf.CHUNK_GRID_NUM *this._gridSize);
		var max=new Vector3((this._chunkOffsetX+1)*TerrainLeaf.CHUNK_GRID_NUM *this._gridSize,sizeOfY.y,(this._chunkOffsetZ+1)*TerrainLeaf.CHUNK_GRID_NUM *this._gridSize);
		if (TerrainLeaf.__ADAPT_MATRIX__){
			Vector3.transformV3ToV3(min,TerrainLeaf.__ADAPT_MATRIX__,min);
			Vector3.transformV3ToV3(max,TerrainLeaf.__ADAPT_MATRIX__,max);
		}
		this._boundingBox=new BoundBox(min,max);
		var size=new Vector3();
		Vector3.subtract(max,min,size);
		Vector3.scale(size,0.5,size);
		var center=new Vector3();
		Vector3.add(min,size,center);
		this._boundingSphere=new BoundSphere(center,Vector3.scalarLength(size));
		this._boundingBoxCorners=__newvec(8,null);
		this._boundingBox.getCorners(this._boundingBoxCorners);
	}

	__proto.calcLeafBoudingBox=function(worldMatrix){
		for (var i=0;i < this._leafNum;i++){
			this._leafs[i].calcLeafBoudingBox(worldMatrix);
		}
	}

	__proto.calcLeafBoudingSphere=function(worldMatrix,maxScale){
		for (var i=0;i < this._leafNum;i++){
			this._leafs[i].calcLeafBoudingSphere(worldMatrix,maxScale);
		}
	}

	__proto._getVertexBuffer=function(index){
		(index===void 0)&& (index=0);
		if (index==0){
			return this._vertexBuffer;
		}
		return null;
	}

	__proto._getIndexBuffer=function(){
		return this._indexBuffer;
	}

	__proto._beforeRender=function(state){
		this._vertexBuffer._bind();
		this._indexBuffer._bind();
		var terrainMaterial=state.renderElement._material;
		if (terrainMaterial.blend==/*laya.d3.core.material.BaseMaterial.BLEND_DISABLE*/0){
			var camera=state.camera;
			if (this.assembleIndex(camera,camera.position)){
				this._indexBuffer.setData(this._indexArrayBuffer);
			}
		}
		return true;
	}

	/**
	*@private
	*/
	__proto._getVertexBuffers=function(){
		return null;
	}

	__proto._render=function(state){
		WebGL.mainContext.drawElements(Terrain.RENDER_LINE_MODEL ? /*laya.webgl.WebGLContext.LINES*/0x0001 :/*laya.webgl.WebGLContext.TRIANGLES*/0x0004,this._currentNumberIndices,/*laya.webgl.WebGLContext.UNSIGNED_SHORT*/0x1403,0);
		Stat.trianglesFaces+=this._numberTriangle;
		Stat.drawCall++;
	}

	/**
	*@inheritDoc
	*/
	__getset(0,__proto,'_originalBoundingSphere',function(){
		return this._boundingSphere;
	});

	/**
	*@inheritDoc
	*/
	__getset(0,__proto,'_originalBoundingBox',function(){
		return this._boundingBox;
	});

	__getset(0,__proto,'_vertexBufferCount',function(){
		return this._numberVertices;
	});

	__getset(0,__proto,'triangleCount',function(){
		return this._numberTriangle;
	});

	__static(TerrainFilter,
	['_TEMP_ARRAY_BUFFER',function(){return this._TEMP_ARRAY_BUFFER=new Uint32Array(TerrainLeaf.CHUNK_GRID_NUM / TerrainLeaf.LEAF_GRID_NUM *TerrainLeaf.CHUNK_GRID_NUM / TerrainLeaf.LEAF_GRID_NUM);}
	]);
	return TerrainFilter;
})(GeometryFilter)


/**
*<code>MeshRender</code> 类用于网格渲染器。
*/
//class laya.d3.terrain.TerrainRender extends laya.d3.core.render.BaseRender
var TerrainRender=(function(_super){
	function TerrainRender(owner){
		/**@private */
		this._terrainSprite3DOwner=null;
		TerrainRender.__super.call(this,owner);
		this._terrainSprite3DOwner=owner;
	}

	__class(TerrainRender,'laya.d3.terrain.TerrainRender',_super);
	var __proto=TerrainRender.prototype;
	__proto._calculateBoundingSphere=function(){
		var terrainFilter=this._terrainSprite3DOwner.terrainFilter;
		if (terrainFilter==null){
			this._boundingSphere.toDefault();
			}else {
			var meshBoundingSphere=terrainFilter._originalBoundingSphere;
			var maxScale=NaN;
			var transform=this._terrainSprite3DOwner.transform;
			var scale=transform.scale;
			if (scale.x >=scale.y && scale.x >=scale.z)
				maxScale=scale.x;
			else
			maxScale=scale.y >=scale.z ? scale.y :scale.z;
			Vector3.transformCoordinate(meshBoundingSphere.center,transform.worldMatrix,this._boundingSphere.center);
			this._boundingSphere.radius=meshBoundingSphere.radius *maxScale;
			terrainFilter.calcLeafBoudingSphere(transform.worldMatrix,maxScale);
		}
	}

	__proto._calculateBoundingBox=function(){
		var terrainFilter=this._terrainSprite3DOwner.terrainFilter;
		if (terrainFilter==null){
			this._boundingBox.toDefault();
			}else {
			var worldMat=this._terrainSprite3DOwner.transform.worldMatrix;
			var corners=terrainFilter._boundingBoxCorners;
			for (var i=0;i < 8;i++)
			Vector3.transformCoordinate(corners[i],worldMat,BaseRender._tempBoundBoxCorners[i]);
			BoundBox.createfromPoints(BaseRender._tempBoundBoxCorners,this._boundingBox);
			terrainFilter.calcLeafBoudingBox(worldMat);
		}
	}

	/**
	*@private
	*/
	__proto._renderUpdate=function(projectionView){
		this._setShaderValueMatrix4x4(/*laya.d3.core.Sprite3D.WORLDMATRIX*/0,this._owner.transform.worldMatrix);
		var projViewWorld=this._owner.getProjectionViewWorldMatrix(projectionView);
		this._setShaderValueMatrix4x4(/*laya.d3.core.Sprite3D.MVPMATRIX*/1,projViewWorld);
		return true;
	}

	/**
	*@private
	*/
	__proto._destroy=function(){
		_super.prototype._destroy.call(this);
		this._terrainSprite3DOwner=null;
	}

	return TerrainRender;
})(BaseRender)


/**
*<code>BaseScene</code> 类用于实现场景。
*/
//class laya.d3.core.scene.Scene extends laya.display.Sprite
var Scene=(function(_super){
	function Scene(){
		this._time=0;
		/**@private */
		//this.__loaded=false;
		/**@private */
		//this._url=null;
		/**@private */
		//this._group=null;
		/**@private */
		//this._lightmaps=null;
		/**@private */
		this._enableLightCount=3;
		/**@private */
		//this._renderTargetTexture=null;
		/**@private */
		this._customRenderQueneIndex=11;
		/**@private */
		//this._lastCurrentTime=NaN;
		/**@private */
		//this._enableFog=false;
		/**@private */
		//this._enableDepthFog=false;
		/**@private */
		//this._fogStart=NaN;
		/**@private */
		//this._fogRange=NaN;
		/**@private */
		//this._fogColor=null;
		/**@private */
		//this._ambientColor=null;
		/**@private */
		//this._shaderValues=null;
		/**@private */
		//this._shaderDefineValue=0;
		/**@private */
		//this._cullingRendersLength=0;
		/**@private */
		//this._cullingRenders=null;
		/**@private */
		//this._dynamicBatchManager=null;
		/**是否启用灯光。*/
		this.enableLight=true;
		/**四/八叉树的根节点。*/
		//this.treeRoot=null;
		/**四/八叉树的尺寸。*/
		//this.treeSize=null;
		/**四/八叉树的层数。*/
		//this.treeLevel=0;
		//阴影相关变量
		//this.parallelSplitShadowMaps=null;
		/**@private */
		//this._componentsMap=null;
		/**@private */
		//this._typeComponentsIndices=null;
		/**@private */
		//this._components=null;
		Scene.__super.call(this);
		this._renderState=new RenderState();
		this._lights=[];
		this._quenes=[];
		this._cameraPool=[];
		this._renderableSprite3Ds=[];
		this.__loaded=true;
		this._lightmaps=[];
		this._shaderValues=new ValusArray();
		this.parallelSplitShadowMaps=[];
		this._dynamicBatchManager=new DynamicBatchManager();
		this._cullingRenders=[];
		this._cullingRendersLength=0;
		this.enableFog=false;
		this.fogStart=300;
		this.fogRange=1000;
		this.fogColor=new Vector3(0.7,0.7,0.7);
		this.ambientColor=new Vector3(0.212,0.227,0.259);
		(WebGL.shaderHighPrecision)&& (this.addShaderDefine(ShaderCompile3D.SHADERDEFINE_HIGHPRECISION));
		this.on(/*laya.events.Event.DISPLAY*/"display",this,this._display);
		this.on(/*laya.events.Event.UNDISPLAY*/"undisplay",this,this._unDisplay);
		this._componentsMap=[];
		this._typeComponentsIndices=[];
		this._components=[];
	}

	__class(Scene,'laya.d3.core.scene.Scene',_super);
	var __proto=Scene.prototype;
	Laya.imps(__proto,{"laya.webgl.submit.ISubmit":true,"laya.resource.ICreateResource":true})
	/**
	*@private
	*/
	__proto._setUrl=function(url){
		this._url=url;
	}

	/**
	*@private
	*/
	__proto._getGroup=function(){
		return this._group;
	}

	/**
	*@private
	*/
	__proto._setGroup=function(value){
		this._group=value;
	}

	/**
	*@private
	*/
	__proto._display=function(){
		Laya.stage._scenes.push(this);
		Laya.stage._scenes.sort(Scene._sortScenes);
		for (var i=0,n=this._childs.length;i < n;i++){
			var spr=this._childs[i];
			(spr.active)&& (spr._activeHierarchy());
		}
	}

	/**
	*@private
	*/
	__proto._unDisplay=function(){
		var scenes=Laya.stage._scenes;
		scenes.splice(scenes.indexOf(this),1);
		for (var i=0,n=this._childs.length;i < n;i++){
			var spr=this._childs[i];
			(spr.active)&& (spr._inActiveHierarchy());
		}
	}

	/**
	*@private
	*/
	__proto._addChild3D=function(sprite3D){
		sprite3D.transform._onWorldTransform();
		sprite3D._setBelongScene(this);
		(this.displayedInStage && sprite3D.active)&& (sprite3D._activeHierarchy());
	}

	/**
	*@private
	*/
	__proto._removeChild3D=function(sprite3D){
		sprite3D.transform.parent=null;
		(this.displayedInStage && sprite3D.active)&& (sprite3D._inActiveHierarchy());
		sprite3D._setUnBelongScene();
	}

	/**
	*初始化八叉树。
	*@param width 八叉树宽度。
	*@param height 八叉树高度。
	*@param depth 八叉树深度。
	*@param center 八叉树中心点
	*@param level 八叉树层级。
	*/
	__proto.initOctree=function(width,height,depth,center,level){
		(level===void 0)&& (level=6);
		this.treeSize=new Vector3(width,height,depth);
		this.treeLevel=level;
		this.treeRoot=new OctreeNode(this,0);
		this.treeRoot.init(center,this.treeSize);
	}

	/**
	*@private
	*场景相关渲染准备设置。
	*@param gl WebGL上下文。
	*@return state 渲染状态。
	*/
	__proto._prepareUpdateToRenderState=function(gl,state){
		state.elapsedTime=this._lastCurrentTime ? this.timer.currTimer-this._lastCurrentTime :0;
		this._lastCurrentTime=this.timer.currTimer;
		state.scene=this;
	}

	/**
	*@private
	*/
	__proto._prepareSceneToRender=function(state){
		var lightCount=this._lights.length;
		if (lightCount > 0){
			var renderLightCount=0;
			for (var i=0;i < lightCount;i++){
				if (!this._lights[i]._prepareToScene(state))
					continue ;
				renderLightCount++;
				if (renderLightCount >=this._enableLightCount)
					break ;
			}
		}
	}

	/**
	*@private
	*/
	__proto._updateChilds=function(state){
		for (var i=0,n=this._childs.length;i < n;++i)
		this._childs[i]._update(state);
	}

	/**
	*@private
	*/
	__proto._preRenderScene=function(gl,state,boundFrustum){
		var view=state._viewMatrix;
		var projection=state._projectionMatrix;
		var projectionView=state._projectionViewMatrix;
		var i=0,iNum=0;
		var camera=state.camera;
		if (camera.useOcclusionCulling){
			if (this.treeRoot)
				FrustumCulling.renderObjectCullingOctree(boundFrustum,this,camera,view,projection,projectionView);
			else
			FrustumCulling.renderObjectCulling(boundFrustum,this,camera,view,projection,projectionView);
			}else {
			FrustumCulling.renderObjectCullingNoBoundFrustum(this,camera,view,projection,projectionView);
		}
		for (i=0,iNum=this._quenes.length;i < iNum;i++)
		(this._quenes[i])&& (this._quenes[i]._preRender(state));
	}

	/**
	*@private
	*/
	__proto._clear=function(gl,state){
		var viewport=state._viewport;
		var camera=state.camera;
		var vpX=viewport.x;
		var vpY=camera.renderTargetSize.height-viewport.y-viewport.height;
		var vpWidth=viewport.width;
		var vpHeight=viewport.height;
		gl.viewport(vpX,vpY,vpWidth,vpHeight);
		var flag=/*laya.webgl.WebGLContext.DEPTH_BUFFER_BIT*/0x00000100;
		var renderTarget=camera.renderTarget;
		switch (camera.clearFlag){
			case /*laya.d3.core.BaseCamera.CLEARFLAG_SOLIDCOLOR*/0:;
				var clearColor=camera.clearColor;
				if (clearColor){
					gl.enable(/*laya.webgl.WebGLContext.SCISSOR_TEST*/0x0C11);
					gl.scissor(vpX,vpY,vpWidth,vpHeight);
					var clearColorE=clearColor.elements;
					gl.clearColor(clearColorE[0],clearColorE[1],clearColorE[2],clearColorE[3]);
					flag |=/*laya.webgl.WebGLContext.COLOR_BUFFER_BIT*/0x00004000;
				}
				if (renderTarget){
					(clearColor)|| (flag=/*laya.webgl.WebGLContext.COLOR_BUFFER_BIT*/0x00004000);
				switch (renderTarget.depthStencilFormat){
					case /*laya.webgl.WebGLContext.DEPTH_COMPONENT16*/0x81A5:
						flag |=/*laya.webgl.WebGLContext.DEPTH_BUFFER_BIT*/0x00000100;
						break ;
					case /*laya.webgl.WebGLContext.STENCIL_INDEX8*/0x8D48:
						flag |=/*laya.webgl.WebGLContext.STENCIL_BUFFER_BIT*/0x00000400;
						break ;
					case /*laya.webgl.WebGLContext.DEPTH_STENCIL*/0x84F9:
						flag |=/*laya.webgl.WebGLContext.DEPTH_BUFFER_BIT*/0x00000100;
						flag |=/*laya.webgl.WebGLContext.STENCIL_BUFFER_BIT*/0x00000400;
						break ;
					}
			}
			gl.clear(flag);
			if (clearColor)
				gl.disable(/*laya.webgl.WebGLContext.SCISSOR_TEST*/0x0C11);
			break ;
			case /*laya.d3.core.BaseCamera.CLEARFLAG_SKY*/1:
			case /*laya.d3.core.BaseCamera.CLEARFLAG_DEPTHONLY*/2:
			if (renderTarget){
				flag=/*laya.webgl.WebGLContext.COLOR_BUFFER_BIT*/0x00004000;
				switch (renderTarget.depthStencilFormat){
					case /*laya.webgl.WebGLContext.DEPTH_COMPONENT16*/0x81A5:
						flag |=/*laya.webgl.WebGLContext.DEPTH_BUFFER_BIT*/0x00000100;
						break ;
					case /*laya.webgl.WebGLContext.STENCIL_INDEX8*/0x8D48:
						flag |=/*laya.webgl.WebGLContext.STENCIL_BUFFER_BIT*/0x00000400;
						break ;
					case /*laya.webgl.WebGLContext.DEPTH_STENCIL*/0x84F9:
						flag |=/*laya.webgl.WebGLContext.DEPTH_BUFFER_BIT*/0x00000100;
						flag |=/*laya.webgl.WebGLContext.STENCIL_BUFFER_BIT*/0x00000400
						break ;
					}
			}
			gl.clear(flag);
			break ;
			case /*laya.d3.core.BaseCamera.CLEARFLAG_NONE*/3:
			break ;
			default :
			throw new Error("BaseScene:camera clearFlag invalid.");
		}
	}

	/**
	*@private
	*/
	__proto._renderScene=function(gl,state){
		var camera=state.camera;
		var i=0,n=0;
		var queue;
		for (i=0;i < 2;i++){
			queue=this._quenes[i];
			if (queue){
				camera.renderTarget ? queue._render(state,true):queue._render(state,false);
			}
		}
		if (camera.clearFlag===/*laya.d3.core.BaseCamera.CLEARFLAG_SKY*/1){
			var sky=camera.sky;
			if (sky){
				WebGLContext.setCullFace(gl,false);
				WebGLContext.setDepthFunc(gl,/*laya.webgl.WebGLContext.LEQUAL*/0x0203);
				WebGLContext.setDepthMask(gl,false);
				sky._render(state);
				WebGLContext.setDepthFunc(gl,/*laya.webgl.WebGLContext.LESS*/0x0201);
				WebGLContext.setDepthMask(gl,true);
			}
		}
		for (i=2,n=this._quenes.length;i < n;i++){
			queue=this._quenes[i];
			if (queue){
				queue._sortAlpha(state.camera.transform.position);
				camera.renderTarget ? queue._render(state,true):queue._render(state,false);
			}
		}
	}

	/**
	*@private
	*/
	__proto._set3DRenderConfig=function(gl){
		gl.disable(/*laya.webgl.WebGLContext.BLEND*/0x0BE2);
		WebGLContext._blend=false;
		gl.blendFunc(/*laya.webgl.WebGLContext.SRC_ALPHA*/0x0302,/*laya.webgl.WebGLContext.ONE_MINUS_SRC_ALPHA*/0x0303);
		WebGLContext._sFactor=/*laya.webgl.WebGLContext.SRC_ALPHA*/0x0302;
		WebGLContext._dFactor=/*laya.webgl.WebGLContext.ONE_MINUS_SRC_ALPHA*/0x0303;
		gl.disable(/*laya.webgl.WebGLContext.DEPTH_TEST*/0x0B71);
		WebGLContext._depthTest=false;
		gl.enable(/*laya.webgl.WebGLContext.CULL_FACE*/0x0B44);
		WebGLContext._cullFace=true;
		gl.depthMask(1);
		WebGLContext._depthMask=true;
		gl.frontFace(/*laya.webgl.WebGLContext.CW*/0x0900);
		WebGLContext._frontFace=/*laya.webgl.WebGLContext.CW*/0x0900;
	}

	/**
	*@private
	*/
	__proto._set2DRenderConfig=function(gl){
		WebGLContext.setBlend(gl,true);
		WebGLContext.setBlendFunc(gl,/*laya.webgl.WebGLContext.ONE*/1,/*laya.webgl.WebGLContext.ONE_MINUS_SRC_ALPHA*/0x0303);
		WebGLContext.setDepthTest(gl,false);
		WebGLContext.setCullFace(gl,false);
		WebGLContext.setDepthMask(gl,true);
		WebGLContext.setFrontFace(gl,/*laya.webgl.WebGLContext.CCW*/0x0901);
		gl.viewport(0,0,RenderState2D.width,RenderState2D.height);
	}

	/**
	*@private
	*/
	__proto._parseCustomProps=function(rootNode,innerResouMap,customProps,nodeData){
		var lightMapsData=nodeData.customProps.lightmaps;
		var lightMapCount=lightMapsData.length;
		var lightmaps=this._lightmaps;
		lightmaps.length=lightMapCount;
		for (var i=0;i < lightMapCount;i++)
		lightmaps[i]=Loader.getRes(innerResouMap[lightMapsData[i].replace(".exr",".png")]);
		this.setlightmaps(lightmaps);
		var ambientColorData=nodeData.customProps.ambientColor;
		(ambientColorData)&& (this.ambientColor=new Vector3(ambientColorData[0],ambientColorData[1],ambientColorData[2]));
		var fogColorData=nodeData.customProps.fogColor;
		(fogColorData)&& (this.fogColor=new Vector3(fogColorData[0],fogColorData[1],fogColorData[2]));
	}

	/**
	*@private
	*/
	__proto._addLight=function(light){
		if (this._lights.indexOf(light)< 0)this._lights.push(light);
	}

	/**
	*@private
	*/
	__proto._removeLight=function(light){
		var index=this._lights.indexOf(light);
		index >=0 && (this._lights.splice(index,1));
	}

	/**
	*@private
	*/
	__proto._updateScene=function(){
		var renderState=this._renderState;
		this._prepareUpdateToRenderState(WebGL.mainContext,renderState);
		this._updateComponents(renderState);
		this._updateChilds(renderState);
		this._lateUpdateComponents(renderState);
		this._time+=renderState.elapsedTime / 1000;
		this._shaderValues.setValue(/*CLASS CONST:laya.d3.core.scene.Scene.TIME*/22,this._time);
	}

	/**
	*@private
	*/
	__proto._updateSceneConch=function(){
		var renderState=this._renderState;
		this._prepareUpdateToRenderState(WebGL.mainContext,renderState);
		this._updateComponents(renderState);
		this._lateUpdateComponents(renderState);
		this._prepareSceneToRender(renderState);
		for (var i=0,n=this._cameraPool.length;i < n;i++){
			var camera=this._cameraPool[i];
			renderState.camera=camera;
			camera._prepareCameraToRender();
		}
	}

	/**
	*@private
	*/
	__proto._preRenderShadow=function(state,lightFrustum,shdowQueues,lightViewProjectMatrix,nPSSMNum){
		if (this.treeRoot){
			FrustumCulling.renderShadowObjectCullingOctree(this,lightFrustum,shdowQueues,lightViewProjectMatrix,nPSSMNum);
			}else {
			FrustumCulling.renderShadowObjectCulling(this,lightFrustum,shdowQueues,lightViewProjectMatrix,nPSSMNum);
		}
		for (var i=0,iNum=shdowQueues.length;i < iNum;i++)
		(shdowQueues[i])&& (shdowQueues[i]._preRender(state));
	}

	/**
	*@private
	*/
	__proto._renderShadowMap=function(gl,state,sceneCamera){
		var parallelSplitShadowMap=this.parallelSplitShadowMaps[0];
		parallelSplitShadowMap._calcAllLightCameraInfo(sceneCamera);
		var pssmNum=parallelSplitShadowMap.PSSMNum;
		this._preRenderShadow(state,parallelSplitShadowMap._lightCulling,parallelSplitShadowMap._shadowQuenes,parallelSplitShadowMap._lightVPMatrix[0],pssmNum);
		this.addShaderDefine(ParallelSplitShadowMap.SHADERDEFINE_CAST_SHADOW);
		var renderTarget,shadowQuene,lightCamera;
		if (pssmNum > 1){
			for (var i=0;i < pssmNum;i++){
				renderTarget=parallelSplitShadowMap.getRenderTarget(i+1);
				parallelSplitShadowMap.beginRenderTarget(i+1);
				gl.clearColor(1,1,1,1);
				gl.clear(/*laya.webgl.WebGLContext.COLOR_BUFFER_BIT*/0x00004000 | /*laya.webgl.WebGLContext.DEPTH_BUFFER_BIT*/0x00000100);
				gl.viewport(0,0,renderTarget.width,renderTarget.height);
				state.camera=lightCamera=parallelSplitShadowMap.getLightCamera(i);
				lightCamera._prepareCameraToRender();
				lightCamera._prepareCameraViewProject(lightCamera.viewMatrix,lightCamera.projectionMatrix);
				state._projectionViewMatrix=parallelSplitShadowMap._lightVPMatrix[i+1];
				shadowQuene=parallelSplitShadowMap._shadowQuenes[i];
				shadowQuene._preRender(state);
				shadowQuene._renderShadow(state,false);
				parallelSplitShadowMap.endRenderTarget(i+1);
			}
			}else {
			renderTarget=parallelSplitShadowMap.getRenderTarget(1);
			parallelSplitShadowMap.beginRenderTarget(1);
			gl.clearColor(1,1,1,1);
			gl.clear(/*laya.webgl.WebGLContext.COLOR_BUFFER_BIT*/0x00004000 | /*laya.webgl.WebGLContext.DEPTH_BUFFER_BIT*/0x00000100);
			gl.viewport(0,0,renderTarget.width,renderTarget.height);
			state.camera=lightCamera=parallelSplitShadowMap.getLightCamera(0);
			lightCamera._prepareCameraToRender();
			lightCamera._prepareCameraViewProject(lightCamera.viewMatrix,lightCamera.projectionMatrix);
			state._projectionViewMatrix=parallelSplitShadowMap._lightVPMatrix[0];
			shadowQuene=parallelSplitShadowMap._shadowQuenes[0];
			shadowQuene._preRender(state);
			shadowQuene._renderShadow(state,true);
			parallelSplitShadowMap.endRenderTarget(1);
		}
		this.removeShaderDefine(ParallelSplitShadowMap.SHADERDEFINE_CAST_SHADOW);
	}

	/**
	*@private
	*/
	__proto.addTreeNode=function(renderObj){
		this.treeRoot.addTreeNode(renderObj);
	}

	/**
	*@private
	*/
	__proto.removeTreeNode=function(renderObj){
		if (!this.treeSize)return;
		if (renderObj._treeNode){
			renderObj._treeNode.removeObject(renderObj);
		}
	}

	/**
	*设置光照贴图。
	*@param value 光照贴图。
	*/
	__proto.setlightmaps=function(value){
		this._lightmaps=value;
		for (var i=0,n=this._renderableSprite3Ds.length;i < n;i++)
		this._renderableSprite3Ds[i]._render._applyLightMapParams();
	}

	/**
	*获取光照贴图。
	*@return 获取光照贴图。
	*/
	__proto.getlightmaps=function(){
		return this._lightmaps;
	}

	/**
	*@inheritDoc
	*/
	__proto.addChildAt=function(node,index){
		if (!((node instanceof laya.d3.core.Sprite3D )))
			throw new Error("Sprite3D:Node type must Sprite3D.");
		if (!node || this.destroyed || node===this)return node;
		if ((node).zOrder)this._set$P("hasZorder",true);
		if (index >=0 && index <=this._childs.length){
			if (node._parent===this){
				var oldIndex=this.getChildIndex(node);
				this._childs.splice(oldIndex,1);
				this._childs.splice(index,0,node);
				if (this.conchModel){
					this.conchModel.removeChild(node.conchModel);
					this.conchModel.addChildAt(node.conchModel,index);
				}
				this._childChanged();
				}else {
				node.parent && node.parent.removeChild(node);
				this._childs===Node.ARRAY_EMPTY && (this._childs=[]);
				this._childs.splice(index,0,node);
				this.conchModel && this.conchModel.addChildAt(node.conchModel,index);
				node.parent=this;
				this._addChild3D(node);
			}
			return node;
			}else {
			throw new Error("appendChildAt:The index is out of bounds");
		}
	}

	/**
	*@inheritDoc
	*/
	__proto.addChild=function(node){
		if (!((node instanceof laya.d3.core.Sprite3D )))
			throw new Error("Sprite3D:Node type must Sprite3D.");
		if (!node || this.destroyed || node===this)return node;
		if ((node).zOrder)this._set$P("hasZorder",true);
		if (node._parent===this){
			var index=this.getChildIndex(node);
			if (index!==this._childs.length-1){
				this._childs.splice(index,1);
				this._childs.push(node);
				if (this.conchModel){
					this.conchModel.removeChild(node.conchModel);
					this.conchModel.addChildAt(node.conchModel,this._childs.length-1);
				}
				this._childChanged();
			}
			}else {
			node.parent && node.parent.removeChild(node);
			this._childs===Node.ARRAY_EMPTY && (this._childs=[]);
			this._childs.push(node);
			this.conchModel && this.conchModel.addChildAt(node.conchModel,this._childs.length-1);
			node.parent=this;
			this._childChanged();
			this._addChild3D(node);
		}
		return node;
	}

	/**
	*@inheritDoc
	*/
	__proto.removeChildAt=function(index){
		var node=this.getChildAt(index);
		if (node){
			this._removeChild3D(node);
			this._childs.splice(index,1);
			this.conchModel && this.conchModel.removeChild(node.conchModel);
			node.parent=null;
		}
		return node;
	}

	/**
	*@inheritDoc
	*/
	__proto.removeChildren=function(beginIndex,endIndex){
		(beginIndex===void 0)&& (beginIndex=0);
		(endIndex===void 0)&& (endIndex=0x7fffffff);
		if (this._childs && this._childs.length > 0){
			var childs=this._childs;
			if (beginIndex===0 && endIndex >=n){
				var arr=childs;
				this._childs=Node.ARRAY_EMPTY;
				}else {
				arr=childs.splice(beginIndex,endIndex-beginIndex);
			}
			for (var i=0,n=arr.length;i < n;i++){
				this._removeChild3D(arr [i]);
				arr[i].parent=null;
				this.conchModel && this.conchModel.removeChild(arr[i].conchModel);
			}
		}
		return this;
	}

	/**
	*@inheritDoc
	*/
	__proto.addFrustumCullingObject=function(renderObject){
		if (this.treeRoot){
			this.addTreeNode(renderObject);
			}else {
			if (this._cullingRendersLength===this._cullingRenders.length)
				this._cullingRenders.push(renderObject);
			else
			this._cullingRenders[this._cullingRendersLength]=renderObject;
			renderObject._indexInSceneFrustumCullingObjects=this._cullingRendersLength++;
		}
	}

	/**
	*@private
	*/
	__proto.removeFrustumCullingObject=function(renderObject){
		if (this.treeRoot){
			this.removeTreeNode(renderObject);
			}else {
			this._cullingRendersLength--;
			var indexInSceneFrustumCullingObjects=renderObject._indexInSceneFrustumCullingObjects;
			if (indexInSceneFrustumCullingObjects!==this._cullingRendersLength){
				var endRender=this._cullingRenders[this._cullingRendersLength];
				this._cullingRenders[indexInSceneFrustumCullingObjects]=endRender;
				endRender._indexInSceneFrustumCullingObjects=indexInSceneFrustumCullingObjects;
				renderObject._indexInSceneFrustumCullingObjects=-1;
			}
		}
	}

	/**
	*获得某个渲染队列。
	*@param index 渲染队列索引。
	*@return 渲染队列。
	*/
	__proto.getRenderQueue=function(index){
		if (index < 3000)
			return this._quenes[1] || (this._quenes[1]=new RenderQueue(this));
		else
		return this._quenes[2] || (this._quenes[2]=new RenderQueue(this));
	}

	/**
	*添加渲染队列。
	*@param renderConfig 渲染队列配置文件。
	*/
	__proto.addRenderQuene=function(){
		this._quenes[this._customRenderQueneIndex++]=new RenderQueue(this);
	}

	/**
	*增加shader宏定义。
	*@param define shader宏定义。
	*/
	__proto.addShaderDefine=function(define){
		this._shaderDefineValue |=define;
	}

	/**
	*移除shader宏定义。
	*@param define shader宏定义。
	*/
	__proto.removeShaderDefine=function(define){
		this._shaderDefineValue &=~define;
	}

	/**
	*添加指定类型脚本。
	*@param type 脚本类型。
	*@return 组件。
	*/
	__proto.addScript=function(type){
		return this._addComponent(type);
	}

	/**
	*通过指定类型和类型索引获得脚本。
	*@param type 脚本类型。
	*@param typeIndex 脚本索引。
	*@return 脚本。
	*/
	__proto.getScriptByType=function(type,typeIndex){
		(typeIndex===void 0)&& (typeIndex=0);
		return this._getComponentByType(type,typeIndex);
	}

	/**
	*通过指定类型获得所有脚本。
	*@param type 脚本类型。
	*@param scripts 脚本输出队列。
	*/
	__proto.getScriptsByType=function(type,scripts){
		this._getComponentsByType(type,scripts);
	}

	/**
	*通过指定索引获得脚本。
	*@param index 索引。
	*@return 脚本。
	*/
	__proto.getScriptByIndex=function(index){
		return this._getComponentByIndex(index);
	}

	/**
	*通过指定类型和类型索引移除脚本。
	*@param type 脚本类型。
	*@param typeIndex 类型索引。
	*/
	__proto.removeScriptByType=function(type,typeIndex){
		(typeIndex===void 0)&& (typeIndex=0);
		this._removeComponentByType(type,typeIndex);
	}

	/**
	*通过指定类型移除所有脚本。
	*@param type 组件类型。
	*/
	__proto.removeScriptsByType=function(type){
		this._removeComponentByType(type);
	}

	/**
	*移除全部脚本。
	*/
	__proto.removeAllScript=function(){
		this._removeAllComponent();
	}

	/**
	*@private
	*/
	__proto.render=function(context,x,y){
		(Render._context.ctx)._renderKey=0;
		this._childs.length > 0 && context.addRenderObject(this);
	}

	/**
	*@private
	*/
	__proto.renderSubmit=function(){
		var gl=WebGL.mainContext;
		var renderState=this._renderState;
		this._set3DRenderConfig(gl);
		this._prepareSceneToRender(this._renderState);
		var i=0,n=0,camera;
		if (Laya3D.debugMode || OctreeNode.debugMode){
			for (i=0,n=this._cameraPool.length;i < n;i++){
				camera=this._cameraPool[i];
				Laya3D._debugPhasorSprite.begin(/*laya.webgl.WebGLContext.LINES*/0x0001,camera);
				(camera.activeInHierarchy)&& (camera._renderCamera(gl,renderState,this));
				Laya3D._debugPhasorSprite.end();
			}
			}else {
			for (i=0,n=this._cameraPool.length;i < n;i++){
				camera=this._cameraPool[i];
				(camera.activeInHierarchy)&& (camera._renderCamera(gl,renderState,this));
			}
		}
		this._set2DRenderConfig(gl);
		return 1;
	}

	/**
	*@private
	*/
	__proto.onAsynLoaded=function(url,data,params){
		var json=data[0]
		if (json.type!=="Scene")
			throw new Error("Scene: the .lh file root type must be Scene,please use other function to  load  this file.");
		var innerResouMap=data[1];
		Utils3D._createNodeByJson(this,json,this,innerResouMap);
		this.event(/*laya.events.Event.HIERARCHY_LOADED*/"hierarchyloaded",[this]);
		this.__loaded=true;
	}

	/**
	*@private
	*/
	__proto.destroy=function(destroyChild){
		(destroyChild===void 0)&& (destroyChild=true);
		if (this.destroyed)
			return;
		_super.prototype.destroy.call(this,destroyChild);
		this._renderState=null;
		this._lights=null;
		this._lightmaps=null;
		this._renderTargetTexture=null;
		this._shaderValues=null;
		this._cullingRenders=null;
		this._dynamicBatchManager=null;
		this._quenes=null;
		this._cameraPool=null;
		this._renderableSprite3Ds=null;
		this.treeRoot=null;
		this.treeSize=null;
		this.parallelSplitShadowMaps=null;
		this._typeComponentsIndices=null;
		this._components=null;
		Loader.clearRes(this.url);
		(this.loaded)|| (Laya3D._cancelLoadByUrl(this.url));
	}

	/**
	*@private
	*/
	__proto.getRenderType=function(){
		return 0;
	}

	/**
	*@private
	*/
	__proto.releaseRender=function(){}
	/**
	*@private
	*/
	__proto._addComponent=function(type){
		var typeComponentIndex;
		var index=this._componentsMap.indexOf(type);
		if (index===-1){
			typeComponentIndex=[];
			this._componentsMap.push(type);
			this._typeComponentsIndices.push(typeComponentIndex);
			}else {
			typeComponentIndex=this._typeComponentsIndices[index];
			if (this._components[typeComponentIndex[0]].isSingleton)
				throw new Error("无法单实例创建"+type+"组件"+"，"+type+"组件已存在！");
		};
		var component=ClassUtils.getInstance(type);
		typeComponentIndex.push(this._components.length);
		this._components.push(component);
		var _this=this;
		component._initialize(_this);
		return component;
	}

	/**
	*@private
	*/
	__proto._removeComponent=function(mapIndex,index){
		var componentIndices=this._typeComponentsIndices[mapIndex];
		var componentIndex=componentIndices[index];
		var component=this._components[componentIndex];
		this._components.splice(componentIndex,1);
		componentIndices.splice(index,1);
		(componentIndices.length===0)&& (this._typeComponentsIndices.splice(mapIndex,1),this._componentsMap.splice(mapIndex,1));
		for (var i=0,n=this._componentsMap.length;i < n;i++){
			componentIndices=this._typeComponentsIndices[i];
			for (var j=componentIndices.length-1;j >=0;j--){
				var oldComponentIndex=componentIndices[j];
				if (oldComponentIndex > componentIndex)
					componentIndices[j]=--oldComponentIndex;
				else
				break ;
			}
		}
		component._destroy();
	}

	/**
	*@private
	*/
	__proto._getComponentByType=function(type,typeIndex){
		(typeIndex===void 0)&& (typeIndex=0);
		var mapIndex=this._componentsMap.indexOf(type);
		if (mapIndex===-1)
			return null;
		return this._components[this._typeComponentsIndices[mapIndex][typeIndex]];
	}

	/**
	*@private
	*/
	__proto._getComponentsByType=function(type,components){
		var index=this._componentsMap.indexOf(type);
		if (index===-1){
			components.length=0;
			return;
		};
		var typeComponents=this._typeComponentsIndices[index];
		var count=typeComponents.length;
		components.length=count;
		for (var i=0;i < count;i++)
		components[i]=this._components[typeComponents[i]];
	}

	/**
	*@private
	*/
	__proto._getComponentByIndex=function(index){
		return this._components[index];
	}

	/**
	*@private
	*/
	__proto._removeComponentByType=function(type,typeIndex){
		(typeIndex===void 0)&& (typeIndex=0);
		var mapIndex=this._componentsMap.indexOf(type);
		if (mapIndex===-1)
			return;
		this._removeComponent(mapIndex,typeIndex);
	}

	/**
	*@private
	*/
	__proto._removeComponentsByType=function(type){
		var mapIndex=this._componentsMap.indexOf(type);
		if (mapIndex===-1)
			return;
		var componentIndices=this._typeComponentsIndices[mapIndex];
		for (var i=0,n=componentIndices.length;i < n;componentIndices.length < n ? n--:i++)
		this._removeComponent(mapIndex,i);
	}

	/**
	*@private
	*/
	__proto._removeAllComponent=function(){
		for (var i=0,n=this._componentsMap.length;i < n;this._componentsMap.length < n ? n--:i++)
		this._removeComponentsByType(this._componentsMap[i]);
	}

	/**
	*@private
	*/
	__proto._updateComponents=function(state){
		for (var i=0,n=this._components.length;i < n;i++){
			var component=this._components[i];
			(!component.started)&& (component._start(state),component.started=true);
			(component.enable)&& (component._update(state));
		}
	}

	/**
	*@private
	*/
	__proto._lateUpdateComponents=function(state){
		for (var i=0;i < this._components.length;i++){
			var component=this._components[i];
			(!component.started)&& (component._start(state),component.started=true);
			(component.enable)&& (component._lateUpdate(state));
		}
	}

	/**
	*@private
	*/
	__proto._preRenderUpdateComponents=function(state){
		for (var i=0;i < this._components.length;i++){
			var component=this._components[i];
			(!component.started)&& (component._start(state),component.started=true);
			(component.enable)&& (component._preRenderUpdate(state));
		}
	}

	/**
	*@private
	*/
	__proto._postRenderUpdateComponents=function(state){
		for (var i=0;i < this._components.length;i++){
			var component=this._components[i];
			(!component.started)&& (component._start(state),component.started=true);
			(component.enable)&& (component._postRenderUpdate(state));
		}
	}

	/**
	*@private
	*/
	__getset(0,__proto,'_loaded',null,function(value){
		this.__loaded=value;
	});

	/**
	*设置雾化颜色。
	*@param value 雾化颜色。
	*/
	/**
	*获取雾化颜色。
	*@return 雾化颜色。
	*/
	__getset(0,__proto,'fogColor',function(){
		return this._fogColor;
		},function(value){
		this._fogColor=value;
		this._shaderValues.setValue(/*CLASS CONST:laya.d3.core.scene.Scene.FOGCOLOR*/0,value.elements);
	});

	/**
	*设置是否允许雾化。
	*@param value 是否允许雾化。
	*/
	/**
	*获取是否允许雾化。
	*@return 是否允许雾化。
	*/
	__getset(0,__proto,'enableFog',function(){
		return this._enableFog;
		},function(value){
		if (this._enableFog!==value){
			this._enableFog=value;
			if (value){
				this.addShaderDefine(ShaderCompile3D.SHADERDEFINE_FOG);
				this.removeShaderDefine(ShaderCompile3D.SAHDERDEFINE_DEPTHFOG);
			}else
			this.removeShaderDefine(ShaderCompile3D.SHADERDEFINE_FOG);
		}
	});

	/**
	*获取资源的URL地址。
	*@return URL地址。
	*/
	__getset(0,__proto,'url',function(){
		return this._url;
	});

	/**
	*获取是否已加载完成。
	*/
	__getset(0,__proto,'loaded',function(){
		return this.__loaded;
	});

	__getset(0,__proto,'enableDepthFog',function(){
		return this._enableDepthFog;
		},function(v){
		if (this._enableDepthFog !=v){
			this._enableDepthFog=v;
			if (v){
				this.addShaderDefine(ShaderCompile3D.SAHDERDEFINE_DEPTHFOG);
				this.removeShaderDefine(ShaderCompile3D.SHADERDEFINE_FOG);
				}else {
				this.removeShaderDefine(ShaderCompile3D.SAHDERDEFINE_DEPTHFOG);
			}
		}
	});

	/**
	*设置雾化起始位置。
	*@param value 雾化起始位置。
	*/
	/**
	*获取雾化起始位置。
	*@return 雾化起始位置。
	*/
	__getset(0,__proto,'fogStart',function(){
		return this._fogStart;
		},function(value){
		this._fogStart=value;
		this._shaderValues.setValue(/*CLASS CONST:laya.d3.core.scene.Scene.FOGSTART*/1,value);
	});

	/**
	*设置雾化范围。
	*@param value 雾化范围。
	*/
	/**
	*获取雾化范围。
	*@return 雾化范围。
	*/
	__getset(0,__proto,'fogRange',function(){
		return this._fogRange;
		},function(value){
		this._fogRange=value;
		this._shaderValues.setValue(/*CLASS CONST:laya.d3.core.scene.Scene.FOGRANGE*/2,value);
	});

	/**
	*设置环境光颜色。
	*@param value 环境光颜色。
	*/
	/**
	*获取环境光颜色。
	*@return 环境光颜色。
	*/
	__getset(0,__proto,'ambientColor',function(){
		return this._ambientColor;
		},function(value){
		this._ambientColor=value;
		this._shaderValues.setValue(/*CLASS CONST:laya.d3.core.scene.Scene.AMBIENTCOLOR*/21,value.elements);
	});

	/**
	*获取当前场景。
	*@return 当前场景。
	*/
	__getset(0,__proto,'scene',function(){
		return this;
	});

	/**
	*获取场景的可渲染精灵。
	*/
	__getset(0,__proto,'renderableSprite3Ds',function(){
		return this._renderableSprite3Ds.slice();
	});

	Scene._sortScenes=function(a,b){
		if (a.parent===Laya.stage && b.parent===Laya.stage){
			var stageChildren=Laya.stage._childs;
			return stageChildren.indexOf(a)-stageChildren.indexOf(b);
			}else if (a.parent!==Laya.stage && b.parent!==Laya.stage){
			return Scene._sortScenes(a.parent,b.parent);
			}else {
			return (a.parent===Laya.stage)?-1 :1;
		}
	}

	Scene.load=function(url){
		return Laya.loader.create(url,null,null,Scene);
	}

	Scene.FOGCOLOR=0;
	Scene.FOGSTART=1;
	Scene.FOGRANGE=2;
	Scene.LIGHTDIRECTION=3;
	Scene.LIGHTDIRCOLOR=4;
	Scene.POINTLIGHTPOS=5;
	Scene.POINTLIGHTRANGE=6;
	Scene.POINTLIGHTATTENUATION=7;
	Scene.POINTLIGHTCOLOR=8;
	Scene.SPOTLIGHTPOS=9;
	Scene.SPOTLIGHTDIRECTION=10;
	Scene.SPOTLIGHTSPOT=11;
	Scene.SPOTLIGHTRANGE=12;
	Scene.SPOTLIGHTATTENUATION=13;
	Scene.SPOTLIGHTCOLOR=14;
	Scene.SHADOWDISTANCE=15;
	Scene.SHADOWLIGHTVIEWPROJECT=16;
	Scene.SHADOWMAPPCFOFFSET=17;
	Scene.SHADOWMAPTEXTURE1=18;
	Scene.SHADOWMAPTEXTURE2=19;
	Scene.SHADOWMAPTEXTURE3=20;
	Scene.AMBIENTCOLOR=21;
	Scene.TIME=22;
	return Scene;
})(Sprite)


/**
*<code>Sprite3D</code> 类用于实现3D精灵。
*/
//class laya.d3.core.Sprite3D extends laya.d3.core.ComponentNode
var Sprite3D=(function(_super){
	function Sprite3D(name){
		/**@private */
		//this._projectionViewWorldMatrix=null;
		/**@private */
		//this._projectionViewWorldUpdateLoopCount=0;
		/**@private */
		//this._projectionViewWorldUpdateCamera=null;
		/**@private */
		//this._id=0;
		/**@private */
		//this.__loaded=false;
		/**@private */
		//this._url=null;
		/**@private */
		//this._group=null;
		/**@private */
		//this._active=false;
		/**@private */
		//this._activeInHierarchy=false;
		/**@private */
		//this._layer=null;
		/**@private */
		//this._shaderDefineValue=0;
		/**@private */
		//this._shaderValues=null;
		/**@private */
		//this._colliders=null;
		/**@private */
		//this._scene=null;
		/**@private */
		//this._transform=null;
		/**@private */
		//this._hierarchyAnimator=null;
		/**是否静态,静态包含一系列的静态处理。*/
		//this.isStatic=false;
		Sprite3D.__super.call(this);
		this.__loaded=true;
		this._projectionViewWorldUpdateLoopCount=-1;
		this._activeInHierarchy=false;
		this._projectionViewWorldMatrix=new Matrix4x4();
		this._shaderValues=new ValusArray();
		this._colliders=[];
		this._id=++Sprite3D._uniqueIDCounter;
		this._transform=new Transform3D(this);
		this.name=name ? name :"Sprite3D-"+Sprite3D._nameNumberCounter++;
		this.layer=Layer.currentCreationLayer;
		this.active=true;
	}

	__class(Sprite3D,'laya.d3.core.Sprite3D',_super);
	var __proto=Sprite3D.prototype;
	Laya.imps(__proto,{"laya.d3.core.render.IUpdate":true,"laya.resource.ICreateResource":true,"laya.d3.core.IClone":true})
	/**
	*@private
	*/
	__proto._setUrl=function(url){
		this._url=url;
	}

	/**
	*@private
	*/
	__proto._getGroup=function(){
		return this._group;
	}

	/**
	*@private
	*/
	__proto._setGroup=function(value){
		this._group=value;
	}

	/**
	*@private
	*/
	__proto._addChild3D=function(sprite3D){
		sprite3D.transform.parent=this.transform;
		if (this._hierarchyAnimator){
			(!sprite3D._hierarchyAnimator)&& (sprite3D._setHierarchyAnimator(this._hierarchyAnimator,null));
			this._getAnimatorToLinkSprite3D(sprite3D,true,/*new vector.<>*/[sprite3D.name]);
		}
		if (this._scene){
			sprite3D._setBelongScene(this._scene);
			(this._activeInHierarchy && sprite3D._active)&& (sprite3D._activeHierarchy());
		}
	}

	/**
	*@private
	*/
	__proto._removeChild3D=function(sprite3D){
		sprite3D.transform.parent=null;
		if (this._scene){
			(this._activeInHierarchy && sprite3D._active)&& (sprite3D._inActiveHierarchy());
			sprite3D._setUnBelongScene();
		}
		if (this._hierarchyAnimator){
			((sprite3D._hierarchyAnimator==this._hierarchyAnimator))&& (sprite3D._clearHierarchyAnimator(this._hierarchyAnimator,null));
			this._getAnimatorToLinkSprite3D(sprite3D,false,/*new vector.<>*/[sprite3D.name]);
		}
	}

	/**
	*@private
	*/
	__proto._parseBaseCustomProps=function(customProps){
		var loccalPosition=this.transform.localPosition;
		loccalPosition.fromArray(customProps.translate);
		this.transform.localPosition=loccalPosition;
		var localRotation=this.transform.localRotation;
		localRotation.fromArray(customProps.rotation);
		this.transform.localRotation=localRotation;
		var localScale=this.transform.localScale;
		localScale.fromArray(customProps.scale);
		this.transform.localScale=localScale;
		var layerData=customProps.layer;
		(layerData !=null)&& (this.layer=Layer.getLayerByNumber(layerData));
	}

	/**
	*@private
	*/
	__proto._parseCustomComponent=function(rootNode,innerResouMap,componentsData){
		for (var k in componentsData){
			var component=componentsData[k];
			switch (k){
				case "Animator":;
					var animator=this.addComponent(Animator);
					if (component.avatarPath){
						animator.avatar=Loader.getRes(innerResouMap[component.avatarPath]);
						}else {
						var avatarData=component.avatar;
						if (avatarData){
							animator.avatar=Loader.getRes(innerResouMap[avatarData.path]);
							var linkSprites=avatarData.linkSprites;
							(linkSprites)&& (rootNode.once(/*laya.events.Event.HIERARCHY_LOADED*/"hierarchyloaded",this,this._onRootNodeHierarchyLoaded,[animator,linkSprites]));
						}
					};
					var clipPaths=component.clipPaths;
					var clipCount=clipPaths.length;
					for (var i=0;i < clipCount;i++)
					animator.addClip(Loader.getRes(innerResouMap[clipPaths[i]]));
					animator.clip=Loader.getRes(innerResouMap[clipPaths[0]]);
					var playOnWake=component.playOnWake;
					(playOnWake!==undefined)&& (animator.playOnWake=playOnWake);
					break ;
				case "Rigidbody":;
					var rigidbody=this.addComponent(Rigidbody);
					break ;
				case "SphereCollider":;
					var sphereCollider=this.addComponent(SphereCollider);
					sphereCollider.isTrigger=component.isTrigger;
					var center=sphereCollider.center;
					center.fromArray(component.center);
					sphereCollider.center=center;
					sphereCollider.radius=component.radius;
					break ;
				case "BoxCollider":;
					var boxCollider=this.addComponent(BoxCollider);
					boxCollider.isTrigger=component.isTrigger;
					boxCollider.center.fromArray(component.center);
					var size=boxCollider.size;
					size.fromArray(component.size);
					boxCollider.size=size;
					break ;
				case "MeshCollider":;
					var meshCollider=this.addComponent(MeshCollider);
					break ;
				default :
				}
		}
	}

	/**
	*@private
	*/
	__proto._onRootNodeHierarchyLoaded=function(animator,linkSprites){
		for (var k in linkSprites){
			var nodeOwner=this;
			var path=linkSprites[k];
			for (var j=0,m=path.length;j < m;j++){
				var p=path[j];
				if (p===""){
					break ;
					}else {
					nodeOwner=nodeOwner.getChildByName(p);
					if (!nodeOwner)
						break ;
				}
			}
			(nodeOwner)&& (animator.linkSprite3DToAvatarNode(k,nodeOwner));
		}
	}

	/**
	*@private
	*/
	__proto._setHierarchyAnimator=function(animator,parentAnimator){
		this._changeHierarchyAnimator(animator);
		for (var i=0,n=this._childs.length;i < n;i++){
			var child=this._childs[i];
			(child._hierarchyAnimator==parentAnimator)&& (child._setHierarchyAnimator(animator,parentAnimator));
		}
	}

	/**
	*@private
	*/
	__proto._clearHierarchyAnimator=function(animator,parentAnimator){
		this._changeHierarchyAnimator(parentAnimator);
		for (var i=0,n=this._childs.length;i < n;i++){
			var child=this._childs[i];
			(child._hierarchyAnimator==animator)&& (child._clearHierarchyAnimator(animator,parentAnimator));
		}
	}

	/**
	*@private
	*/
	__proto._getAnimatorToLinkSprite3D=function(sprite3D,isLink,path){
		var animator=this.getComponentByType(Animator);
		if (animator){
			if (animator.avatar){
				(animator.avatar._version)|| (sprite3D._setAnimatorToLinkAvatar(animator,isLink));
				}else {
				sprite3D._setAnimatorToLinkSprite3DNoAvatar(animator,isLink,path);
			}
		}
		if (this._parent && (this._parent instanceof laya.d3.core.Sprite3D )){
			path.unshift(this._parent.name);
			var p=this._parent;
			(p._hierarchyAnimator)&& (p._getAnimatorToLinkSprite3D(sprite3D,isLink,path));
		}
	}

	/**
	*@private
	*/
	__proto._setAnimatorToLinkSprite3DNoAvatar=function(animator,isLink,path){
		var i=0,n=0;
		for (i=0,n=animator.getClipCount();i < n;i++)
		animator._handleSpriteOwnersBySprite(i,isLink,path,this);
		for (i=0,n=this._childs.length;i < n;i++){
			var child=this._childs[i];
			var index=path.length;
			path.push(child.name);
			child._setAnimatorToLinkSprite3DNoAvatar(animator,isLink,path);
			path.splice(index,1);
		}
	}

	/**
	*@private
	*/
	__proto._changeHierarchyAnimator=function(animator){
		this._hierarchyAnimator=animator;
	}

	/**
	*@private
	*/
	__proto._isLinkSpriteToAnimationNode=function(animator,node,isLink){
		var nodeIndex=animator._avatarNodes.indexOf(node);
		var cacheSpriteToNodesMap=animator._cacheSpriteToNodesMap;
		if (isLink){
			this._transform.dummy=node.transform;
			animator._cacheNodesToSpriteMap[nodeIndex]=cacheSpriteToNodesMap.length;
			cacheSpriteToNodesMap.push(nodeIndex);
			}else {
			this._transform.dummy=null;
			var index=animator._cacheNodesToSpriteMap[nodeIndex];
			animator._cacheNodesToSpriteMap[nodeIndex]=null;
			cacheSpriteToNodesMap.splice(index,1);
		}
	}

	/**
	*@private
	*/
	__proto._setBelongScene=function(scene){
		this._scene=scene;
		for (var i=0,n=this._childs.length;i < n;i++)
		(this._childs [i])._setBelongScene(scene);
	}

	/**
	*@private
	*/
	__proto._setUnBelongScene=function(){
		this._scene=null;
		for (var i=0,n=this._childs.length;i < n;i++)
		(this._childs [i])._setUnBelongScene();
	}

	/**
	*@private
	*/
	__proto._activeHierarchy=function(){
		var i=0,n=0;
		this._activeInHierarchy=true;
		this._addSelfRenderObjects();
		for (i=0,n=this._colliders.length;i < n;i++)
		this._layer._addCollider(this._colliders[i]);
		this.event(/*laya.events.Event.ACTIVE_IN_HIERARCHY_CHANGED*/"activeinhierarchychanged",true);
		for (i=0,n=this._childs.length;i < n;i++){
			var child=this._childs [i];
			(child._active)&& (child._activeHierarchy());
		}
	}

	/**
	*@private
	*/
	__proto._inActiveHierarchy=function(){
		var i=0,n=0;
		this._activeInHierarchy=false;
		this._clearSelfRenderObjects();
		for (i=0,n=this._colliders.length;i < n;i++){
			var col=this._colliders[i];
			col._clearCollsionMap();
			this._layer._removeCollider(col);
		}
		this.event(/*laya.events.Event.ACTIVE_IN_HIERARCHY_CHANGED*/"activeinhierarchychanged",false);
		for (i=0,n=this._childs.length;i < n;i++){
			var child=this._childs [i];
			(child._active)&& (child._inActiveHierarchy());
		}
	}

	/**
	*@private
	*/
	__proto.addComponent=function(type){
		var typeComponentIndex;
		var index=this._componentsMap.indexOf(type);
		if (index===-1){
			typeComponentIndex=[];
			this._componentsMap.push(type);
			this._typeComponentsIndices.push(typeComponentIndex);
			}else {
			typeComponentIndex=this._typeComponentsIndices[index];
			if (this._components[typeComponentIndex[0]].isSingleton)
				throw new Error("无法单实例创建"+type+"组件"+"，"+type+"组件已存在！");
		};
		var component=ClassUtils.getInstance(type);
		typeComponentIndex.push(this._components.length);
		this._components.push(component);
		if ((component instanceof laya.d3.component.physics.Collider )){
			var rigidbody=this.getComponentByType(Rigidbody);
			(rigidbody)&& ((component)._isRigidbody=true);
			(this._activeInHierarchy)&& (this._layer._addCollider(component));
			this._colliders.push(component);
			}else if ((component instanceof laya.d3.component.Animator )){
			var animator=component;
			this._setHierarchyAnimator(animator,this._parent ? (this._parent)._hierarchyAnimator :null);
			this._setAnimatorToLinkSprite3DNoAvatar(animator,true,/*new vector.<>*/[]);
			}else if ((component instanceof laya.d3.component.Rigidbody )){
			for (var i=0,n=this._colliders.length;i < n;i++)
			this._colliders[i]._setIsRigidbody(true);
		}
		if ((component instanceof laya.d3.component.Script ))
			this._scripts.push(component);
		component._initialize(this);
		return component;
	}

	/**
	*@inheritDoc
	*/
	__proto._removeComponent=function(mapIndex,index){
		var i=0,n=0;
		var componentIndices=this._typeComponentsIndices[mapIndex];
		var componentIndex=componentIndices[index];
		var component=this._components[componentIndex];
		if ((component instanceof laya.d3.component.physics.Collider )){
			var colliderComponent=component;
			(this._activeInHierarchy)&& (this._layer._removeCollider(colliderComponent));
			this._colliders.splice(this._colliders.indexOf(colliderComponent),1);
			}else if ((component instanceof laya.d3.component.Animator )){
			var animator=component;
			this._clearHierarchyAnimator(animator,this._parent ? (this._parent)._hierarchyAnimator :null);
			}else if ((component instanceof laya.d3.component.Rigidbody )){
			for (i=0,n=this._colliders.length;i < n;i++){
				var collider=this._colliders[i];
				collider._setIsRigidbody(false);
				var runtimeCollisonMap=collider._runtimeCollisonMap;
				var runtimeCollisonTestMap=collider._runtimeCollisonTestMap;
				for (var k in runtimeCollisonMap)
				delete runtimeCollisonTestMap[k];
			}
		}
		this._components.splice(componentIndex,1);
		if ((component instanceof laya.d3.component.Script ))
			this._scripts.splice(this._scripts.indexOf(component),1);
		componentIndices.splice(index,1);
		(componentIndices.length===0)&& (this._typeComponentsIndices.splice(mapIndex,1),this._componentsMap.splice(mapIndex,1));
		for (i=0,n=this._componentsMap.length;i < n;i++){
			componentIndices=this._typeComponentsIndices[i];
			for (var j=componentIndices.length-1;j >=0;j--){
				var oldComponentIndex=componentIndices[j];
				if (oldComponentIndex > componentIndex)
					componentIndices[j]=--oldComponentIndex;
				else
				break ;
			}
		}
		component._destroy();
	}

	/**
	*清理自身渲染物体，请重载此函数。
	*/
	__proto._clearSelfRenderObjects=function(){}
	/**
	*添加自身渲染物体，请重载此函数。
	*/
	__proto._addSelfRenderObjects=function(){}
	/**
	*@private
	*/
	__proto._parseCustomProps=function(rootNode,innerResouMap,customProps,nodeData){}
	/**
	*更新子节点。
	*@param state 渲染相关状态。
	*/
	__proto._updateChilds=function(state){
		var n=this._childs.length;
		if (n===0)return;
		for (var i=0;i < n;++i)
		this._childs[i]._update((state));
	}

	/**
	*排序函数。
	*@param state 渲染相关状态。
	*/
	__proto._getSortID=function(renderElement,material){
		return material.id */*laya.d3.graphics.VertexDeclaration._maxVertexDeclarationBit*/1000+renderElement._getVertexBuffer().vertexDeclaration.id;
	}

	/**
	*更新
	*@param state 渲染相关状态
	*/
	__proto._update=function(state){
		state.owner=this;
		if (this._activeInHierarchy){
			this._updateComponents(state);
			this._lateUpdateComponents(state);
			Stat.spriteCount++;
			this._childs.length && this._updateChilds(state);
		}
	}

	/**
	*获取投影视图世界矩阵。
	*@param projectionViewMatrix 投影视图矩阵。
	*@return 投影视图世界矩阵。
	*/
	__proto.getProjectionViewWorldMatrix=function(projectionViewMatrix){
		Matrix4x4.multiply(projectionViewMatrix,this.transform.worldMatrix,this._projectionViewWorldMatrix);
		return this._projectionViewWorldMatrix;
	}

	/**
	*加载层级文件，并作为该节点的子节点。
	*@param url
	*/
	__proto.loadHierarchy=function(url){
		this.addChild(laya.d3.core.Sprite3D.load(url));
	}

	/**
	*@inheritDoc
	*/
	__proto.addChildAt=function(node,index){
		if (!((node instanceof laya.d3.core.Sprite3D )))
			throw new Error("Sprite3D:Node type must Sprite3D.");
		if (!node || this.destroyed || node===this)return node;
		if ((node).zOrder)this._set$P("hasZorder",true);
		if (index >=0 && index <=this._childs.length){
			if (node._parent===this){
				var oldIndex=this.getChildIndex(node);
				this._childs.splice(oldIndex,1);
				this._childs.splice(index,0,node);
				if (this.conchModel){
					this.conchModel.removeChild(node.conchModel);
					this.conchModel.addChildAt(node.conchModel,index);
				}
				this._childChanged();
				}else {
				node.parent && node.parent.removeChild(node);
				this._childs===Node.ARRAY_EMPTY && (this._childs=[]);
				this._childs.splice(index,0,node);
				this.conchModel && this.conchModel.addChildAt(node.conchModel,index);
				node.parent=this;
				this._addChild3D(node);
			}
			return node;
			}else {
			throw new Error("appendChildAt:The index is out of bounds");
		}
	}

	/**
	*@inheritDoc
	*/
	__proto.addChild=function(node){
		if (!((node instanceof laya.d3.core.Sprite3D )))
			throw new Error("Sprite3D:Node type must Sprite3D.");
		if (!node || this.destroyed || node===this)return node;
		if ((node).zOrder)this._set$P("hasZorder",true);
		if (node._parent===this){
			var index=this.getChildIndex(node);
			if (index!==this._childs.length-1){
				this._childs.splice(index,1);
				this._childs.push(node);
				if (this.conchModel){
					this.conchModel.removeChild(node.conchModel);
					this.conchModel.addChildAt(node.conchModel,this._childs.length-1);
				}
				this._childChanged();
			}
			}else {
			node.parent && node.parent.removeChild(node);
			this._childs===Node.ARRAY_EMPTY && (this._childs=[]);
			this._childs.push(node);
			this.conchModel && this.conchModel.addChildAt(node.conchModel,this._childs.length-1);
			node.parent=this;
			this._childChanged();
			this._addChild3D(node);
		}
		return node;
	}

	/**
	*@inheritDoc
	*/
	__proto.removeChildAt=function(index){
		var node=this.getChildAt(index);
		if (node){
			this._removeChild3D(node);
			this._childs.splice(index,1);
			this.conchModel && this.conchModel.removeChild(node.conchModel);
			node.parent=null;
		}
		return node;
	}

	/**
	*@inheritDoc
	*/
	__proto.removeChildren=function(beginIndex,endIndex){
		(beginIndex===void 0)&& (beginIndex=0);
		(endIndex===void 0)&& (endIndex=0x7fffffff);
		if (this._childs && this._childs.length > 0){
			var childs=this._childs;
			if (beginIndex===0 && endIndex >=n){
				var arr=childs;
				this._childs=Node.ARRAY_EMPTY;
				}else {
				arr=childs.splice(beginIndex,endIndex-beginIndex);
			}
			for (var i=0,n=arr.length;i < n;i++){
				this._removeChild3D(arr [i]);
				arr[i].parent=null;
				this.conchModel && this.conchModel.removeChild(arr[i].conchModel);
			}
		}
		return this;
	}

	/**
	*@private
	*/
	__proto.onAsynLoaded=function(url,data,params){
		var json=data[0];
		if (json.type!=="Sprite3D")
			throw new Error("Sprite3D: The .lh file root type must be Sprite3D,please use other function to  load  this file.");
		var innerResouMap=data[1];
		Utils3D._createNodeByJson(this,json,this,innerResouMap);
		this.event(/*laya.events.Event.HIERARCHY_LOADED*/"hierarchyloaded",[this]);
		this.__loaded=true;
	}

	/**
	*克隆。
	*@param destObject 克隆源。
	*/
	__proto.cloneTo=function(destObject){
		if (this.destroyed)
			throw new Error("Sprite3D: Can't be cloned if the Sprite3D has destroyed.");
		var destSprite3D=destObject;
		destSprite3D.name=this.name;
		destSprite3D._destroyed=this._destroyed;
		destSprite3D.timer=this.timer;
		destSprite3D._$P=this._$P;
		destSprite3D.active=this._active;
		var destLocalPosition=destSprite3D.transform.localPosition;
		this.transform.localPosition.cloneTo(destLocalPosition);
		destSprite3D.transform.localPosition=destLocalPosition;
		var destLocalRotation=destSprite3D.transform.localRotation;
		this.transform.localRotation.cloneTo(destLocalRotation);
		destSprite3D.transform.localRotation=destLocalRotation;
		var destLocalScale=destSprite3D.transform.localScale;
		this.transform.localScale.cloneTo(destLocalScale);
		destSprite3D.transform.localScale=destLocalScale;
		destSprite3D.isStatic=this.isStatic;
		var i=0,n=0;
		for (i=0,n=this._componentsMap.length;i < n;i++){
			var destComponent=destSprite3D.addComponent(this._componentsMap[i]);
			this._components[i]._cloneTo(destComponent);
		}
		for (i=0,n=this._childs.length;i < n;i++)
		destSprite3D.addChild(this._childs[i].clone());
		var destAnimator=destSprite3D.getComponentByType(Animator);
		if (destAnimator){
			var destLinkSpritesData=destAnimator._linkSpritesData;
			if (destLinkSpritesData){
				for (var k in destLinkSpritesData){
					var path=destLinkSpritesData[k];
					var sp=destSprite3D;
					for (var j=0,m=path.length;j < m;j++){
						sp=sp.getChildByName(path[j]);
						if (!sp)
							break ;
					}
					if (sp){
						var node=destAnimator._avatarNodeMap[k];
						sp._isLinkSpriteToAnimationNode(destAnimator,node,true);
					}
				}
			}
		}
	}

	/**
	*克隆。
	*@return 克隆副本。
	*/
	__proto.clone=function(){
		var destSprite3D=/*__JS__ */new this.constructor();
		this.cloneTo(destSprite3D);
		return destSprite3D;
	}

	/**
	*@inheritDoc
	*/
	__proto.destroy=function(destroyChild){
		(destroyChild===void 0)&& (destroyChild=true);
		if (this.destroyed)
			return;
		laya.display.Node.prototype.destroy.call(this,destroyChild);
		var i=0,n=0;
		for (i=0,n=this._components.length;i < n;i++)
		this._components[i]._destroy();
		this._components=null;
		this._componentsMap=null;
		this._typeComponentsIndices=null;
		this._transform=null;
		this._colliders=null;
		Loader.clearRes(this.url);
		(this.loaded)|| (Laya3D._cancelLoadByUrl(this.url));
	}

	/**
	*@private
	*/
	__proto._handleSpriteToAvatar=function(animator,isLink){
		var i=0,n=0;
		var avatarNodes=animator._avatarNodes;
		var node=animator._avatarNodeMap[this.name];
		if (node && node.name===this.name && !this._transform.dummy)
			this._isLinkSpriteToAnimationNode(animator,node,isLink);
	}

	/**
	*@private
	*/
	__proto._setAnimatorToLinkAvatar=function(animator,isLink){
		this._handleSpriteToAvatar(animator,isLink);
		for (var i=0,n=this._childs.length;i < n;i++){
			var child=this._childs[i];
			child._setAnimatorToLinkAvatar(animator,isLink);
		}
	}

	/**
	*获取在场景中是否激活。
	*@return 在场景中是否激活。
	*/
	__getset(0,__proto,'activeInHierarchy',function(){
		return this._activeInHierarchy;
	});

	/**
	*@private
	*/
	__getset(0,__proto,'_loaded',null,function(value){
		this.__loaded=value;
	});

	/**
	*设置是否激活。
	*@param value 是否激活。
	*/
	/**
	*获取自身是否激活。
	*@return 自身是否激活。
	*/
	__getset(0,__proto,'active',function(){
		return this._active;
		},function(value){
		if (this._active!==value){
			this._active=value;
			if (this._parent){
				if ((this._parent===this._scene && this._parent.displayedInStage)|| (this._parent)._activeInHierarchy){
					if (value)
						this._activeHierarchy();
					else
					this._inActiveHierarchy();
				}
			}
		}
	});

	/**
	*获得组件的数量。
	*@return 组件数量。
	*/
	__getset(0,__proto,'componentsCount',function(){
		return this._components.length;
	});

	/**
	*获取是否已加载完成。
	*/
	__getset(0,__proto,'loaded',function(){
		return this.__loaded;
	});

	/**
	*获取唯一标识ID。
	*@return 唯一标识ID。
	*/
	__getset(0,__proto,'id',function(){
		return this._id;
	});

	/**
	*获取资源的URL地址。
	*@return URL地址。
	*/
	__getset(0,__proto,'url',function(){
		return this._url;
	});

	/**
	*设置蒙版。
	*@param value 蒙版。
	*/
	/**
	*获取蒙版。
	*@return 蒙版。
	*/
	__getset(0,__proto,'layer',function(){
		return this._layer;
		},function(value){
		if (this._layer!==value){
			if (value){
				if (this._activeInHierarchy){
					var i=0,n=this._colliders.length;
					if (this._layer){
						for (i=0;i < n;i++)
						this._layer._removeCollider(this._colliders[i]);
					}
					for (i=0;i < n;i++)
					value._addCollider(this._colliders[i]);
				}
				this._layer=value;
				this.event(/*laya.events.Event.LAYER_CHANGED*/"layerchanged",value);
				}else {
				throw new Error("Layer value can be null.");
			}
		}
	});

	/**
	*获得所属场景。
	*@return 场景。
	*/
	__getset(0,__proto,'scene',function(){
		return this._scene;
	});

	/**
	*获取精灵变换。
	*/
	__getset(0,__proto,'transform',function(){
		return this._transform;
	});

	Sprite3D.instantiate=function(original,parent,worldPositionStays,position,rotation){
		(worldPositionStays===void 0)&& (worldPositionStays=true);
		var destSprite3D=original.clone();
		(parent)&& (parent.addChild(destSprite3D));
		var transform=destSprite3D.transform;
		if (worldPositionStays){
			var worldMatrix=transform.worldMatrix;
			original.transform.worldMatrix.cloneTo(worldMatrix);
			transform.worldMatrix=worldMatrix;
			}else {
			(position)&& (transform.position=position);
			(rotation)&& (transform.rotation=rotation);
		}
		return destSprite3D;
	}

	Sprite3D.load=function(url){
		return Laya.loader.create(url,null,null,Sprite3D);
	}

	Sprite3D.WORLDMATRIX=0;
	Sprite3D.MVPMATRIX=1;
	Sprite3D._uniqueIDCounter=0;
	Sprite3D._nameNumberCounter=0;
	return Sprite3D;
})(ComponentNode)


//class laya.d3.shader.Shader3D extends laya.webgl.shader.BaseShader
var Shader3D=(function(_super){
	function Shader3D(vs,ps,attributeMap,sceneUniformMap,cameraUniformMap,spriteUniformMap,materialUniformMap,renderElementUniformMap){
		//this._attributeMap=null;
		//this._sceneUniformMap=null;
		//this._cameraUniformMap=null;
		//this._spriteUniformMap=null;
		//this._materialUniformMap=null;
		//this._renderElementUniformMap=null;
		//this._vs=null;
		//this._ps=null;
		this._curActTexIndex=0;
		//this._reCompile=false;
		//this._vshader=null;
		//this._pshader=null;
		this._program=null;
		this._attributeParams=null;
		this._uniformParams=null;
		this._attributeParamsMap=[];
		this._sceneUniformParamsMap=[];
		this._cameraUniformParamsMap=[];
		this._spriteUniformParamsMap=[];
		this._materialUniformParamsMap=[];
		this._renderElementUniformParamsMap=[];
		//this._id=0;
		/**@private */
		//this._uploadLoopCount=0;
		/**@private */
		//this._uploadRenderElement=null;
		/**@private */
		//this._uploadMaterial=null;
		/**@private */
		//this._uploadSprite3D=null;
		/**@private */
		//this._uploadCamera=null;
		/**@private */
		//this._uploadScene=null;
		/**@private */
		//this._uploadVertexBuffer=null;
		Shader3D.__super.call(this);
		if ((!vs)|| (!ps))throw "Shader Error";
		this._id=++Shader3D._count;
		this._vs=vs;
		this._ps=ps;
		this._attributeMap=attributeMap;
		this._sceneUniformMap=sceneUniformMap;
		this._cameraUniformMap=cameraUniformMap;
		this._spriteUniformMap=spriteUniformMap;
		this._materialUniformMap=materialUniformMap;
		this._renderElementUniformMap=renderElementUniformMap;
		this.recreateResource();
	}

	__class(Shader3D,'laya.d3.shader.Shader3D',_super);
	var __proto=Shader3D.prototype;
	__proto.recreateResource=function(){
		this._compile();
		this.completeCreate();
		this.memorySize=0;
	}

	//忽略尺寸尺寸
	__proto.disposeResource=function(){
		WebGL.mainContext.deleteShader(this._vshader);
		WebGL.mainContext.deleteShader(this._pshader);
		WebGL.mainContext.deleteProgram(this._program);
		this._vshader=this._pshader=this._program=null;
		this._attributeParams=null;
		this._uniformParams=null;
		this.memorySize=0;
		this._curActTexIndex=0;
	}

	__proto._compile=function(){
		if (!this._vs || !this._ps || this._attributeParams || this._uniformParams)
			return;
		this._reCompile=true;
		this._attributeParams=[];
		this._uniformParams=[];
		var text=[this._vs,this._ps];
		var result;
		var gl=WebGL.mainContext;
		this._program=gl.createProgram();
		this._vshader=Shader3D._createShader(gl,text[0],/*laya.webgl.WebGLContext.VERTEX_SHADER*/0x8B31);
		this._pshader=Shader3D._createShader(gl,text[1],/*laya.webgl.WebGLContext.FRAGMENT_SHADER*/0x8B30);
		gl.attachShader(this._program,this._vshader);
		gl.attachShader(this._program,this._pshader);
		gl.linkProgram(this._program);
		if (!Render.isConchApp && ShaderCompile3D.debugMode && !gl.getProgramParameter(this._program,/*laya.webgl.WebGLContext.LINK_STATUS*/0x8B82))
			throw gl.getProgramInfoLog(this._program);
		var one,i=0,j=0,n=0,location;
		var attribNum=0;
		if (Render.isConchApp){
			attribNum=gl.getProgramParameterEx(this._vs,this._ps,"",/*laya.webgl.WebGLContext.ACTIVE_ATTRIBUTES*/0x8B89);
		}
		else{
			attribNum=gl.getProgramParameter(this._program,/*laya.webgl.WebGLContext.ACTIVE_ATTRIBUTES*/0x8B89);
		}
		for (i=0;i < attribNum;i++){
			var attrib=null;
			if (Render.isConchApp){
				attrib=gl.getActiveAttribEx(this._vs,this._ps,"",i);
			}
			else{
				attrib=gl.getActiveAttrib(this._program,i);
			}
			location=gl.getAttribLocation(this._program,attrib.name);
			one={vartype:"attribute",ivartype:0,attrib:attrib,location:location,name:attrib.name,type:attrib.type,isArray:false,isSame:false,preValue:null,indexOfParams:0};
			this._attributeParams.push(one);
		};
		var nUniformNum=0;
		if (Render.isConchApp){
			nUniformNum=gl.getProgramParameterEx(this._vs,this._ps,"",/*laya.webgl.WebGLContext.ACTIVE_UNIFORMS*/0x8B86);
		}
		else{
			nUniformNum=gl.getProgramParameter(this._program,/*laya.webgl.WebGLContext.ACTIVE_UNIFORMS*/0x8B86);
		}
		for (i=0;i < nUniformNum;i++){
			var uniform=null;
			if (Render.isConchApp){
				uniform=gl.getActiveUniformEx(this._vs,this._ps,"",i);
			}
			else{
				uniform=gl.getActiveUniform(this._program,i);
			}
			location=gl.getUniformLocation(this._program,uniform.name);
			one={vartype:"uniform",ivartype:1,attrib:attrib,location:location,name:uniform.name,type:uniform.type,isArray:false,isSame:false,preValue:null,indexOfParams:0};
			if (one.name.indexOf('[0]')> 0){
				one.name=one.name.substr(0,one.name.length-3);
				one.isArray=true;
				one.location=gl.getUniformLocation(this._program,one.name);
			}
			this._uniformParams.push(one);
		}
		for (i=0,n=this._attributeParams.length;i < n;i++){
			one=this._attributeParams[i];
			one.indexOfParams=i;
			one.index=1;
			one.value=[one.location,null];
			one.codename=one.name;
			one.name=(this._attributeMap[one.codename] !=null)? this._attributeMap[one.codename] :one.codename;
			this._attributeParamsMap.push(one.name);
			this._attributeParamsMap.push(one);
			one._this=this;
			one.uploadedValue=[];
			one.fun=this._attribute;
		}
		for (i=0,n=this._uniformParams.length;i < n;i++){
			one=this._uniformParams[i];
			one.indexOfParams=i;
			one.index=1;
			one.value=[one.location,null];
			one.codename=one.name;
			if (this._sceneUniformMap[one.codename] !=null){
				one.name=this._sceneUniformMap[one.codename];
				this._sceneUniformParamsMap.push(one.name);
				this._sceneUniformParamsMap.push(one);
				}else if (this._cameraUniformMap[one.codename] !=null){
				one.name=this._cameraUniformMap[one.codename];
				this._cameraUniformParamsMap.push(one.name);
				this._cameraUniformParamsMap.push(one);
				}else if (this._spriteUniformMap[one.codename] !=null){
				one.name=this._spriteUniformMap[one.codename];
				this._spriteUniformParamsMap.push(one.name);
				this._spriteUniformParamsMap.push(one);
				}else if (this._materialUniformMap[one.codename] !=null){
				one.name=this._materialUniformMap[one.codename];
				this._materialUniformParamsMap.push(one.name);
				this._materialUniformParamsMap.push(one);
				}else if (this._renderElementUniformMap[one.codename] !=null){
				one.name=this._renderElementUniformMap[one.codename];
				this._renderElementUniformParamsMap.push(one.name);
				this._renderElementUniformParamsMap.push(one);
				}else {
				console.log("Shader:can't find uinform name:"+one.codename+" in shader file.");
			}
			one._this=this;
			one.uploadedValue=[];
			switch (one.type){
				case /*laya.webgl.WebGLContext.INT*/0x1404:
					one.fun=one.isArray ? this._uniform1iv :this._uniform1i;
					break ;
				case /*laya.webgl.WebGLContext.FLOAT*/0x1406:
					one.fun=one.isArray ? this._uniform1fv :this._uniform1f;
					break ;
				case /*laya.webgl.WebGLContext.FLOAT_VEC2*/0x8B50:
					one.fun=one.isArray ? this._uniform_vec2v :this._uniform_vec2;
					break ;
				case /*laya.webgl.WebGLContext.FLOAT_VEC3*/0x8B51:
					one.fun=one.isArray ? this._uniform_vec3v :this._uniform_vec3;
					break ;
				case /*laya.webgl.WebGLContext.FLOAT_VEC4*/0x8B52:
					one.fun=one.isArray ? this._uniform_vec4v :this._uniform_vec4;
					break ;
				case /*laya.webgl.WebGLContext.SAMPLER_2D*/0x8B5E:
					one.fun=this._uniform_sampler2D;
					break ;
				case /*laya.webgl.WebGLContext.SAMPLER_CUBE*/0x8B60:
					one.fun=this._uniform_samplerCube;
					break ;
				case /*laya.webgl.WebGLContext.FLOAT_MAT4*/0x8B5C:
					one.fun=this._uniformMatrix4fv;
					break ;
				case /*laya.webgl.WebGLContext.BOOL*/0x8B56:
					one.fun=this._uniform1i;
					break ;
				case /*laya.webgl.WebGLContext.FLOAT_MAT2*/0x8B5A:
					one.fun=this._uinformMatrix2fv;
					break ;
				case /*laya.webgl.WebGLContext.FLOAT_MAT3*/0x8B5B:
					one.fun=this._uinformMatrix3fv;
					break ;
				default :
					throw new Error("compile shader err!");
					break ;
				}
		}
	}

	__proto._attribute=function(one,value){
		var gl=WebGL.mainContext;
		var enableAtributes=Buffer._enableAtributes;
		var location=one.location;
		(enableAtributes[location])|| (gl.enableVertexAttribArray(location));
		gl.vertexAttribPointer(location,value[0],value[1],value[2],value[3],value[4]);
		enableAtributes[location]=Buffer._bindVertexBuffer;
		return 1;
	}

	__proto._uniform1f=function(one,value){
		var uploadedValue=one.uploadedValue;
		if (uploadedValue[0]!==value){
			WebGL.mainContext.uniform1f(one.location,uploadedValue[0]=value);
			return 1;
		}
		return 0;
	}

	__proto._uniform1fv=function(one,value){
		if (value.length < 4){
			var uploadedValue=one.uploadedValue;
			if (uploadedValue[0]!==value[0] || uploadedValue[1]!==value[1] || uploadedValue[2]!==value[2] || uploadedValue[3]!==value[3]){
				WebGL.mainContext.uniform1fv(one.location,value);
				uploadedValue[0]=value[0];
				uploadedValue[1]=value[1];
				uploadedValue[2]=value[2];
				uploadedValue[3]=value[3];
				return 1;
			}
			return 0;
			}else {
			WebGL.mainContext.uniform1fv(one.location,value);
			return 1;
		}
	}

	__proto._uniform_vec2=function(one,value){
		var uploadedValue=one.uploadedValue;
		if (uploadedValue[0]!==value[0] || uploadedValue[1]!==value[1]){
			WebGL.mainContext.uniform2f(one.location,uploadedValue[0]=value[0],uploadedValue[1]=value[1]);
			return 1;
		}
		return 0;
	}

	__proto._uniform_vec2v=function(one,value){
		if (value.length < 2){
			var uploadedValue=one.uploadedValue;
			if (uploadedValue[0]!==value[0] || uploadedValue[1]!==value[1] || uploadedValue[2]!==value[2] || uploadedValue[3]!==value[3]){
				WebGL.mainContext.uniform2fv(one.location,value);
				uploadedValue[0]=value[0];
				uploadedValue[1]=value[1];
				uploadedValue[2]=value[2];
				uploadedValue[3]=value[3];
				return 1;
			}
			return 0;
			}else {
			WebGL.mainContext.uniform2fv(one.location,value);
			return 1;
		}
	}

	__proto._uniform_vec3=function(one,value){
		var uploadedValue=one.uploadedValue;
		if (uploadedValue[0]!==value[0] || uploadedValue[1]!==value[1] || uploadedValue[2]!==value[2]){
			WebGL.mainContext.uniform3f(one.location,uploadedValue[0]=value[0],uploadedValue[1]=value[1],uploadedValue[2]=value[2]);
			return 1;
		}
		return 0;
	}

	__proto._uniform_vec3v=function(one,value){
		WebGL.mainContext.uniform3fv(one.location,value);
		return 1;
	}

	__proto._uniform_vec4=function(one,value){
		var uploadedValue=one.uploadedValue;
		if (uploadedValue[0]!==value[0] || uploadedValue[1]!==value[1] || uploadedValue[2]!==value[2] || uploadedValue[3]!==value[3]){
			WebGL.mainContext.uniform4f(one.location,uploadedValue[0]=value[0],uploadedValue[1]=value[1],uploadedValue[2]=value[2],uploadedValue[3]=value[3]);
			return 1;
		}
		return 0;
	}

	__proto._uniform_vec4v=function(one,value){
		WebGL.mainContext.uniform4fv(one.location,value);
		return 1;
	}

	__proto._uniformMatrix2fv=function(one,value){
		WebGL.mainContext.uniformMatrix2fv(one.location,false,value);
		return 1;
	}

	__proto._uniformMatrix3fv=function(one,value){
		WebGL.mainContext.uniformMatrix3fv(one.location,false,value);
		return 1;
	}

	__proto._uniformMatrix4fv=function(one,value){
		WebGL.mainContext.uniformMatrix4fv(one.location,false,value);
		return 1;
	}

	__proto._uinformMatrix2fv=function(one,value){
		WebGL.mainContext.uniformMatrix2fv(one.location,false,value);
		return 1;
	}

	__proto._uinformMatrix3fv=function(one,value){
		WebGL.mainContext.uniformMatrix3fv(one.location,false,value);
		return 1;
	}

	__proto._uniform1i=function(one,value){
		var uploadedValue=one.uploadedValue;
		if (uploadedValue[0]!==value){
			WebGL.mainContext.uniform1i(one.location,uploadedValue[0]=value);
			return 1;
		}
		return 0;
	}

	__proto._uniform1iv=function(one,value){
		WebGL.mainContext.uniform1iv(one.location,value);
		return 1;
	}

	__proto._uniform_ivec2=function(one,value){
		var uploadedValue=one.uploadedValue;
		if (uploadedValue[0]!==value[0] || uploadedValue[1]!==value[1]){
			WebGL.mainContext.uniform2i(one.location,uploadedValue[0]=value[0],uploadedValue[1]=value[1]);
			return 1;
		}
		return 0;
	}

	__proto._uniform_ivec2v=function(one,value){
		WebGL.mainContext.uniform2iv(one.location,value);
		return 1;
	}

	__proto._uniform_vec3i=function(one,value){
		var uploadedValue=one.uploadedValue;
		if (uploadedValue[0]!==value[0] || uploadedValue[1]!==value[1] || uploadedValue[2]!==value[2]){
			WebGL.mainContext.uniform3i(one.location,uploadedValue[0]=value[0],uploadedValue[1]=value[1],uploadedValue[2]=value[2]);
			return 1;
		}
		return 0;
	}

	__proto._uniform_vec3vi=function(one,value){
		WebGL.mainContext.uniform3iv(one.location,value);
		return 1;
	}

	__proto._uniform_vec4i=function(one,value){
		var uploadedValue=one.uploadedValue;
		if (uploadedValue[0]!==value[0] || uploadedValue[1]!==value[1] || uploadedValue[2]!==value[2] || uploadedValue[3]!==value[3]){
			WebGL.mainContext.uniform4i(one.location,uploadedValue[0]=value[0],uploadedValue[1]=value[1],uploadedValue[2]=value[2],uploadedValue[3]=value[3]);
			return 1;
		}
		return 0;
	}

	__proto._uniform_vec4vi=function(one,value){
		WebGL.mainContext.uniform4iv(one.location,value);
		return 1;
	}

	__proto._uniform_sampler2D=function(one,texture){
		var value=texture.source || texture.defaulteTexture.source;
		var gl=WebGL.mainContext;
		var uploadedValue=one.uploadedValue;
		if (uploadedValue[0]==null){
			if (this._curActTexIndex > 7)
				throw new Error("Shader3D: shader support textures max count is 8,can't large than it.");
			uploadedValue[0]=this._curActTexIndex;
			gl.uniform1i(one.location,this._curActTexIndex);
			gl.activeTexture(Shader3D._TEXTURES[this._curActTexIndex]);
			if (value)
				WebGLContext.bindTexture(gl,/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,value);
			this._curActTexIndex++;
			return 1;
			}else {
			gl.activeTexture(Shader3D._TEXTURES[uploadedValue[0]]);
			if (value)
				WebGLContext.bindTexture(gl,/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,value);
			return 0;
		}
	}

	__proto._uniform_samplerCube=function(one,texture){
		var value=texture.source || texture.defaulteTexture.source;
		var gl=WebGL.mainContext;
		var uploadedValue=one.uploadedValue;
		if (uploadedValue[0]==null){
			if (this._curActTexIndex > 7)
				throw new Error("Shader3D: shader support textures max count is 8,can't large than it.");
			uploadedValue[0]=this._curActTexIndex;
			gl.uniform1i(one.location,this._curActTexIndex);
			gl.activeTexture(Shader3D._TEXTURES[this._curActTexIndex]);
			if (value)
				WebGLContext.bindTexture(gl,/*laya.webgl.WebGLContext.TEXTURE_CUBE_MAP*/0x8513,value);
			else
			WebGLContext.bindTexture(gl,/*laya.webgl.WebGLContext.TEXTURE_CUBE_MAP*/0x8513,SolidColorTextureCube.grayTexture.source);
			this._curActTexIndex++;
			return 1;
			}else {
			gl.activeTexture(Shader3D._TEXTURES[uploadedValue[0]]);
			if (value)
				WebGLContext.bindTexture(gl,/*laya.webgl.WebGLContext.TEXTURE_CUBE_MAP*/0x8513,value);
			else
			WebGLContext.bindTexture(gl,/*laya.webgl.WebGLContext.TEXTURE_CUBE_MAP*/0x8513,SolidColorTextureCube.grayTexture.source);
			return 0;
		}
	}

	__proto._noSetValue=function(one){
		console.log("no....:"+one.name);
	}

	//throw new Error("upload shader err,must set value:"+one.name);
	__proto.bind=function(){
		BaseShader.activeShader=this;
		BaseShader.bindShader=this;
		this.activeResource();
		return WebGLContext.UseProgram(this._program);
	}

	/**
	*按数组的定义提交
	*@param shaderValue 数组格式[name,value,...]
	*/
	__proto.uploadAttributes=function(attributeShaderValue,_bufferUsage){
		var value;
		var one,shaderCall=0;
		for (var i=0,n=this._attributeParamsMap.length;i < n;i+=2){
			one=this._attributeParamsMap[i+1];
			value=attributeShaderValue[this._attributeParamsMap[i]];
			if (value !=null){
				_bufferUsage && _bufferUsage[one.name] && _bufferUsage[one.name].bind();
				shaderCall+=one.fun.call(this,one,value);
			}
		}
		Stat.shaderCall+=shaderCall;
	}

	/**
	*按数组的定义提交
	*@param shaderValue 数组格式[name,value,...]
	*/
	__proto.uploadAttributesX=function(attributeShaderValue,vb){
		var value;
		var one,shaderCall=0;
		for (var i=0,n=this._attributeParamsMap.length;i < n;i+=2){
			one=this._attributeParamsMap[i+1];
			value=attributeShaderValue[this._attributeParamsMap[i]];
			if (value !=null){
				vb._bind();
				shaderCall+=one.fun.call(this,one,value);
			}
		}
		Stat.shaderCall+=shaderCall;
	}

	/**
	*按数组的定义提交
	*@param shaderValue 数组格式[name,value,...]
	*/
	__proto.uploadSceneUniforms=function(shaderValue){
		var value;
		var one,shaderCall=0;
		for (var i=0,n=this._sceneUniformParamsMap.length;i < n;i+=2){
			one=this._sceneUniformParamsMap[i+1];
			value=shaderValue[this._sceneUniformParamsMap[i]];
			if (value !=null)
				shaderCall+=one.fun.call(this,one,value);
		}
		Stat.shaderCall+=shaderCall;
	}

	/**
	*按数组的定义提交
	*@param shaderValue 数组格式[name,value,...]
	*/
	__proto.uploadCameraUniforms=function(shaderValue){
		var value;
		var one,shaderCall=0;
		for (var i=0,n=this._cameraUniformParamsMap.length;i < n;i+=2){
			one=this._cameraUniformParamsMap[i+1];
			value=shaderValue[this._cameraUniformParamsMap[i]];
			if (value !=null)
				shaderCall+=one.fun.call(this,one,value);
		}
		Stat.shaderCall+=shaderCall;
	}

	/**
	*按数组的定义提交
	*@param shaderValue 数组格式[name,value,...]
	*/
	__proto.uploadSpriteUniforms=function(shaderValue){
		var value;
		var one,shaderCall=0;
		for (var i=0,n=this._spriteUniformParamsMap.length;i < n;i+=2){
			one=this._spriteUniformParamsMap[i+1];
			value=shaderValue[this._spriteUniformParamsMap[i]];
			if (value !=null)
				shaderCall+=one.fun.call(this,one,value);
		}
		Stat.shaderCall+=shaderCall;
	}

	/**
	*按数组的定义提交
	*@param shaderValue 数组格式[name,value,...]
	*/
	__proto.uploadMaterialUniforms=function(shaderValue){
		var value;
		var one,shaderCall=0;
		for (var i=0,n=this._materialUniformParamsMap.length;i < n;i+=2){
			one=this._materialUniformParamsMap[i+1];
			value=shaderValue[this._materialUniformParamsMap[i]];
			if (value !=null)
				shaderCall+=one.fun.call(this,one,value);
		}
		Stat.shaderCall+=shaderCall;
	}

	/**
	*按数组的定义提交
	*@param shaderValue 数组格式[name,value,...]
	*/
	__proto.uploadRenderElementUniforms=function(shaderValue){
		var value;
		var one,shaderCall=0;
		for (var i=0,n=this._renderElementUniformParamsMap.length;i < n;i+=2){
			one=this._renderElementUniformParamsMap[i+1];
			value=shaderValue[this._renderElementUniformParamsMap[i]];
			if (value !=null)
				shaderCall+=one.fun.call(this,one,value);
		}
		Stat.shaderCall+=shaderCall;
	}

	Shader3D.create=function(vs,ps,attributeMap,sceneUniformMap,cameraUniformMap,spriteUniformMap,materialUniformMap,renderElementUniformMap){
		return new Shader3D(vs,ps,attributeMap,sceneUniformMap,cameraUniformMap,spriteUniformMap,materialUniformMap,renderElementUniformMap);
	}

	Shader3D.addInclude=function(fileName,txt){
		ShaderCompile.addInclude(fileName,txt);
	}

	Shader3D._createShader=function(gl,str,type){
		var shader=gl.createShader(type);
		gl.shaderSource(shader,str);
		gl.compileShader(shader);
		if (ShaderCompile3D.debugMode && !gl.getShaderParameter(shader,/*laya.webgl.WebGLContext.COMPILE_STATUS*/0x8B81))
			throw gl.getShaderInfoLog(shader);
		return shader;
	}

	Shader3D.PERIOD_RENDERELEMENT=0;
	Shader3D.PERIOD_MATERIAL=1;
	Shader3D.PERIOD_SPRITE=2;
	Shader3D.PERIOD_CAMERA=3;
	Shader3D.PERIOD_SCENE=4;
	Shader3D._TEXTURES=[ /*laya.webgl.WebGLContext.TEXTURE0*/0x84C0,/*laya.webgl.WebGLContext.TEXTURE1*/0x84C1,/*laya.webgl.WebGLContext.TEXTURE2*/0x84C2,/*laya.webgl.WebGLContext.TEXTURE3*/0x84C3,/*laya.webgl.WebGLContext.TEXTURE4*/0x84C4,/*laya.webgl.WebGLContext.TEXTURE5*/0x84C5,/*laya.webgl.WebGLContext.TEXTURE6*/0x84C6,/*laya.webgl.WebGLContext.TEXTURE7*/0x84C7];
	Shader3D._count=0;
	__static(Shader3D,
	['shaderParamsMap',function(){return this.shaderParamsMap={"float":/*laya.webgl.WebGLContext.FLOAT*/0x1406,"int":/*laya.webgl.WebGLContext.INT*/0x1404,"bool":/*laya.webgl.WebGLContext.BOOL*/0x8B56,"vec2":/*laya.webgl.WebGLContext.FLOAT_VEC2*/0x8B50,"vec3":/*laya.webgl.WebGLContext.FLOAT_VEC3*/0x8B51,"vec4":/*laya.webgl.WebGLContext.FLOAT_VEC4*/0x8B52,"ivec2":/*laya.webgl.WebGLContext.INT_VEC2*/0x8B53,"ivec3":/*laya.webgl.WebGLContext.INT_VEC3*/0x8B54,"ivec4":/*laya.webgl.WebGLContext.INT_VEC4*/0x8B55,"bvec2":/*laya.webgl.WebGLContext.BOOL_VEC2*/0x8B57,"bvec3":/*laya.webgl.WebGLContext.BOOL_VEC3*/0x8B58,"bvec4":/*laya.webgl.WebGLContext.BOOL_VEC4*/0x8B59,"mat2":/*laya.webgl.WebGLContext.FLOAT_MAT2*/0x8B5A,"mat3":/*laya.webgl.WebGLContext.FLOAT_MAT3*/0x8B5B,"mat4":/*laya.webgl.WebGLContext.FLOAT_MAT4*/0x8B5C,"sampler2D":/*laya.webgl.WebGLContext.SAMPLER_2D*/0x8B5E,"samplerCube":/*laya.webgl.WebGLContext.SAMPLER_CUBE*/0x8B60};},'nameKey',function(){return this.nameKey=new StringKey();}
	]);
	return Shader3D;
})(BaseShader)


/**
*<code>BlinnPhongMaterial</code> 类用于实现Blinn-Phong材质。
*/
//class laya.d3.core.material.BlinnPhongMaterial extends laya.d3.core.material.BaseMaterial
var BlinnPhongMaterial=(function(_super){
	function BlinnPhongMaterial(){
		/**@private */
		//this._albedoColor=null;
		/**@private */
		//this._albedoIntensity=NaN;
		/**@private */
		//this._enableLighting=false;
		BlinnPhongMaterial.__super.call(this);
		this.setShaderName("BLINNPHONG");
		this._albedoIntensity=1.0;
		this._albedoColor=new Vector4(1.0,1.0,1.0,1.0);
		this._setColor(6,new Vector4(1.0,1.0,1.0,1.0));
		this._setColor(8,new Vector3(1.0,1.0,1.0));
		this._setNumber(9,0.078125);
		this._setColor(10,new Vector3(1.0,1.0,1.0));
		this._setNumber(0,0.5);
		this._setColor(11,new Vector4(1.0,1.0,0.0,0.0));
		this._enableLighting=true;
		this.renderMode=0;
	}

	__class(BlinnPhongMaterial,'laya.d3.core.material.BlinnPhongMaterial',_super);
	var __proto=BlinnPhongMaterial.prototype;
	/**
	*禁用灯光。
	*/
	__proto.disableLight=function(){
		this._addDisablePublicShaderDefine(ShaderCompile3D.SHADERDEFINE_POINTLIGHT | ShaderCompile3D.SHADERDEFINE_SPOTLIGHT | ShaderCompile3D.SHADERDEFINE_DIRECTIONLIGHT);
	}

	/**
	*禁用雾化。
	*/
	__proto.disableFog=function(){
		this._addDisablePublicShaderDefine(ShaderCompile3D.SHADERDEFINE_FOG);
	}

	/**
	*@inheritDoc
	*/
	__proto.cloneTo=function(destObject){
		_super.prototype.cloneTo.call(this,destObject);
		var destMaterial=destObject;
		destMaterial._enableLighting=this._enableLighting;
		destMaterial._albedoIntensity=this._albedoIntensity;
		this._albedoColor.cloneTo(destMaterial._albedoColor);
	}

	/**
	*设置渲染模式。
	*@return 渲染模式。
	*/
	__getset(0,__proto,'renderMode',null,function(value){
		switch (value){
			case 0:
				this.renderQueue=/*laya.d3.core.material.BaseMaterial.RENDERQUEUE_OPAQUE*/2000;
				this.depthWrite=true;
				this.cull=2;
				this.blend=0;
				this.alphaTest=false;
				this.depthTest=0x0201;
				this._removeShaderDefine(BlinnPhongMaterial.SHADERDEFINE_ADDTIVEFOG);
				break ;
			case 1:
				this.depthWrite=true;
				this.cull=2;
				this.blend=0;
				this.renderQueue=/*laya.d3.core.material.BaseMaterial.RENDERQUEUE_OPAQUE*/2000;
				this.alphaTest=true;
				this.depthTest=0x0201;
				this._removeShaderDefine(BlinnPhongMaterial.SHADERDEFINE_ADDTIVEFOG);
				break ;
			case 2:
				this.renderQueue=/*laya.d3.core.material.BaseMaterial.RENDERQUEUE_TRANSPARENT*/3000;
				this.depthWrite=false;
				this.cull=2;
				this.blend=1;
				this.srcBlend=0x0302;
				this.dstBlend=0x0303;
				this.alphaTest=false;
				this.depthTest=0x0201;
				this._removeShaderDefine(BlinnPhongMaterial.SHADERDEFINE_ADDTIVEFOG);
				break ;
			case 3:
				this.renderQueue=/*laya.d3.core.material.BaseMaterial.RENDERQUEUE_TRANSPARENT*/3000;
				this.depthWrite=false;
				this.cull=2;
				this.blend=1;
				this.srcBlend=0x0302;
				this.dstBlend=1;
				this.alphaTest=false;
				this.depthTest=0x0201;
				this._addShaderDefine(BlinnPhongMaterial.SHADERDEFINE_ADDTIVEFOG);
				break ;
			default :
				throw new Error("Material:renderMode value error.");
			}
		this._conchMaterial && this._conchMaterial.setRenderMode(value);
	});

	/**
	*设置法线贴图。
	*@param value 法线贴图。
	*/
	/**
	*获取法线贴图。
	*@return 法线贴图。
	*/
	__getset(0,__proto,'normalTexture',function(){
		return this._getTexture(2);
		},function(value){
		if (value)
			this._addShaderDefine(laya.d3.core.material.BlinnPhongMaterial.SHADERDEFINE_NORMALMAP);
		else
		this._removeShaderDefine(laya.d3.core.material.BlinnPhongMaterial.SHADERDEFINE_NORMALMAP);
		this._setTexture(2,value);
	});

	/**
	*设置反射颜色。
	*@param value 反射颜色。
	*/
	/**
	*获取反射颜色。
	*@return value 反射颜色。
	*/
	__getset(0,__proto,'reflectColor',function(){
		return this._getColor(10);
		},function(value){
		this._setColor(10,value);
	});

	/**
	*获取纹理平铺和偏移。
	*@param value 纹理平铺和偏移。
	*/
	/**
	*获取纹理平铺和偏移。
	*@return 纹理平铺和偏移。
	*/
	__getset(0,__proto,'tilingOffset',function(){
		return this._getColor(11);
		},function(value){
		if (value){
			var valueE=value.elements;
			if (valueE[0] !=1 || valueE[1] !=1 || valueE[2] !=0 || valueE[3] !=0)
				this._addShaderDefine(laya.d3.core.material.BlinnPhongMaterial.SHADERDEFINE_TILINGOFFSET);
			else
			this._removeShaderDefine(laya.d3.core.material.BlinnPhongMaterial.SHADERDEFINE_TILINGOFFSET);
			}else {
			this._removeShaderDefine(laya.d3.core.material.BlinnPhongMaterial.SHADERDEFINE_TILINGOFFSET);
		}
		this._setColor(11,value);
	});

	/**
	*设置高光颜色。
	*@param value 高光颜色。
	*/
	/**
	*获取高光颜色。
	*@return 高光颜色。
	*/
	__getset(0,__proto,'specularColor',function(){
		return this._getColor(8);
		},function(value){
		this._setColor(8,value);
	});

	/**
	*设置漫反射颜色。
	*@param value 漫反射颜色。
	*/
	/**
	*获取漫反射颜色。
	*@return 漫反射颜色。
	*/
	__getset(0,__proto,'albedoColor',function(){
		return this._albedoColor;
		},function(value){
		var finalAlbedo=this._getColor(6);
		Vector4.scale(value,this._albedoIntensity,finalAlbedo);
		this._albedoColor=value;
	});

	/**
	*设置漫反射颜色。
	*@param value 漫反射颜色。
	*/
	/**
	*获取漫反射颜色。
	*@return 漫反射颜色。
	*/
	__getset(0,__proto,'albedoIntensity',function(){
		return this._albedoIntensity;
		},function(value){
		if (this._albedoIntensity!==value){
			var finalAlbedo=this._getColor(6);
			Vector4.scale(this._albedoColor,value,finalAlbedo);
			this._albedoIntensity=value;
		}
	});

	/**
	*设置漫反射贴图。
	*@param value 漫反射贴图。
	*/
	/**
	*获取漫反射贴图。
	*@return 漫反射贴图。
	*/
	__getset(0,__proto,'albedoTexture',function(){
		return this._getTexture(1);
		},function(value){
		if (value)
			this._addShaderDefine(laya.d3.core.material.BlinnPhongMaterial.SHADERDEFINE_DIFFUSEMAP);
		else
		this._removeShaderDefine(laya.d3.core.material.BlinnPhongMaterial.SHADERDEFINE_DIFFUSEMAP);
		this._setTexture(1,value);
	});

	/**
	*设置高光强度,范围为0到1。
	*@param value 高光强度。
	*/
	/**
	*获取高光强度,范围为0到1。
	*@return 高光强度。
	*/
	__getset(0,__proto,'shininess',function(){
		return this._getNumber(9);
		},function(value){
		value=Math.max(0.0,Math.min(1.0,value));
		this._setNumber(9,value);
	});

	/**
	*设置高光贴图，高光强度则从该贴图RGB值中获取,如果该值为空则从漫反射贴图的Alpha通道获取。
	*@param value 高光贴图。
	*/
	/**
	*获取高光贴图。
	*@return 高光贴图。
	*/
	__getset(0,__proto,'specularTexture',function(){
		return this._getTexture(3);
		},function(value){
		if (value)
			this._addShaderDefine(laya.d3.core.material.BlinnPhongMaterial.SHADERDEFINE_SPECULARMAP);
		else
		this._removeShaderDefine(laya.d3.core.material.BlinnPhongMaterial.SHADERDEFINE_SPECULARMAP);
		this._setTexture(3,value);
	});

	/**
	*设置反射贴图。
	*@param value 反射贴图。
	*/
	/**
	*获取反射贴图。
	*@return 反射贴图。
	*/
	__getset(0,__proto,'reflectTexture',function(){
		return this._getTexture(5);
		},function(value){
		if (value)
			this._addShaderDefine(laya.d3.core.material.BlinnPhongMaterial.SHADERDEFINE_REFLECTMAP);
		else
		this._removeShaderDefine(laya.d3.core.material.BlinnPhongMaterial.SHADERDEFINE_REFLECTMAP);
		this._setTexture(5,value);
	});

	/**
	*设置是否启用光照。
	*@param value 是否启用光照。
	*/
	/**
	*获取是否启用光照。
	*@return 是否启用光照。
	*/
	__getset(0,__proto,'enableLighting',function(){
		return this._enableLighting;
		},function(value){
		if (this._enableLighting!==value){
			if (value)
				this._removeDisablePublicShaderDefine(ShaderCompile3D.SHADERDEFINE_POINTLIGHT | ShaderCompile3D.SHADERDEFINE_SPOTLIGHT | ShaderCompile3D.SHADERDEFINE_DIRECTIONLIGHT);
			else
			this._addDisablePublicShaderDefine(ShaderCompile3D.SHADERDEFINE_POINTLIGHT | ShaderCompile3D.SHADERDEFINE_SPOTLIGHT | ShaderCompile3D.SHADERDEFINE_DIRECTIONLIGHT);
			this._enableLighting=value;
		}
	});

	BlinnPhongMaterial.__init__=function(){
		BlinnPhongMaterial.SHADERDEFINE_DIFFUSEMAP=BlinnPhongMaterial.shaderDefines.registerDefine("DIFFUSEMAP");
		BlinnPhongMaterial.SHADERDEFINE_NORMALMAP=BlinnPhongMaterial.shaderDefines.registerDefine("NORMALMAP");
		BlinnPhongMaterial.SHADERDEFINE_SPECULARMAP=BlinnPhongMaterial.shaderDefines.registerDefine("SPECULARMAP");
		BlinnPhongMaterial.SHADERDEFINE_REFLECTMAP=BlinnPhongMaterial.shaderDefines.registerDefine("REFLECTMAP");
		BlinnPhongMaterial.SHADERDEFINE_TILINGOFFSET=BlinnPhongMaterial.shaderDefines.registerDefine("TILINGOFFSET");
		BlinnPhongMaterial.SHADERDEFINE_ADDTIVEFOG=BlinnPhongMaterial.shaderDefines.registerDefine("ADDTIVEFOG");
	}

	BlinnPhongMaterial.load=function(url){
		return Laya.loader.create(url,null,null,BlinnPhongMaterial);
	}

	BlinnPhongMaterial.SPECULARSOURCE_DIFFUSEMAPALPHA=0;
	BlinnPhongMaterial.SPECULARSOURCE_SPECULARMAP=0;
	BlinnPhongMaterial.RENDERMODE_OPAQUE=0;
	BlinnPhongMaterial.RENDERMODE_CUTOUT=1;
	BlinnPhongMaterial.RENDERMODE_TRANSPARENT=2;
	BlinnPhongMaterial.RENDERMODE_ADDTIVE=3;
	BlinnPhongMaterial.SHADERDEFINE_DIFFUSEMAP=0;
	BlinnPhongMaterial.SHADERDEFINE_NORMALMAP=0;
	BlinnPhongMaterial.SHADERDEFINE_SPECULARMAP=0;
	BlinnPhongMaterial.SHADERDEFINE_REFLECTMAP=0;
	BlinnPhongMaterial.SHADERDEFINE_TILINGOFFSET=0;
	BlinnPhongMaterial.SHADERDEFINE_ADDTIVEFOG=0;
	BlinnPhongMaterial.ALBEDOTEXTURE=1;
	BlinnPhongMaterial.NORMALTEXTURE=2;
	BlinnPhongMaterial.SPECULARTEXTURE=3;
	BlinnPhongMaterial.EMISSIVETEXTURE=4;
	BlinnPhongMaterial.REFLECTTEXTURE=5;
	BlinnPhongMaterial.ALBEDOCOLOR=6;
	BlinnPhongMaterial.MATERIALSPECULAR=8;
	BlinnPhongMaterial.SHININESS=9;
	BlinnPhongMaterial.MATERIALREFLECT=10;
	BlinnPhongMaterial.TILINGOFFSET=11;
	__static(BlinnPhongMaterial,
	['defaultMaterial',function(){return this.defaultMaterial=new BlinnPhongMaterial();},'shaderDefines',function(){return this.shaderDefines=new ShaderDefines$1(BaseMaterial.shaderDefines);}
	]);
	return BlinnPhongMaterial;
})(BaseMaterial)


/**
*...
*@author ...
*/
//class laya.d3.core.material.ExtendTerrainMaterial extends laya.d3.core.material.BaseMaterial
var ExtendTerrainMaterial=(function(_super){
	//NATIVE
	function ExtendTerrainMaterial(){
		ExtendTerrainMaterial.__super.call(this);
		this.setShaderName("ExtendTerrain");
		this.renderMode=1;
	}

	__class(ExtendTerrainMaterial,'laya.d3.core.material.ExtendTerrainMaterial',_super);
	var __proto=ExtendTerrainMaterial.prototype;
	__proto._setDetailNum=function(value){
		switch (value){
			case 1:
				this._addShaderDefine(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM1);
				this._removeShaderDefine(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM2);
				this._removeShaderDefine(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM3);
				this._removeShaderDefine(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM4);
				this._removeShaderDefine(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM5);
				break ;
			case 2:
				this._addShaderDefine(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM2);
				this._removeShaderDefine(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM1);
				this._removeShaderDefine(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM3);
				this._removeShaderDefine(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM4);
				this._removeShaderDefine(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM5);
				break ;
			case 3:
				this._addShaderDefine(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM3);
				this._removeShaderDefine(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM1);
				this._removeShaderDefine(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM2);
				this._removeShaderDefine(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM4);
				this._removeShaderDefine(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM5);
				break ;
			case 4:
				this._addShaderDefine(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM4);
				this._removeShaderDefine(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM1);
				this._removeShaderDefine(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM2);
				this._removeShaderDefine(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM3);
				this._removeShaderDefine(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM5);
				break ;
			case 5:
				this._addShaderDefine(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM5);
				this._removeShaderDefine(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM1);
				this._removeShaderDefine(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM2);
				this._removeShaderDefine(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM3);
				this._removeShaderDefine(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM4);
				break ;
			}
	}

	/**
	*设置禁受光照影响。
	*/
	__proto.disableLight=function(){
		this._addDisablePublicShaderDefine(ShaderCompile3D.SHADERDEFINE_POINTLIGHT | ShaderCompile3D.SHADERDEFINE_SPOTLIGHT | ShaderCompile3D.SHADERDEFINE_DIRECTIONLIGHT);
	}

	__getset(0,__proto,'diffuseScaleOffset2',null,function(scaleOffset2){
		this._setColor(7,scaleOffset2);
	});

	/**
	*设置splatAlpha贴图。
	*@param value splatAlpha贴图。
	*/
	/**
	*获取splatAlpha贴图。
	*@return splatAlpha贴图。
	*/
	__getset(0,__proto,'splatAlphaTexture',function(){
		return this._getTexture(0);
		},function(value){
		this._setTexture(0,value);
	});

	__getset(0,__proto,'diffuseScaleOffset3',null,function(scaleOffset3){
		this._setColor(8,scaleOffset3);
	});

	/**
	*设置第一层贴图。
	*@param value 第一层贴图。
	*/
	__getset(0,__proto,'diffuseTexture1',null,function(value){
		this._setTexture(1,value);
		this._setDetailNum(1);
	});

	/**
	*设置渲染模式。
	*@return 渲染模式。
	*/
	__getset(0,__proto,'renderMode',null,function(value){
		switch (value){
			case 1:
				this.renderQueue=/*laya.d3.core.material.BaseMaterial.RENDERQUEUE_OPAQUE*/2000;
				this.depthWrite=true;
				this.cull=2;
				this.blend=0;
				this.depthTest=0x0201;
				break ;
			case 2:
				this.renderQueue=/*laya.d3.core.material.BaseMaterial.RENDERQUEUE_OPAQUE*/2000;
				this.depthWrite=false;
				this.cull=2;
				this.blend=1;
				this.srcBlend=0x0302;
				this.dstBlend=0x0303;
				this.depthTest=0x0203;
				break ;
			default :
				throw new Error("ExtendTerrainMaterial:renderMode value error.");
			}
		this._conchMaterial && this._conchMaterial.setRenderMode(value);
	});

	/**
	*设置第二层贴图。
	*@param value 第二层贴图。
	*/
	/**
	*获取第二层贴图。
	*@return 第二层贴图。
	*/
	__getset(0,__proto,'diffuseTexture2',function(){
		return this._getTexture(2);
		},function(value){
		this._setTexture(2,value);
		this._setDetailNum(2);
	});

	__getset(0,__proto,'diffuseScaleOffset1',null,function(scaleOffset1){
		this._setColor(6,scaleOffset1);
	});

	/**
	*设置第三层贴图。
	*@param value 第三层贴图。
	*/
	/**
	*获取第三层贴图。
	*@return 第三层贴图。
	*/
	__getset(0,__proto,'diffuseTexture3',function(){
		return this._getTexture(3);
		},function(value){
		this._setTexture(3,value);
		this._setDetailNum(3);
	});

	/**
	*设置第四层贴图。
	*@param value 第四层贴图。
	*/
	/**
	*获取第四层贴图。
	*@return 第四层贴图。
	*/
	__getset(0,__proto,'diffuseTexture4',function(){
		return this._getTexture(4);
		},function(value){
		this._setTexture(4,value);
		this._setDetailNum(4);
	});

	/**
	*设置第五层贴图。
	*@param value 第五层贴图。
	*/
	/**
	*获取第五层贴图。
	*@return 第五层贴图。
	*/
	__getset(0,__proto,'diffuseTexture5',function(){
		return this._getTexture(5);
		},function(value){
		this._setTexture(5,value);
		this._setDetailNum(5);
	});

	__getset(0,__proto,'diffuseScaleOffset4',null,function(scaleOffset4){
		this._setColor(9,scaleOffset4);
	});

	__getset(0,__proto,'diffuseScaleOffset5',null,function(scaleOffset5){
		this._setColor(10,scaleOffset5);
	});

	/**
	*设置反射率颜色。
	*@param value 反射率颜色。
	*/
	/**
	*获取反射率颜色。
	*@return 反射率颜色。
	*/
	__getset(0,__proto,'albedo',function(){
		return this._getColor(14);
		},function(value){
		this._setColor(14,value);
	});

	/**
	*设置环境光颜色。
	*@param value 环境光颜色
	*/
	/**
	*获取环境光颜色。
	*@return 环境光颜色。
	*/
	__getset(0,__proto,'ambientColor',function(){
		return this._getColor(11);
		},function(value){
		this._setColor(11,value);
	});

	/**
	*设置漫反射颜色。
	*@param value 漫反射颜色。
	*/
	/**
	*获取漫反射颜色。
	*@return 漫反射颜色。
	*/
	__getset(0,__proto,'diffuseColor',function(){
		return this._getColor(12);
		},function(value){
		this._setColor(12,value);
	});

	/**
	*设置高光颜色。
	*@param value 高光颜色。
	*/
	/**
	*获取高光颜色。
	*@return 高光颜色。
	*/
	__getset(0,__proto,'specularColor',function(){
		return this._getColor(13);
		},function(value){
		this._setColor(13,value);
	});

	ExtendTerrainMaterial.__init__=function(){
		ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM1=ExtendTerrainMaterial.shaderDefines.registerDefine("ExtendTerrain_DETAIL_NUM1");
		ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM2=ExtendTerrainMaterial.shaderDefines.registerDefine("ExtendTerrain_DETAIL_NUM2");
		ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM3=ExtendTerrainMaterial.shaderDefines.registerDefine("ExtendTerrain_DETAIL_NUM3");
		ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM4=ExtendTerrainMaterial.shaderDefines.registerDefine("ExtendTerrain_DETAIL_NUM4");
		ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM5=ExtendTerrainMaterial.shaderDefines.registerDefine("ExtendTerrain_DETAIL_NUM5");
	}

	ExtendTerrainMaterial.RENDERMODE_OPAQUE=1;
	ExtendTerrainMaterial.RENDERMODE_TRANSPARENT=2;
	ExtendTerrainMaterial.SPLATALPHATEXTURE=0;
	ExtendTerrainMaterial.DIFFUSETEXTURE1=1;
	ExtendTerrainMaterial.DIFFUSETEXTURE2=2;
	ExtendTerrainMaterial.DIFFUSETEXTURE3=3;
	ExtendTerrainMaterial.DIFFUSETEXTURE4=4;
	ExtendTerrainMaterial.DIFFUSETEXTURE5=5;
	ExtendTerrainMaterial.DIFFUSESCALEOFFSET1=6;
	ExtendTerrainMaterial.DIFFUSESCALEOFFSET2=7;
	ExtendTerrainMaterial.DIFFUSESCALEOFFSET3=8;
	ExtendTerrainMaterial.DIFFUSESCALEOFFSET4=9;
	ExtendTerrainMaterial.DIFFUSESCALEOFFSET5=10;
	ExtendTerrainMaterial.MATERIALAMBIENT=11;
	ExtendTerrainMaterial.MATERIALDIFFUSE=12;
	ExtendTerrainMaterial.MATERIALSPECULAR=13;
	ExtendTerrainMaterial.MATERIALALBEDO=14;
	ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM1=0;
	ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM2=0;
	ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM3=0;
	ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM4=0;
	ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM5=0;
	__static(ExtendTerrainMaterial,
	['shaderDefines',function(){return this.shaderDefines=new ShaderDefines$1(BaseMaterial.shaderDefines);}
	]);
	return ExtendTerrainMaterial;
})(BaseMaterial)


/**
*...
*@author ...
*/
//class laya.d3.core.material.GlitterMaterial extends laya.d3.core.material.BaseMaterial
var GlitterMaterial=(function(_super){
	function GlitterMaterial(){
		GlitterMaterial.__super.call(this);
		this.setShaderName("GLITTER");
		this.renderMode=1;
		this._setColor(3,new Vector4(1.0,1.0,1.0,1.0));
		this._setColor(2,new Vector4(1.0,1.0,1.0,1.0));
	}

	__class(GlitterMaterial,'laya.d3.core.material.GlitterMaterial',_super);
	var __proto=GlitterMaterial.prototype;
	/**
	*@inheritDoc
	*/
	__proto.setShaderName=function(name){
		_super.prototype.setShaderName.call(this,name);
	}

	/**
	*设置渲染模式。
	*@return 渲染模式。
	*/
	__getset(0,__proto,'renderMode',null,function(value){
		switch (value){
			case 1:
				this.renderQueue=/*laya.d3.core.material.BaseMaterial.RENDERQUEUE_OPAQUE*/2000;
				this.depthWrite=true;
				this.cull=2;
				this.blend=0;
				break ;
			case 2:
				this.renderQueue=/*laya.d3.core.material.BaseMaterial.RENDERQUEUE_OPAQUE*/2000;
				this.depthWrite=true;
				this.cull=0;
				this.blend=0;
				break ;
			case 13:
				this.renderQueue=/*laya.d3.core.material.BaseMaterial.RENDERQUEUE_TRANSPARENT*/3000;
				this.depthWrite=true;
				this.cull=2;
				this.blend=1;
				this.srcBlend=0x0302;
				this.dstBlend=0x0303;
				break ;
			case 14:
				this.renderQueue=/*laya.d3.core.material.BaseMaterial.RENDERQUEUE_TRANSPARENT*/3000;
				this.depthWrite=true;
				this.cull=0;
				this.blend=1;
				this.srcBlend=0x0302;
				this.dstBlend=0x0303;
				break ;
			case 15:
				this.renderQueue=/*laya.d3.core.material.BaseMaterial.RENDERQUEUE_TRANSPARENT*/3000;
				this.depthWrite=true;
				this.cull=2;
				this.blend=1;
				this.srcBlend=0x0302;
				this.dstBlend=1;
				break ;
			case 16:
				this.renderQueue=/*laya.d3.core.material.BaseMaterial.RENDERQUEUE_TRANSPARENT*/3000;
				this.depthWrite=true;
				this.cull=0;
				this.blend=1;
				this.srcBlend=0x0302;
				this.dstBlend=1;
				break ;
			case 5:
				this.renderQueue=/*laya.d3.core.material.BaseMaterial.RENDERQUEUE_TRANSPARENT*/3000;
				this.depthWrite=false;
				this.cull=2;
				this.blend=1;
				this.srcBlend=0x0302;
				this.dstBlend=0x0303;
				break ;
			case 6:
				this.renderQueue=/*laya.d3.core.material.BaseMaterial.RENDERQUEUE_TRANSPARENT*/3000;
				this.depthWrite=false;
				this.cull=0;
				this.blend=1;
				this.srcBlend=0x0302;
				this.dstBlend=0x0303;
				break ;
			case 7:
				this.renderQueue=/*laya.d3.core.material.BaseMaterial.RENDERQUEUE_TRANSPARENT*/3000;
				this.depthWrite=false;
				this.cull=2;
				this.blend=1;
				this.srcBlend=0x0302;
				this.dstBlend=1;
				break ;
			case 8:
				this.renderQueue=/*laya.d3.core.material.BaseMaterial.RENDERQUEUE_TRANSPARENT*/3000;
				this.depthWrite=false;
				this.cull=0;
				this.blend=1;
				this.srcBlend=0x0302;
				this.dstBlend=1;
				break ;
			case 9:
				this.renderQueue=/*laya.d3.core.material.BaseMaterial.RENDERQUEUE_TRANSPARENT*/3000;
				this.depthTest=0x0201;
				this.cull=2;
				this.blend=1;
				this.srcBlend=0x0302;
				this.dstBlend=0x0303;
				break ;
			case 10:
				this.renderQueue=/*laya.d3.core.material.BaseMaterial.RENDERQUEUE_TRANSPARENT*/3000;
				this.depthTest=0x0201;
				this.cull=0;
				this.blend=1;
				this.srcBlend=0x0302;
				this.dstBlend=0x0303;
				break ;
			case 11:
				this.renderQueue=/*laya.d3.core.material.BaseMaterial.RENDERQUEUE_TRANSPARENT*/3000;
				this.depthTest=0x0201;
				this.cull=2;
				this.blend=1;
				this.srcBlend=0x0302;
				this.dstBlend=1;
				break ;
			case 12:
				this.renderQueue=/*laya.d3.core.material.BaseMaterial.RENDERQUEUE_TRANSPARENT*/3000;
				this.depthTest=0x0201;
				this.cull=0;
				this.blend=1;
				this.srcBlend=0x0302;
				this.dstBlend=1;
				break ;
			default :
				throw new Error("Material:renderMode value error.");
			}
		this._conchMaterial && this._conchMaterial.setRenderMode(value);
	});

	/**
	*设置漫反射贴图。
	*@param value 漫反射贴图。
	*/
	/**
	*获取漫反射贴图。
	*@return 漫反射贴图。
	*/
	__getset(0,__proto,'diffuseTexture',function(){
		return this._getTexture(1);
		},function(value){
		this._setTexture(1,value);
	});

	/**
	*设置反射率。
	*@param value 反射率。
	*/
	/**
	*获取反射率。
	*@return 反射率。
	*/
	__getset(0,__proto,'albedo',function(){
		return this._getColor(2);
		},function(value){
		this._setColor(2,value);
	});

	/**
	*设置颜色。
	*@param value 颜色。
	*/
	/**
	*获取颜色。
	*@return 漫反射颜色。
	*/
	__getset(0,__proto,'color',function(){
		return this._getColor(3);
		},function(value){
		this._setColor(3,value);
	});

	GlitterMaterial.load=function(url){
		return Laya.loader.create(url,null,null,GlitterMaterial);
	}

	GlitterMaterial.RENDERMODE_OPAQUE=1;
	GlitterMaterial.RENDERMODE_OPAQUEDOUBLEFACE=2;
	GlitterMaterial.RENDERMODE_TRANSPARENT=13;
	GlitterMaterial.RENDERMODE_TRANSPARENTDOUBLEFACE=14;
	GlitterMaterial.RENDERMODE_ADDTIVE=15;
	GlitterMaterial.RENDERMODE_ADDTIVEDOUBLEFACE=16;
	GlitterMaterial.RENDERMODE_DEPTHREAD_TRANSPARENT=5;
	GlitterMaterial.RENDERMODE_DEPTHREAD_TRANSPARENTDOUBLEFACE=6;
	GlitterMaterial.RENDERMODE_DEPTHREAD_ADDTIVE=7;
	GlitterMaterial.RENDERMODE_DEPTHREAD_ADDTIVEDOUBLEFACE=8;
	GlitterMaterial.RENDERMODE_NONDEPTH_TRANSPARENT=9;
	GlitterMaterial.RENDERMODE_NONDEPTH_TRANSPARENTDOUBLEFACE=10;
	GlitterMaterial.RENDERMODE_NONDEPTH_ADDTIVE=11;
	GlitterMaterial.RENDERMODE_NONDEPTH_ADDTIVEDOUBLEFACE=12;
	GlitterMaterial.DIFFUSETEXTURE=1;
	GlitterMaterial.ALBEDO=2;
	GlitterMaterial.UNICOLOR=3;
	__static(GlitterMaterial,
	['defaultMaterial',function(){return this.defaultMaterial=new GlitterMaterial();}
	]);
	return GlitterMaterial;
})(BaseMaterial)


//class laya.d3.core.material.PBRMaterial extends laya.d3.core.material.BaseMaterial
var PBRMaterial=(function(_super){
	function PBRMaterial(){
		/**@private */
		this._transformUV=null;
		PBRMaterial.__super.call(this);
		if (!laya.d3.core.material.PBRMaterial.pbrlutTex){
			var lutdt=Browser.window['__pbrlutdata'];
			if (!lutdt){
				alert('no pbr lutdata, need pbrlut.js');
				throw 'no pbr lutdata, need pbrlut.js';
			};
			var luttex=DataTexture2D.create((new Uint32Array(lutdt)).buffer,256,256,/*laya.webgl.WebGLContext.NEAREST*/0x2600,/*laya.webgl.WebGLContext.NEAREST*/0x2600,false);
			laya.d3.core.material.PBRMaterial.pbrlutTex=luttex;
		}
		this._setTexture(4,laya.d3.core.material.PBRMaterial.pbrlutTex);
		this.setShaderName("PBR");
		this._setNumber(0,0.5);
		this.use_groundtruth=false;
	}

	__class(PBRMaterial,'laya.d3.core.material.PBRMaterial',_super);
	var __proto=PBRMaterial.prototype;
	/**
	*禁用灯光。
	*/
	__proto.disableLight=function(){
		this._addDisablePublicShaderDefine(ShaderCompile3D.SHADERDEFINE_POINTLIGHT | ShaderCompile3D.SHADERDEFINE_SPOTLIGHT | ShaderCompile3D.SHADERDEFINE_DIRECTIONLIGHT);
	}

	/**
	*禁用雾化。
	*/
	__proto.disableFog=function(){
		this._addDisablePublicShaderDefine(ShaderCompile3D.SHADERDEFINE_FOG);
	}

	__proto.onAsynLoaded=function(url,data,params){
		_super.prototype.onAsynLoaded.call(this,url,data,params);
	}

	/**
	*vdc算法产生的序列。这个比random要均匀一些。
	*/
	__proto.radicalInverse_VdC=function(bits){
		var tmpUint=new Uint32Array(1);
		return (function(bits){
			bits=(bits << 16)| (bits >>> 16);
			bits=((bits & 0x55555555)<< 1)| ((bits & 0xAAAAAAAA)>>> 1);
			bits=((bits & 0x33333333)<< 2)| ((bits & 0xCCCCCCCC)>>> 2);
			bits=((bits & 0x0F0F0F0F)<< 4)| ((bits & 0xF0F0F0F0)>>> 4);
			bits=((bits & 0x00FF00FF)<< 8)| ((bits & 0xFF00FF00)>>> 8);
			tmpUint[0]=bits;
			return tmpUint[0] *2.3283064365386963e-10;
		})(bits);
	}

	/**
	*
	*/
	__proto.createHammersleyTex=function(w,h){
		var ret=new Uint8Array(w *h *4);
		var ri=0;
		var ci=0;
		for (ci=0;ci < w *h;ci++){
			var v=this.radicalInverse_VdC(ci);
			ret[ri++]=v *255;
			ret[ri++]=0;
			ret[ri++]=0;
			ret[ri++]=255;
		}
		return ret;
	}

	/**
	*设置法线贴图。
	*@param value 法线贴图。
	*/
	/**
	*获取法线贴图。
	*@return 法线贴图。
	*/
	__getset(0,__proto,'normalTexture',function(){
		return this._getTexture(2);
		},function(value){
		this._setTexture(2,value);
	});

	__getset(0,__proto,'has_tangent',null,function(v){
		this._addShaderDefine(PBRMaterial.SHADERDEFINE_HAS_TANGENT);
	});

	/**
	*设置粗糙度的值，0为特别光滑，1为特别粗糙。
	*@param value 粗糙度。
	*/
	/**
	*获取粗糙度的值，0为特别光滑，1为特别粗糙。
	*@return 粗糙度的值。
	*/
	__getset(0,__proto,'roughness',function(){
		return this._getNumber(6);
		},function(value){
		this._setNumber(6,value);
		this._addShaderDefine(PBRMaterial.SHADERDEFINE_FIX_ROUGHNESS);
	});

	__getset(0,__proto,'metaless',function(){
		return this._getNumber(7);
		},function(v){
		this._setNumber(7,v);
		this._addShaderDefine(PBRMaterial.SHADERDEFINE_FIX_METALESS);
	});

	/**
	*设置PBRLUT贴图。
	*@param value PBRLUT贴图。
	*/
	/**
	*获取PBRLUT贴图。
	*@return PBRLUT贴图。
	*/
	__getset(0,__proto,'pbrlutTexture',function(){
		return this._getTexture(4);
		},function(value){
		this._setTexture(4,value);
	});

	__getset(0,__proto,'use_groundtruth',null,function(v){
		if (v){
			this._addShaderDefine(PBRMaterial.SHADERDEFINE_USE_GROUNDTRUTH);
			if (!laya.d3.core.material.PBRMaterial.HammersleyNoiseTex){
				var texdata=this.createHammersleyTex(32,32);
				laya.d3.core.material.PBRMaterial.HammersleyNoiseTex=DataTexture2D.create(texdata.buffer,32,32,/*laya.webgl.WebGLContext.NEAREST*/0x2600,/*laya.webgl.WebGLContext.NEAREST*/0x2600,false);
			}
			this._setTexture(15,PBRMaterial.HammersleyNoiseTex);
			}else {
			laya.d3.core.material.PBRMaterial.HammersleyNoiseTex=null;
			this._removeShaderDefine(PBRMaterial.SHADERDEFINE_USE_GROUNDTRUTH);
		}
	});

	/**
	*设置UV变换。
	*@param value UV变换。
	*/
	/**
	*获取UV变换。
	*@return UV变换。
	*/
	__getset(0,__proto,'transformUV',function(){
		return this._transformUV;
		},function(value){
		this._transformUV=value;
		this._setMatrix4x4(8,value.matrix);
		if (this._conchMaterial){
			this._conchMaterial.setShaderValue(8,value.matrix.elements,0);
		}
	});

	/**
	*设置漫反射贴图。
	*@param value 漫反射贴图。
	*/
	/**
	*获取漫反射贴图。
	*@return 漫反射贴图。
	*/
	__getset(0,__proto,'diffuseTexture',function(){
		return this._getTexture(1);
		},function(value){
		this._setTexture(1,value);
	});

	__getset(0,__proto,'renderMode',null,function(value){
		switch (value){
			case 1:
				this.renderQueue=/*laya.d3.core.material.BaseMaterial.RENDERQUEUE_OPAQUE*/2000;
				this.depthWrite=true;
				this.cull=2;
				this.blend=0;
				this.alphaTest=false;
				break ;
			case 2:
				this.renderQueue=/*laya.d3.core.material.BaseMaterial.RENDERQUEUE_OPAQUE*/2000;
				this.depthWrite=true;
				this.cull=0;
				this.blend=0;
				this.alphaTest=false;
				break ;
			case 3:
				this.depthWrite=true;
				this.cull=2;
				this.blend=0;
				this.renderQueue=/*laya.d3.core.material.BaseMaterial.RENDERQUEUE_OPAQUE*/2000;
				break ;
			case 13:
				this.renderQueue=/*laya.d3.core.material.BaseMaterial.RENDERQUEUE_TRANSPARENT*/3000;
				this.depthWrite=true;
				this.cull=2;
				this.blend=1;
				this.srcBlend=0x0302;
				this.dstBlend=0x0303;
				break ;
			default :
				throw new Error("PBRMaterial:renderMode value error.");
			}
	});

	/**
	*设置pbr信息贴图。
	*@param value pbr信息贴图。
	*/
	/**
	*获取pbr信息贴图。
	*@return pbr信息贴图。
	*/
	__getset(0,__proto,'pbrInfoTexture',function(){
		return this._getTexture(3);
		},function(value){
		this._setTexture(3,value);
		this._addShaderDefine(PBRMaterial.SHADERDEFINE_HAS_PBRINFO);
	});

	__getset(0,__proto,'testClipZ',null,function(v){
		this._addShaderDefine(PBRMaterial.SHADERDEFINE_TEST_CLIPZ);
	});

	PBRMaterial.__init__=function(){
		PBRMaterial.SHADERDEFINE_FIX_METALESS=PBRMaterial.shaderDefines.registerDefine("FIX_METALESS");
		PBRMaterial.SHADERDEFINE_FIX_ROUGHNESS=PBRMaterial.shaderDefines.registerDefine("FIX_ROUGHNESS");
		PBRMaterial.SHADERDEFINE_HAS_TANGENT=PBRMaterial.shaderDefines.registerDefine("HAS_TANGENT");
		PBRMaterial.SHADERDEFINE_HAS_PBRINFO=PBRMaterial.shaderDefines.registerDefine("HAS_PBRINFO");
		PBRMaterial.SHADERDEFINE_USE_GROUNDTRUTH=PBRMaterial.shaderDefines.registerDefine("USE_GROUNDTRUTH");
		PBRMaterial.SHADERDEFINE_TEST_CLIPZ=PBRMaterial.shaderDefines.registerDefine("CLIPZ");
	}

	PBRMaterial.load=function(url){
		return Laya.loader.create(url,null,null,PBRMaterial);
	}

	PBRMaterial.DIFFUSETEXTURE=1;
	PBRMaterial.NORMALTEXTURE=2;
	PBRMaterial.PBRINFOTEXTURE=3;
	PBRMaterial.PBRLUTTEXTURE=4;
	PBRMaterial.UVANIAGE=5;
	PBRMaterial.MATERIALROUGHNESS=6;
	PBRMaterial.MATERIALMETALESS=7;
	PBRMaterial.UVMATRIX=8;
	PBRMaterial.UVAGE=9;
	PBRMaterial.AOOBJPOS=14;
	PBRMaterial.HSNOISETEXTURE=15;
	PBRMaterial.SHADERDEFINE_FIX_ROUGHNESS=0;
	PBRMaterial.SHADERDEFINE_FIX_METALESS=0;
	PBRMaterial.SHADERDEFINE_HAS_TANGENT=0;
	PBRMaterial.SHADERDEFINE_TEST_CLIPZ=0;
	PBRMaterial.SHADERDEFINE_HAS_PBRINFO=0;
	PBRMaterial.SHADERDEFINE_USE_GROUNDTRUTH=0;
	PBRMaterial.RENDERMODE_OPAQUE=1;
	PBRMaterial.RENDERMODE_OPAQUEDOUBLEFACE=2;
	PBRMaterial.RENDERMODE_CUTOUT=3;
	PBRMaterial.RENDERMODE_CUTOUTDOUBLEFACE=4;
	PBRMaterial.RENDERMODE_TRANSPARENT=13;
	PBRMaterial.pbrlutTex=null;
	PBRMaterial.HammersleyNoiseTex=null;
	__static(PBRMaterial,
	['defaultMaterial',function(){return this.defaultMaterial=new PBRMaterial();},'shaderDefines',function(){return this.shaderDefines=new ShaderDefines$1(BaseMaterial.shaderDefines);}
	]);
	return PBRMaterial;
})(BaseMaterial)


/**
*...
*@author WuTaiLang
*/
//class laya.d3.core.material.PBRSpecularMaterial extends laya.d3.core.material.BaseMaterial
var PBRSpecularMaterial=(function(_super){
	function PBRSpecularMaterial(){
		PBRSpecularMaterial.__super.call(this);
		this.setShaderName("PBRSpecular");
		this._setColor(7,new Vector4(1.0,1.0,1.0,1.0));
		this._setColor(9,new Vector4(0.0,0.0,0.0,0.0));
		this._setColor(8,new Vector4(0.2,0.2,0.2,0.2));
		this._setNumber(10,0.5);
		this._setNumber(11,1.0);
		this._setNumber(12,0);
		this._setNumber(13,1.0);
		this._setNumber(14,1.0);
		this._setNumber(15,0.001);
		this._setBool(16,false);
		this._setNumber(0,0.5);
	}

	__class(PBRSpecularMaterial,'laya.d3.core.material.PBRSpecularMaterial',_super);
	var __proto=PBRSpecularMaterial.prototype;
	/**
	*设置漫反射颜色。
	*@param value 漫反射颜色。
	*/
	/**
	*获取漫反射颜色。
	*@return 漫反射颜色。
	*/
	__getset(0,__proto,'albedoColor',function(){
		return this._getColor(7);
		},function(value){
		this._setColor(7,value);
	});

	/**
	*设置高光贴图。
	*@param value 高光贴图。
	*/
	/**
	*获取高光贴图。
	*@return 高光贴图。
	*/
	__getset(0,__proto,'specularTexture',function(){
		return this._getTexture(2);
		},function(value){
		if (value)
			this._addShaderDefine(laya.d3.core.material.PBRSpecularMaterial.SHADERDEFINE_SPECULARTEXTURE);
		else
		this._removeShaderDefine(laya.d3.core.material.PBRSpecularMaterial.SHADERDEFINE_SPECULARTEXTURE);
		this._setTexture(2,value);
	});

	/**
	*设置漫反射贴图。
	*@param value 漫反射贴图。
	*/
	/**
	*获取漫反射贴图。
	*@return 漫反射贴图。
	*/
	__getset(0,__proto,'albedoTexture',function(){
		return this._getTexture(1);
		},function(value){
		if (value)
			this._addShaderDefine(laya.d3.core.material.PBRSpecularMaterial.SHADERDEFINE_DIFFUSETEXTURE);
		else
		this._removeShaderDefine(laya.d3.core.material.PBRSpecularMaterial.SHADERDEFINE_DIFFUSETEXTURE);
		this._setTexture(1,value);
	});

	/**
	*设置遮挡贴图。
	*@param value 遮挡贴图。
	*/
	/**
	*获取遮挡贴图。
	*@return 遮挡贴图。
	*/
	__getset(0,__proto,'occlusionTexture',function(){
		return this._getTexture(5);
		},function(value){
		if (value)
			this._addShaderDefine(laya.d3.core.material.PBRSpecularMaterial.SHADERDEFINE_OCCLUSIONTEXTURE);
		else
		this._removeShaderDefine(laya.d3.core.material.PBRSpecularMaterial.SHADERDEFINE_OCCLUSIONTEXTURE);
		this._setTexture(5,value);
	});

	/**
	*设置法线贴图。
	*@param value 法线贴图。
	*/
	/**
	*获取法线贴图。
	*@return 法线贴图。
	*/
	__getset(0,__proto,'normalTexture',function(){
		return this._getTexture(3);
		},function(value){
		if (value)
			this._addShaderDefine(laya.d3.core.material.PBRSpecularMaterial.SHADERDEFINE_NORMALTEXTURE);
		else
		this._removeShaderDefine(laya.d3.core.material.PBRSpecularMaterial.SHADERDEFINE_NORMALTEXTURE);
		this._setTexture(3,value);
	});

	/**
	*设置视差贴图。
	*@param value 视察贴图。
	*/
	/**
	*获取视差贴图。
	*@return 视察贴图。
	*/
	__getset(0,__proto,'parallaxTexture',function(){
		return this._getTexture(4);
		},function(value){
		if (value)
			this._addShaderDefine(laya.d3.core.material.PBRSpecularMaterial.SHADERDEFINE_PARALLAXTEXTURE);
		else
		this._removeShaderDefine(laya.d3.core.material.PBRSpecularMaterial.SHADERDEFINE_PARALLAXTEXTURE);
		this._setTexture(4,value);
	});

	/**
	*设置放射颜色。
	*@param value 放射颜色。
	*/
	/**
	*获取放射颜色。
	*@return 放射颜色。
	*/
	__getset(0,__proto,'emissionColor',function(){
		return this._getColor(9);
		},function(value){
		this._setColor(9,value);
	});

	/**
	*设置法线贴图缩放系数。
	*@param value 法线贴图缩放系数。
	*/
	/**
	*获取法线贴图缩放系数。
	*@return 法线贴图缩放系数。
	*/
	__getset(0,__proto,'normalTextureScale',function(){
		return this._getNumber(14);
		},function(value){
		this._setNumber(14,value);
	});

	/**
	*设置视差贴图缩放系数。
	*@param value 视差缩放系数。
	*/
	/**
	*获取视差贴图缩放系数。
	*@return 视差缩放系数。
	*/
	__getset(0,__proto,'parallaxTextureScale',function(){
		return this._getNumber(15);
		},function(value){
		value=Math.max(0.005,Math.min(0.08,value));
		this._setNumber(15,value);
	});

	/**
	*设置遮挡贴图强度。
	*@param value 遮挡贴图强度,范围为0到1。
	*/
	/**
	*获取遮挡贴图强度。
	*@return 遮挡贴图强度,范围为0到1。
	*/
	__getset(0,__proto,'occlusionTextureStrength',function(){
		return this._getNumber(13);
		},function(value){
		value=Math.max(0.0,Math.min(1.0,value));
		this._setNumber(13,value);
	});

	/**
	*设置高光颜色。
	*@param value 高光颜色。
	*/
	/**
	*获取高光颜色。
	*@return 高光颜色。
	*/
	__getset(0,__proto,'specularColor',function(){
		return this._getColor(8);
		},function(value){
		this._setColor(8,value);
	});

	/**
	*设置光滑度。
	*@param value 光滑度,范围为0到1。
	*/
	/**
	*获取光滑度。
	*@return 光滑度,范围为0到1。
	*/
	__getset(0,__proto,'smoothness',function(){
		return this._getNumber(10);
		},function(value){
		value=Math.max(0.0,Math.min(1.0,value));
		this._setNumber(10,value);
	});

	/**
	*设置光滑度缩放系数。
	*@param value 光滑度缩放系数,范围为0到1。
	*/
	/**
	*获取光滑度缩放系数。
	*@return 光滑度缩放系数,范围为0到1。
	*/
	__getset(0,__proto,'smoothnessTextureScale',function(){
		return this._getNumber(11);
		},function(value){
		value=Math.max(0.0,Math.min(1.0,value));
		this._setNumber(11,value);
	});

	/**
	*设置光滑度数据源。
	*@param value 光滑滑度数据源,0或1。
	*/
	/**
	*获取光滑度数据源
	*@return 光滑滑度数据源,0或1。
	*/
	__getset(0,__proto,'smoothnessSource',function(){
		return this._getNumber(12);
		},function(value){
		if (value==1)
			this._addShaderDefine(laya.d3.core.material.PBRSpecularMaterial.SHADERDEFINE_SMOOTHNESSSOURCE_DIFFUSETEXTURE_ALPHA);
		else{
			this._removeShaderDefine(laya.d3.core.material.PBRSpecularMaterial.SHADERDEFINE_SMOOTHNESSSOURCE_DIFFUSETEXTURE_ALPHA);
			value=0;
		}
		this._setNumber(12,value);
	});

	/**
	*设置是否激活放射属性。
	*@param value 是否激活放射属性
	*/
	/**
	*获取是否激活放射属性。
	*@return 是否激活放射属性。
	*/
	__getset(0,__proto,'enableEmission',function(){
		return this._getBool(16);
		},function(value){
		if (value)
			this._addShaderDefine(laya.d3.core.material.PBRSpecularMaterial.SHADERDEFINE_EMISSION);
		else{
			this._removeShaderDefine(laya.d3.core.material.PBRSpecularMaterial.SHADERDEFINE_EMISSION);
		}
		this._setBool(16,value);
	});

	/**
	*设置放射贴图。
	*@param value 放射贴图。
	*/
	/**
	*获取放射贴图。
	*@return 放射贴图。
	*/
	__getset(0,__proto,'emissionTexture',function(){
		return this._getTexture(6);
		},function(value){
		if (value)
			this._addShaderDefine(laya.d3.core.material.PBRSpecularMaterial.SHADERDEFINE_EMISSIONTEXTURE);
		else
		this._removeShaderDefine(laya.d3.core.material.PBRSpecularMaterial.SHADERDEFINE_EMISSIONTEXTURE);
		this._setTexture(6,value);
	});

	/**
	*设置纹理平铺和偏移。
	*@param value 纹理平铺和偏移。
	*/
	/**
	*获取纹理平铺和偏移。
	*@return 纹理平铺和偏移。
	*/
	__getset(0,__proto,'tilingOffset',function(){
		return this._getColor(17);
		},function(value){
		if (value){
			var valueE=value.elements;
			if (valueE[0] !=1 || valueE[1] !=1 || valueE[2] !=0 || valueE[3] !=0)
				this._addShaderDefine(laya.d3.core.material.PBRSpecularMaterial.SHADERDEFINE_TILINGOFFSET);
			else
			this._removeShaderDefine(laya.d3.core.material.PBRSpecularMaterial.SHADERDEFINE_TILINGOFFSET);
			}else {
			this._removeShaderDefine(laya.d3.core.material.PBRSpecularMaterial.SHADERDEFINE_TILINGOFFSET);
		}
		this._setColor(17,value);
	});

	PBRSpecularMaterial.__init__=function(){
		PBRSpecularMaterial.SHADERDEFINE_DIFFUSETEXTURE=PBRSpecularMaterial.shaderDefines.registerDefine("DIFFUSETEXTURE");
		PBRSpecularMaterial.SHADERDEFINE_SPECULARTEXTURE=PBRSpecularMaterial.shaderDefines.registerDefine("SPECULARTEXTURE");
		PBRSpecularMaterial.SHADERDEFINE_SMOOTHNESSSOURCE_DIFFUSETEXTURE_ALPHA=PBRSpecularMaterial.shaderDefines.registerDefine("SMOOTHNESSSOURCE_DIFFUSETEXTURE_ALPHA");
		PBRSpecularMaterial.SHADERDEFINE_NORMALTEXTURE=PBRSpecularMaterial.shaderDefines.registerDefine("NORMALTEXTURE");
		PBRSpecularMaterial.SHADERDEFINE_PARALLAXTEXTURE=PBRSpecularMaterial.shaderDefines.registerDefine("PARALLAXTEXTURE");
		PBRSpecularMaterial.SHADERDEFINE_OCCLUSIONTEXTURE=PBRSpecularMaterial.shaderDefines.registerDefine("OCCLUSIONTEXTURE");
		PBRSpecularMaterial.SHADERDEFINE_EMISSION=PBRSpecularMaterial.shaderDefines.registerDefine("EMISSION");
		PBRSpecularMaterial.SHADERDEFINE_EMISSIONTEXTURE=PBRSpecularMaterial.shaderDefines.registerDefine("EMISSIONTEXTURE");
		PBRSpecularMaterial.SHADERDEFINE_TILINGOFFSET=PBRSpecularMaterial.shaderDefines.registerDefine("TILINGOFFSET");
	}

	PBRSpecularMaterial.SmoothnessSource_MetallicGlossTexture_Alpha=0;
	PBRSpecularMaterial.SmoothnessSource_DiffuseTexture_Alpha=1;
	PBRSpecularMaterial.SHADERDEFINE_DIFFUSETEXTURE=0;
	PBRSpecularMaterial.SHADERDEFINE_NORMALTEXTURE=0;
	PBRSpecularMaterial.SHADERDEFINE_SMOOTHNESSSOURCE_DIFFUSETEXTURE_ALPHA=0;
	PBRSpecularMaterial.SHADERDEFINE_SPECULARTEXTURE=0;
	PBRSpecularMaterial.SHADERDEFINE_OCCLUSIONTEXTURE=0;
	PBRSpecularMaterial.SHADERDEFINE_PARALLAXTEXTURE=0;
	PBRSpecularMaterial.SHADERDEFINE_EMISSION=0;
	PBRSpecularMaterial.SHADERDEFINE_EMISSIONTEXTURE=0;
	PBRSpecularMaterial.SHADERDEFINE_TILINGOFFSET=0;
	PBRSpecularMaterial.DIFFUSETEXTURE=1;
	PBRSpecularMaterial.SPECULARTEXTURE=2;
	PBRSpecularMaterial.NORMALTEXTURE=3;
	PBRSpecularMaterial.PARALLAXTEXTURE=4;
	PBRSpecularMaterial.OCCLUSIONTEXTURE=5;
	PBRSpecularMaterial.EMISSIONTEXTURE=6;
	PBRSpecularMaterial.DIFFUSECOLOR=7;
	PBRSpecularMaterial.SPECULARCOLOR=8;
	PBRSpecularMaterial.EMISSIONCOLOR=9;
	PBRSpecularMaterial.SMOOTHNESS=10;
	PBRSpecularMaterial.SMOOTHNESSSCALE=11;
	PBRSpecularMaterial.SMOOTHNESSSOURCE=12;
	PBRSpecularMaterial.OCCLUSIONSTRENGTH=13;
	PBRSpecularMaterial.NORMALSCALE=14;
	PBRSpecularMaterial.PARALLAXSCALE=15;
	PBRSpecularMaterial.ENABLEEMISSION=16;
	PBRSpecularMaterial.TILINGOFFSET=17;
	__static(PBRSpecularMaterial,
	['shaderDefines',function(){return this.shaderDefines=new ShaderDefines$1(BaseMaterial.shaderDefines);}
	]);
	return PBRSpecularMaterial;
})(BaseMaterial)


/**
*...
*@author WuTaiLang
*/
//class laya.d3.core.material.PBRStandardMaterial extends laya.d3.core.material.BaseMaterial
var PBRStandardMaterial=(function(_super){
	function PBRStandardMaterial(){
		PBRStandardMaterial.__super.call(this);
		this.setShaderName("PBRStandard");
		this._setColor(7,new Vector4(1.0,1.0,1.0,1.0));
		this._setColor(8,new Vector4(0.0,0.0,0.0,0.0));
		this._setNumber(9,0.0);
		this._setNumber(10,0.5);
		this._setNumber(11,1.0);
		this._setNumber(12,0);
		this._setNumber(13,1.0);
		this._setNumber(14,1.0);
		this._setNumber(15,0.001);
		this._setBool(16,false);
		this._setNumber(0,0.5);
	}

	__class(PBRStandardMaterial,'laya.d3.core.material.PBRStandardMaterial',_super);
	var __proto=PBRStandardMaterial.prototype;
	/**
	*设置漫反射颜色。
	*@param value 漫反射颜色。
	*/
	/**
	*获取漫反射颜色。
	*@return 漫反射颜色。
	*/
	__getset(0,__proto,'albedoColor',function(){
		return this._getColor(7);
		},function(value){
		this._setColor(7,value);
	});

	/**
	*设置漫反射贴图。
	*@param value 漫反射贴图。
	*/
	/**
	*获取漫反射贴图。
	*@return 漫反射贴图。
	*/
	__getset(0,__proto,'albedoTexture',function(){
		return this._getTexture(1);
		},function(value){
		if (value)
			this._addShaderDefine(laya.d3.core.material.PBRStandardMaterial.SHADERDEFINE_DIFFUSETEXTURE);
		else
		this._removeShaderDefine(laya.d3.core.material.PBRStandardMaterial.SHADERDEFINE_DIFFUSETEXTURE);
		this._setTexture(1,value);
	});

	/**
	*设置是否激活放射属性。
	*@param value 是否激活放射属性
	*/
	/**
	*获取是否激活放射属性。
	*@return 是否激活放射属性。
	*/
	__getset(0,__proto,'enableEmission',function(){
		return this._getBool(16);
		},function(value){
		if (value)
			this._addShaderDefine(laya.d3.core.material.PBRStandardMaterial.SHADERDEFINE_EMISSION);
		else {
			this._removeShaderDefine(laya.d3.core.material.PBRStandardMaterial.SHADERDEFINE_EMISSION);
		}
		this._setBool(16,value);
	});

	/**
	*设置金属光滑度贴图。
	*@param value 金属光滑度贴图。
	*/
	/**
	*获取金属光滑度贴图。
	*@return 金属光滑度贴图。
	*/
	__getset(0,__proto,'metallicGlossTexture',function(){
		return this._getTexture(2);
		},function(value){
		if (value)
			this._addShaderDefine(laya.d3.core.material.PBRStandardMaterial.SHADERDEFINE_METALLICGLOSSTEXTURE);
		else
		this._removeShaderDefine(laya.d3.core.material.PBRStandardMaterial.SHADERDEFINE_METALLICGLOSSTEXTURE);
		this._setTexture(2,value);
	});

	/**
	*设置遮挡贴图。
	*@param value 遮挡贴图。
	*/
	/**
	*获取遮挡贴图。
	*@return 遮挡贴图。
	*/
	__getset(0,__proto,'occlusionTexture',function(){
		return this._getTexture(5);
		},function(value){
		if (value)
			this._addShaderDefine(laya.d3.core.material.PBRStandardMaterial.SHADERDEFINE_OCCLUSIONTEXTURE);
		else
		this._removeShaderDefine(laya.d3.core.material.PBRStandardMaterial.SHADERDEFINE_OCCLUSIONTEXTURE);
		this._setTexture(5,value);
	});

	/**
	*设置法线贴图。
	*@param value 法线贴图。
	*/
	/**
	*获取法线贴图。
	*@return 法线贴图。
	*/
	__getset(0,__proto,'normalTexture',function(){
		return this._getTexture(3);
		},function(value){
		if (value)
			this._addShaderDefine(laya.d3.core.material.PBRStandardMaterial.SHADERDEFINE_NORMALTEXTURE);
		else
		this._removeShaderDefine(laya.d3.core.material.PBRStandardMaterial.SHADERDEFINE_NORMALTEXTURE);
		this._setTexture(3,value);
	});

	/**
	*设置视差贴图。
	*@param value 视察贴图。
	*/
	/**
	*获取视差贴图。
	*@return 视察贴图。
	*/
	__getset(0,__proto,'parallaxTexture',function(){
		return this._getTexture(4);
		},function(value){
		if (value)
			this._addShaderDefine(laya.d3.core.material.PBRStandardMaterial.SHADERDEFINE_PARALLAXTEXTURE);
		else
		this._removeShaderDefine(laya.d3.core.material.PBRStandardMaterial.SHADERDEFINE_PARALLAXTEXTURE);
		this._setTexture(4,value);
	});

	/**
	*设置放射颜色。
	*@param value 放射颜色。
	*/
	/**
	*获取放射颜色。
	*@return 放射颜色。
	*/
	__getset(0,__proto,'emissionColor',function(){
		return this._getColor(8);
		},function(value){
		this._setColor(8,value);
	});

	/**
	*设置法线贴图缩放系数。
	*@param value 法线贴图缩放系数。
	*/
	/**
	*获取法线贴图缩放系数。
	*@return 法线贴图缩放系数。
	*/
	__getset(0,__proto,'normalTextureScale',function(){
		return this._getNumber(14);
		},function(value){
		this._setNumber(14,value);
	});

	/**
	*设置视差贴图缩放系数。
	*@param value 视差缩放系数。
	*/
	/**
	*获取视差贴图缩放系数。
	*@return 视差缩放系数。
	*/
	__getset(0,__proto,'parallaxTextureScale',function(){
		return this._getNumber(15);
		},function(value){
		value=Math.max(0.005,Math.min(0.08,value));
		this._setNumber(15,value);
	});

	/**
	*设置遮挡贴图强度。
	*@param value 遮挡贴图强度,范围为0到1。
	*/
	/**
	*获取遮挡贴图强度。
	*@return 遮挡贴图强度,范围为0到1。
	*/
	__getset(0,__proto,'occlusionTextureStrength',function(){
		return this._getNumber(13);
		},function(value){
		value=Math.max(0.0,Math.min(1.0,value));
		this._setNumber(13,value);
	});

	/**
	*设置金属度。
	*@param value 金属度,范围为0到1。
	*/
	/**
	*获取金属度。
	*@return 金属度,范围为0到1。
	*/
	__getset(0,__proto,'metallic',function(){
		return this._getNumber(9);
		},function(value){
		value=Math.max(0.0,Math.min(1.0,value));
		this._setNumber(9,value);
	});

	/**
	*设置光滑度。
	*@param value 光滑度,范围为0到1。
	*/
	/**
	*获取光滑度。
	*@return 光滑度,范围为0到1。
	*/
	__getset(0,__proto,'smoothness',function(){
		return this._getNumber(10);
		},function(value){
		value=Math.max(0.0,Math.min(1.0,value));
		this._setNumber(10,value);
	});

	/**
	*设置光滑度缩放系数。
	*@param value 光滑度缩放系数,范围为0到1。
	*/
	/**
	*获取光滑度缩放系数。
	*@return 光滑度缩放系数,范围为0到1。
	*/
	__getset(0,__proto,'smoothnessTextureScale',function(){
		return this._getNumber(11);
		},function(value){
		value=Math.max(0.0,Math.min(1.0,value));
		this._setNumber(11,value);
	});

	/**
	*设置光滑度数据源。
	*@param value 光滑滑度数据源,0或1。
	*/
	/**
	*获取光滑度数据源
	*@return 光滑滑度数据源,0或1。
	*/
	__getset(0,__proto,'smoothnessSource',function(){
		return this._getNumber(12);
		},function(value){
		if (value==1)
			this._addShaderDefine(laya.d3.core.material.PBRStandardMaterial.SHADERDEFINE_SMOOTHNESSSOURCE_DIFFUSETEXTURE_ALPHA);
		else {
			this._removeShaderDefine(laya.d3.core.material.PBRStandardMaterial.SHADERDEFINE_SMOOTHNESSSOURCE_DIFFUSETEXTURE_ALPHA);
			value=0;
		}
		this._setNumber(12,value);
	});

	/**
	*设置放射贴图。
	*@param value 放射贴图。
	*/
	/**
	*获取放射贴图。
	*@return 放射贴图。
	*/
	__getset(0,__proto,'emissionTexture',function(){
		return this._getTexture(6);
		},function(value){
		if (value)
			this._addShaderDefine(laya.d3.core.material.PBRStandardMaterial.SHADERDEFINE_EMISSIONTEXTURE);
		else
		this._removeShaderDefine(laya.d3.core.material.PBRStandardMaterial.SHADERDEFINE_EMISSIONTEXTURE);
		this._setTexture(6,value);
	});

	/**
	*设置纹理平铺和偏移。
	*@param value 纹理平铺和偏移。
	*/
	/**
	*获取纹理平铺和偏移。
	*@return 纹理平铺和偏移。
	*/
	__getset(0,__proto,'tilingOffset',function(){
		return this._getColor(17);
		},function(value){
		if (value){
			var valueE=value.elements;
			if (valueE[0] !=1 || valueE[1] !=1 || valueE[2] !=0 || valueE[3] !=0)
				this._addShaderDefine(laya.d3.core.material.PBRStandardMaterial.SHADERDEFINE_TILINGOFFSET);
			else
			this._removeShaderDefine(laya.d3.core.material.PBRStandardMaterial.SHADERDEFINE_TILINGOFFSET);
			}else {
			this._removeShaderDefine(laya.d3.core.material.PBRStandardMaterial.SHADERDEFINE_TILINGOFFSET);
		}
		this._setColor(17,value);
	});

	PBRStandardMaterial.__init__=function(){
		PBRStandardMaterial.SHADERDEFINE_DIFFUSETEXTURE=PBRStandardMaterial.shaderDefines.registerDefine("DIFFUSETEXTURE");
		PBRStandardMaterial.SHADERDEFINE_METALLICGLOSSTEXTURE=PBRStandardMaterial.shaderDefines.registerDefine("METALLICGLOSSTEXTURE");
		PBRStandardMaterial.SHADERDEFINE_SMOOTHNESSSOURCE_DIFFUSETEXTURE_ALPHA=PBRStandardMaterial.shaderDefines.registerDefine("SMOOTHNESSSOURCE_DIFFUSETEXTURE_ALPHA");
		PBRStandardMaterial.SHADERDEFINE_NORMALTEXTURE=PBRStandardMaterial.shaderDefines.registerDefine("NORMALTEXTURE");
		PBRStandardMaterial.SHADERDEFINE_PARALLAXTEXTURE=PBRStandardMaterial.shaderDefines.registerDefine("PARALLAXTEXTURE");
		PBRStandardMaterial.SHADERDEFINE_OCCLUSIONTEXTURE=PBRStandardMaterial.shaderDefines.registerDefine("OCCLUSIONTEXTURE");
		PBRStandardMaterial.SHADERDEFINE_EMISSION=PBRStandardMaterial.shaderDefines.registerDefine("EMISSION");
		PBRStandardMaterial.SHADERDEFINE_EMISSIONTEXTURE=PBRStandardMaterial.shaderDefines.registerDefine("EMISSIONTEXTURE");
		PBRStandardMaterial.SHADERDEFINE_TILINGOFFSET=PBRStandardMaterial.shaderDefines.registerDefine("TILINGOFFSET");
	}

	PBRStandardMaterial.SmoothnessSource_MetallicGlossTexture_Alpha=0;
	PBRStandardMaterial.SmoothnessSource_DiffuseTexture_Alpha=1;
	PBRStandardMaterial.SHADERDEFINE_DIFFUSETEXTURE=0;
	PBRStandardMaterial.SHADERDEFINE_NORMALTEXTURE=0;
	PBRStandardMaterial.SHADERDEFINE_SMOOTHNESSSOURCE_DIFFUSETEXTURE_ALPHA=0;
	PBRStandardMaterial.SHADERDEFINE_METALLICGLOSSTEXTURE=0;
	PBRStandardMaterial.SHADERDEFINE_OCCLUSIONTEXTURE=0;
	PBRStandardMaterial.SHADERDEFINE_PARALLAXTEXTURE=0;
	PBRStandardMaterial.SHADERDEFINE_EMISSION=0;
	PBRStandardMaterial.SHADERDEFINE_EMISSIONTEXTURE=0;
	PBRStandardMaterial.SHADERDEFINE_TILINGOFFSET=0;
	PBRStandardMaterial.DIFFUSETEXTURE=1;
	PBRStandardMaterial.METALLICGLOSSTEXTURE=2;
	PBRStandardMaterial.NORMALTEXTURE=3;
	PBRStandardMaterial.PARALLAXTEXTURE=4;
	PBRStandardMaterial.OCCLUSIONTEXTURE=5;
	PBRStandardMaterial.EMISSIONTEXTURE=6;
	PBRStandardMaterial.DIFFUSECOLOR=7;
	PBRStandardMaterial.EMISSIONCOLOR=8;
	PBRStandardMaterial.METALLIC=9;
	PBRStandardMaterial.SMOOTHNESS=10;
	PBRStandardMaterial.SMOOTHNESSSCALE=11;
	PBRStandardMaterial.SMOOTHNESSSOURCE=12;
	PBRStandardMaterial.OCCLUSIONSTRENGTH=13;
	PBRStandardMaterial.NORMALSCALE=14;
	PBRStandardMaterial.PARALLAXSCALE=15;
	PBRStandardMaterial.ENABLEEMISSION=16;
	PBRStandardMaterial.TILINGOFFSET=17;
	__static(PBRStandardMaterial,
	['shaderDefines',function(){return this.shaderDefines=new ShaderDefines$1(BaseMaterial.shaderDefines);}
	]);
	return PBRStandardMaterial;
})(BaseMaterial)


/**
*...
*@author ...
*/
//class laya.d3.core.material.StandardMaterial extends laya.d3.core.material.BaseMaterial
var StandardMaterial=(function(_super){
	function StandardMaterial(){
		/**@private */
		this._transformUV=null;
		StandardMaterial.__super.call(this);
		this.setShaderName("SIMPLE");
		this._setColor(9,new Vector3(0.6,0.6,0.6));
		this._setColor(10,new Vector3(1.0,1.0,1.0));
		this._setColor(11,new Vector4(1.0,1.0,1.0,8.0));
		this._setColor(12,new Vector3(1.0,1.0,1.0));
		this._setColor(7,new Vector4(1.0,1.0,1.0,1.0));
		this._setNumber(0,0.5);
		this._setColor(15,new Vector4(1.0,1.0,0.0,0.0));
		this.renderMode=1;
	}

	__class(StandardMaterial,'laya.d3.core.material.StandardMaterial',_super);
	var __proto=StandardMaterial.prototype;
	/**
	*禁用灯光。
	*/
	__proto.disableLight=function(){
		this._addDisablePublicShaderDefine(ShaderCompile3D.SHADERDEFINE_POINTLIGHT | ShaderCompile3D.SHADERDEFINE_SPOTLIGHT | ShaderCompile3D.SHADERDEFINE_DIRECTIONLIGHT);
	}

	/**
	*禁用雾化。
	*/
	__proto.disableFog=function(){
		this._addDisablePublicShaderDefine(ShaderCompile3D.SHADERDEFINE_FOG);
	}

	/**
	*@inheritDoc
	*/
	__proto.onAsynLoaded=function(url,data,params){
		var jsonData=data[0];
		if (jsonData.version){
			_super.prototype.onAsynLoaded.call(this,url,data,params);
			}else {
			var textureMap=data[1];
			var props=jsonData.props;
			for (var prop in props)
			this[prop]=props[prop];
			StandardMaterial._parseStandardMaterial(textureMap,this,jsonData);
			this._endLoaded();
		}
	}

	/**
	*@inheritDoc
	*/
	__proto.cloneTo=function(destObject){
		_super.prototype.cloneTo.call(this,destObject);
		var dest=destObject;
		(this._transformUV)&& (dest._transformUV=this._transformUV.clone());
	}

	/**
	*设置环境光颜色。
	*@param value 环境光颜色。
	*/
	__getset(0,__proto,'ambientColor',function(){
		return this._getColor(9);
		},function(value){
		this._setColor(9,value);
	});

	/**
	*设置环境贴图。
	*@param value 环境贴图。
	*/
	/**
	*获取环境贴图。
	*@return 环境贴图。
	*/
	__getset(0,__proto,'ambientTexture',function(){
		return this._getTexture(5);
		},function(value){
		if (value){
			this._addShaderDefine(laya.d3.core.material.StandardMaterial.SHADERDEFINE_AMBIENTMAP);
			}else {
			this._removeShaderDefine(laya.d3.core.material.StandardMaterial.SHADERDEFINE_AMBIENTMAP);
		}
		this._setTexture(5,value);
	});

	/**
	*设置渲染模式。
	*@return 渲染模式。
	*/
	__getset(0,__proto,'renderMode',null,function(value){
		switch (value){
			case 1:
				this.renderQueue=/*laya.d3.core.material.BaseMaterial.RENDERQUEUE_OPAQUE*/2000;
				this.depthWrite=true;
				this.cull=2;
				this.blend=0;
				this.alphaTest=false;
				this._removeShaderDefine(StandardMaterial.SHADERDEFINE_ADDTIVEFOG);
				break ;
			case 2:
				this.renderQueue=/*laya.d3.core.material.BaseMaterial.RENDERQUEUE_OPAQUE*/2000;
				this.depthWrite=true;
				this.cull=0;
				this.blend=0;
				this.alphaTest=false;
				this._removeShaderDefine(StandardMaterial.SHADERDEFINE_ADDTIVEFOG);
				break ;
			case 3:
				this.depthWrite=true;
				this.cull=2;
				this.blend=0;
				this.renderQueue=/*laya.d3.core.material.BaseMaterial.RENDERQUEUE_OPAQUE*/2000;
				this.alphaTest=true;
				this._removeShaderDefine(StandardMaterial.SHADERDEFINE_ADDTIVEFOG);
				break ;
			case 4:
				this.renderQueue=/*laya.d3.core.material.BaseMaterial.RENDERQUEUE_OPAQUE*/2000;
				this.depthWrite=true;
				this.cull=0;
				this.blend=0;
				this.alphaTest=true;
				this._removeShaderDefine(StandardMaterial.SHADERDEFINE_ADDTIVEFOG);
				break ;
			case 13:
				this.renderQueue=/*laya.d3.core.material.BaseMaterial.RENDERQUEUE_TRANSPARENT*/3000;
				this.depthWrite=true;
				this.cull=2;
				this.blend=1;
				this.srcBlend=0x0302;
				this.dstBlend=0x0303;
				this.alphaTest=false;
				this._removeShaderDefine(StandardMaterial.SHADERDEFINE_ADDTIVEFOG);
				break ;
			case 14:
				this.renderQueue=/*laya.d3.core.material.BaseMaterial.RENDERQUEUE_TRANSPARENT*/3000;
				this.depthWrite=true;
				this.cull=0;
				this.blend=1;
				this.srcBlend=0x0302;
				this.dstBlend=0x0303;
				this.alphaTest=false;
				this._removeShaderDefine(StandardMaterial.SHADERDEFINE_ADDTIVEFOG);
				break ;
			case 15:
				this.renderQueue=/*laya.d3.core.material.BaseMaterial.RENDERQUEUE_TRANSPARENT*/3000;
				this.depthWrite=true;
				this.cull=2;
				this.blend=1;
				this.srcBlend=0x0302;
				this.dstBlend=1;
				this.alphaTest=false;
				this._addShaderDefine(StandardMaterial.SHADERDEFINE_ADDTIVEFOG);
				break ;
			case 16:
				this.renderQueue=/*laya.d3.core.material.BaseMaterial.RENDERQUEUE_TRANSPARENT*/3000;
				this.depthWrite=true;
				this.cull=0;
				this.blend=1;
				this.srcBlend=0x0302;
				this.dstBlend=1;
				this.alphaTest=false;
				this._addShaderDefine(StandardMaterial.SHADERDEFINE_ADDTIVEFOG);
				break ;
			case 5:
				this.renderQueue=/*laya.d3.core.material.BaseMaterial.RENDERQUEUE_TRANSPARENT*/3000;
				this.depthWrite=false;
				this.cull=2;
				this.blend=1;
				this.srcBlend=0x0302;
				this.dstBlend=0x0303;
				this.alphaTest=false;
				this._removeShaderDefine(StandardMaterial.SHADERDEFINE_ADDTIVEFOG);
				break ;
			case 6:
				this.renderQueue=/*laya.d3.core.material.BaseMaterial.RENDERQUEUE_TRANSPARENT*/3000;
				this.depthWrite=false;
				this.cull=0;
				this.blend=1;
				this.srcBlend=0x0302;
				this.dstBlend=0x0303;
				this.alphaTest=false;
				this._removeShaderDefine(StandardMaterial.SHADERDEFINE_ADDTIVEFOG);
				break ;
			case 7:
				this.renderQueue=/*laya.d3.core.material.BaseMaterial.RENDERQUEUE_TRANSPARENT*/3000;
				this.depthWrite=false;
				this.cull=2;
				this.blend=1;
				this.srcBlend=0x0302;
				this.dstBlend=1;
				this.alphaTest=false;
				this._addShaderDefine(StandardMaterial.SHADERDEFINE_ADDTIVEFOG);
				break ;
			case 8:
				this.renderQueue=/*laya.d3.core.material.BaseMaterial.RENDERQUEUE_TRANSPARENT*/3000;
				this.depthWrite=false;
				this.cull=0;
				this.blend=1;
				this.srcBlend=0x0302;
				this.dstBlend=1;
				this.alphaTest=false;
				this._addShaderDefine(StandardMaterial.SHADERDEFINE_ADDTIVEFOG);
				break ;
			case 9:
				this.renderQueue=/*laya.d3.core.material.BaseMaterial.RENDERQUEUE_TRANSPARENT*/3000;
				this.depthTest=0x0201;
				this.cull=2;
				this.blend=1;
				this.srcBlend=0x0302;
				this.dstBlend=0x0303;
				this.alphaTest=false;
				this._removeShaderDefine(StandardMaterial.SHADERDEFINE_ADDTIVEFOG);
				break ;
			case 10:
				this.renderQueue=/*laya.d3.core.material.BaseMaterial.RENDERQUEUE_TRANSPARENT*/3000;
				this.depthTest=0x0201;
				this.cull=0;
				this.blend=1;
				this.srcBlend=0x0302;
				this.dstBlend=0x0303;
				this.alphaTest=false;
				this._removeShaderDefine(StandardMaterial.SHADERDEFINE_ADDTIVEFOG);
				break ;
			case 11:
				this.renderQueue=/*laya.d3.core.material.BaseMaterial.RENDERQUEUE_TRANSPARENT*/3000;
				this.depthTest=0x0201;
				this.cull=2;
				this.blend=1;
				this.srcBlend=0x0302;
				this.dstBlend=1;
				this.alphaTest=false;
				this._addShaderDefine(StandardMaterial.SHADERDEFINE_ADDTIVEFOG);
				break ;
			case 12:
				this.renderQueue=/*laya.d3.core.material.BaseMaterial.RENDERQUEUE_TRANSPARENT*/3000;
				this.depthTest=0x0201;
				this.cull=0;
				this.blend=1;
				this.srcBlend=0x0302;
				this.dstBlend=1;
				this.alphaTest=false;
				this._addShaderDefine(StandardMaterial.SHADERDEFINE_ADDTIVEFOG);
				break ;
			default :
				throw new Error("Material:renderMode value error.");
			}
		this._conchMaterial && this._conchMaterial.setRenderMode(value);
	});

	/**
	*设置反射颜色。
	*@param value 反射颜色。
	*/
	__getset(0,__proto,'reflectColor',function(){
		return this._getColor(12);
		},function(value){
		this._setColor(12,value);
	});

	/**
	*获取纹理平铺和偏移。
	*@param value 纹理平铺和偏移。
	*/
	/**
	*获取纹理平铺和偏移。
	*@return 纹理平铺和偏移。
	*/
	__getset(0,__proto,'tilingOffset',function(){
		return this._getColor(15);
		},function(value){
		if (value){
			var valueE=value.elements;
			if (valueE[0] !=1 || valueE[1] !=1 || valueE[2] !=0 || valueE[3] !=0)
				this._addShaderDefine(laya.d3.core.material.StandardMaterial.SHADERDEFINE_TILINGOFFSET);
			else
			this._removeShaderDefine(laya.d3.core.material.StandardMaterial.SHADERDEFINE_TILINGOFFSET);
			}else {
			this._removeShaderDefine(laya.d3.core.material.StandardMaterial.SHADERDEFINE_TILINGOFFSET);
		}
		this._setColor(15,value);
	});

	/**
	*设置反射率。
	*@param value 反射率。
	*/
	__getset(0,__proto,'albedo',function(){
		return this._getColor(7);
		},function(value){
		this._setColor(7,value);
	});

	/**
	*设置漫反射光颜色。
	*@param value 漫反射光颜色。
	*/
	__getset(0,__proto,'diffuseColor',function(){
		return this._getColor(10);
		},function(value){
		this._setColor(10,value);
	});

	/**
	*设置反射率。
	*@param value 反射率。
	*/
	__getset(0,__proto,'albedoColor',function(){
		return this._getColor(7);
		},function(value){
		this._setColor(7,value);
	});

	/**
	*设置高光颜色。
	*@param value 高光颜色。
	*/
	__getset(0,__proto,'specularColor',function(){
		return this._getColor(11);
		},function(value){
		this._setColor(11,value);
	});

	/**
	*设置漫反射贴图。
	*@param value 漫反射贴图。
	*/
	/**
	*获取漫反射贴图。
	*@return 漫反射贴图。
	*/
	__getset(0,__proto,'diffuseTexture',function(){
		return this._getTexture(1);
		},function(value){
		if (value){
			this._addShaderDefine(laya.d3.core.material.StandardMaterial.SHADERDEFINE_DIFFUSEMAP);
			}else {
			this._removeShaderDefine(laya.d3.core.material.StandardMaterial.SHADERDEFINE_DIFFUSEMAP);
		}
		this._setTexture(1,value);
	});

	/**
	*设置法线贴图。
	*@param value 法线贴图。
	*/
	/**
	*获取法线贴图。
	*@return 法线贴图。
	*/
	__getset(0,__proto,'normalTexture',function(){
		return this._getTexture(2);
		},function(value){
		if (value){
			this._addShaderDefine(laya.d3.core.material.StandardMaterial.SHADERDEFINE_NORMALMAP);
			}else {
			this._removeShaderDefine(laya.d3.core.material.StandardMaterial.SHADERDEFINE_NORMALMAP);
		}
		this._setTexture(2,value);
	});

	/**
	*设置高光贴图。
	*@param value 高光贴图。
	*/
	/**
	*获取高光贴图。
	*@return 高光贴图。
	*/
	__getset(0,__proto,'specularTexture',function(){
		return this._getTexture(3);
		},function(value){
		if (value){
			this._addShaderDefine(laya.d3.core.material.StandardMaterial.SHADERDEFINE_SPECULARMAP);
			}else {
			this._removeShaderDefine(laya.d3.core.material.StandardMaterial.SHADERDEFINE_SPECULARMAP);
		}
		this._setTexture(3,value);
	});

	/**
	*设置放射贴图。
	*@param value 放射贴图。
	*/
	/**
	*获取放射贴图。
	*@return 放射贴图。
	*/
	__getset(0,__proto,'emissiveTexture',function(){
		return this._getTexture(4);
		},function(value){
		if (value){
			this._addShaderDefine(laya.d3.core.material.StandardMaterial.SHADERDEFINE_EMISSIVEMAP);
			}else {
			this._removeShaderDefine(laya.d3.core.material.StandardMaterial.SHADERDEFINE_EMISSIVEMAP);
		}
		this._setTexture(4,value);
	});

	/**
	*设置反射贴图。
	*@param value 反射贴图。
	*/
	/**
	*获取反射贴图。
	*@return 反射贴图。
	*/
	__getset(0,__proto,'reflectTexture',function(){
		return this._getTexture(6);
		},function(value){
		if (value){
			this._addShaderDefine(laya.d3.core.material.StandardMaterial.SHADERDEFINE_REFLECTMAP);
			}else {
			this._removeShaderDefine(laya.d3.core.material.StandardMaterial.SHADERDEFINE_REFLECTMAP);
		}
		this._setTexture(6,value);
	});

	/**
	*设置UV变换。
	*@param value UV变换。
	*/
	/**
	*获取UV变换。
	*@return UV变换。
	*/
	__getset(0,__proto,'transformUV',function(){
		return this._transformUV;
		},function(value){
		this._transformUV=value;
		this._setMatrix4x4(13,value.matrix);
		if (value)
			this._addShaderDefine(laya.d3.core.material.StandardMaterial.SHADERDEFINE_UVTRANSFORM);
		else
		this._removeShaderDefine(laya.d3.core.material.StandardMaterial.SHADERDEFINE_UVTRANSFORM);
		if (this._conchMaterial){
			this._conchMaterial.setShaderValue(13,value.matrix.elements,0);
		}
	});

	StandardMaterial.__init__=function(){
		StandardMaterial.SHADERDEFINE_DIFFUSEMAP=StandardMaterial.shaderDefines.registerDefine("DIFFUSEMAP");
		StandardMaterial.SHADERDEFINE_NORMALMAP=StandardMaterial.shaderDefines.registerDefine("NORMALMAP");
		StandardMaterial.SHADERDEFINE_SPECULARMAP=StandardMaterial.shaderDefines.registerDefine("SPECULARMAP");
		StandardMaterial.SHADERDEFINE_EMISSIVEMAP=StandardMaterial.shaderDefines.registerDefine("EMISSIVEMAP");
		StandardMaterial.SHADERDEFINE_AMBIENTMAP=StandardMaterial.shaderDefines.registerDefine("AMBIENTMAP");
		StandardMaterial.SHADERDEFINE_REFLECTMAP=StandardMaterial.shaderDefines.registerDefine("REFLECTMAP");
		StandardMaterial.SHADERDEFINE_UVTRANSFORM=StandardMaterial.shaderDefines.registerDefine("UVTRANSFORM");
		StandardMaterial.SHADERDEFINE_TILINGOFFSET=StandardMaterial.shaderDefines.registerDefine("TILINGOFFSET");
		StandardMaterial.SHADERDEFINE_ADDTIVEFOG=StandardMaterial.shaderDefines.registerDefine("ADDTIVEFOG");
	}

	StandardMaterial.load=function(url){
		return Laya.loader.create(url,null,null,StandardMaterial);
	}

	StandardMaterial._parseStandardMaterial=function(textureMap,material,json){
		var customProps=json.customProps;
		var ambientColorValue=customProps.ambientColor;
		material.ambientColor=new Vector3(ambientColorValue[0],ambientColorValue[1],ambientColorValue[2]);
		var diffuseColorValue=customProps.diffuseColor;
		material.diffuseColor=new Vector3(diffuseColorValue[0],diffuseColorValue[1],diffuseColorValue[2]);
		var specularColorValue=customProps.specularColor;
		material.specularColor=new Vector4(specularColorValue[0],specularColorValue[1],specularColorValue[2],specularColorValue[3]);
		var reflectColorValue=customProps.reflectColor;
		material.reflectColor=new Vector3(reflectColorValue[0],reflectColorValue[1],reflectColorValue[2]);
		var albedoColorValue=customProps.albedoColor;
		(albedoColorValue)&& (material.albedo=new Vector4(albedoColorValue[0],albedoColorValue[1],albedoColorValue[2],albedoColorValue[3]));
		var diffuseTexture=customProps.diffuseTexture.texture2D;
		(diffuseTexture)&& (material.diffuseTexture=Loader.getRes(textureMap[diffuseTexture]));
		var normalTexture=customProps.normalTexture.texture2D;
		(normalTexture)&& (material.normalTexture=Loader.getRes(textureMap[normalTexture]));
		var specularTexture=customProps.specularTexture.texture2D;
		(specularTexture)&& (material.specularTexture=Loader.getRes(textureMap[specularTexture]));
		var emissiveTexture=customProps.emissiveTexture.texture2D;
		(emissiveTexture)&& (material.emissiveTexture=Loader.getRes(textureMap[emissiveTexture]));
		var ambientTexture=customProps.ambientTexture.texture2D;
		(ambientTexture)&& (material.ambientTexture=Loader.getRes(textureMap[ambientTexture]));
		var reflectTexture=customProps.reflectTexture.texture2D;
		(reflectTexture)&& (material.reflectTexture=Loader.getRes(textureMap[reflectTexture]));
	}

	StandardMaterial.RENDERMODE_OPAQUE=1;
	StandardMaterial.RENDERMODE_OPAQUEDOUBLEFACE=2;
	StandardMaterial.RENDERMODE_CUTOUT=3;
	StandardMaterial.RENDERMODE_CUTOUTDOUBLEFACE=4;
	StandardMaterial.RENDERMODE_TRANSPARENT=13;
	StandardMaterial.RENDERMODE_TRANSPARENTDOUBLEFACE=14;
	StandardMaterial.RENDERMODE_ADDTIVE=15;
	StandardMaterial.RENDERMODE_ADDTIVEDOUBLEFACE=16;
	StandardMaterial.RENDERMODE_DEPTHREAD_TRANSPARENT=5;
	StandardMaterial.RENDERMODE_DEPTHREAD_TRANSPARENTDOUBLEFACE=6;
	StandardMaterial.RENDERMODE_DEPTHREAD_ADDTIVE=7;
	StandardMaterial.RENDERMODE_DEPTHREAD_ADDTIVEDOUBLEFACE=8;
	StandardMaterial.RENDERMODE_NONDEPTH_TRANSPARENT=9;
	StandardMaterial.RENDERMODE_NONDEPTH_TRANSPARENTDOUBLEFACE=10;
	StandardMaterial.RENDERMODE_NONDEPTH_ADDTIVE=11;
	StandardMaterial.RENDERMODE_NONDEPTH_ADDTIVEDOUBLEFACE=12;
	StandardMaterial.SHADERDEFINE_DIFFUSEMAP=0;
	StandardMaterial.SHADERDEFINE_NORMALMAP=0;
	StandardMaterial.SHADERDEFINE_SPECULARMAP=0;
	StandardMaterial.SHADERDEFINE_EMISSIVEMAP=0;
	StandardMaterial.SHADERDEFINE_AMBIENTMAP=0;
	StandardMaterial.SHADERDEFINE_REFLECTMAP=0;
	StandardMaterial.SHADERDEFINE_UVTRANSFORM=0;
	StandardMaterial.SHADERDEFINE_TILINGOFFSET=0;
	StandardMaterial.SHADERDEFINE_ADDTIVEFOG=0;
	StandardMaterial.DIFFUSETEXTURE=1;
	StandardMaterial.NORMALTEXTURE=2;
	StandardMaterial.SPECULARTEXTURE=3;
	StandardMaterial.EMISSIVETEXTURE=4;
	StandardMaterial.AMBIENTTEXTURE=5;
	StandardMaterial.REFLECTTEXTURE=6;
	StandardMaterial.ALBEDO=7;
	StandardMaterial.UVANIAGE=8;
	StandardMaterial.MATERIALAMBIENT=9;
	StandardMaterial.MATERIALDIFFUSE=10;
	StandardMaterial.MATERIALSPECULAR=11;
	StandardMaterial.MATERIALREFLECT=12;
	StandardMaterial.UVMATRIX=13;
	StandardMaterial.UVAGE=14;
	StandardMaterial.TILINGOFFSET=15;
	__static(StandardMaterial,
	['defaultMaterial',function(){return this.defaultMaterial=new StandardMaterial();},'shaderDefines',function(){return this.shaderDefines=new ShaderDefines$1(BaseMaterial.shaderDefines);}
	]);
	return StandardMaterial;
})(BaseMaterial)


/**
*...
*@author ...
*/
//class laya.d3.core.material.TerrainMaterial extends laya.d3.core.material.BaseMaterial
var TerrainMaterial=(function(_super){
	function TerrainMaterial(){
		this._diffuseScale1=null;
		this._diffuseScale2=null;
		this._diffuseScale3=null;
		this._diffuseScale4=null;
		TerrainMaterial.__super.call(this);
		this.setShaderName("Terrain");
		this.renderMode=1;
		this._diffuseScale1=new Vector2();
		this._diffuseScale2=new Vector2();
		this._diffuseScale3=new Vector2();
		this._diffuseScale4=new Vector2();
		this.ambientColor=new Vector3(0.6,0.6,0.6);
		this.diffuseColor=new Vector3(1.0,1.0,1.0);
		this.specularColor=new Vector4(0.2,0.2,0.2,32.0);
	}

	__class(TerrainMaterial,'laya.d3.core.material.TerrainMaterial',_super);
	var __proto=TerrainMaterial.prototype;
	__proto.setDiffuseScale1=function(x,y){
		this._diffuseScale1.x=x;
		this._diffuseScale1.y=y;
		this._setColor(6,this._diffuseScale1);
	}

	__proto.setDiffuseScale2=function(x,y){
		this._diffuseScale2.x=x;
		this._diffuseScale2.y=y;
		this._setColor(7,this._diffuseScale2);
	}

	__proto.setDiffuseScale3=function(x,y){
		this._diffuseScale3.x=x;
		this._diffuseScale3.y=y;
		this._setColor(8,this._diffuseScale3);
	}

	__proto.setDiffuseScale4=function(x,y){
		this._diffuseScale4.x=x;
		this._diffuseScale4.y=y;
		this._setColor(9,this._diffuseScale4);
	}

	__proto.setDetailNum=function(value){
		switch (value){
			case 1:
				this._addShaderDefine(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM1);
				this._removeShaderDefine(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM2);
				this._removeShaderDefine(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM3);
				this._removeShaderDefine(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM4);
				break ;
			case 2:
				this._addShaderDefine(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM2);
				this._removeShaderDefine(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM1);
				this._removeShaderDefine(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM3);
				this._removeShaderDefine(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM4);
				break ;
			case 3:
				this._addShaderDefine(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM3);
				this._removeShaderDefine(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM1);
				this._removeShaderDefine(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM2);
				this._removeShaderDefine(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM4);
				break ;
			case 4:
				this._addShaderDefine(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM4);
				this._removeShaderDefine(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM1);
				this._removeShaderDefine(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM2);
				this._removeShaderDefine(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM3);
				break ;
			}
	}

	__proto.disableLight=function(){
		this._addDisablePublicShaderDefine(ShaderCompile3D.SHADERDEFINE_POINTLIGHT | ShaderCompile3D.SHADERDEFINE_SPOTLIGHT | ShaderCompile3D.SHADERDEFINE_DIRECTIONLIGHT);
	}

	/**
	*@inheritDoc
	*/
	__proto.setShaderName=function(name){
		_super.prototype.setShaderName.call(this,name);
	}

	/**
	*设置渲染模式。
	*@return 渲染模式。
	*/
	__getset(0,__proto,'renderMode',null,function(value){
		switch (value){
			case 1:
				this.renderQueue=/*laya.d3.core.material.BaseMaterial.RENDERQUEUE_OPAQUE*/2000;
				this.depthWrite=true;
				this.cull=2;
				this.blend=0;
				this.depthTest=0x0201;
				break ;
			case 2:
				this.renderQueue=/*laya.d3.core.material.BaseMaterial.RENDERQUEUE_OPAQUE*/2000;
				this.depthWrite=false;
				this.cull=2;
				this.blend=1;
				this.srcBlend=0x0302;
				this.dstBlend=0x0303;
				this.depthTest=0x0203;
				break ;
			default :
				throw new Error("TerrainMaterial:renderMode value error.");
			}
		this._conchMaterial && this._conchMaterial.setRenderMode(value);
	});

	/**
	*设置第二层贴图。
	*@param value 第二层贴图。
	*/
	/**
	*获取第二层贴图。
	*@return 第二层贴图。
	*/
	__getset(0,__proto,'diffuseTexture2',function(){
		return this._getTexture(3);
		},function(value){
		this._setTexture(3,value);
	});

	__getset(0,__proto,'ambientColor',function(){
		return this._getColor(10);
		},function(value){
		this._setColor(10,value);
	});

	/**
	*设置第四层贴图。
	*@param value 第四层贴图。
	*/
	/**
	*获取第四层贴图。
	*@return 第四层贴图。
	*/
	__getset(0,__proto,'diffuseTexture4',function(){
		return this._getTexture(5);
		},function(value){
		this._setTexture(5,value);
	});

	__getset(0,__proto,'diffuseColor',function(){
		return this._getColor(11);
		},function(value){
		this._setColor(11,value);
	});

	/**
	*设置第一层贴图。
	*@param value 第一层贴图。
	*/
	/**
	*获取第一层贴图。
	*@return 第一层贴图。
	*/
	__getset(0,__proto,'diffuseTexture1',function(){
		return this._getTexture(2);
		},function(value){
		this._setTexture(2,value);
	});

	__getset(0,__proto,'specularColor',function(){
		return this._getColor(12);
		},function(value){
		this._setColor(12,value);
	});

	/**
	*设置第三层贴图。
	*@param value 第三层贴图。
	*/
	/**
	*获取第三层贴图。
	*@return 第三层贴图。
	*/
	__getset(0,__proto,'diffuseTexture3',function(){
		return this._getTexture(4);
		},function(value){
		this._setTexture(4,value);
	});

	/**
	*设置splatAlpha贴图。
	*@param value splatAlpha贴图。
	*/
	/**
	*获取splatAlpha贴图。
	*@return splatAlpha贴图。
	*/
	__getset(0,__proto,'splatAlphaTexture',function(){
		return this._getTexture(0);
		},function(value){
		this._setTexture(0,value);
	});

	__getset(0,__proto,'normalTexture',function(){
		return this._getTexture(1);
		},function(value){
		this._setTexture(1,value);
	});

	TerrainMaterial.__init__=function(){
		TerrainMaterial.SHADERDEFINE_DETAIL_NUM1=TerrainMaterial.shaderDefines.registerDefine("DETAIL_NUM1");
		TerrainMaterial.SHADERDEFINE_DETAIL_NUM2=TerrainMaterial.shaderDefines.registerDefine("DETAIL_NUM2");
		TerrainMaterial.SHADERDEFINE_DETAIL_NUM4=TerrainMaterial.shaderDefines.registerDefine("DETAIL_NUM4");
		TerrainMaterial.SHADERDEFINE_DETAIL_NUM3=TerrainMaterial.shaderDefines.registerDefine("DETAIL_NUM3");
	}

	TerrainMaterial.load=function(url){
		return Laya.loader.create(url,null,null,TerrainMaterial);
	}

	TerrainMaterial.RENDERMODE_OPAQUE=1;
	TerrainMaterial.RENDERMODE_TRANSPARENT=2;
	TerrainMaterial.SPLATALPHATEXTURE=0;
	TerrainMaterial.NORMALTEXTURE=1;
	TerrainMaterial.DIFFUSETEXTURE1=2;
	TerrainMaterial.DIFFUSETEXTURE2=3;
	TerrainMaterial.DIFFUSETEXTURE3=4;
	TerrainMaterial.DIFFUSETEXTURE4=5;
	TerrainMaterial.DIFFUSESCALE1=6;
	TerrainMaterial.DIFFUSESCALE2=7;
	TerrainMaterial.DIFFUSESCALE3=8;
	TerrainMaterial.DIFFUSESCALE4=9;
	TerrainMaterial.MATERIALAMBIENT=10;
	TerrainMaterial.MATERIALDIFFUSE=11;
	TerrainMaterial.MATERIALSPECULAR=12;
	TerrainMaterial.SHADERDEFINE_DETAIL_NUM1=0;
	TerrainMaterial.SHADERDEFINE_DETAIL_NUM2=0;
	TerrainMaterial.SHADERDEFINE_DETAIL_NUM3=0;
	TerrainMaterial.SHADERDEFINE_DETAIL_NUM4=0;
	__static(TerrainMaterial,
	['defaultMaterial',function(){return this.defaultMaterial=new TerrainMaterial();},'shaderDefines',function(){return this.shaderDefines=new ShaderDefines$1(BaseMaterial.shaderDefines);}
	]);
	return TerrainMaterial;
})(BaseMaterial)


//class laya.d3.core.material.WaterMaterial extends laya.d3.core.material.BaseMaterial
var WaterMaterial=(function(_super){
	function WaterMaterial(){
		this._useVertexDeep=false;
		WaterMaterial.__super.call(this);
		this.setShaderName("Water");
	}

	__class(WaterMaterial,'laya.d3.core.material.WaterMaterial',_super);
	var __proto=WaterMaterial.prototype;
	/**
	*禁用雾化。
	*/
	__proto.disableFog=function(){
		this._addDisablePublicShaderDefine(ShaderCompile3D.SHADERDEFINE_FOG);
	}

	__proto.onAsynLoaded=function(url,data,params){
		_super.prototype.onAsynLoaded.call(this,url,data,params);
	}

	/**
	*设置漫反射贴图。
	*@param value 漫反射贴图。
	*/
	/**
	*获取漫反射贴图。
	*@return 漫反射贴图。
	*/
	__getset(0,__proto,'diffuseTexture',function(){
		return this._getTexture(1);
		},function(value){
		this._setTexture(1,value);
	});

	/**
	*设置法线贴图。
	*@param value 法线贴图。
	*/
	/**
	*获取法线贴图。
	*@return 法线贴图。
	*/
	__getset(0,__proto,'normalTexture',function(){
		return this._getTexture(2);
		},function(value){
		this._setTexture(2,value);
	});

	__getset(0,__proto,'underWaterTexture',function(){
		return this._getTexture(3);
		},function(value){
		this._setTexture(3,value);
	});

	__getset(0,__proto,'deepColorTexture',function(){
		return this._getTexture(10);
		},function(v){
		this._setTexture(10,v);
	});

	__getset(0,__proto,'useFoam',null,function(v){
		if (v){
			this._addShaderDefine(WaterMaterial.SHADERDEFINE_USE_FOAM);
			}else {
			this._removeShaderDefine(WaterMaterial.SHADERDEFINE_USE_FOAM);
		}
	});

	__getset(0,__proto,'skyTexture',function(){
		return this._getTexture(11);
		},function(v){
		this._setTexture(11,v);
	});

	__getset(0,__proto,'deepScale',function(){
		return this._getNumber(20);
		},function(v){
		this._setNumber(20,v);
	});

	__getset(0,__proto,'detailTexture',function(){
		return this._getTexture(9);
		},function(value){
		this._setTexture(9,value);
	});

	__getset(0,__proto,'foamTexture',function(){
		return this._getTexture(17);
		},function(v){
		this._setTexture(17,v);
	});

	__getset(0,__proto,'waterInfoTexture',function(){
		return this._getTexture(16);
		},function(v){
		this._setTexture(16,v);
	});

	/**
	*对定点进行变换的纹理。现在不用
	*/
	__getset(0,__proto,'vertexDispTexture',function(){
		return this._getTexture(4);
		},function(value){
		this._setTexture(4,value);
	});

	__getset(0,__proto,'currentTm',function(){
		return this._getNumber(8);
		},function(v){
		this._setNumber(8,v);
	});

	__getset(0,__proto,'waveInfo',function(){
		return this._getBuffer(12);
		},function(v){
		this._setBuffer(12,v);
	});

	__getset(0,__proto,'waveInfoD',function(){
		return this._getBuffer(13);
		},function(v){
		this._setBuffer(13,v);
	});

	__getset(0,__proto,'waveMainDir',function(){
		return this._getNumber(14);
		},function(deg){
		this._setNumber(14,deg *Math.PI / 180);
	});

	__getset(0,__proto,'geoWaveUVScale',function(){
		return this._getNumber(18);
		},function(v){
		this._setNumber(18,v);
	});

	__getset(0,__proto,'windSpeed',function(){
		return 0;
		},function(s){
	});

	__getset(0,__proto,'scrsize',null,function(v){
		this._setBuffer(15,v);
	});

	__getset(0,__proto,'seaColor',function(){
		return this._getBuffer(19);
		},function(v){
		this._setBuffer(19,v);
	});

	__getset(0,__proto,'useVertexDeep',function(){
		return this._useVertexDeep;
		},function(v){
		this._useVertexDeep=v;
		if (v)
			this._addShaderDefine(WaterMaterial.SHADERDEFINE_USEVERTEXHEIGHT);
		else {
			this._removeShaderDefine(WaterMaterial.SHADERDEFINE_USEVERTEXHEIGHT);
		}
	});

	__getset(0,__proto,'windDir',function(){
		return 0;
		},function(d){
	});

	__getset(0,__proto,'useRefractTexture',null,function(v){
		if (v){
			this._addShaderDefine(WaterMaterial.SHADERDEFINE_USE_REFRACT_TEX);
			}else {
			this._removeShaderDefine(WaterMaterial.SHADERDEFINE_USE_REFRACT_TEX);
		}
	});

	__getset(0,__proto,'renderMode',null,function(value){
		switch (value){
			case 1:
				this.renderQueue=/*laya.d3.core.material.BaseMaterial.RENDERQUEUE_OPAQUE*/2000;
				this.depthWrite=true;
				this.cull=2;
				this.blend=0;
				this.alphaTest=false;
				break ;
			case 2:
				this.renderQueue=/*laya.d3.core.material.BaseMaterial.RENDERQUEUE_OPAQUE*/2000;
				this.depthWrite=true;
				this.cull=0;
				this.blend=0;
				this.alphaTest=false;
				break ;
			case 3:
				this.depthWrite=true;
				this.cull=2;
				this.blend=0;
				this.renderQueue=/*laya.d3.core.material.BaseMaterial.RENDERQUEUE_OPAQUE*/2000;
				break ;
			case 13:
				this.renderQueue=/*laya.d3.core.material.BaseMaterial.RENDERQUEUE_TRANSPARENT*/3000;
				this.depthWrite=true;
				this.cull=2;
				this.blend=1;
				this.srcBlend=0x0302;
				this.dstBlend=0x0303;
				break ;
			default :
				throw new Error("PBRMaterial:renderMode value error.");
			}
	});

	WaterMaterial.__init__=function(){
		WaterMaterial.SHADERDEFINE_CUBE_ENV=WaterMaterial.shaderDefines.registerDefine("CUBE_ENV");
		WaterMaterial.SHADERDEFINE_HDR_ENV=WaterMaterial.shaderDefines.registerDefine("HDR_ENV");
		WaterMaterial.SHADERDEFINE_SHOW_NORMAL=WaterMaterial.shaderDefines.registerDefine("SHOW_NORMAL");
		WaterMaterial.SHADERDEFINE_USEVERTEXHEIGHT=WaterMaterial.shaderDefines.registerDefine("USE_VERTEX_DEEPINFO");
		WaterMaterial.SHADERDEFINE_USE_FOAM=WaterMaterial.shaderDefines.registerDefine("USE_FOAM");
		WaterMaterial.SHADERDEFINE_USE_REFRACT_TEX=WaterMaterial.shaderDefines.registerDefine("USE_REFR_TEX");
	}

	WaterMaterial.load=function(url){
		return Laya.loader.create(url,null,null,WaterMaterial);
	}

	WaterMaterial.DIFFUSETEXTURE=1;
	WaterMaterial.NORMALTEXTURE=2;
	WaterMaterial.UNDERWATERTEXTURE=3;
	WaterMaterial.VERTEXDISPTEXTURE=4;
	WaterMaterial.UVANIAGE=5;
	WaterMaterial.UVMATRIX=6;
	WaterMaterial.UVAGE=7;
	WaterMaterial.CURTM=8;
	WaterMaterial.DETAILTEXTURE=9;
	WaterMaterial.DEEPCOLORTEXTURE=10;
	WaterMaterial.SKYTEXTURE=11;
	WaterMaterial.WAVEINFO=12;
	WaterMaterial.WAVEINFOD=13;
	WaterMaterial.WAVEMAINDIR=14;
	WaterMaterial.SCRSIZE=15;
	WaterMaterial.WATERINFO=16;
	WaterMaterial.FOAMTEXTURE=17;
	WaterMaterial.GEOWAVE_UV_SCALE=18;
	WaterMaterial.SEA_COLOR=19;
	WaterMaterial.WAVEINFODEEPSCALE=20;
	WaterMaterial.SHADERDEFINE_SHOW_NORMAL=0;
	WaterMaterial.SHADERDEFINE_CUBE_ENV=0;
	WaterMaterial.SHADERDEFINE_HDR_ENV=0;
	WaterMaterial.SHADERDEFINE_USE_FOAM=0;
	WaterMaterial.SHADERDEFINE_USE_REFRACT_TEX=0;
	WaterMaterial.SHADERDEFINE_USEVERTEXHEIGHT=0;
	WaterMaterial.RENDERMODE_OPAQUE=1;
	WaterMaterial.RENDERMODE_OPAQUEDOUBLEFACE=2;
	WaterMaterial.RENDERMODE_CUTOUT=3;
	WaterMaterial.RENDERMODE_CUTOUTDOUBLEFACE=4;
	WaterMaterial.RENDERMODE_TRANSPARENT=13;
	__static(WaterMaterial,
	['defaultMaterial',function(){return this.defaultMaterial=new WaterMaterial();},'shaderDefines',function(){return this.shaderDefines=new ShaderDefines$1(BaseMaterial.shaderDefines);}
	]);
	return WaterMaterial;
})(BaseMaterial)


/**
*<code>IndexBuffer3D</code> 类用于创建索引缓冲。
*/
//class laya.d3.graphics.IndexBuffer3D extends laya.webgl.utils.Buffer
var IndexBuffer3D=(function(_super){
	function IndexBuffer3D(indexType,indexCount,bufferUsage,canRead){
		/**@private */
		this._indexType=null;
		/**@private */
		this._indexTypeByteCount=0;
		/**@private */
		this._indexCount=0;
		/**@private */
		this._canRead=false;
		(bufferUsage===void 0)&& (bufferUsage=/*laya.webgl.WebGLContext.STATIC_DRAW*/0x88E4);
		(canRead===void 0)&& (canRead=false);
		IndexBuffer3D.__super.call(this);
		this._indexType=indexType;
		this._indexCount=indexCount;
		this._bufferUsage=bufferUsage;
		this._bufferType=/*laya.webgl.WebGLContext.ELEMENT_ARRAY_BUFFER*/0x8893;
		this._canRead=canRead;
		var byteLength=0;
		if (indexType==/*CLASS CONST:laya.d3.graphics.IndexBuffer3D.INDEXTYPE_USHORT*/"ushort")
			this._indexTypeByteCount=2;
		else if (indexType==/*CLASS CONST:laya.d3.graphics.IndexBuffer3D.INDEXTYPE_UBYTE*/"ubyte")
		this._indexTypeByteCount=1;
		else
		throw new Error("unidentification index type.");
		byteLength=this._indexTypeByteCount *indexCount;
		this._byteLength=byteLength;
		this._bind();
		Buffer._gl.bufferData(this._bufferType,byteLength,this._bufferUsage);
		if (canRead){
			if (indexType==/*CLASS CONST:laya.d3.graphics.IndexBuffer3D.INDEXTYPE_USHORT*/"ushort")
				this._buffer=new Uint16Array(indexCount);
			else if (indexType==/*CLASS CONST:laya.d3.graphics.IndexBuffer3D.INDEXTYPE_UBYTE*/"ubyte")
			this._buffer=new Uint8Array(indexCount);
			this.memorySize=byteLength *2;
			}else {
			this.memorySize=byteLength;
		}
	}

	__class(IndexBuffer3D,'laya.d3.graphics.IndexBuffer3D',_super);
	var __proto=IndexBuffer3D.prototype;
	/**
	*设置数据。
	*@param data 索引数据。
	*@param bufferOffset 索引缓冲中的偏移。
	*@param dataStartIndex 索引数据的偏移。
	*@param dataCount 索引数据的数量。
	*/
	__proto.setData=function(data,bufferOffset,dataStartIndex,dataCount){
		(bufferOffset===void 0)&& (bufferOffset=0);
		(dataStartIndex===void 0)&& (dataStartIndex=0);
		(dataCount===void 0)&& (dataCount=4294967295);
		var byteCount=0;
		if (this._indexType==/*CLASS CONST:laya.d3.graphics.IndexBuffer3D.INDEXTYPE_USHORT*/"ushort"){
			byteCount=2;
			if (dataStartIndex!==0 || dataCount!==4294967295)
				data=new Uint16Array(data.buffer,dataStartIndex *byteCount,dataCount);
			}else if (this._indexType==/*CLASS CONST:laya.d3.graphics.IndexBuffer3D.INDEXTYPE_UBYTE*/"ubyte"){
			byteCount=1;
			if (dataStartIndex!==0 || dataCount!==4294967295)
				data=new Uint8Array(data.buffer,dataStartIndex *byteCount,dataCount);
		}
		this._bind();
		Buffer._gl.bufferSubData(this._bufferType,bufferOffset *byteCount,data);
		if (this._canRead){
			if (bufferOffset!==0 || dataStartIndex!==0 || dataCount!==4294967295){
				var maxLength=this._buffer.length-bufferOffset;
				if (dataCount > maxLength)
					dataCount=maxLength;
				for (var i=0;i < dataCount;i++)
				this._buffer[bufferOffset+i]=data[i];
				}else {
				this._buffer=data;
			}
		}
	}

	/**
	*获取索引数据。
	*@return 索引数据。
	*/
	__proto.getData=function(){
		if (this._canRead)
			return this._buffer;
		else
		throw new Error("Can't read data from VertexBuffer with only write flag!");
	}

	/**
	*@inheritDoc
	*/
	__proto.disposeResource=function(){
		_super.prototype.disposeResource.call(this);
		this._buffer=null;
		this.memorySize=0;
	}

	/**
	*获取索引类型。
	*@return 索引类型。
	*/
	__getset(0,__proto,'indexType',function(){
		return this._indexType;
	});

	/**
	*获取索引类型字节数量。
	*@return 索引类型字节数量。
	*/
	__getset(0,__proto,'indexTypeByteCount',function(){
		return this._indexTypeByteCount;
	});

	/**
	*获取索引个数。
	*@return 索引个数。
	*/
	__getset(0,__proto,'indexCount',function(){
		return this._indexCount;
	});

	/**
	*获取是否可读。
	*@return 是否可读。
	*/
	__getset(0,__proto,'canRead',function(){
		return this._canRead;
	});

	IndexBuffer3D.INDEXTYPE_UBYTE="ubyte";
	IndexBuffer3D.INDEXTYPE_USHORT="ushort";
	IndexBuffer3D.create=function(indexType,indexCount,bufferUsage,canRead){
		(bufferUsage===void 0)&& (bufferUsage=/*laya.webgl.WebGLContext.STATIC_DRAW*/0x88E4);
		(canRead===void 0)&& (canRead=false);
		return new IndexBuffer3D(indexType,indexCount,bufferUsage,canRead);
	}

	return IndexBuffer3D;
})(Buffer)


/**
*<code>VertexBuffer3D</code> 类用于创建顶点缓冲。
*/
//class laya.d3.graphics.VertexBuffer3D extends laya.webgl.utils.Buffer
var VertexBuffer3D=(function(_super){
	function VertexBuffer3D(vertexDeclaration,vertexCount,bufferUsage,canRead){
		/**@private */
		this._vertexDeclaration=null;
		/**@private */
		this._vertexCount=0;
		/**@private */
		this._canRead=false;
		(canRead===void 0)&& (canRead=false);
		VertexBuffer3D.__super.call(this);
		this._vertexDeclaration=vertexDeclaration;
		this._vertexCount=vertexCount;
		this._bufferUsage=bufferUsage;
		this._bufferType=/*laya.webgl.WebGLContext.ARRAY_BUFFER*/0x8892;
		this._canRead=canRead;
		this.memorySize=this._byteLength=this._vertexDeclaration.vertexStride *vertexCount;
		this._bind();
		Buffer._gl.bufferData(this._bufferType,this._byteLength,this._bufferUsage);
		canRead && (this._buffer=new Float32Array(this._byteLength / 4));
	}

	__class(VertexBuffer3D,'laya.d3.graphics.VertexBuffer3D',_super);
	var __proto=VertexBuffer3D.prototype;
	/**
	*和索引缓冲一起绑定。
	*@param ib 索引缓冲。
	*/
	__proto.bindWithIndexBuffer=function(ib){
		(ib)&& (ib._bind());
		this._bind();
	}

	/**
	*设置数据。
	*@param data 顶点数据。
	*@param bufferOffset 顶点缓冲中的偏移。
	*@param dataStartIndex 顶点数据的偏移。
	*@param dataCount 顶点数据的数量。
	*/
	__proto.setData=function(data,bufferOffset,dataStartIndex,dataCount){
		(bufferOffset===void 0)&& (bufferOffset=0);
		(dataStartIndex===void 0)&& (dataStartIndex=0);
		(dataCount===void 0)&& (dataCount=4294967295);
		if (dataStartIndex!==0 || dataCount!==4294967295)
			data=new Float32Array(data.buffer,dataStartIndex *4,dataCount);
		this._bind();
		Buffer._gl.bufferSubData(this._bufferType,bufferOffset *4,data);
		if (this._canRead){
			if (bufferOffset!==0 || dataStartIndex!==0 || dataCount!==4294967295){
				var maxLength=this._buffer.length-bufferOffset;
				if (dataCount > maxLength)
					dataCount=maxLength;
				for (var i=0;i < dataCount;i++)
				this._buffer[bufferOffset+i]=data[i];
				}else {
				this._buffer=data;
			}
		}
	}

	/**
	*获取顶点数据。
	*@return 顶点数据。
	*/
	__proto.getData=function(){
		if (this._canRead)
			return this._buffer;
		else
		throw new Error("Can't read data from VertexBuffer with only write flag!");
	}

	/**销毁顶点缓冲。*/
	__proto.disposeResource=function(){
		var gl=WebGL.mainContext;
		var elements=this._vertexDeclaration.getVertexElements();
		var enableAtributes=Buffer._enableAtributes;
		for (var i=0,n=elements.length;i < n;i++){
			if (enableAtributes[i]===this._glBuffer){
				gl.disableVertexAttribArray(i);
				enableAtributes[i]=null;
			}
		}
		_super.prototype.disposeResource.call(this);
		this._buffer=null;
		this._vertexDeclaration=null;
		this.memorySize=0;
	}

	/**
	*获取顶点结构声明。
	*@return 顶点结构声明。
	*/
	__getset(0,__proto,'vertexDeclaration',function(){
		return this._vertexDeclaration;
	});

	/**
	*获取顶点个数。
	*@return 顶点个数。
	*/
	__getset(0,__proto,'vertexCount',function(){
		return this._vertexCount;
	});

	/**
	*获取是否可读。
	*@return 是否可读。
	*/
	__getset(0,__proto,'canRead',function(){
		return this._canRead;
	});

	VertexBuffer3D.create=function(vertexDeclaration,vertexCount,bufferUsage,canRead){
		(bufferUsage===void 0)&& (bufferUsage=/*laya.webgl.WebGLContext.STATIC_DRAW*/0x88E4);
		(canRead===void 0)&& (canRead=false);
		return new VertexBuffer3D(vertexDeclaration,vertexCount,bufferUsage,canRead);
	}

	return VertexBuffer3D;
})(Buffer)


/**
*...
*@author ...
*/
//class laya.d3.core.particleShuriKen.ShurikenParticleMaterial extends laya.d3.core.material.BaseMaterial
var ShurikenParticleMaterial=(function(_super){
	function ShurikenParticleMaterial(){
		ShurikenParticleMaterial.__super.call(this);
		this.setShaderName("PARTICLESHURIKEN");
		this.renderMode=6;
	}

	__class(ShurikenParticleMaterial,'laya.d3.core.particleShuriKen.ShurikenParticleMaterial',_super);
	var __proto=ShurikenParticleMaterial.prototype;
	/**
	*@private
	*/
	__proto.onAsynLoaded=function(url,data,params){
		var jsonData=data[0];
		if (jsonData.version){
			_super.prototype.onAsynLoaded.call(this,url,data,params);
			}else {
			var textureMap=data[1];
			var props=jsonData.props;
			for (var prop in props)
			this[prop]=props[prop];
			ShurikenParticleMaterial._parseShurikenParticleMaterial(textureMap,this,jsonData);
			this._endLoaded();
		}
	}

	/**
	*设置渲染模式。
	*@return 渲染模式。
	*/
	__getset(0,__proto,'renderMode',null,function(value){
		switch (value){
			case 1:
				this.renderQueue=/*laya.d3.core.material.BaseMaterial.RENDERQUEUE_OPAQUE*/2000;
				this.depthWrite=true;
				this.cull=2;
				this.blend=0;
				this.alphaTest=false;
				this._removeShaderDefine(ShurikenParticleMaterial.SHADERDEFINE_ADDTIVEFOG);
				break ;
			case 2:
				this.renderQueue=/*laya.d3.core.material.BaseMaterial.RENDERQUEUE_OPAQUE*/2000;
				this.depthWrite=true;
				this.cull=0;
				this.blend=0;
				this.alphaTest=false;
				this._removeShaderDefine(ShurikenParticleMaterial.SHADERDEFINE_ADDTIVEFOG);
				break ;
			case 3:
				this.depthWrite=true;
				this.cull=2;
				this.blend=0;
				this.renderQueue=/*laya.d3.core.material.BaseMaterial.RENDERQUEUE_OPAQUE*/2000;
				this.alphaTest=true;
				this._removeShaderDefine(ShurikenParticleMaterial.SHADERDEFINE_ADDTIVEFOG);
				break ;
			case 4:
				this.renderQueue=/*laya.d3.core.material.BaseMaterial.RENDERQUEUE_OPAQUE*/2000;
				this.depthWrite=true;
				this.cull=0;
				this.blend=0;
				this.alphaTest=true;
				this._removeShaderDefine(ShurikenParticleMaterial.SHADERDEFINE_ADDTIVEFOG);
				break ;
			case 13:
				this.renderQueue=/*laya.d3.core.material.BaseMaterial.RENDERQUEUE_TRANSPARENT*/3000;
				this.depthWrite=true;
				this.cull=2;
				this.blend=1;
				this.srcBlend=0x0302;
				this.dstBlend=0x0303;
				this.alphaTest=false;
				this._removeShaderDefine(ShurikenParticleMaterial.SHADERDEFINE_ADDTIVEFOG);
				break ;
			case 14:
				this.renderQueue=/*laya.d3.core.material.BaseMaterial.RENDERQUEUE_TRANSPARENT*/3000;
				this.depthWrite=true;
				this.cull=0;
				this.blend=1;
				this.srcBlend=0x0302;
				this.dstBlend=0x0303;
				this.alphaTest=false;
				this._removeShaderDefine(ShurikenParticleMaterial.SHADERDEFINE_ADDTIVEFOG);
				break ;
			case 15:
				this.renderQueue=/*laya.d3.core.material.BaseMaterial.RENDERQUEUE_TRANSPARENT*/3000;
				this.depthWrite=true;
				this.cull=2;
				this.blend=1;
				this.srcBlend=0x0302;
				this.dstBlend=1;
				this.alphaTest=false;
				this._addShaderDefine(ShurikenParticleMaterial.SHADERDEFINE_ADDTIVEFOG);
				break ;
			case 16:
				this.renderQueue=/*laya.d3.core.material.BaseMaterial.RENDERQUEUE_TRANSPARENT*/3000;
				this.depthWrite=true;
				this.cull=0;
				this.blend=1;
				this.srcBlend=0x0302;
				this.dstBlend=1;
				this.alphaTest=false;
				this._addShaderDefine(ShurikenParticleMaterial.SHADERDEFINE_ADDTIVEFOG);
				break ;
			case 5:
				this.renderQueue=/*laya.d3.core.material.BaseMaterial.RENDERQUEUE_TRANSPARENT*/3000;
				this.depthWrite=false;
				this.cull=2;
				this.blend=1;
				this.srcBlend=0x0302;
				this.dstBlend=0x0303;
				this.alphaTest=false;
				this._removeShaderDefine(ShurikenParticleMaterial.SHADERDEFINE_ADDTIVEFOG);
				break ;
			case 6:
				this.renderQueue=/*laya.d3.core.material.BaseMaterial.RENDERQUEUE_TRANSPARENT*/3000;
				this.depthWrite=false;
				this.cull=0;
				this.blend=1;
				this.srcBlend=0x0302;
				this.dstBlend=0x0303;
				this.alphaTest=false;
				this._removeShaderDefine(ShurikenParticleMaterial.SHADERDEFINE_ADDTIVEFOG);
				break ;
			case 7:
				this.renderQueue=/*laya.d3.core.material.BaseMaterial.RENDERQUEUE_TRANSPARENT*/3000;
				this.depthWrite=false;
				this.cull=2;
				this.blend=1;
				this.srcBlend=0x0302;
				this.dstBlend=1;
				this.alphaTest=false;
				this._addShaderDefine(ShurikenParticleMaterial.SHADERDEFINE_ADDTIVEFOG);
				break ;
			case 8:
				this.renderQueue=/*laya.d3.core.material.BaseMaterial.RENDERQUEUE_TRANSPARENT*/3000;
				this.depthWrite=false;
				this.cull=0;
				this.blend=1;
				this.srcBlend=0x0302;
				this.dstBlend=1;
				this.alphaTest=false;
				this._addShaderDefine(ShurikenParticleMaterial.SHADERDEFINE_ADDTIVEFOG);
				break ;
			case 9:
				this.renderQueue=/*laya.d3.core.material.BaseMaterial.RENDERQUEUE_TRANSPARENT*/3000;
				this.depthTest=0x0201;
				this.cull=2;
				this.blend=1;
				this.srcBlend=0x0302;
				this.dstBlend=0x0303;
				this.alphaTest=false;
				this._removeShaderDefine(ShurikenParticleMaterial.SHADERDEFINE_ADDTIVEFOG);
				break ;
			case 10:
				this.renderQueue=/*laya.d3.core.material.BaseMaterial.RENDERQUEUE_TRANSPARENT*/3000;
				this.depthTest=0x0201;
				this.cull=0;
				this.blend=1;
				this.srcBlend=0x0302;
				this.dstBlend=0x0303;
				this.alphaTest=false;
				this._removeShaderDefine(ShurikenParticleMaterial.SHADERDEFINE_ADDTIVEFOG);
				break ;
			case 11:
				this.renderQueue=/*laya.d3.core.material.BaseMaterial.RENDERQUEUE_TRANSPARENT*/3000;
				this.depthTest=0x0201;
				this.cull=2;
				this.blend=1;
				this.srcBlend=0x0302;
				this.dstBlend=1;
				this.alphaTest=false;
				this._addShaderDefine(ShurikenParticleMaterial.SHADERDEFINE_ADDTIVEFOG);
				break ;
			case 12:
				this.renderQueue=/*laya.d3.core.material.BaseMaterial.RENDERQUEUE_TRANSPARENT*/3000;
				this.depthTest=0x0201;
				this.cull=0;
				this.blend=1;
				this.srcBlend=0x0302;
				this.dstBlend=1;
				this.alphaTest=false;
				this._addShaderDefine(ShurikenParticleMaterial.SHADERDEFINE_ADDTIVEFOG);
				break ;
			default :
				throw new Error("Material:renderMode value error.");
			}
		this._conchMaterial && this._conchMaterial.setRenderMode(value);
	});

	/**
	*设置颜色。
	*@param value 颜色。
	*/
	/**
	*获取颜色。
	*@return 颜色。
	*/
	__getset(0,__proto,'tintColor',function(){
		return this._getColor(2);
		},function(value){
		if (value)
			this._addShaderDefine(laya.d3.core.particleShuriKen.ShurikenParticleMaterial.SHADERDEFINE_TINTCOLOR);
		else
		this._removeShaderDefine(laya.d3.core.particleShuriKen.ShurikenParticleMaterial.SHADERDEFINE_TINTCOLOR);
		this._setColor(2,value);
	});

	/**
	*获取纹理平铺和偏移。
	*@param value 纹理平铺和偏移。
	*/
	/**
	*获取纹理平铺和偏移。
	*@return 纹理平铺和偏移。
	*/
	__getset(0,__proto,'tilingOffset',function(){
		return this._getColor(3);
		},function(value){
		if (value){
			var valueE=value.elements;
			if (valueE[0] !=1 || valueE[1] !=1 || valueE[2] !=0 || valueE[3] !=0)
				this._addShaderDefine(laya.d3.core.particleShuriKen.ShurikenParticleMaterial.SHADERDEFINE_TILINGOFFSET);
			else
			this._removeShaderDefine(laya.d3.core.particleShuriKen.ShurikenParticleMaterial.SHADERDEFINE_TILINGOFFSET);
			}else {
			this._removeShaderDefine(laya.d3.core.particleShuriKen.ShurikenParticleMaterial.SHADERDEFINE_TILINGOFFSET);
		}
		this._setColor(3,value);
	});

	/**
	*设置漫反射贴图。
	*@param value 漫反射贴图。
	*/
	/**
	*获取漫反射贴图。
	*@return 漫反射贴图。
	*/
	__getset(0,__proto,'diffuseTexture',function(){
		return this._getTexture(1);
		},function(value){
		if (value)
			this._addShaderDefine(laya.d3.core.particleShuriKen.ShurikenParticleMaterial.SHADERDEFINE_DIFFUSEMAP);
		else
		this._removeShaderDefine(laya.d3.core.particleShuriKen.ShurikenParticleMaterial.SHADERDEFINE_DIFFUSEMAP);
		this._setTexture(1,value);
	});

	ShurikenParticleMaterial.__init__=function(){
		ShurikenParticleMaterial.SHADERDEFINE_DIFFUSEMAP=ShurikenParticleMaterial.shaderDefines.registerDefine("DIFFUSEMAP");
		ShurikenParticleMaterial.SHADERDEFINE_TINTCOLOR=ShurikenParticleMaterial.shaderDefines.registerDefine("TINTCOLOR");
		ShurikenParticleMaterial.SHADERDEFINE_ADDTIVEFOG=ShurikenParticleMaterial.shaderDefines.registerDefine("ADDTIVEFOG");
		ShurikenParticleMaterial.SHADERDEFINE_TILINGOFFSET=ShurikenParticleMaterial.shaderDefines.registerDefine("TILINGOFFSET");
	}

	ShurikenParticleMaterial.load=function(url){
		return Laya.loader.create(url,null,null,ShurikenParticleMaterial);
	}

	ShurikenParticleMaterial._parseShurikenParticleMaterial=function(textureMap,material,json){
		var customProps=json.customProps;
		var diffuseTexture=customProps.diffuseTexture.texture2D;
		(diffuseTexture)&& (material.diffuseTexture=Loader.getRes(textureMap[diffuseTexture]));
		var tintColorValue=customProps.tintColor;
		(tintColorValue)&& (material.tintColor=new Vector4(tintColorValue[0],tintColorValue[1],tintColorValue[2],tintColorValue[3]));
	}

	ShurikenParticleMaterial.RENDERMODE_OPAQUE=1;
	ShurikenParticleMaterial.RENDERMODE_OPAQUEDOUBLEFACE=2;
	ShurikenParticleMaterial.RENDERMODE_CUTOUT=3;
	ShurikenParticleMaterial.RENDERMODE_CUTOUTDOUBLEFACE=4;
	ShurikenParticleMaterial.RENDERMODE_TRANSPARENT=13;
	ShurikenParticleMaterial.RENDERMODE_TRANSPARENTDOUBLEFACE=14;
	ShurikenParticleMaterial.RENDERMODE_ADDTIVE=15;
	ShurikenParticleMaterial.RENDERMODE_ADDTIVEDOUBLEFACE=16;
	ShurikenParticleMaterial.RENDERMODE_DEPTHREAD_TRANSPARENT=5;
	ShurikenParticleMaterial.RENDERMODE_DEPTHREAD_TRANSPARENTDOUBLEFACE=6;
	ShurikenParticleMaterial.RENDERMODE_DEPTHREAD_ADDTIVE=7;
	ShurikenParticleMaterial.RENDERMODE_DEPTHREAD_ADDTIVEDOUBLEFACE=8;
	ShurikenParticleMaterial.RENDERMODE_NONDEPTH_TRANSPARENT=9;
	ShurikenParticleMaterial.RENDERMODE_NONDEPTH_TRANSPARENTDOUBLEFACE=10;
	ShurikenParticleMaterial.RENDERMODE_NONDEPTH_ADDTIVE=11;
	ShurikenParticleMaterial.RENDERMODE_NONDEPTH_ADDTIVEDOUBLEFACE=12;
	ShurikenParticleMaterial.SHADERDEFINE_DIFFUSEMAP=0;
	ShurikenParticleMaterial.SHADERDEFINE_TINTCOLOR=0;
	ShurikenParticleMaterial.SHADERDEFINE_TILINGOFFSET=0;
	ShurikenParticleMaterial.SHADERDEFINE_ADDTIVEFOG=0;
	ShurikenParticleMaterial.DIFFUSETEXTURE=1;
	ShurikenParticleMaterial.TINTCOLOR=2;
	ShurikenParticleMaterial.TILINGOFFSET=3;
	__static(ShurikenParticleMaterial,
	['defaultMaterial',function(){return this.defaultMaterial=new ShurikenParticleMaterial();},'shaderDefines',function(){return this.shaderDefines=new ShaderDefines$1(BaseMaterial.shaderDefines);}
	]);
	return ShurikenParticleMaterial;
})(BaseMaterial)


/**
*...
*@author ...
*/
//class laya.d3.core.trail.TrailMaterial extends laya.d3.core.material.BaseMaterial
var TrailMaterial=(function(_super){
	function TrailMaterial(){
		TrailMaterial.__super.call(this);
		this.setShaderName("Trail");
		this._setColor(2,new Vector4(1.0,1.0,1.0,1.0));
	}

	__class(TrailMaterial,'laya.d3.core.trail.TrailMaterial',_super);
	var __proto=TrailMaterial.prototype;
	/**
	*设置颜色。
	*@param value 颜色。
	*/
	/**
	*获取颜色。
	*@return 颜色。
	*/
	__getset(0,__proto,'tintColor',function(){
		return this._getColor(2);
		},function(value){
		this._setColor(2,value);
	});

	/**
	*设置贴图。
	*@param value 贴图。
	*/
	/**
	*获取贴图。
	*@return 贴图。
	*/
	__getset(0,__proto,'diffuseTexture',function(){
		return this._getTexture(1);
		},function(value){
		if (value)
			this._addShaderDefine(laya.d3.core.trail.TrailMaterial.SHADERDEFINE_DIFFUSETEXTURE);
		else
		this._removeShaderDefine(laya.d3.core.trail.TrailMaterial.SHADERDEFINE_DIFFUSETEXTURE);
		this._setTexture(1,value);
	});

	/**
	*设置纹理平铺和偏移。
	*@param value 纹理平铺和偏移。
	*/
	/**
	*获取纹理平铺和偏移。
	*@return 纹理平铺和偏移。
	*/
	__getset(0,__proto,'tilingOffset',function(){
		return this._getColor(3);
		},function(value){
		if (value){
			var valueE=value.elements;
			if (valueE[0] !=1 || valueE[1] !=1 || valueE[2] !=0 || valueE[3] !=0)
				this._addShaderDefine(laya.d3.core.trail.TrailMaterial.SHADERDEFINE_TILINGOFFSET);
			else
			this._removeShaderDefine(laya.d3.core.trail.TrailMaterial.SHADERDEFINE_TILINGOFFSET);
			}else {
			this._removeShaderDefine(laya.d3.core.trail.TrailMaterial.SHADERDEFINE_TILINGOFFSET);
		}
		this._setColor(3,value);
	});

	TrailMaterial.__init__=function(){
		TrailMaterial.SHADERDEFINE_DIFFUSETEXTURE=TrailMaterial.shaderDefines.registerDefine("DIFFUSETEXTURE");
		TrailMaterial.SHADERDEFINE_TILINGOFFSET=TrailMaterial.shaderDefines.registerDefine("TILINGOFFSET");
	}

	TrailMaterial.load=function(url){
		return Laya.loader.create(url,null,null,TrailMaterial);
	}

	TrailMaterial.SHADERDEFINE_DIFFUSETEXTURE=0;
	TrailMaterial.SHADERDEFINE_TILINGOFFSET=0;
	TrailMaterial.DIFFUSETEXTURE=1;
	TrailMaterial.TINTCOLOR=2;
	TrailMaterial.TILINGOFFSET=3;
	__static(TrailMaterial,
	['defaultMaterial',function(){return this.defaultMaterial=new TrailMaterial();},'shaderDefines',function(){return this.shaderDefines=new ShaderDefines$1(BaseMaterial.shaderDefines);}
	]);
	return TrailMaterial;
})(BaseMaterial)


/**
*<code>RigidAnimations</code> 类用于创建变换动画组件。
*/
//class laya.d3.component.animation.RigidAnimations extends laya.d3.component.animation.KeyframeAnimations
var RigidAnimations=(function(_super){
	function RigidAnimations(){
		/**@private */
		this._animationSprites=null;
		/**@private */
		this._animationSpritesInitLocalMatrix=null;
		/**@private */
		this._tempCurAnimationData=null;
		/**@private */
		this._curOriginalData=null;
		/**@private */
		this._lastFrameIndex=-1;
		/**@private */
		this._curAnimationDatas=null;
		RigidAnimations.__super.call(this);
		this._animationSprites=[];
		this._animationSpritesInitLocalMatrix=[];
	}

	__class(RigidAnimations,'laya.d3.component.animation.RigidAnimations',_super);
	var __proto=RigidAnimations.prototype;
	/**
	*@private
	*/
	__proto._init=function(){
		var nodes=this._templet.getNodes(this.currentAnimationClipIndex);
		var curParentSprite=this._owner;
		var nodeLength=nodes.length;
		var pathStart=0;
		var extentDatas=new Uint16Array(this._templet.getPublicExtData());
		for (var i=0;i < nodeLength;i++){
			var hierarchys=extentDatas.slice(pathStart+1,pathStart+1+extentDatas[pathStart]);
			pathStart+=(extentDatas[pathStart]+1);
			for (var j=1;j < hierarchys.length;j++){
				var childIndex=hierarchys[j];
				curParentSprite=curParentSprite._childs[hierarchys[j]];
			};
			var curSprite=curParentSprite.getChildByName(nodes[i].name);
			if (!curSprite)
				break ;
			this._animationSprites[i]=curSprite;
			var localMatrix=this._animationSpritesInitLocalMatrix[i];
			(localMatrix)|| (localMatrix=this._animationSpritesInitLocalMatrix[i]=new Matrix4x4());
			curSprite.transform.localMatrix.cloneTo(localMatrix);
			curParentSprite=this._owner;
		}
	}

	/**
	*@private
	*/
	__proto._animtionPlay=function(){
		if (this._templet.loaded)
			this._init();
		else
		this._templet.once(/*laya.events.Event.LOADED*/"loaded",this,this._init);
	}

	/**
	*@private
	*/
	__proto._animtionStop=function(){
		this._lastFrameIndex=-1;
		if (this._player.returnToZeroStopped){
			this._curAnimationDatas=null;
			for (var i=0;i < this._animationSprites.length;i++)
			this._animationSprites[i].transform.localMatrix=this._animationSpritesInitLocalMatrix[i];
		}
	}

	/**
	*@private
	*摄像机动画作用函数。
	*/
	__proto._effectAnimation=function(nodes){
		for (var nodeIndex=0,nodeLength=this._animationSprites.length;nodeIndex < nodeLength;nodeIndex++){
			var sprite=this._animationSprites[nodeIndex];
			var matrix=sprite.transform.localMatrix;
			var matrixE=matrix.elements;
			for (var i=0;i < 16;i++)
			matrixE[i]=this._curAnimationDatas[nodeIndex *16+i];
			sprite.transform.localMatrix=matrix;
		}
	}

	/**
	*@private
	*初始化载入摄像机动画组件。
	*@param owner 所属精灵对象。
	*/
	__proto._load=function(owner){
		_super.prototype._load.call(this,owner);
		this._player.on(/*laya.events.Event.STOPPED*/"stopped",this,this._animtionStop);
		this._player.on(/*laya.events.Event.PLAYED*/"played",this,this._animtionPlay);
	}

	/**
	*@private
	*更新摄像机动画组件。
	*@param state 渲染状态。
	*/
	__proto._update=function(state){
		if (this._player.state!==/*laya.ani.AnimationState.playing*/2 || !this._templet || !this._templet.loaded)
			return;
		var rate=this._player.playbackRate *Laya.timer.scale;
		var cachePlayRate=this._player.cachePlayRate;
		var isCache=this._player.isCache && rate >=cachePlayRate;
		var frameIndex=isCache ? this.currentFrameIndex :-1;
		if (frameIndex!==-1 && this._lastFrameIndex===frameIndex)
			return;
		var animationClipIndex=this.currentAnimationClipIndex;
		var nodes=this._templet.getNodes(animationClipIndex);
		var animationDatasCache=this._templet._animationDatasCache;
		if (isCache){
			var cacheData=this._templet.getAnimationDataWithCache(cachePlayRate,animationDatasCache,animationClipIndex,frameIndex);
			if (cacheData){
				this._curAnimationDatas=cacheData;
				this._lastFrameIndex=frameIndex;
				this._effectAnimation(nodes);
				return;
			}
		};
		var nodeFloatCount=nodes.length *16;
		if (isCache){
			this._curAnimationDatas=new Float32Array(nodeFloatCount);
			}else{
			(this._tempCurAnimationData)|| (this._tempCurAnimationData=new Float32Array(nodeFloatCount));
			this._curAnimationDatas=this._tempCurAnimationData;
		}
		this._curOriginalData || (this._curOriginalData=new Float32Array(this._templet.getTotalkeyframesLength(animationClipIndex)));
		if (isCache)
			this._templet.getOriginalData(animationClipIndex,this._curOriginalData,this._player._fullFrames[animationClipIndex],frameIndex,this._player.currentFrameTime);
		else
		this._templet.getOriginalDataUnfixedRate(animationClipIndex,this._curOriginalData,this._player.currentPlayTime);
		Utils3D._computeRootAnimationData(nodes,this._curOriginalData,this._curAnimationDatas);
		if (isCache){
			this._templet.setAnimationDataWithCache(cachePlayRate,animationDatasCache,animationClipIndex,frameIndex,this._curAnimationDatas);
		}
		this._lastFrameIndex=frameIndex;
		this._effectAnimation(nodes);
	}

	/**
	*@private
	*卸载组件时执行。
	*/
	__proto._unload=function(owner){
		_super.prototype._unload.call(this,owner);
		this._animationSprites=null;
		this._animationSpritesInitLocalMatrix=null;
		this._tempCurAnimationData=null;
		this._curOriginalData=null;
		this._curAnimationDatas=null;
	}

	/**
	*设置url地址。
	*@param value 地址。
	*/
	__getset(0,__proto,'url',null,function(value){
		console.log("Warning: discard property,please use templet property instead.");
		var templet=Laya.loader.create(value,null,null,AnimationTemplet);
		if (this._templet!==templet){
			if (this._player.state!==/*laya.ani.AnimationState.stopped*/0)
				this._player.stop(true);
			this._templet=templet;
			this._player.templet=templet;
			this._curOriginalData=null;
			this._curAnimationDatas=null;
			this._tempCurAnimationData=null;
			(this._templet._animationDatasCache)|| (this._templet._animationDatasCache=[]);
			this.event(/*laya.events.Event.ANIMATION_CHANGED*/"animationchanged",this);
		}
	});

	__getset(0,__proto,'templet',_super.prototype._$get_templet,function(value){
		if (this._templet!==value){
			if (this._player.state!==/*laya.ani.AnimationState.stopped*/0)
				this._player.stop(true);
			this._templet=value;
			this._player.templet=value;
			this._curOriginalData=null;
			this._curAnimationDatas=null;
			this._tempCurAnimationData=null;
			(this._templet._animationDatasCache)|| (this._templet._animationDatasCache=[]);
			this.event(/*laya.events.Event.ANIMATION_CHANGED*/"animationchanged",this);
		}
	});

	return RigidAnimations;
})(KeyframeAnimations)


/**
*<code>SkinAnimations</code> 类用于创建蒙皮动画组件。
*/
//class laya.d3.component.animation.SkinAnimations extends laya.d3.component.animation.KeyframeAnimations
var SkinAnimations=(function(_super){
	function SkinAnimations(){
		/**@private */
		this._tempCurAnimationData=null;
		/**@private */
		this._tempCurBonesData=null;
		/**@private */
		this._curOriginalData=null;
		/**@private */
		this._lastFrameIndex=-1;
		/**@private */
		this._curMeshAnimationData=null;
		/**@private */
		this._curBonesDatas=null;
		/**@private */
		this._curAnimationDatas=null;
		/**@private */
		this._ownerMesh=null;
		/**@private */
		this._boneIndexToMeshList=null;
		/**@private */
		this._oldVersion=false;
		SkinAnimations.__super.call(this);
		this._boneIndexToMeshList=[];
	}

	__class(SkinAnimations,'laya.d3.component.animation.SkinAnimations',_super);
	var __proto=SkinAnimations.prototype;
	/**
	*@private
	*/
	__proto._computeBoneIndexToMeshOnTemplet=function(){
		if (this._templet.loaded)
			this._computeBoneIndexToMeshOnMesh();
		else
		this._templet.once(/*laya.events.Event.LOADED*/"loaded",this,this._computeBoneIndexToMeshOnMesh);
	}

	/**
	*@private
	*/
	__proto._computeBoneIndexToMeshOnMesh=function(){
		if (this._templet._aniVersion==="LAYAANIMATION:02")
			this._oldVersion=false;
		else
		this._oldVersion=true;
		var mesh=(this._owner).meshFilter.sharedMesh;
		if (mesh.loaded)
			this._computeBoneIndexToMesh(mesh);
		else
		mesh.on(/*laya.events.Event.LOADED*/"loaded",this,this._computeBoneIndexToMesh);
	}

	/**
	*@private
	*/
	__proto._computeBoneIndexToMesh=function(mesh){
		var meshBoneNames=mesh._boneNames;
		if (meshBoneNames){
			var binPoseCount=meshBoneNames.length;
			var anis=this._templet._anis;
			for (var i=0,n=anis.length;i < n;i++){
				var boneIndexToMesh=this._boneIndexToMeshList[i];
				(boneIndexToMesh)|| (boneIndexToMesh=this._boneIndexToMeshList[i]=[]);
				boneIndexToMesh.length=binPoseCount;
				var ani=anis[i];
				for (var j=0;j < binPoseCount;j++)
				boneIndexToMesh[j]=ani.bone3DMap[meshBoneNames[j]];
			}
		}
	}

	/**@private */
	__proto._getAnimationDatasWithCache=function(rate,mesh,cacheDatas,aniIndex,frameIndex){
		var aniDatas=cacheDatas[aniIndex];
		if (!aniDatas){
			return null;
			}else {
			var rateDatas=aniDatas[rate];
			if (!rateDatas)
				return null;
			else {
				var meshDatas=rateDatas[mesh.id];
				if (!meshDatas)
					return null;
				else
				return meshDatas[frameIndex];
			}
		}
	}

	/**@private */
	__proto._setAnimationDatasWithCache=function(rate,mesh,cacheDatas,aniIndex,frameIndex,animationDatas){
		var aniDatas=(cacheDatas[aniIndex])|| (cacheDatas[aniIndex]={});
		var rateDatas=(aniDatas[rate])|| (aniDatas[rate]={});
		var meshDatas=(rateDatas[mesh.id])|| (rateDatas[mesh.id]=[]);
		meshDatas[frameIndex]=animationDatas;
	}

	/**@private */
	__proto._onAnimationPlayMeshLoaded=function(){
		var renderElements=this._ownerMesh.meshRender._renderElements;
		for (var i=0,n=renderElements.length;i < n;i++)
		renderElements[i]._canDynamicBatch=false;
	}

	/**@private */
	__proto._onAnimationPlay=function(){
		this._ownerMesh._render._addShaderDefine(SkinnedMeshSprite3D.SHADERDEFINE_BONE);
		var mesh=this._ownerMesh.meshFilter.sharedMesh;
		if (mesh.loaded)
			this._onAnimationPlayMeshLoaded();
		else
		mesh.once(/*laya.events.Event.LOADED*/"loaded",this,this._onAnimationPlayMeshLoaded);
	}

	/**@private */
	__proto._onAnimationStop=function(){
		this._lastFrameIndex=-1;
		if (this._player.returnToZeroStopped){
			this._curBonesDatas=null;
			this._curAnimationDatas=null;
			this._ownerMesh._render._removeShaderDefine(SkinnedMeshSprite3D.SHADERDEFINE_BONE);
		};
		var renderElements=this._ownerMesh.meshRender._renderElements;
		for (var i=0,n=renderElements.length;i < n;i++)
		renderElements[i]._canDynamicBatch=true;
	}

	/**
	*@private
	*初始化载入蒙皮动画组件。
	*@param owner 所属精灵对象。
	*/
	__proto._load=function(owner){
		_super.prototype._load.call(this,owner);
		this._ownerMesh=(owner);
		this._player.on(/*laya.events.Event.PLAYED*/"played",this,this._onAnimationPlay);
		this._player.on(/*laya.events.Event.STOPPED*/"stopped",this,this._onAnimationStop);
		(this._owner).meshFilter.on(/*laya.events.Event.MESH_CHANGED*/"meshchanged",this,this._computeBoneIndexToMeshOnTemplet);
	}

	/**
	*@private
	*更新蒙皮动画组件。
	*@param state 渲染状态参数。
	*/
	__proto._update=function(state){
		var mesh=this._ownerMesh.meshFilter.sharedMesh;
		if (this._player.state!==/*laya.ani.AnimationState.playing*/2 || !this._templet || !this._templet.loaded || !mesh.loaded)
			return;
		var rate=this._player.playbackRate *Laya.timer.scale;
		var cachePlayRate=this._player.cachePlayRate;
		var isCache=this._player.isCache && rate >=cachePlayRate;
		var frameIndex=isCache ? this.currentFrameIndex :-1;
		if (frameIndex!==-1 && this._lastFrameIndex===frameIndex)
			return;
		var animationClipIndex=this.currentAnimationClipIndex;
		var boneDatasCache=this._templet._animationDatasCache[0];
		var animationDatasCache=this._templet._animationDatasCache[1];
		if (isCache){
			var cacheAnimationDatas=this._getAnimationDatasWithCache(cachePlayRate,mesh,animationDatasCache,animationClipIndex,frameIndex);
			if (cacheAnimationDatas){
				this._curAnimationDatas=cacheAnimationDatas;
				this._curBonesDatas=this._templet.getAnimationDataWithCache(cachePlayRate,boneDatasCache,animationClipIndex,frameIndex);
				this._lastFrameIndex=frameIndex;
				return;
			}
		};
		var isCacheBonesDatas=false;
		if (isCache){
			this._curBonesDatas=this._templet.getAnimationDataWithCache(cachePlayRate,boneDatasCache,animationClipIndex,frameIndex);
			isCacheBonesDatas=this._curBonesDatas ? true :false;
		};
		var bones=this._templet.getNodes(animationClipIndex);
		var boneFloatCount=bones.length *16;
		var inverseAbsoluteBindPoses=mesh.InverseAbsoluteBindPoses;
		if (this._oldVersion)
			(this._curMeshAnimationData)|| (this._curMeshAnimationData=new Float32Array(boneFloatCount));
		else
		(this._curMeshAnimationData)|| (this._curMeshAnimationData=new Float32Array(inverseAbsoluteBindPoses.length *16));
		var i=0,n=0,j=0;
		var curSubAnimationDatas,subMesh,boneIndicesCount=0;
		var subMeshCount=mesh.getSubMeshCount();
		if (isCache){
			this._curAnimationDatas=[];
			this._curAnimationDatas.length=subMeshCount;
			for (i=0;i < subMeshCount;i++){
				curSubAnimationDatas=this._curAnimationDatas[i]=[];
				subMesh=mesh.getSubMesh(i);
				boneIndicesCount=subMesh._boneIndicesList.length;
				curSubAnimationDatas.length=boneIndicesCount;
				for (j=0;j < boneIndicesCount;j++)
				curSubAnimationDatas[j]=new Float32Array(subMesh._boneIndicesList[j].length *16);
			}
			(isCacheBonesDatas)|| (this._curBonesDatas=new Float32Array(boneFloatCount));
			}else {
			if (!this._tempCurAnimationData){
				this._tempCurAnimationData=[];
				this._tempCurAnimationData.length=subMeshCount;
				for (i=0;i < subMeshCount;i++){
					curSubAnimationDatas=this._tempCurAnimationData[i]=[];
					subMesh=mesh.getSubMesh(i);
					boneIndicesCount=subMesh._boneIndicesList.length;
					curSubAnimationDatas.length=boneIndicesCount;
					for (j=0;j < boneIndicesCount;j++)
					curSubAnimationDatas[j]=new Float32Array(subMesh._boneIndicesList[j].length *16);
				}
			}
			(this._tempCurBonesData)|| (this._tempCurBonesData=new Float32Array(boneFloatCount));
			this._curAnimationDatas=this._tempCurAnimationData;
			this._curBonesDatas=this._tempCurBonesData;
		}
		this._curOriginalData || (this._curOriginalData=new Float32Array(this._templet.getTotalkeyframesLength(animationClipIndex)));
		if (isCache)
			this._templet.getOriginalData(animationClipIndex,this._curOriginalData,this._player._fullFrames[animationClipIndex],frameIndex,this._player.currentFrameTime);
		else
		this._templet.getOriginalDataUnfixedRate(animationClipIndex,this._curOriginalData,this._player.currentPlayTime);
		if (this._oldVersion){
			if (isCache && isCacheBonesDatas)
				Utils3D._computeAnimationDatasByArrayAndMatrixFastOld(inverseAbsoluteBindPoses,this._curBonesDatas,this._curMeshAnimationData);
			else
			Utils3D._computeBoneAndAnimationDatasByBindPoseMatrxixOld(bones,this._curOriginalData,inverseAbsoluteBindPoses,this._curBonesDatas,this._curMeshAnimationData);
			}else {
			var boneIndexToMesh=this._boneIndexToMeshList[animationClipIndex];
			if (isCache && isCacheBonesDatas)
				Utils3D._computeAnimationDatasByArrayAndMatrixFast(inverseAbsoluteBindPoses,this._curBonesDatas,this._curMeshAnimationData,boneIndexToMesh);
			else
			Utils3D._computeBoneAndAnimationDatasByBindPoseMatrxix(bones,this._curOriginalData,inverseAbsoluteBindPoses,this._curBonesDatas,this._curMeshAnimationData,boneIndexToMesh);
		}
		for (i=0;i < subMeshCount;i++){
			var boneIndicesList=mesh.getSubMesh(i)._boneIndicesList;
			boneIndicesCount=boneIndicesList.length;
			curSubAnimationDatas=this._curAnimationDatas[i]
			for (j=0;j < boneIndicesCount;j++)
			SkinAnimations._splitAnimationDatas(boneIndicesList[j],this._curMeshAnimationData,curSubAnimationDatas[j]);
		}
		if (isCache){
			this._setAnimationDatasWithCache(cachePlayRate,mesh,animationDatasCache,animationClipIndex,frameIndex,this._curAnimationDatas);
			(isCacheBonesDatas)|| (this._templet.setAnimationDataWithCache(cachePlayRate,boneDatasCache,animationClipIndex,frameIndex,this._curBonesDatas));
		}
		this._lastFrameIndex=frameIndex;
	}

	/**
	*@private
	*在渲染前更新蒙皮动画组件渲染参数。
	*@param state 渲染状态参数。
	*/
	__proto._preRenderUpdate=function(state){
		var subMesh=state.renderElement.renderObj;
		if (this._curAnimationDatas)
			subMesh._skinAnimationDatas=this._curAnimationDatas[subMesh._indexInMesh];
		else
		subMesh._skinAnimationDatas=null;
	}

	/**
	*@private
	*卸载组件时执行
	*/
	__proto._unload=function(owner){
		(this.player.state==/*laya.ani.AnimationState.playing*/2)&& (this._ownerMesh._render._removeShaderDefine(SkinnedMeshSprite3D.SHADERDEFINE_BONE));
		(this._templet && !this._templet.loaded)&& (this._templet.off(/*laya.events.Event.LOADED*/"loaded",this,this._computeBoneIndexToMeshOnMesh));
		var mesh=this._ownerMesh.meshFilter.sharedMesh;
		(mesh.loaded)|| (mesh.off(/*laya.events.Event.LOADED*/"loaded",this,this._onAnimationPlayMeshLoaded));
		_super.prototype._unload.call(this,owner);
		this._tempCurAnimationData=null;
		this._tempCurBonesData=null;
		this._curOriginalData=null;
		this._curMeshAnimationData=null;
		this._curBonesDatas=null;
		this._curAnimationDatas=null;
		this._ownerMesh=null;
	}

	/**
	*获取骨骼数据。
	*@return 骨骼数据。
	*/
	__getset(0,__proto,'curBonesDatas',function(){
		return this._curBonesDatas;
	});

	__getset(0,__proto,'templet',_super.prototype._$get_templet,function(value){
		if (this._templet!==value){
			if (this._player.state!==/*laya.ani.AnimationState.stopped*/0)
				this._player.stop(true);
			this._templet=value;
			this._player.templet=value;
			this._computeBoneIndexToMeshOnTemplet();
			this._curOriginalData=null;
			this._curMeshAnimationData=null;
			this._tempCurBonesData=null;
			this._tempCurAnimationData=null;
			(this._templet._animationDatasCache)|| (this._templet._animationDatasCache=[[],[]]);
			this.event(/*laya.events.Event.ANIMATION_CHANGED*/"animationchanged",this);
		}
	});

	SkinAnimations._splitAnimationDatas=function(indices,bonesData,subAnimationDatas){
		for (var i=0,n=indices.length,ii=0;i < n;i++){
			for (var j=0;j < 16;j++,ii++){
				subAnimationDatas[ii]=bonesData[(indices[i] << 4)+j];
			}
		}
	}

	return SkinAnimations;
})(KeyframeAnimations)


/**
*<code>BoxCollider</code> 类用于创建盒子碰撞器。
*/
//class laya.d3.component.physics.BoxCollider extends laya.d3.component.physics.Collider
var BoxCollider=(function(_super){
	function BoxCollider(){
		/**@private */
		this._size=null;
		/**@private */
		this._transformOrientedBoundBox=null;
		/**中心点 */
		this.center=null;
		BoxCollider.__super.call(this);
		this._needUpdate=false;
	}

	__class(BoxCollider,'laya.d3.component.physics.BoxCollider',_super);
	var __proto=BoxCollider.prototype;
	/**
	*@private
	*/
	__proto._updateCollider=function(){
		if (this._needUpdate){
			var obbMat=this._transformOrientedBoundBox.transformation;
			var transform=(this._owner).transform;
			var rotation=transform.rotation;
			var scale=transform.scale;
			var centerE=this.center.elements;
			if (centerE[0]===0.0 && centerE[1]===0.0 && centerE[2]===0.0){
				Matrix4x4.createAffineTransformation(transform.position,rotation,Vector3.ONE,obbMat);
				}else {
				Vector3.multiply(this.center,scale,BoxCollider._deviationV3);
				Vector3.transformQuat(BoxCollider._deviationV3,rotation,BoxCollider._deviationV3);
				Vector3.add(transform.position,BoxCollider._deviationV3,BoxCollider._deviationV3);
				Matrix4x4.createAffineTransformation(BoxCollider._deviationV3,rotation,Vector3.ONE,obbMat);
			}
			this._transformOrientedBoundBox.transformation=obbMat;
			var extentsE=this._transformOrientedBoundBox.extents.elements;
			var sizeE=this._size.elements;
			var scaleE=scale.elements;
			extentsE[0]=sizeE[0] *0.5 *scaleE[0];
			extentsE[1]=sizeE[1] *0.5 *scaleE[1];
			extentsE[2]=sizeE[2] *0.5 *scaleE[2];
			this._needUpdate=false;
		}
	}

	/**
	*@private
	*/
	__proto._onWorldMatrixChanged=function(){
		this._needUpdate=true;
		for (var k in this._runtimeCollisonMap){
			this._runtimeCollisonTestMap[k]=true;
			this._runtimeCollisonMap[k]._runtimeCollisonTestMap[this.id]=true;
		}
	}

	/**
	*@inheritDoc
	*/
	__proto._initialize=function(owner){
		laya.d3.component.Component3D.prototype._initialize.call(this,owner);
		this._transformOrientedBoundBox=new OrientedBoundBox(new Vector3(),new Matrix4x4());
		this._size=new Vector3();
		this.center=new Vector3();
		(owner).transform.on(/*laya.events.Event.WORLDMATRIX_NEEDCHANGE*/"worldmatrixneedchanged",this,this._onWorldMatrixChanged);
		this._needUpdate=true;
	}

	/**
	*@inheritDoc
	*/
	__proto._getType=function(){
		return 1;
	}

	/**
	*@inheritDoc
	*/
	__proto._collisonTo=function(other){
		switch (other._getType()){
			case 0:
				return this.boundBox.containsSphere((other).boundSphere)!==/*laya.d3.math.ContainmentType.Disjoint*/0;
				break ;
			case 1:
				return this.boundBox.containsOrientedBoundBox((other).boundBox)!==/*laya.d3.math.ContainmentType.Disjoint*/0;
				break ;
			case 2:;
				var meshCollider=other;
				if (this.boundBox.containsBoundBox(meshCollider._boundBox)!==/*laya.d3.math.ContainmentType.Disjoint*/0){
					var positions=(other).mesh._positions;
					for (var i=0,n=positions.length;i < n;i++){
						if (this.boundBox.containsPoint(positions[i])===/*laya.d3.math.ContainmentType.Contains*/1)
							return true
					}
					return false;
					}else {
					return false;
				}
				break ;
			default :
				throw new Error("BoxCollider:unknown collider type.");
			}
	}

	/**
	*@inheritDoc
	*/
	__proto._cloneTo=function(dest){
		var destBoxCollider=dest;
		var destSize=destBoxCollider.size;
		this.size.cloneTo(destSize);
		destBoxCollider.size=destSize;
		this.center.cloneTo(destBoxCollider.center);
	}

	/**
	*@inheritDoc
	*/
	__proto.raycast=function(ray,hitInfo,maxDistance){
		(maxDistance===void 0)&& (maxDistance=1.79e+308);
		this._updateCollider();
		var distance=this._transformOrientedBoundBox.intersectsRay(ray,hitInfo.position);
		if (distance!==-1 && distance <=maxDistance){
			hitInfo.distance=distance;
			hitInfo.sprite3D=this._owner;
			return true;
			}else {
			hitInfo.distance=-1;
			hitInfo.sprite3D=null;
			return false;
		}
	}

	/**
	*从AABB碰撞盒设置center和Size。
	*@param boundBox 碰撞盒。
	*/
	__proto.setFromBoundBox=function(boundBox){
		OrientedBoundBox.createByBoundBox(boundBox,this._transformOrientedBoundBox);
		var extents=this._transformOrientedBoundBox.extents;
		this._size=new Vector3(extents.x *2,extents.y *2,extents.z *2);
		this.center=new Vector3();
		Vector3.add(boundBox.min,boundBox.max,this.center);
		Vector3.scale(this.center,0.5,this.center);
		this._needUpdate=true;
	}

	/**
	*获取包围盒子,只读,不允许修改。
	*@return 包围球。
	*/
	__getset(0,__proto,'boundBox',function(){
		this._updateCollider();
		return this._transformOrientedBoundBox;
	});

	/**
	*设置盒子碰撞器长宽高的一半。
	*@param 长宽高的一半。
	*/
	/**
	*获取盒子碰撞器长宽高的一半。
	*@return 长宽高的一半。
	*/
	__getset(0,__proto,'size',function(){
		return this._size;
		},function(value){
		this._size=value;
		this._needUpdate=true;
	});

	__static(BoxCollider,
	['_deviationV3',function(){return this._deviationV3=new Vector3();},'_obbCenterV3',function(){return this._obbCenterV3=new Vector3();}
	]);
	return BoxCollider;
})(Collider)


/**
*<code>MeshCollider</code> 类用于创建网格碰撞器。
*/
//class laya.d3.component.physics.MeshCollider extends laya.d3.component.physics.Collider
var MeshCollider=(function(_super){
	function MeshCollider(){
		/**@private */
		this._transformBoundingBox=null;
		/**@private */
		this._mesh=null;
		MeshCollider.__super.call(this);
		this._transformBoundingBox=new BoundBox(new Vector3(),new Vector3());
		this._needUpdate=false;
	}

	__class(MeshCollider,'laya.d3.component.physics.MeshCollider',_super);
	var __proto=MeshCollider.prototype;
	/**
	*@private
	*/
	__proto._updateBoundBoxCollider=function(){
		if (this._needUpdate){
			var worldMat=(this._owner).transform.worldMatrix;
			var corners=this._mesh.boundingBoxCorners;
			for (var i=0;i < 8;i++)
			Vector3.transformCoordinate(corners[i],worldMat,MeshCollider._tempBoundBoxCorners[i]);
			BoundBox.createfromPoints(MeshCollider._tempBoundBoxCorners,this._transformBoundingBox);
			this._needUpdate=false;
		}
	}

	/**
	*@private
	*/
	__proto._raycastMesh=function(ray,sprite3D,outHitInfo,maxDistance){
		(maxDistance===void 0)&& (maxDistance=1.79e+308);
		var worldMatrix=sprite3D.transform.worldMatrix;
		var invertWorldMatrix=MeshCollider._tempMatrix4x40;
		worldMatrix.invert(invertWorldMatrix);
		var rayOrigin=ray.origin;
		var rayDirection=ray.direction;
		var transformRay=MeshCollider._tempRay0;
		Vector3.transformCoordinate(rayOrigin,invertWorldMatrix,transformRay.origin);
		Vector3.TransformNormal(rayDirection,invertWorldMatrix,transformRay.direction);
		var curMinDistance=Number.MAX_VALUE;
		for (var i=0,n=this._mesh.getRenderElementsCount();i < n;i++){
			var renderObj=this._mesh.getRenderElement(i);
			var vertexBuffer=renderObj._getVertexBuffer(0);
			var vertexDatas=vertexBuffer.getData();
			var indexDatas=renderObj._getIndexBuffer().getData();
			var elementRaycastHit=MeshCollider._tempRaycastHit;
			var isHit=Picker.rayIntersectsPositionsAndIndices(transformRay,vertexDatas,vertexBuffer.vertexDeclaration,indexDatas,elementRaycastHit);
			if (isHit){
				Vector3.transformCoordinate(elementRaycastHit.position,worldMatrix,elementRaycastHit.position);
				var rayOriToPos=MeshCollider._tempVector30;
				Vector3.subtract(rayOrigin,elementRaycastHit.position,rayOriToPos);
				var distance=Vector3.scalarLength(rayOriToPos);
				if ((distance < maxDistance)&& (distance < curMinDistance)){
					elementRaycastHit.distance=distance;
					elementRaycastHit.sprite3D=sprite3D;
					var trianglePositions=elementRaycastHit.trianglePositions;
					Vector3.transformCoordinate(trianglePositions[0],worldMatrix,trianglePositions[0]);
					Vector3.transformCoordinate(trianglePositions[1],worldMatrix,trianglePositions[1]);
					Vector3.transformCoordinate(trianglePositions[2],worldMatrix,trianglePositions[2]);
					var triangleNormals=elementRaycastHit.triangleNormals;
					Vector3.transformCoordinate(triangleNormals[0],worldMatrix,triangleNormals[0]);
					Vector3.transformCoordinate(triangleNormals[1],worldMatrix,triangleNormals[1]);
					Vector3.transformCoordinate(triangleNormals[2],worldMatrix,triangleNormals[2]);
					curMinDistance=distance;
					elementRaycastHit.cloneTo(outHitInfo);
					return true;
				}
				return false;
			}
		}
		return false;
	}

	/**
	*@private
	*/
	__proto._onWorldMatrixChanged=function(){
		this._needUpdate=true;
	}

	/**
	*@inheritDoc
	*/
	__proto._initialize=function(owner){
		laya.d3.component.Component3D.prototype._initialize.call(this,owner);
		(owner).transform.on(/*laya.events.Event.WORLDMATRIX_NEEDCHANGE*/"worldmatrixneedchanged",this,this._onWorldMatrixChanged);
		this._needUpdate=true;
	}

	/**
	*@inheritDoc
	*/
	__proto._getType=function(){
		return 2;
	}

	/**
	*@inheritDoc
	*/
	__proto._collisonTo=function(other){
		var i=0,n=0;
		var positions=this.mesh._positions;
		switch (other._getType()){
			case 0:;
				var otherSphere=other;
				if (Collision.sphereContainsBox(otherSphere.boundSphere,this._boundBox)!==/*laya.d3.math.ContainmentType.Disjoint*/0){
					for (i=0,n=positions.length;i < n;i++){
						if (Collision.sphereContainsPoint(otherSphere.boundSphere,positions[i])===/*laya.d3.math.ContainmentType.Contains*/1)
							return true
					}
					return false;
					}else {
					return false;
				}
				break ;
			case 1:;
				var otherBox=other;
				if (otherBox.boundBox.containsBoundBox(this._boundBox)!==/*laya.d3.math.ContainmentType.Disjoint*/0){
					for (i=0,n=positions.length;i < n;i++){
						if (otherBox.boundBox.containsPoint(positions[i])===/*laya.d3.math.ContainmentType.Contains*/1)
							return true
					}
					return false;
					break ;
					}else {
					return false;
				}
			case 2:;
				var otherMesh=other;
				if (Collision.intersectsBoxAndBox(otherMesh._boundBox,this._boundBox)!==/*laya.d3.math.ContainmentType.Contains*/1){
					return true;
					}else {
					return false;
				}
				throw new Error("MeshCollider:unknown collider type.");
				break ;
			default :
				throw new Error("MeshCollider:unknown collider type.");
			}
	}

	/**
	*@inheritDoc
	*/
	__proto._cloneTo=function(dest){
		var destCollider=dest;
		destCollider.mesh=this._mesh;
	}

	/**
	*@inheritDoc
	*/
	__proto.raycast=function(ray,hitInfo,maxDistance){
		(maxDistance===void 0)&& (maxDistance=1.79e+308);
		if (this._mesh==null || !this._mesh.loaded)
			return false;
		var distance=Collision.intersectsRayAndBoxRD(ray,this._boundBox);
		if (distance!==-1 && distance <=maxDistance && this._raycastMesh(ray,this._owner,hitInfo,maxDistance)){
			return true;
			}else {
			hitInfo.distance=-1;
			hitInfo.sprite3D=null;
			return false;
		}
	}

	/**
	*@private 只读,不允许修改。
	*/
	__getset(0,__proto,'_boundBox',function(){
		this._updateBoundBoxCollider();
		return this._transformBoundingBox;
	});

	/**
	*设置碰撞器网格。
	*@param value 碰撞其网格。
	*/
	/**
	*获取碰撞器网格。
	*@return 碰撞其网格。
	*/
	__getset(0,__proto,'mesh',function(){
		return this._mesh;
		},function(value){
		this._mesh=value;
	});

	__static(MeshCollider,
	['_tempRay0',function(){return this._tempRay0=new Ray(new Vector3(),new Vector3());},'_tempVector30',function(){return this._tempVector30=new Vector3();},'_tempMatrix4x40',function(){return this._tempMatrix4x40=new Matrix4x4();},'_tempRaycastHit',function(){return this._tempRaycastHit=new RaycastHit();},'_tempBoundBoxCorners',function(){return this._tempBoundBoxCorners=/*new vector.<>*/[new Vector3(),new Vector3(),new Vector3(),new Vector3(),new Vector3(),new Vector3(),new Vector3(),new Vector3()];}
	]);
	return MeshCollider;
})(Collider)


/**
*<code>SphereCollider</code> 类用于创建球碰撞器。
*/
//class laya.d3.component.physics.SphereCollider extends laya.d3.component.physics.Collider
var SphereCollider=(function(_super){
	function SphereCollider(){
		/**@private */
		this._originalBoundSphere=null;
		/**@private */
		this._transformBoundSphere=null;
		SphereCollider.__super.call(this);
		this._needUpdate=false;
	}

	__class(SphereCollider,'laya.d3.component.physics.SphereCollider',_super);
	var __proto=SphereCollider.prototype;
	/**
	*@private
	*/
	__proto._updateCollider=function(){
		if (this._needUpdate){
			var maxScale=NaN;
			var transform=(this._owner).transform;
			var scale=transform.scale;
			if (scale.x >=scale.y && scale.x >=scale.z)
				maxScale=scale.x;
			else
			maxScale=scale.y >=scale.z ? scale.y :scale.z;
			Vector3.transformCoordinate(this._originalBoundSphere.center,transform.worldMatrix,this._transformBoundSphere.center);
			this._transformBoundSphere.radius=this._originalBoundSphere.radius *maxScale;
			this._needUpdate=false;
		}
	}

	/**
	*@private
	*/
	__proto._onWorldMatrixChanged=function(){
		this._needUpdate=true;
		for (var k in this._runtimeCollisonMap){
			this._runtimeCollisonTestMap[k]=true;
			this._runtimeCollisonMap[k]._runtimeCollisonTestMap[this.id]=true;
		}
	}

	/**
	*@inheritDoc
	*/
	__proto._initialize=function(owner){
		laya.d3.component.Component3D.prototype._initialize.call(this,owner);
		this._originalBoundSphere=new BoundSphere(new Vector3(0,0,0),0.5);
		this._transformBoundSphere=new BoundSphere(new Vector3(0,0,0),0.5);
		(owner).transform.on(/*laya.events.Event.WORLDMATRIX_NEEDCHANGE*/"worldmatrixneedchanged",this,this._onWorldMatrixChanged);
		this._needUpdate=true;
	}

	/**
	*@inheritDoc
	*/
	__proto._getType=function(){
		return 0;
	}

	/**
	*@inheritDoc
	*/
	__proto._collisonTo=function(other){
		switch (other._getType()){
			case 0:
				return Collision.sphereContainsSphere(this.boundSphere,(other).boundSphere)!==/*laya.d3.math.ContainmentType.Disjoint*/0;
				break ;
			case 1:
				return (other).boundBox.containsSphere(this.boundSphere)!==/*laya.d3.math.ContainmentType.Disjoint*/0;
				break ;
			case 2:;
				var meshCollider=other;
				if (Collision.sphereContainsBox(this.boundSphere,meshCollider._boundBox)!==/*laya.d3.math.ContainmentType.Disjoint*/0){
					var positions=meshCollider.mesh._positions;
					for (var i=0,n=positions.length;i < n;i++){
						if (Collision.sphereContainsPoint(this.boundSphere,positions[i])===/*laya.d3.math.ContainmentType.Contains*/1)
							return true
					}
					return false;
					}else {
					return false;
				}
				break ;
			default :
				throw new Error("SphereCollider:unknown collider type.");
			}
	}

	/**
	*@inheritDoc
	*/
	__proto._cloneTo=function(dest){
		var destCollider=dest;
		destCollider.radius=this.radius;
		var destCenter=destCollider.center;
		this.center.cloneTo(destCenter);
		destCollider.center=destCenter;
	}

	/**
	*@inheritDoc
	*/
	__proto.raycast=function(ray,hitInfo,maxDistance){
		(maxDistance===void 0)&& (maxDistance=1.79e+308);
		this._updateCollider();
		var distance=this._transformBoundSphere.intersectsRayPoint(ray,hitInfo.position);
		if (distance!==-1 && distance <=maxDistance){
			hitInfo.distance=distance;
			hitInfo.sprite3D=this._owner;
			return true;
			}else {
			hitInfo.distance=-1;
			hitInfo.sprite3D=null;
			return false;
		}
	}

	/**
	*设置中心点。
	*@param value 中心点。
	*/
	/**
	*获取中心点。
	*@return 中心点。
	*/
	__getset(0,__proto,'center',function(){
		return this._originalBoundSphere.center;
		},function(value){
		this._originalBoundSphere.center=value;
	});

	/**
	*设置半径。
	*@param value 半径。
	*/
	/**
	*获取半径。
	*@return 半径。
	*/
	__getset(0,__proto,'radius',function(){
		return this._originalBoundSphere.radius;
		},function(value){
		this._originalBoundSphere.radius=value;
	});

	/**
	*获取包围球,只读,不允许修改。
	*@return 包围球。
	*/
	__getset(0,__proto,'boundSphere',function(){
		this._updateCollider();
		return this._transformBoundSphere;
	});

	return SphereCollider;
})(Collider)


//class laya.d3.resource.DataTexture2D extends laya.d3.resource.BaseTexture
var DataTexture2D=(function(_super){
	function DataTexture2D(){
		this.simLodInfo=null;
		/**@private 文件路径全名。*/
		this._src=null;
		/**@private Imagedata */
		this._buffer=null;
		this._mipmaps=null;
		/**@private 异步加载锁*/
		this._recreateLock=false;
		/**@private 异步加载完成后是否需要释放（有可能在恢复过程中,再次被释放，用此变量做标记）*/
		this._needReleaseAgain=false;
		DataTexture2D.__super.call(this);
		this._type=/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1;
	}

	__class(DataTexture2D,'laya.d3.resource.DataTexture2D',_super);
	var __proto=DataTexture2D.prototype;
	__proto.genDebugMipmaps=function(){
		var ret=[];
		ret.push(new Uint8Array((new Uint32Array(512 *256)).fill(0xff0000ff).buffer));
		ret.push(new Uint8Array((new Uint32Array(256 *128)).fill(0xff0080ff).buffer));
		ret.push(new Uint8Array((new Uint32Array(128 *64)).fill(0xff00ffff).buffer));
		ret.push(new Uint8Array((new Uint32Array(64 *32)).fill(0xff00ff00).buffer));
		ret.push(new Uint8Array((new Uint32Array(32 *16)).fill(0xff804000).buffer));
		ret.push(new Uint8Array((new Uint32Array(16 *8)).fill(0xffff0000).buffer));
		ret.push(new Uint8Array((new Uint32Array(8 *4)).fill(0xffff0080).buffer));
		ret.push(new Uint8Array((new Uint32Array(4 *2)).fill(0x0).buffer));
		ret.push(new Uint8Array((new Uint32Array(2 *1)).fill(0xff808080).buffer));
		ret.push(new Uint8Array((new Uint32Array(1 *1)).fill(0xffffffff).buffer));
		return ret;
	}

	/**
	*@private
	*/
	__proto._onTextureLoaded=function(buff){}
	/**
	*@private
	*/
	__proto._createWebGlTexture=function(){
		if (!this._buffer && !this._mipmaps)
			throw "create GLTextur err:no data";
		var gl=WebGL.mainContext;
		gl.getExtension("EXT_shader_texture_lod");
		var glTexture=this._source=gl.createTexture();
		var w=this._width;
		var h=this._height;
		var preTarget=WebGLContext.curBindTexTarget;
		var preTexture=WebGLContext.curBindTexValue;
		WebGLContext.bindTexture(gl,this._type,glTexture);
		if (this._mipmaps){
			if (laya.d3.resource.DataTexture2D.lodasatlas){
				var infoi=0;
				gl.texImage2D(this._type,0,/*laya.webgl.WebGLContext.RGBA*/0x1908,this._width,this._height,0,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401,null);
				for (var i=0;i < this._mipmaps.length;i++){
					if (this._mipmaps[i].byteLength !=cw *ch *4){
						throw "mipmap size error  level:"+i;
					}
					gl.texSubImage2D(this._type,0,DataTexture2D.simLodRect[infoi++],DataTexture2D.simLodRect[infoi++],DataTexture2D.simLodRect[infoi++],DataTexture2D.simLodRect[infoi++],/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401,new Uint8Array(this._mipmaps[i]));
				}
				this.minFifter=/*laya.webgl.WebGLContext.LINEAR*/0x2601;
				this.magFifter=/*laya.webgl.WebGLContext.LINEAR*/0x2601;
				}else {
				var cw=this._width;
				var ch=this._height;
				infoi=0;
				gl.texImage2D(this._type,0,/*laya.webgl.WebGLContext.RGBA*/0x1908,this._width,this._height,0,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401,null);
				for (i=0;i < this._mipmaps.length;i++){
					if (this._mipmaps[i].byteLength !=cw *ch *4){
						throw "mipmap size error  level:"+i;
					}
					gl.texImage2D(this._type,i,/*laya.webgl.WebGLContext.RGBA*/0x1908,cw,ch,0,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401,new Uint8Array(this._mipmaps[i]));
					cw /=2;
					ch /=2;
					if (cw < 1)cw=1;
					if (ch < 1)ch=1;
					this.minFifter=/*laya.webgl.WebGLContext.LINEAR_MIPMAP_LINEAR*/0x2703;
					this.magFifter=/*laya.webgl.WebGLContext.LINEAR*/0x2601;
				}
			}
			this.mipmap=false;
			}else {
			gl.texImage2D(this._type,0,/*laya.webgl.WebGLContext.RGBA*/0x1908,w,h,0,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401,new Uint8Array(this._buffer));
		};
		var minFifter=this._minFifter;
		var magFifter=this._magFifter;
		var repeat=this._repeat ? /*laya.webgl.WebGLContext.REPEAT*/0x2901 :/*laya.webgl.WebGLContext.CLAMP_TO_EDGE*/0x812F;
		var isPot=Arith.isPOT(w,h);
		if (isPot){
			if (this._mipmap || this._mipmaps)
				(minFifter!==-1)|| (minFifter=/*laya.webgl.WebGLContext.LINEAR_MIPMAP_LINEAR*/0x2703);
			else
			(minFifter!==-1)|| (minFifter=/*laya.webgl.WebGLContext.LINEAR*/0x2601);
			(magFifter!==-1)|| (magFifter=/*laya.webgl.WebGLContext.LINEAR*/0x2601);
			gl.texParameteri(this._type,/*laya.webgl.WebGLContext.TEXTURE_MIN_FILTER*/0x2801,minFifter);
			gl.texParameteri(this._type,/*laya.webgl.WebGLContext.TEXTURE_MAG_FILTER*/0x2800,magFifter);
			gl.texParameteri(this._type,/*laya.webgl.WebGLContext.TEXTURE_WRAP_S*/0x2802,repeat);
			if (this._mipmaps)
				gl.texParameteri(this._type,/*laya.webgl.WebGLContext.TEXTURE_WRAP_T*/0x2803,/*laya.webgl.WebGLContext.CLAMP_TO_EDGE*/0x812F);
			else
			gl.texParameteri(this._type,/*laya.webgl.WebGLContext.TEXTURE_WRAP_T*/0x2803,repeat);
			this._mipmap && gl.generateMipmap(this._type);
			}else {
			throw "data texture must be POT";
		}
		(preTarget && preTexture)&& (WebGLContext.bindTexture(gl,preTarget,preTexture));
		if (this.src && this.src.length > 0)
			this._buffer=null;
		if (isPot)
			this.memorySize=w *h *4 *(1+1 / 3);
		else
		this.memorySize=w *h *4;
		this._recreateLock=false;
	}

	/**
	*重新创建资源，如果异步创建中被强制释放再创建，则需等待释放完成后再重新加载创建。
	*/
	__proto.recreateResource=function(){
		if (!this._buffer && (this._src==null || this._src===""))
			return;
		this._needReleaseAgain=false;
		if (!this._buffer && !this._mipmaps){
			this._recreateLock=true;
			var _this=this;
			}else {
			if (this._recreateLock){
				return;
			}
			this._createWebGlTexture();
			this.completeCreate();
		}
	}

	/**
	*@private
	*/
	__proto.onAsynLoaded=function(url,data,params){
		var imgdata;
		if (params){
			imgdata=params[0].call(this,data);
		}
		if (imgdata){
			this._width=imgdata.width;
			this._height=imgdata.height;
			this._buffer=imgdata.data;
		}
		this._src=url;
		this._size=new Size(this._width,this._height);
		if (this._conchTexture){
			alert('怎么给runtime传递datatexture数据');
		}else
		this.activeResource();
		this._endLoaded();
	}

	/**
	*返回图片像素。
	*@return 图片像素。
	*/
	__proto.getPixels=function(){
		return new Uint8Array(this._buffer);
	}

	/**
	*销毁资源。
	*/
	__proto.disposeResource=function(){
		if (this._recreateLock){
			this._needReleaseAgain=true;
		}
		if (this._source){
			WebGL.mainContext.deleteTexture(this._source);
			this._source=null;
			this._buffer=null;
			this.memorySize=0;
		}
	}

	/**
	*获取文件路径全名。
	*/
	__getset(0,__proto,'src',function(){
		return this._src;
	});

	DataTexture2D.create=function(data,w,h,magfilter,minfilter,mipmap){
		(magfilter===void 0)&& (magfilter=/*laya.webgl.WebGLContext.LINEAR*/0x2601);
		(minfilter===void 0)&& (minfilter=/*laya.webgl.WebGLContext.LINEAR*/0x2601);
		(mipmap===void 0)&& (mipmap=true);
		if (!data || data.byteLength < (w *h *4))
			throw 'DataTexture2D create error';
		var ret=new DataTexture2D();
		ret._buffer=data;
		ret._width=w;
		ret._height=h;
		ret._mipmap=mipmap;
		ret._magFifter=magfilter;
		ret._minFifter=minfilter;
		ret._size=new Size(ret._width,ret._height);
		if (ret._conchTexture){
			alert('怎么给runtime传递datatexture数据');
		}else
		ret.activeResource();
		return ret;
	}

	DataTexture2D.load=function(url,w,h,magfilter,minfilter){
		(w===void 0)&& (w=0);
		(h===void 0)&& (h=0);
		(magfilter===void 0)&& (magfilter=/*laya.webgl.WebGLContext.LINEAR*/0x2601);
		(minfilter===void 0)&& (minfilter=/*laya.webgl.WebGLContext.LINEAR*/0x2601);
		var extension=Utils.getFileExtension(url);
		if (extension==='mipmaps'){
			var ret=Laya.loader.create(url,null,null,DataTexture2D,[function(data){
				this._mipmaps=[];
				var szinfo=new Uint32Array(data);
				this._width=szinfo[0];
				var validw=512;
				if (laya.d3.resource.DataTexture2D.lodasatlas){
					this._width *=2;
					validw=1024;
				}
				if (this._width !=validw){
					console.error("现在只支持512x256的环境贴图。当前的是"+szinfo[0]);
					throw "现在只支持512x256的环境贴图。当前的是"+szinfo[0];
				}
				this._height=szinfo[1];
				var curw=laya.d3.resource.DataTexture2D.lodasatlas ? this._width / 2 :this._width;
				var curh=this._height;
				var cursz=8;
				while (true){
					var curbufsz=curw *curh *4;
					if (cursz+curbufsz > data.byteLength){
						throw "load mipmaps data size error ";
					};
					var tbuf=new Uint8Array(data,cursz,curbufsz);
					this._mipmaps.push(tbuf);
					cursz+=curbufsz;
					if (curw==1 && curh==1){
						break ;
					}
					curw /=2;
					curh /=2;
					if (curw < 1)curw=1;
					if (curh < 1)curh=1;
				}
				return null;
			}]);
			if (laya.d3.resource.DataTexture2D.lodasatlas){
				ret.simLodInfo=new Float32Array(40);
				for (var i=0;i < ret.simLodInfo.length;){
					ret.simLodInfo[i]=(DataTexture2D.simLodRect[i]+0.5)/ 1024;
					i++;
					ret.simLodInfo[i]=(DataTexture2D.simLodRect[i]+0.5)/ 256;
					i++;
					ret.simLodInfo[i]=Math.max(DataTexture2D.simLodRect[i]-1,0.1)/ 1024;
					i++;
					ret.simLodInfo[i]=Math.max(DataTexture2D.simLodRect[i]-1.5,0.1)/ 256;
					i++;
				}
			}
			return ret;
			}else if (typeof(w)=='number'){
			return Laya.loader.create(url,null,null,DataTexture2D,[function(data){
				this._width=w;
				this._height=h;
				this._buffer=data;
				return null;
			}]);
			}else if (typeof(w)=='function'){
			return Laya.loader.create(url,null,null,DataTexture2D,[w]);
			}else {
			throw new Error("unknown params.");
		}
	}

	DataTexture2D.lodasatlas=false;
	__static(DataTexture2D,
	['simLodRect',function(){return this.simLodRect=new Uint32Array([
		0,0,512,256,
		512,0,256,128,
		512+256,0,128,64,
		512+256+128,0,64,32,
		512+256+128+64,0,32,16,
		512+256+128+64+32,0,16,8,
		512+256+128+64+32+16,0,8,4,
		512+256+128+64+32+16+8,0,4,2,
		512+256+128+64+32+16+8+4,0,2,1,
		512+256+128+64+32+16+8+4+2,0,1,1]);}
	]);
	return DataTexture2D;
})(BaseTexture)


/**
*@private
*<code>PrimitiveMesh</code> 类用于创建基本网格的父类。
*/
//class laya.d3.resource.models.PrimitiveMesh extends laya.d3.resource.models.BaseMesh
var PrimitiveMesh=(function(_super){
	function PrimitiveMesh(){
		this._numberVertices=0;
		this._numberIndices=0;
		this._vertexBuffer=null;
		this._indexBuffer=null;
		PrimitiveMesh.__super.call(this);
	}

	__class(PrimitiveMesh,'laya.d3.resource.models.PrimitiveMesh',_super);
	var __proto=PrimitiveMesh.prototype;
	Laya.imps(__proto,{"laya.d3.core.render.IRenderable":true})
	__proto._getVertexBuffer=function(index){
		(index===void 0)&& (index=0);
		if (index===0)
			return this._vertexBuffer;
		else
		return null;
	}

	__proto._getVertexBuffers=function(){
		return null;
	}

	__proto._getIndexBuffer=function(){
		return this._indexBuffer;
	}

	/**
	*获取网格顶点
	*@return 网格顶点。
	*/
	__proto._getPositions=function(){
		var vertices=[];
		var positionElement;
		var vertexElements=this._vertexBuffer.vertexDeclaration.getVertexElements();
		var j=0;
		for (j=0;j < vertexElements.length;j++){
			var vertexElement=vertexElements[j];
			if (vertexElement.elementFormat===/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3" && vertexElement.elementUsage===/*laya.d3.graphics.VertexElementUsage.POSITION0*/0){
				positionElement=vertexElement;
				break ;
			}
		};
		var verticesData=this._vertexBuffer.getData();
		for (j=0;j < verticesData.length;j+=this._vertexBuffer.vertexDeclaration.vertexStride / 4){
			var ofset=j+positionElement.offset / 4;
			var position=new Vector3(verticesData[ofset+0],verticesData[ofset+1],verticesData[ofset+2]);
			vertices.push(position);
		}
		return vertices;
	}

	__proto.getRenderElement=function(index){
		return this;
	}

	__proto.getRenderElementsCount=function(){
		return 1;
	}

	__proto.disposeResource=function(){
		(this._vertexBuffer)&& (this._vertexBuffer.destroy(),this._vertexBuffer=null);
		(this._indexBuffer)&& (this._indexBuffer.destroy(),this._indexBuffer=null);
		this.memorySize=0;
	}

	__proto._beforeRender=function(state){
		this._vertexBuffer._bind();
		this._indexBuffer._bind();
		return true;
	}

	__proto._render=function(state){
		WebGL.mainContext.drawElements(/*laya.webgl.WebGLContext.TRIANGLES*/0x0004,this._numberIndices,/*laya.webgl.WebGLContext.UNSIGNED_SHORT*/0x1403,0);
		Stat.drawCall++;
		Stat.trianglesFaces+=this._numberIndices / 3;
	}

	__getset(0,__proto,'_vertexBufferCount',function(){
		return 1;
	});

	__getset(0,__proto,'triangleCount',function(){
		return this._indexBuffer.indexCount / 3;
	});

	return PrimitiveMesh;
})(BaseMesh)


/**
*<code>Mesh</code> 类用于创建文件网格数据模板。
*/
//class laya.d3.resource.models.Mesh extends laya.d3.resource.models.BaseMesh
var Mesh=(function(_super){
	function Mesh(){
		/**@private */
		this._materials=null;
		/**@private */
		this._subMeshes=null;
		/**@private */
		this._vertexBuffers=null;
		/**@private */
		this._indexBuffer=null;
		/**@private */
		this._boneNames=null;
		/**@private */
		this._inverseBindPoses=null;
		/**@private */
		this._skinnedDatas=null;
		Mesh.__super.call(this);
		this._subMeshes=[];
		this._materials=[];
		this._vertexBuffers=[];
	}

	__class(Mesh,'laya.d3.resource.models.Mesh',_super);
	var __proto=Mesh.prototype;
	/**
	*获取网格顶点，并产生数据
	*@return 网格顶点。
	*/
	__proto._getPositions=function(){
		var vertices=[];
		var i=0,j=0,vertexBuffer,positionElement,vertexElements,vertexElement,ofset=0,verticesData;
		if (this._vertexBuffers.length!==0){
			var vertexBufferCount=this._vertexBuffers.length;
			for (i=0;i < vertexBufferCount;i++){
				vertexBuffer=this._vertexBuffers[i];
				vertexElements=vertexBuffer.vertexDeclaration.getVertexElements();
				for (j=0;j < vertexElements.length;j++){
					vertexElement=vertexElements[j];
					if (vertexElement.elementFormat===/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3" && vertexElement.elementUsage===/*laya.d3.graphics.VertexElementUsage.POSITION0*/0){
						positionElement=vertexElement;
						break ;
					}
				}
				verticesData=vertexBuffer.getData();
				for (j=0;j < verticesData.length;j+=vertexBuffer.vertexDeclaration.vertexStride / 4){
					ofset=j+positionElement.offset / 4;
					vertices.push(new Vector3(verticesData[ofset+0],verticesData[ofset+1],verticesData[ofset+2]));
				}
			}
			}else {
			var submesheCount=this._subMeshes.length;
			for (i=0;i < submesheCount;i++){
				var subMesh=this._subMeshes[i];
				vertexBuffer=subMesh._getVertexBuffer();
				vertexElements=vertexBuffer.vertexDeclaration.getVertexElements();
				for (j=0;j < vertexElements.length;j++){
					vertexElement=vertexElements[j];
					if (vertexElement.elementFormat===/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3" && vertexElement.elementUsage===/*laya.d3.graphics.VertexElementUsage.POSITION0*/0){
						positionElement=vertexElement;
						break ;
					}
				}
				verticesData=vertexBuffer.getData();
				for (j=0;j < verticesData.length;j+=vertexBuffer.vertexDeclaration.vertexStride / 4){
					ofset=j+positionElement.offset / 4;
					vertices.push(new Vector3(verticesData[ofset+0],verticesData[ofset+1],verticesData[ofset+2]));
				}
			}
		}
		return vertices;
	}

	/**
	*添加子网格（开发者禁止修改）。
	*@param subMesh 子网格。
	*/
	__proto._setSubMeshes=function(subMeshes){
		this._subMeshes=subMeshes
		this._subMeshCount=subMeshes.length;
		for (var i=0;i < this._subMeshCount;i++)
		subMeshes[i]._indexInMesh=i;
		this._positions=this._getPositions();
		this._generateBoundingObject();
	}

	/**
	*@private
	*/
	__proto.onAsynLoaded=function(url,data,params){
		var bufferData=data[0];
		var textureMap=data[1];
		MeshReader.read(bufferData,this,this._materials,this._subMeshes,textureMap);
		this.completeCreate();
		this._endLoaded();
	}

	/**
	*获得子网格。
	*@param index 子网格索引。
	*@return 子网格。
	*/
	__proto.getSubMesh=function(index){
		return this._subMeshes[index];
	}

	/**
	*获得子网格数量。
	*@return 子网格数量。
	*/
	__proto.getSubMeshCount=function(){
		return this._subMeshes.length;
	}

	/**
	*@inheritDoc
	*/
	__proto.getRenderElementsCount=function(){
		return this._subMeshes.length;
	}

	/**
	*@inheritDoc
	*/
	__proto.getRenderElement=function(index){
		return this._subMeshes[index];
	}

	/**
	*@inheritDoc
	*/
	__proto.disposeResource=function(){
		for (var i=0;i < this._subMeshes.length;i++)
		this._subMeshes[i].dispose();
		this._materials=null;
		this._subMeshes=null;
		this._vertexBuffers=null;
		this._indexBuffer=null;
		this._boneNames=null;
		this._inverseBindPoses=null;
	}

	/**
	*获取材质队列的浅拷贝。
	*@return 材质队列的浅拷贝。
	*/
	__getset(0,__proto,'materials',function(){
		return this._materials.slice();
	});

	/**
	*获取网格的全局默认绑定动作逆矩阵。
	*@return 网格的全局默认绑定动作逆矩阵。
	*/
	__getset(0,__proto,'InverseAbsoluteBindPoses',function(){
		return this._inverseBindPoses;
	});

	Mesh.load=function(url){
		return Laya.loader.create(url,null,null,Mesh);
	}

	return Mesh;
})(BaseMesh)


/**
*<code>RenderTarget</code> 类用于创建渲染目标。
*/
//class laya.d3.resource.RenderTexture extends laya.d3.resource.BaseTexture
var RenderTexture=(function(_super){
	function RenderTexture(width,height,surfaceFormat,surfaceType,depthStencilFormat,mipMap,repeat,minFifter,magFifter){
		/**@private */
		this._alreadyResolved=false;
		/**@private */
		this._surfaceFormat=0;
		/**@private */
		this._surfaceType=0;
		/**@private */
		this._depthStencilFormat=0;
		/**@private */
		this._frameBuffer=null;
		/**@private */
		this._depthStencilBuffer=null;
		(surfaceFormat===void 0)&& (surfaceFormat=/*laya.webgl.WebGLContext.RGBA*/0x1908);
		(surfaceType===void 0)&& (surfaceType=/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401);
		(depthStencilFormat===void 0)&& (depthStencilFormat=/*laya.webgl.WebGLContext.DEPTH_COMPONENT16*/0x81A5);
		(mipMap===void 0)&& (mipMap=false);
		(repeat===void 0)&& (repeat=false);
		(minFifter===void 0)&& (minFifter=-1);
		(magFifter===void 0)&& (magFifter=-1);
		RenderTexture.__super.call(this);
		this._type=/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1;
		this._width=width;
		this._height=height;
		this._size=new Size(width,height);
		this._surfaceFormat=surfaceFormat;
		this._surfaceType=surfaceType;
		this._depthStencilFormat=depthStencilFormat;
		this._mipmap=mipMap;
		this._repeat=repeat;
		this._minFifter=minFifter;
		this._magFifter=magFifter;
		this.activeResource();
		this._alreadyResolved=true;
	}

	__class(RenderTexture,'laya.d3.resource.RenderTexture',_super);
	var __proto=RenderTexture.prototype;
	__proto.recreateResource=function(){
		var gl=WebGL.mainContext;
		this._frameBuffer=gl.createFramebuffer();
		this._source=gl.createTexture();
		var preTarget=WebGLContext.curBindTexTarget;
		var preTexture=WebGLContext.curBindTexValue;
		WebGLContext.bindTexture(gl,this._type,this._source);
		gl.texImage2D(this._type,0,/*laya.webgl.WebGLContext.RGBA*/0x1908,this._width,this._height,0,this._surfaceFormat,this._surfaceType,null);
		var minFifter=this._minFifter;
		var magFifter=this._magFifter;
		var repeat=this._repeat ? /*laya.webgl.WebGLContext.REPEAT*/0x2901 :/*laya.webgl.WebGLContext.CLAMP_TO_EDGE*/0x812F;
		var isPot=Arith.isPOT(this._width,this._height);
		if (isPot){
			if (this._mipmap)
				(minFifter!==-1)|| (minFifter=/*laya.webgl.WebGLContext.LINEAR_MIPMAP_LINEAR*/0x2703);
			else
			(minFifter!==-1)|| (minFifter=/*laya.webgl.WebGLContext.LINEAR*/0x2601);
			(magFifter!==-1)|| (magFifter=/*laya.webgl.WebGLContext.LINEAR*/0x2601);
			gl.texParameteri(this._type,/*laya.webgl.WebGLContext.TEXTURE_MIN_FILTER*/0x2801,minFifter);
			gl.texParameteri(this._type,/*laya.webgl.WebGLContext.TEXTURE_MAG_FILTER*/0x2800,magFifter);
			gl.texParameteri(this._type,/*laya.webgl.WebGLContext.TEXTURE_WRAP_S*/0x2802,repeat);
			gl.texParameteri(this._type,/*laya.webgl.WebGLContext.TEXTURE_WRAP_T*/0x2803,repeat);
			this._mipmap && gl.generateMipmap(this._type);
			}else {
			(minFifter!==-1)|| (minFifter=/*laya.webgl.WebGLContext.LINEAR*/0x2601);
			(magFifter!==-1)|| (magFifter=/*laya.webgl.WebGLContext.LINEAR*/0x2601);
			gl.texParameteri(this._type,/*laya.webgl.WebGLContext.TEXTURE_MIN_FILTER*/0x2801,minFifter);
			gl.texParameteri(this._type,/*laya.webgl.WebGLContext.TEXTURE_MAG_FILTER*/0x2800,magFifter);
			gl.texParameteri(this._type,/*laya.webgl.WebGLContext.TEXTURE_WRAP_S*/0x2802,/*laya.webgl.WebGLContext.CLAMP_TO_EDGE*/0x812F);
			gl.texParameteri(this._type,/*laya.webgl.WebGLContext.TEXTURE_WRAP_T*/0x2803,/*laya.webgl.WebGLContext.CLAMP_TO_EDGE*/0x812F);
		}
		gl.bindFramebuffer(/*laya.webgl.WebGLContext.FRAMEBUFFER*/0x8D40,this._frameBuffer);
		gl.framebufferTexture2D(/*laya.webgl.WebGLContext.FRAMEBUFFER*/0x8D40,/*laya.webgl.WebGLContext.COLOR_ATTACHMENT0*/0x8CE0,/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,this._source,0);
		if (this._depthStencilFormat){
			this._depthStencilBuffer=gl.createRenderbuffer();
			gl.bindRenderbuffer(/*laya.webgl.WebGLContext.RENDERBUFFER*/0x8D41,this._depthStencilBuffer);
			gl.renderbufferStorage(/*laya.webgl.WebGLContext.RENDERBUFFER*/0x8D41,this._depthStencilFormat,this._width,this._height);
			switch (this._depthStencilFormat){
				case /*laya.webgl.WebGLContext.DEPTH_COMPONENT16*/0x81A5:
					gl.framebufferRenderbuffer(/*laya.webgl.WebGLContext.FRAMEBUFFER*/0x8D40,/*laya.webgl.WebGLContext.DEPTH_ATTACHMENT*/0x8D00,/*laya.webgl.WebGLContext.RENDERBUFFER*/0x8D41,this._depthStencilBuffer);
					break ;
				case /*laya.webgl.WebGLContext.STENCIL_INDEX8*/0x8D48:
					gl.framebufferRenderbuffer(/*laya.webgl.WebGLContext.FRAMEBUFFER*/0x8D40,/*laya.webgl.WebGLContext.STENCIL_ATTACHMENT*/0x8D20,/*laya.webgl.WebGLContext.RENDERBUFFER*/0x8D41,this._depthStencilBuffer);
					break ;
				case /*laya.webgl.WebGLContext.DEPTH_STENCIL*/0x84F9:
					gl.framebufferRenderbuffer(/*laya.webgl.WebGLContext.FRAMEBUFFER*/0x8D40,/*laya.webgl.WebGLContext.DEPTH_STENCIL_ATTACHMENT*/0x821A,/*laya.webgl.WebGLContext.RENDERBUFFER*/0x8D41,this._depthStencilBuffer);
					break ;
				}
		}
		gl.bindFramebuffer(/*laya.webgl.WebGLContext.FRAMEBUFFER*/0x8D40,null);
		(preTarget && preTexture)&& (WebGLContext.bindTexture(gl,preTarget,preTexture));
		gl.bindRenderbuffer(/*laya.webgl.WebGLContext.RENDERBUFFER*/0x8D41,null);
		this.memorySize=this._width *this._height *4;
		this.completeCreate();
	}

	/**
	*开始绑定。
	*/
	__proto.start=function(){
		WebGL.mainContext.bindFramebuffer(/*laya.webgl.WebGLContext.FRAMEBUFFER*/0x8D40,this.frameBuffer);
		RenderTexture._currentRenderTarget=this;
		this._alreadyResolved=false;
	}

	/**
	*结束绑定。
	*/
	__proto.end=function(){
		WebGL.mainContext.bindFramebuffer(/*laya.webgl.WebGLContext.FRAMEBUFFER*/0x8D40,null);
		RenderTexture._currentRenderTarget=null;
		this._alreadyResolved=true;
	}

	/**
	*获得像素数据。
	*@param x X像素坐标。
	*@param y Y像素坐标。
	*@param width 宽度。
	*@param height 高度。
	*@return 像素数据。
	*/
	__proto.getData=function(x,y,width,height){
		var gl=WebGL.mainContext;
		gl.bindFramebuffer(/*laya.webgl.WebGLContext.FRAMEBUFFER*/0x8D40,this._frameBuffer);
		var canRead=(gl.checkFramebufferStatus(/*laya.webgl.WebGLContext.FRAMEBUFFER*/0x8D40)===/*laya.webgl.WebGLContext.FRAMEBUFFER_COMPLETE*/0x8CD5);
		if (!canRead){
			gl.bindFramebuffer(/*laya.webgl.WebGLContext.FRAMEBUFFER*/0x8D40,null);
			return null;
		};
		var pixels=new Uint8Array(this._width *this._height *4);
		gl.readPixels(x,y,width,height,this._surfaceFormat,this._surfaceType,pixels);
		gl.bindFramebuffer(/*laya.webgl.WebGLContext.FRAMEBUFFER*/0x8D40,null);
		return pixels;
	}

	/**
	*销毁资源。
	*/
	__proto.disposeResource=function(){
		if (this._frameBuffer){
			var gl=WebGL.mainContext;
			gl.deleteTexture(this._source);
			gl.deleteFramebuffer(this._frameBuffer);
			gl.deleteRenderbuffer(this._depthStencilBuffer);
			this._source=null;
			this._frameBuffer=null;
			this._depthStencilBuffer=null;
			this.memorySize=0;
		}
	}

	/**
	*获取表面格式。
	*@return 表面格式。
	*/
	__getset(0,__proto,'surfaceFormat',function(){
		return this._surfaceFormat;
	});

	/**
	*获取表面类型。
	*@return 表面类型。
	*/
	__getset(0,__proto,'surfaceType',function(){
		return this._surfaceType;
	});

	/**
	*获取深度格式。
	*@return 深度格式。
	*/
	__getset(0,__proto,'depthStencilFormat',function(){
		return this._depthStencilFormat;
	});

	/**
	*获取RenderTarget数据源,如果alreadyResolved等于false，则返回null。
	*@return RenderTarget数据源。
	*/
	__getset(0,__proto,'source',function(){
		if (this._alreadyResolved)
			return Laya.superGet(BaseTexture,this,'source');
		else
		return null;
	});

	__getset(0,__proto,'depthStencilBuffer',function(){
		return this._depthStencilBuffer;
	});

	__getset(0,__proto,'frameBuffer',function(){
		return this._frameBuffer;
	});

	RenderTexture._currentRenderTarget=null;
	return RenderTexture;
})(BaseTexture)


/**
*<code>SolidColorTexture2D</code> 二维纯色纹理。
*/
//class laya.d3.resource.SolidColorTexture2D extends laya.d3.resource.BaseTexture
var SolidColorTexture2D=(function(_super){
	function SolidColorTexture2D(color){
		/**@private */
		this._color=null;
		/**@private */
		this._pixels=null;
		SolidColorTexture2D.__super.call(this);
		this._type=/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1;
		this._width=1;
		this._height=1;
		this._size=new Size(this.width,this.height);
		this._color=color;
		this._pixels=new Uint8Array([color.x *255,color.y *255,color.z *255,color.w *255]);
	}

	__class(SolidColorTexture2D,'laya.d3.resource.SolidColorTexture2D',_super);
	var __proto=SolidColorTexture2D.prototype;
	/**
	*@private
	*/
	__proto._createWebGlTexture=function(){
		var gl=WebGL.mainContext;
		var glTex=this._source=gl.createTexture();
		var w=this._width;
		var h=this._height;
		var preTarget=WebGLContext.curBindTexTarget;
		var preTexture=WebGLContext.curBindTexValue;
		WebGLContext.bindTexture(gl,this._type,glTex);
		gl.texImage2D(this._type,0,/*laya.webgl.WebGLContext.RGBA*/0x1908,w,h,0,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401,this._pixels);
		var minFifter=this._minFifter;
		var magFifter=this._magFifter;
		var repeat=this._repeat ? /*laya.webgl.WebGLContext.REPEAT*/0x2901 :/*laya.webgl.WebGLContext.CLAMP_TO_EDGE*/0x812F;
		var isPot=Arith.isPOT(w,h);
		if (isPot){
			if (this._mipmap)
				(minFifter!==-1)|| (minFifter=/*laya.webgl.WebGLContext.LINEAR_MIPMAP_LINEAR*/0x2703);
			else
			(minFifter!==-1)|| (minFifter=/*laya.webgl.WebGLContext.LINEAR*/0x2601);
			(magFifter!==-1)|| (magFifter=/*laya.webgl.WebGLContext.LINEAR*/0x2601);
			gl.texParameteri(this._type,/*laya.webgl.WebGLContext.TEXTURE_MIN_FILTER*/0x2801,minFifter);
			gl.texParameteri(this._type,/*laya.webgl.WebGLContext.TEXTURE_MAG_FILTER*/0x2800,magFifter);
			gl.texParameteri(this._type,/*laya.webgl.WebGLContext.TEXTURE_WRAP_S*/0x2802,repeat);
			gl.texParameteri(this._type,/*laya.webgl.WebGLContext.TEXTURE_WRAP_T*/0x2803,repeat);
			this._mipmap && gl.generateMipmap(this._type);
			}else {
			(minFifter!==-1)|| (minFifter=/*laya.webgl.WebGLContext.LINEAR*/0x2601);
			(magFifter!==-1)|| (magFifter=/*laya.webgl.WebGLContext.LINEAR*/0x2601);
			gl.texParameteri(this._type,/*laya.webgl.WebGLContext.TEXTURE_MIN_FILTER*/0x2801,minFifter);
			gl.texParameteri(this._type,/*laya.webgl.WebGLContext.TEXTURE_MAG_FILTER*/0x2800,magFifter);
			gl.texParameteri(this._type,/*laya.webgl.WebGLContext.TEXTURE_WRAP_S*/0x2802,/*laya.webgl.WebGLContext.CLAMP_TO_EDGE*/0x812F);
			gl.texParameteri(this._type,/*laya.webgl.WebGLContext.TEXTURE_WRAP_T*/0x2803,/*laya.webgl.WebGLContext.CLAMP_TO_EDGE*/0x812F);
		}
		(preTarget && preTexture)&& (WebGLContext.bindTexture(gl,preTarget,preTexture));
		if (isPot)
			this.memorySize=w *h *4 *(1+1 / 3);
		else
		this.memorySize=w *h *4;
	}

	/**
	*重新创建资源，如果异步创建中被强制释放再创建，则需等待释放完成后再重新加载创建。
	*/
	__proto.recreateResource=function(){
		this._createWebGlTexture();
		this.completeCreate();
	}

	/**
	*销毁资源。
	*/
	__proto.disposeResource=function(){
		if (this._source){
			WebGL.mainContext.deleteTexture(this._source);
			this._source=null;
			this.memorySize=0;
		}
	}

	__static(SolidColorTexture2D,
	['magentaTexture',function(){return this.magentaTexture=new SolidColorTexture2D(new Vector4(1.0,0.0,1.0,1.0));},'grayTexture',function(){return this.grayTexture=new SolidColorTexture2D(new Vector4(0.5,0.5,0.5,1.0));}
	]);
	return SolidColorTexture2D;
})(BaseTexture)


//class laya.d3.resource.SolidColorTextureCube extends laya.d3.resource.BaseTexture
var SolidColorTextureCube=(function(_super){
	function SolidColorTextureCube(color){
		/**@private */
		this._color=null;
		/**@private */
		this._pixels=null;
		/**@private */
		this._texCount=6;
		SolidColorTextureCube.__super.call(this);
		this._type=/*laya.webgl.WebGLContext.TEXTURE_CUBE_MAP*/0x8513;
		this._width=1;
		this._height=1;
		this._size=new Size(this.width,this.height);
		this._color=color;
		this._pixels=new Uint8Array([color.x *255,color.y *255,color.z *255,color.w *255]);
	}

	__class(SolidColorTextureCube,'laya.d3.resource.SolidColorTextureCube',_super);
	var __proto=SolidColorTextureCube.prototype;
	__proto._createWebGlTexture=function(){
		var gl=WebGL.mainContext;
		var glTex=this._source=gl.createTexture();
		var w=this._width;
		var h=this._height;
		var preTarget=WebGLContext.curBindTexTarget;
		var preTexture=WebGLContext.curBindTexValue;
		WebGLContext.bindTexture(gl,this._type,glTex);
		gl.texImage2D(/*laya.webgl.WebGLContext.TEXTURE_CUBE_MAP_POSITIVE_X*/0x8515,0,/*laya.webgl.WebGLContext.RGBA*/0x1908,w,h,0,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401,this._pixels);
		gl.texImage2D(/*laya.webgl.WebGLContext.TEXTURE_CUBE_MAP_NEGATIVE_X*/0x8516,0,/*laya.webgl.WebGLContext.RGBA*/0x1908,w,h,0,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401,this._pixels);
		gl.texImage2D(/*laya.webgl.WebGLContext.TEXTURE_CUBE_MAP_POSITIVE_Y*/0x8517,0,/*laya.webgl.WebGLContext.RGBA*/0x1908,w,h,0,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401,this._pixels);
		gl.texImage2D(/*laya.webgl.WebGLContext.TEXTURE_CUBE_MAP_NEGATIVE_Y*/0x8518,0,/*laya.webgl.WebGLContext.RGBA*/0x1908,w,h,0,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401,this._pixels);
		gl.texImage2D(/*laya.webgl.WebGLContext.TEXTURE_CUBE_MAP_POSITIVE_Z*/0x8519,0,/*laya.webgl.WebGLContext.RGBA*/0x1908,w,h,0,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401,this._pixels);
		gl.texImage2D(/*laya.webgl.WebGLContext.TEXTURE_CUBE_MAP_NEGATIVE_Z*/0x851A,0,/*laya.webgl.WebGLContext.RGBA*/0x1908,w,h,0,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401,this._pixels);
		var minFifter=this.minFifter;
		var magFifter=this.magFifter;
		var repeat=this._repeat ? /*laya.webgl.WebGLContext.REPEAT*/0x2901 :/*laya.webgl.WebGLContext.CLAMP_TO_EDGE*/0x812F;
		var isPOT=Arith.isPOT(w,h);
		if (isPOT){
			if (this.mipmap)
				(minFifter!==-1)|| (minFifter=/*laya.webgl.WebGLContext.LINEAR_MIPMAP_LINEAR*/0x2703);
			else
			(minFifter!==-1)|| (minFifter=/*laya.webgl.WebGLContext.LINEAR*/0x2601);
			(magFifter!==-1)|| (magFifter=/*laya.webgl.WebGLContext.LINEAR*/0x2601);
			gl.texParameteri(this._type,/*laya.webgl.WebGLContext.TEXTURE_MIN_FILTER*/0x2801,minFifter);
			gl.texParameteri(this._type,/*laya.webgl.WebGLContext.TEXTURE_MAG_FILTER*/0x2800,magFifter);
			gl.texParameteri(this._type,/*laya.webgl.WebGLContext.TEXTURE_WRAP_S*/0x2802,repeat);
			gl.texParameteri(this._type,/*laya.webgl.WebGLContext.TEXTURE_WRAP_T*/0x2803,repeat);
			this.mipmap && gl.generateMipmap(this._type);
			}else {
			(minFifter!==-1)|| (minFifter=/*laya.webgl.WebGLContext.LINEAR*/0x2601);
			(magFifter!==-1)|| (magFifter=/*laya.webgl.WebGLContext.LINEAR*/0x2601);
			gl.texParameteri(this._type,/*laya.webgl.WebGLContext.TEXTURE_MIN_FILTER*/0x2801,minFifter);
			gl.texParameteri(this._type,/*laya.webgl.WebGLContext.TEXTURE_MAG_FILTER*/0x2800,magFifter);
			gl.texParameteri(this._type,/*laya.webgl.WebGLContext.TEXTURE_WRAP_S*/0x2802,/*laya.webgl.WebGLContext.CLAMP_TO_EDGE*/0x812F);
			gl.texParameteri(this._type,/*laya.webgl.WebGLContext.TEXTURE_WRAP_T*/0x2803,/*laya.webgl.WebGLContext.CLAMP_TO_EDGE*/0x812F);
		}
		(preTarget && preTexture)&& (WebGLContext.bindTexture(gl,preTarget,preTexture));
		if (isPOT)
			this.memorySize=w *h *4 *(1+1 / 3)*this._texCount;
		else
		this.memorySize=w *h *4 *this._texCount;
	}

	__proto.recreateResource=function(){
		this._createWebGlTexture();
		this.completeCreate();
	}

	//处理创建完成后相关操作
	__proto.disposeResource=function(){
		if (this._source){
			WebGL.mainContext.deleteTexture(this._source);
			this._source=null;
			this.memorySize=0;
		}
	}

	__static(SolidColorTextureCube,
	['magentaTexture',function(){return this.magentaTexture=new SolidColorTextureCube(new Vector4(1.0,0.0,1.0,1.0));},'grayTexture',function(){return this.grayTexture=new SolidColorTextureCube(new Vector4(0.5,0.5,0.5,1.0));}
	]);
	return SolidColorTextureCube;
})(BaseTexture)


/**
*<code>Texture2D</code> 二维纹理。
*/
//class laya.d3.resource.Texture2D extends laya.d3.resource.BaseTexture
var Texture2D=(function(_super){
	function Texture2D(canRead,reapeat,format,mipmap){
		/**@private */
		this._canRead=false;
		/**@private HTML Image*/
		this._image=null;
		/**@private */
		this._pixels=null;
		(canRead===void 0)&& (canRead=false);
		(reapeat===void 0)&& (reapeat=true);
		(format===void 0)&& (format=/*laya.webgl.WebGLContext.RGBA*/0x1908);
		(mipmap===void 0)&& (mipmap=true);
		Texture2D.__super.call(this);
		this._type=/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1;
		this._repeat=reapeat;
		this._canRead=canRead;
		this._format=format;
		this._mipmap=mipmap;
	}

	__class(Texture2D,'laya.d3.resource.Texture2D',_super);
	var __proto=Texture2D.prototype;
	/**
	*@private
	*/
	__proto._createWebGlTexture=function(){
		if (!this._image)
			throw "create GLTextur err:no data:"+this._image;
		var gl=WebGL.mainContext;
		var glTexture=this._source=gl.createTexture();
		var w=this._width;
		var h=this._height;
		var preTarget=WebGLContext.curBindTexTarget;
		var preTexture=WebGLContext.curBindTexValue;
		WebGLContext.bindTexture(gl,this._type,glTexture);
		switch (this._format){
			case /*laya.webgl.WebGLContext.RGB*/0x1907:
			case /*laya.webgl.WebGLContext.RGBA*/0x1908:
				if (this._canRead)
					gl.texImage2D(this._type,0,this._format,w,h,0,this._format,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401,this._pixels);
				else
				gl.texImage2D(this._type,0,this._format,this._format,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401,this._image);
				break ;
			case WebGL.compressEtc1.COMPRESSED_RGB_ETC1_WEBGL:
				gl.compressedTexImage2D(this._type,0,this._format,this._width,this._height,0,this._image);
				break ;
			};
		var minFifter=this._minFifter;
		var magFifter=this._magFifter;
		var repeat=this._repeat ? /*laya.webgl.WebGLContext.REPEAT*/0x2901 :/*laya.webgl.WebGLContext.CLAMP_TO_EDGE*/0x812F;
		var wrapModeU=this._wrapModeU==0 ? /*laya.webgl.WebGLContext.REPEAT*/0x2901 :/*laya.webgl.WebGLContext.CLAMP_TO_EDGE*/0x812F;
		var wrapModeV=this._wrapModeV==0 ? /*laya.webgl.WebGLContext.REPEAT*/0x2901 :/*laya.webgl.WebGLContext.CLAMP_TO_EDGE*/0x812F;
		var isPot=Arith.isPOT(w,h);
		if (isPot){
			if (this._mipmap)
				(minFifter!==-1)|| (minFifter=/*laya.webgl.WebGLContext.LINEAR_MIPMAP_LINEAR*/0x2703);
			else
			(minFifter!==-1)|| (minFifter=/*laya.webgl.WebGLContext.LINEAR*/0x2601);
			(magFifter!==-1)|| (magFifter=/*laya.webgl.WebGLContext.LINEAR*/0x2601);
			gl.texParameteri(this._type,/*laya.webgl.WebGLContext.TEXTURE_MIN_FILTER*/0x2801,minFifter);
			gl.texParameteri(this._type,/*laya.webgl.WebGLContext.TEXTURE_MAG_FILTER*/0x2800,magFifter);
			gl.texParameteri(this._type,/*laya.webgl.WebGLContext.TEXTURE_WRAP_S*/0x2802,repeat);
			gl.texParameteri(this._type,/*laya.webgl.WebGLContext.TEXTURE_WRAP_T*/0x2803,repeat);
			gl.texParameteri(this._type,/*laya.webgl.WebGLContext.TEXTURE_WRAP_S*/0x2802,wrapModeU);
			gl.texParameteri(this._type,/*laya.webgl.WebGLContext.TEXTURE_WRAP_T*/0x2803,wrapModeV);
			this._mipmap && gl.generateMipmap(this._type);
			}else {
			(minFifter!==-1)|| (minFifter=/*laya.webgl.WebGLContext.LINEAR*/0x2601);
			(magFifter!==-1)|| (magFifter=/*laya.webgl.WebGLContext.LINEAR*/0x2601);
			gl.texParameteri(this._type,/*laya.webgl.WebGLContext.TEXTURE_MIN_FILTER*/0x2801,minFifter);
			gl.texParameteri(this._type,/*laya.webgl.WebGLContext.TEXTURE_MAG_FILTER*/0x2800,magFifter);
			gl.texParameteri(this._type,/*laya.webgl.WebGLContext.TEXTURE_WRAP_S*/0x2802,/*laya.webgl.WebGLContext.CLAMP_TO_EDGE*/0x812F);
			gl.texParameteri(this._type,/*laya.webgl.WebGLContext.TEXTURE_WRAP_T*/0x2803,/*laya.webgl.WebGLContext.CLAMP_TO_EDGE*/0x812F);
		}
		(preTarget && preTexture)&& (WebGLContext.bindTexture(gl,preTarget,preTexture));
		this._image.onload=null;
		this._image=null;
		if (isPot)
			this.memorySize=w *h *4 *(1+1 / 3);
		else
		this.memorySize=w *h *4;
	}

	/**
	*重新创建资源，如果异步创建中被强制释放再创建，则需等待释放完成后再重新加载创建。
	*/
	__proto.recreateResource=function(){
		this._createWebGlTexture();
		this.completeCreate();
	}

	/**
	*@private
	*/
	__proto.onAsynLoaded=function(url,data,params){
		if (params){
			var canRead=params[0];
			(canRead!==undefined)&& (this._canRead=canRead);
			var repeat=params[1];
			(repeat!==undefined)&& (this._repeat=repeat);
			var format=params[2];
			(format!==undefined)&& (this._format=format);
			var mipmap=params[3];
			(mipmap!==undefined)&& (this._mipmap=mipmap);
			var wrapModeU=params.wrapModeU;
			(wrapModeU!==undefined)&& (this._wrapModeU=wrapModeU);
			var wrapModeV=params.wrapModeV;
			(wrapModeV!==undefined)&& (this._wrapModeV=wrapModeV);
		}
		switch (this._format){
			case /*laya.webgl.WebGLContext.RGB*/0x1907:
			case /*laya.webgl.WebGLContext.RGBA*/0x1908:
				this._image=data;
				var w=data.width;
				var h=data.height;
				this._width=w;
				this._height=h;
				this._size=new Size(w,h);
				if (this._canRead){
					if (Render.isConchApp){
						if (/*__JS__ */data instanceof window.HTMLElement){
							this._pixels=new Uint8Array(data.getImageData(0,0,w,h));
						}
					}
					else {
						Browser.canvas.size(w,h);
						Browser.canvas.clear();
						Browser.context.drawImage(data,0,0,w,h);
						this._pixels=new Uint8Array(Browser.context.getImageData(0,0,w,h).data.buffer);
					}
				}
				break ;
			case WebGL.compressEtc1.COMPRESSED_RGB_ETC1_WEBGL:;
				var readData=new Byte(data);
				var magicNumber=readData.readUTFBytes(4);
				var version=readData.readUTFBytes(2);
				var dataType=readData.getInt16();
				readData.endian=/*laya.utils.Byte.BIG_ENDIAN*/"bigEndian";
				this._width=readData.getInt16();
				this._height=readData.getInt16();
				this._size=new Size(this._width,this._height);
				var originalWidth=readData.getInt16();
				var originalHeight=readData.getInt16();
				this._image=new Uint8Array(data,readData.pos);
			}
		this.recreateResource();
		this._endLoaded();
	}

	/**
	*返回图片像素。
	*@return 图片像素。
	*/
	__proto.getPixels=function(){
		if (this._canRead)
			return this._pixels;
		else
		throw new Error("Texture2D: must set texture canRead is true.");
	}

	/**
	*销毁资源。
	*/
	__proto.disposeResource=function(){
		if (this._source){
			WebGL.mainContext.deleteTexture(this._source);
			this._source=null;
			this._image=null;
			this.memorySize=0;
		}
	}

	/**@private */
	__getset(0,__proto,'_src',function(){
		return this.url;
	});

	/**@private */
	__getset(0,__proto,'src',function(){
		return this.url;
	});

	Texture2D.load=function(url){
		return Laya.loader.create(url,null,null,Texture2D);
	}

	return Texture2D;
})(BaseTexture)


//class laya.d3.resource.TextureCube extends laya.d3.resource.BaseTexture
var TextureCube=(function(_super){
	function TextureCube(){
		/**@private */
		//this._images=null;
		TextureCube.__super.call(this);
		this._type=/*laya.webgl.WebGLContext.TEXTURE_CUBE_MAP*/0x8513;
	}

	__class(TextureCube,'laya.d3.resource.TextureCube',_super);
	var __proto=TextureCube.prototype;
	/**
	*@private
	*/
	__proto._onTextureLoaded=function(images){
		this._images=images;
		var minWidth=2147483647;
		var minHeight=2147483647;
		for (var i=0;i < 6;i++){
			var image=images[i];
			minWidth=Math.min(minWidth,image.width);
			minHeight=Math.min(minHeight,image.height);
		}
		this._width=minWidth;
		this._height=minHeight;
		this._size=new Size(minWidth,minHeight);
	}

	__proto._createWebGlTexture=function(){
		var texCount=6;
		var i=0;
		for (i=0;i < texCount;i++){
			if (!this._images[i]){
				throw "create GLTextur err:no data:"+this._images[i];
			}
		};
		var gl=WebGL.mainContext;
		var glTex=this._source=gl.createTexture();
		var w=this._width;
		var h=this._height;
		var preTarget=WebGLContext.curBindTexTarget;
		var preTexture=WebGLContext.curBindTexValue;
		WebGLContext.bindTexture(gl,this._type,glTex);
		gl.texImage2D(/*laya.webgl.WebGLContext.TEXTURE_CUBE_MAP_POSITIVE_X*/0x8515,0,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401,this._images[0]);
		gl.texImage2D(/*laya.webgl.WebGLContext.TEXTURE_CUBE_MAP_NEGATIVE_X*/0x8516,0,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401,this._images[1]);
		gl.texImage2D(/*laya.webgl.WebGLContext.TEXTURE_CUBE_MAP_POSITIVE_Y*/0x8517,0,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401,this._images[2]);
		gl.texImage2D(/*laya.webgl.WebGLContext.TEXTURE_CUBE_MAP_NEGATIVE_Y*/0x8518,0,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401,this._images[3]);
		gl.texImage2D(/*laya.webgl.WebGLContext.TEXTURE_CUBE_MAP_POSITIVE_Z*/0x8519,0,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401,this._images[4]);
		gl.texImage2D(/*laya.webgl.WebGLContext.TEXTURE_CUBE_MAP_NEGATIVE_Z*/0x851A,0,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401,this._images[5]);
		var minFifter=this.minFifter;
		var magFifter=this.magFifter;
		var repeat=this._repeat ? /*laya.webgl.WebGLContext.REPEAT*/0x2901 :/*laya.webgl.WebGLContext.CLAMP_TO_EDGE*/0x812F;
		var isPOT=Arith.isPOT(w,h);
		if (isPOT){
			if (this.mipmap)
				(minFifter!==-1)|| (minFifter=/*laya.webgl.WebGLContext.LINEAR_MIPMAP_LINEAR*/0x2703);
			else
			(minFifter!==-1)|| (minFifter=/*laya.webgl.WebGLContext.LINEAR*/0x2601);
			(magFifter!==-1)|| (magFifter=/*laya.webgl.WebGLContext.LINEAR*/0x2601);
			gl.texParameteri(this._type,/*laya.webgl.WebGLContext.TEXTURE_MIN_FILTER*/0x2801,minFifter);
			gl.texParameteri(this._type,/*laya.webgl.WebGLContext.TEXTURE_MAG_FILTER*/0x2800,magFifter);
			gl.texParameteri(this._type,/*laya.webgl.WebGLContext.TEXTURE_WRAP_S*/0x2802,repeat);
			gl.texParameteri(this._type,/*laya.webgl.WebGLContext.TEXTURE_WRAP_T*/0x2803,repeat);
			this.mipmap && gl.generateMipmap(this._type);
			}else {
			(minFifter!==-1)|| (minFifter=/*laya.webgl.WebGLContext.LINEAR*/0x2601);
			(magFifter!==-1)|| (magFifter=/*laya.webgl.WebGLContext.LINEAR*/0x2601);
			gl.texParameteri(this._type,/*laya.webgl.WebGLContext.TEXTURE_MIN_FILTER*/0x2801,minFifter);
			gl.texParameteri(this._type,/*laya.webgl.WebGLContext.TEXTURE_MAG_FILTER*/0x2800,magFifter);
			gl.texParameteri(this._type,/*laya.webgl.WebGLContext.TEXTURE_WRAP_S*/0x2802,/*laya.webgl.WebGLContext.CLAMP_TO_EDGE*/0x812F);
			gl.texParameteri(this._type,/*laya.webgl.WebGLContext.TEXTURE_WRAP_T*/0x2803,/*laya.webgl.WebGLContext.CLAMP_TO_EDGE*/0x812F);
		}
		(preTarget && preTexture)&& (WebGLContext.bindTexture(gl,preTarget,preTexture));
		for (i=0;i < 6;i++){
			this._images[i].onload=null;
			this._images[i]=null;
		}
		if (isPOT)
			this.memorySize=w *h *4 *(1+1 / 3)*texCount;
		else
		this.memorySize=w *h *4 *texCount;
	}

	__proto.recreateResource=function(){
		if (this._url==null)
			return;
		this._createWebGlTexture();
		this.completeCreate();
	}

	/**
	*@private
	*/
	__proto.onAsynLoaded=function(url,data,params){
		this._onTextureLoaded(data);
		this.activeResource();
		this._endLoaded();
	}

	__proto.disposeResource=function(){
		if (this._source){
			WebGL.mainContext.deleteTexture(this._source);
			this._source=null;
			this.memorySize=0;
		}
	}

	/**
	*@inheritDoc
	*/
	__getset(0,__proto,'defaulteTexture',function(){
		return SolidColorTextureCube.grayTexture;
	});

	TextureCube.load=function(url){
		return Laya.loader.create(url,null,null,TextureCube);
	}

	return TextureCube;
})(BaseTexture)


/**
*<code>SkinMeshRender</code> 类用于蒙皮渲染器。
*/
//class laya.d3.core.SkinnedMeshRender extends laya.d3.core.MeshRender
var SkinnedMeshRender=(function(_super){
	function SkinnedMeshRender(owner){
		/**@private */
		//this._cacheAvatar=null;
		/**@private */
		//this._cacheMesh=null;
		/**@private */
		//this._cacheAnimationNode=null;
		/**@private */
		//this._cacheAnimationNodeIndex=null;
		/**@private */
		//this._subSkinnedDatas=null;
		/**@private */
		//this._localBoundingBoxCorners=null;
		/**@private */
		//this._localBoundBox=null;
		/**@private */
		//this._cacheAnimator=null;
		/**@private */
		//this._rootIndex=0;
		/**@private */
		//this._rootBone=null;
		/**用于裁剪的包围球。 */
		//this.localBoundSphere=null;
		//.......................................兼容代码........................................
		this._hasIndependentBound=true;
		SkinnedMeshRender.__super.call(this,owner);
		this._owner.transform.off(/*laya.events.Event.WORLDMATRIX_NEEDCHANGE*/"worldmatrixneedchanged",this,this._onWorldMatNeedChange);
		this._cacheAnimationNodeIndex=[];
		this._cacheAnimationNode=[];
		this._localBoundingBoxCorners=__newvec(8,null);
		(this._owner).meshFilter.on(/*laya.events.Event.MESH_CHANGED*/"meshchanged",this,this._$3__onMeshChanged);
	}

	__class(SkinnedMeshRender,'laya.d3.core.SkinnedMeshRender',_super);
	var __proto=SkinnedMeshRender.prototype;
	/**
	*@private
	*/
	__proto._getCacheAnimationNodes=function(){
		var meshBoneNames=this._cacheMesh._boneNames;
		var binPoseCount=meshBoneNames.length;
		this._cacheAnimationNode.length=binPoseCount;
		this._cacheAnimationNodeIndex.length=binPoseCount;
		var avatarNodes=this._cacheAnimator._avatarNodes;
		var nodeMap=this._cacheAnimator._avatarNodeMap;
		for (var i=0;i < binPoseCount;i++){
			var node=nodeMap[meshBoneNames[i]];
			this._cacheAnimationNode[i]=node;
			this._cacheAnimationNodeIndex[i]=avatarNodes.indexOf(node);
		}
	}

	/**
	*@private
	*/
	__proto._offComputeBoneIndexToMeshEvent=function(avatar,mesh){
		if (avatar.loaded){
			if (!mesh.loaded)
				mesh.off(/*laya.events.Event.LOADED*/"loaded",this,this._getCacheAnimationNodes);
			}else {
			avatar.off(/*laya.events.Event.LOADED*/"loaded",this,this._computeBoneIndexToMeshWithAsyncMesh);
		}
	}

	/**
	*@private
	*/
	__proto._computeBoneIndexToMeshWithAsyncAvatar=function(){
		if (this._cacheAvatar.loaded)
			this._computeBoneIndexToMeshWithAsyncMesh();
		else
		this._cacheAvatar.once(/*laya.events.Event.LOADED*/"loaded",this,this._computeBoneIndexToMeshWithAsyncMesh);
	}

	/**
	*@private
	*/
	__proto._computeBoneIndexToMeshWithAsyncMesh=function(){
		if (this._cacheMesh.loaded)
			this._getCacheAnimationNodes();
		else
		this._cacheMesh.on(/*laya.events.Event.LOADED*/"loaded",this,this._getCacheAnimationNodes);
	}

	/**
	*@private
	*/
	__proto._$3__onMeshChanged=function(meshFilter,lastMesh,mesh){
		this._cacheMesh=mesh;
		(lastMesh && !lastMesh.loaded)&& (mesh.off(/*laya.events.Event.LOADED*/"loaded",this,this._onMeshLoaded));
		if (mesh.loaded)
			this._onMeshLoaded(mesh);
		else
		mesh.on(/*laya.events.Event.LOADED*/"loaded",this,this._onMeshLoaded);
		if (this._cacheAvatar){
			(lastMesh)&& (this._offComputeBoneIndexToMeshEvent(this._cacheAvatar,lastMesh));
			(mesh)&& (this._computeBoneIndexToMeshWithAsyncAvatar());
		}
	}

	/**
	*@private
	*/
	__proto._onMeshLoaded=function(mesh){
		var subMeshCount=mesh.subMeshCount;
		this._subSkinnedDatas=[];
		this._subSkinnedDatas.length=subMeshCount;
		for (var i=0;i < subMeshCount;i++){
			var subMeshDatas=this._subSkinnedDatas[i]=[];
			var boneIndicesList=mesh.getSubMesh(i)._boneIndicesList;
			for (var j=0,m=boneIndicesList.length;j < m;j++)
			subMeshDatas[j]=new Float32Array(boneIndicesList[j].length *16);
		}
	}

	/**
	*@private
	*/
	__proto._setCacheAnimator=function(animator){
		this._cacheAnimator=animator;
		(this._rootBone)&& (this._rootIndex=animator._avatarNodes.indexOf(animator._avatarNodeMap[this._rootBone]));
	}

	/**
	*@private
	*/
	__proto._setRootBone=function(name){
		this._rootBone=name;
		(this._cacheAnimator)&& (this._rootIndex=this._cacheAnimator._avatarNodes.indexOf(this._cacheAnimator._avatarNodeMap[name]));
	}

	/**
	*@private
	*/
	__proto._setCacheAvatar=function(value){
		if (this._cacheAvatar!==value){
			if (this._cacheMesh){
				(this._cacheAvatar)&& (this._offComputeBoneIndexToMeshEvent(this._cacheAvatar,this._cacheMesh));
				this._cacheAvatar=value;
				if (value){
					this._addShaderDefine(SkinnedMeshSprite3D.SHADERDEFINE_BONE);
					this._computeBoneIndexToMeshWithAsyncAvatar();
				}
				}else {
				this._cacheAvatar=value;
			}
		}
	}

	/**
	*@inheritDoc
	*/
	__proto._calculateBoundingBox=function(){
		if (this._hasIndependentBound){
			if (this._cacheAnimator){
				var ownerTrans=this._owner.transform;
				var ownWorMat=ownerTrans.worldMatrix;
				if (this._cacheAnimator._canCache){
					var curAvatarAnimationDatas=this._cacheAnimator._curAvatarNodeDatas;
					Utils3D.matrix4x4MultiplyMFM((this._cacheAnimator.owner).transform.worldMatrix,curAvatarAnimationDatas[this._rootIndex],ownWorMat);
					}else {
					Utils3D.matrix4x4MultiplyMFM((this._cacheAnimator.owner).transform.worldMatrix,this._cacheAnimator._avatarNodeMap[this._rootBone].transform.getWorldMatrix(),ownWorMat);
				}
				ownerTrans.worldMatrix=ownWorMat;
				var rootBone=this._cacheAnimator._avatarNodeMap[this._rootBone];
				if (rootBone==null || this._localBoundBox==null)
					this._boundingBox.toDefault();
				else
				this._calculateBoundBoxByInitCorners(this._localBoundingBoxCorners);
			}
			}else {
			_super.prototype._calculateBoundingBox.call(this);
		}
	}

	/**
	*@inheritDoc
	*/
	__proto._calculateBoundingSphere=function(){
		if (this._hasIndependentBound){
			if (this._cacheAnimator){
				var ownerTrans=this._owner.transform;
				var ownWorMat=ownerTrans.worldMatrix;
				if (this._cacheAnimator._canCache){
					var curAvatarAnimationDatas=this._cacheAnimator._curAvatarNodeDatas;
					Utils3D.matrix4x4MultiplyMFM((this._cacheAnimator.owner).transform.worldMatrix,curAvatarAnimationDatas[this._rootIndex],ownWorMat);
				}else
				Utils3D.matrix4x4MultiplyMFM((this._cacheAnimator.owner).transform.worldMatrix,this._cacheAnimator._avatarNodeMap[this._rootBone].transform.getWorldMatrix(),ownWorMat);
				ownerTrans.worldMatrix=ownWorMat;
				var rootBone=this._cacheAnimator._avatarNodeMap[this._rootBone];
				if (rootBone==null || this.localBoundSphere==null)
					this._boundingSphere.toDefault();
				else
				this._calculateBoundingSphereByInitSphere(this.localBoundSphere);
			}
			}else {
			_super.prototype._calculateBoundingSphere.call(this);
		}
	}

	/**
	*@inheritDoc
	*/
	__proto._updateOctreeNode=function(){
		var treeNode=this._treeNode;
		if (treeNode){
			treeNode.updateObject(this);
		}
	}

	/**
	*@inheritDoc
	*/
	__proto._renderUpdate=function(projectionView){
		var projViewWorld;
		var animator=this._cacheAnimator;
		var subMeshCount=this._cacheMesh.subMeshCount;
		var ownerTrans=this._owner.transform;
		if (animator){
			var cache=animator._canCache;
			var curAvatarAnimationDatas=this._cacheAnimator._curAvatarNodeDatas;
			var aniOwner=animator.owner;
			this._setShaderValueMatrix4x4(/*laya.d3.core.Sprite3D.WORLDMATRIX*/0,aniOwner._transform.worldMatrix);
			projViewWorld=aniOwner.getProjectionViewWorldMatrix(projectionView);
			this._setShaderValueMatrix4x4(/*laya.d3.core.Sprite3D.MVPMATRIX*/1,projViewWorld);
			if (this._cacheMesh && this._cacheMesh.loaded && this._cacheAvatar && this._cacheAvatar.loaded){
				var i=0,n=0;
				var inverseBindPoses=this._cacheMesh._inverseBindPoses;
				var skinnedDatas=this._cacheMesh._skinnedDatas;
				if (cache){
					for (i=0,n=inverseBindPoses.length;i < n;i++)
					Utils3D._mulMatrixArray(curAvatarAnimationDatas[this._cacheAnimationNodeIndex[i]],inverseBindPoses[i],skinnedDatas,i *16);
					}else {
					for (i=0,n=inverseBindPoses.length;i < n;i++)
					Utils3D._mulMatrixArray(this._cacheAnimationNode[i].transform.getWorldMatrix(),inverseBindPoses[i],skinnedDatas,i *16);
				}
				for (i=0;i < subMeshCount;i++){
					var boneIndicesList=this._cacheMesh.getSubMesh(i)._boneIndicesList;
					var boneIndicesCount=boneIndicesList.length;
					var subSkinnedDatas=this._subSkinnedDatas[i];
					for (var j=0;j < boneIndicesCount;j++)
					SkinnedMeshRender._splitAnimationDatas(boneIndicesList[j],skinnedDatas,subSkinnedDatas[j]);
					(this._renderElements [i])._skinAnimationDatas=subSkinnedDatas;
				}
			}
			}else {
			this._setShaderValueMatrix4x4(/*laya.d3.core.Sprite3D.WORLDMATRIX*/0,ownerTrans.worldMatrix);
			projViewWorld=this._owner.getProjectionViewWorldMatrix(projectionView);
			this._setShaderValueMatrix4x4(/*laya.d3.core.Sprite3D.MVPMATRIX*/1,projViewWorld);
		}
		if (Laya3D.debugMode)
			this._renderRenderableBoundBox();
		return true;
	}

	/**
	*设置包围球。
	*@param value
	*/
	/**
	*获取包围球。
	*@return 包围球。
	*/
	__getset(0,__proto,'localBoundBox',function(){
		return this._localBoundBox;
		},function(value){
		this._localBoundBox=value;
		value.getCorners(this._localBoundingBoxCorners);
	});

	/**
	*@inheritDoc
	*/
	__getset(0,__proto,'boundingSphere',function(){
		this._calculateBoundingSphere();
		return this._boundingSphere;
	});

	/**
	*@inheritDoc
	*/
	__getset(0,__proto,'boundingBox',function(){
		this._calculateBoundingBox();
		return this._boundingBox;
	});

	/**
	*@inheritDoc
	*/
	__getset(0,__proto,'boundingBoxCenter',function(){
		var boundBox=this.boundingBox;
		Vector3.add(boundBox.min,boundBox.max,this._boundingBoxCenter);
		Vector3.scale(this._boundingBoxCenter,0.5,this._boundingBoxCenter);
		return this._boundingBoxCenter;
	});

	SkinnedMeshRender._splitAnimationDatas=function(indices,bonesData,subAnimationDatas){
		for (var i=0,n=indices.length,ii=0;i < n;i++){
			var index=indices[i] << 4;
			for (var j=0;j < 16;j++,ii++)
			subAnimationDatas[ii]=bonesData[index+j];
		}
	}

	return SkinnedMeshRender;
})(MeshRender)


/**
*<code>BaseCamera</code> 类用于创建摄像机的父类。
*/
//class laya.d3.core.BaseCamera extends laya.d3.core.Sprite3D
var BaseCamera=(function(_super){
	function BaseCamera(nearPlane,farPlane){
		/**@private */
		//this._tempVector3=null;
		/**@private 位置。*/
		//this._position=null;
		/**@private 向上向量。*/
		//this._up=null;
		/**@private 前向量。*/
		//this._forward=null;
		/**@private 右向量。*/
		//this._right=null;
		/**@private 渲染顺序。*/
		//this._renderingOrder=0;
		/**@private 渲染目标尺寸。*/
		//this._renderTargetSize=null;
		/**@private 近裁剪面。*/
		//this._nearPlane=NaN;
		/**@private 远裁剪面。*/
		//this._farPlane=NaN;
		/**@private 视野。*/
		//this._fieldOfView=NaN;
		/**@private 正交投影的垂直尺寸。*/
		//this._orthographicVerticalSize=NaN;
		/**@private 天空。*/
		//this._sky=null;
		/**@private */
		//this._orthographic=false;
		/**@private 渲染目标。*/
		//this._renderTarget=null;
		/**@private 是否使用用户自定义投影矩阵，如果使用了用户投影矩阵，摄像机投影矩阵相关的参数改变则不改变投影矩阵的值，需调用ResetProjectionMatrix方法。*/
		//this._useUserProjectionMatrix=false;
		/**@private 表明视口是否使用裁剪空间表达。*/
		//this._viewportExpressedInClipSpace=false;
		/**清楚标记。*/
		//this.clearFlag=0;
		/**摄像机的清除颜色。*/
		//this.clearColor=null;
		/**可视遮罩图层。 */
		//this.cullingMask=0;
		/**渲染时是否用遮挡剔除。 */
		//this.useOcclusionCulling=false;
		BaseCamera.__super.call(this);
		(nearPlane===void 0)&& (nearPlane=0.3);
		(farPlane===void 0)&& (farPlane=1000);
		this._tempVector3=new Vector3();
		this._position=new Vector3();
		this._up=new Vector3();
		this._forward=new Vector3();
		this._right=new Vector3();
		this._fieldOfView=60;
		this._useUserProjectionMatrix=false;
		this._orthographic=false;
		this._viewportExpressedInClipSpace=true;
		this._renderTargetSize=Size.fullScreen;
		this._orthographicVerticalSize=10;
		this.renderingOrder=0;
		this._nearPlane=nearPlane;
		this._farPlane=farPlane;
		this.cullingMask=2147483647;
		this.clearFlag=/*CLASS CONST:laya.d3.core.BaseCamera.CLEARFLAG_SOLIDCOLOR*/0;
		this.useOcclusionCulling=true;
		this._calculateProjectionMatrix();
		Laya.stage.on(/*laya.events.Event.RESIZE*/"resize",this,this._onScreenSizeChanged);
	}

	__class(BaseCamera,'laya.d3.core.BaseCamera',_super);
	var __proto=BaseCamera.prototype;
	/**
	*通过RenderingOrder属性对摄像机机型排序。
	*/
	__proto._sortCamerasByRenderingOrder=function(){
		if (this._displayedInStage){
			var cameraPool=this.scene._cameraPool;
			var n=cameraPool.length-1;
			for (var i=0;i < n;i++){
				if (cameraPool[i].renderingOrder > cameraPool[n].renderingOrder){
					var tempCamera=cameraPool[i];
					cameraPool[i]=cameraPool[n];
					cameraPool[n]=tempCamera;
				}
			}
		}
	}

	/**
	*@private
	*/
	__proto._calculateProjectionMatrix=function(){}
	/**
	*@private
	*/
	__proto._onScreenSizeChanged=function(){
		this._calculateProjectionMatrix();
	}

	/**
	*@private
	*/
	__proto._prepareCameraToRender=function(){
		Layer._currentCameraCullingMask=this.cullingMask;
		var cameraSV=this._shaderValues;
		cameraSV.setValue(/*CLASS CONST:laya.d3.core.BaseCamera.CAMERAPOS*/0,this.transform.position.elements);
		cameraSV.setValue(/*CLASS CONST:laya.d3.core.BaseCamera.CAMERADIRECTION*/5,this.forward.elements);
		cameraSV.setValue(/*CLASS CONST:laya.d3.core.BaseCamera.CAMERAUP*/6,this.up.elements);
	}

	/**
	*@private
	*/
	__proto._prepareCameraViewProject=function(viewMatrix,projectMatrix){
		var cameraSV=this._shaderValues;
		cameraSV.setValue(/*CLASS CONST:laya.d3.core.BaseCamera.VIEWMATRIX*/1,viewMatrix.elements);
		cameraSV.setValue(/*CLASS CONST:laya.d3.core.BaseCamera.PROJECTMATRIX*/2,projectMatrix.elements);
	}

	/**
	*@private
	*/
	__proto._renderCamera=function(gl,state,scene){}
	/**
	*增加可视图层。
	*@param layer 图层。
	*/
	__proto.addLayer=function(layer){
		if (layer.number===29 || layer.number==30)
			return;
		this.cullingMask=this.cullingMask | layer.mask;
	}

	/**
	*移除可视图层。
	*@param layer 图层。
	*/
	__proto.removeLayer=function(layer){
		if (layer.number===29 || layer.number==30)
			return;
		this.cullingMask=this.cullingMask & ~layer.mask;
	}

	/**
	*增加所有图层。
	*/
	__proto.addAllLayers=function(){
		this.cullingMask=2147483647;
	}

	/**
	*移除所有图层。
	*/
	__proto.removeAllLayers=function(){
		this.cullingMask=0 | Layer.getLayerByNumber(29).mask | Layer.getLayerByNumber(30).mask;
	}

	__proto.ResetProjectionMatrix=function(){
		this._useUserProjectionMatrix=false;
		this._calculateProjectionMatrix();
	}

	/**
	*向前移动。
	*@param distance 移动距离。
	*/
	__proto.moveForward=function(distance){
		this._tempVector3.elements[0]=this._tempVector3.elements[1]=0;
		this._tempVector3.elements[2]=distance;
		this.transform.translate(this._tempVector3);
	}

	/**
	*向右移动。
	*@param distance 移动距离。
	*/
	__proto.moveRight=function(distance){
		this._tempVector3.elements[1]=this._tempVector3.elements[2]=0;
		this._tempVector3.elements[0]=distance;
		this.transform.translate(this._tempVector3);
	}

	/**
	*向上移动。
	*@param distance 移动距离。
	*/
	__proto.moveVertical=function(distance){
		this._tempVector3.elements[0]=this._tempVector3.elements[2]=0;
		this._tempVector3.elements[1]=distance;
		this.transform.translate(this._tempVector3,false);
	}

	//}// BoundingFrustumWorldSpace
	__proto._addSelfRenderObjects=function(){
		var cameraPool=this.scene._cameraPool;
		var cmaeraCount=cameraPool.length;
		if (cmaeraCount > 0){
			for (var i=cmaeraCount-1;i >=0;i--){
				if (this.renderingOrder <=cameraPool[i].renderingOrder){
					cameraPool.splice(i+1,0,this);
					break ;
				}
			}
			}else {
			cameraPool.push(this);
			if (this.scene.conchModel){
				this.scene.conchModel.setCurrentCamera(this.conchModel);
			}
		}
	}

	__proto._clearSelfRenderObjects=function(){
		var cameraPool=this.scene._cameraPool;
		cameraPool.splice(cameraPool.indexOf(this),1);
	}

	/**
	*@inheritDoc
	*/
	__proto.destroy=function(destroyChild){
		(destroyChild===void 0)&& (destroyChild=true);
		(this._sky)&& (this._sky.destroy());
		this.renderTarget=null;
		Laya.stage.off(/*laya.events.Event.RESIZE*/"resize",this,this._onScreenSizeChanged);
		_super.prototype.destroy.call(this,destroyChild);
	}

	/**设置天空。*/
	/**获取天空。*/
	__getset(0,__proto,'sky',function(){
		return this._sky;
		},function(value){
		this._sky=value;
		value._ownerCamera=this;
	});

	/**
	*获取前向量。
	*@return 前向量。
	*/
	__getset(0,__proto,'forward',function(){
		var worldMatrixe=this.transform.worldMatrix.elements;
		var forwarde=this._forward.elements;
		forwarde[0]=-worldMatrixe[8];
		forwarde[1]=-worldMatrixe[9];
		forwarde[2]=-worldMatrixe[10];
		return this._forward;
	});

	/**获取位置。*/
	__getset(0,__proto,'position',function(){
		var worldMatrixe=this.transform.worldMatrix.elements;
		var positione=this._position.elements;
		positione[0]=worldMatrixe[12];
		positione[1]=worldMatrixe[13];
		positione[2]=worldMatrixe[14];
		return this._position;
	});

	/**
	*设置渲染场景的渲染目标。
	*@param value 渲染场景的渲染目标。
	*/
	/**
	*获取渲染场景的渲染目标。
	*@return 渲染场景的渲染目标。
	*/
	__getset(0,__proto,'renderTarget',function(){
		return this._renderTarget;
		},function(value){
		this._renderTarget=value;
		if (value !=null)
			this._renderTargetSize=value.size;
	});

	/**
	*获取上向量。
	*@return 上向量。
	*/
	__getset(0,__proto,'up',function(){
		var worldMatrixe=this.transform.worldMatrix.elements;
		var upe=this._up.elements;
		upe[0]=worldMatrixe[4];
		upe[1]=worldMatrixe[5];
		upe[2]=worldMatrixe[6];
		return this._up;
	});

	/**
	*获取右向量。
	*@return 右向量。
	*/
	__getset(0,__proto,'right',function(){
		var worldMatrixe=this.transform.worldMatrix.elements;
		var righte=this._right.elements;
		righte[0]=worldMatrixe[0];
		righte[1]=worldMatrixe[1];
		righte[2]=worldMatrixe[2];
		return this._right;
	});

	/**
	*设置渲染目标的尺寸
	*@param value 渲染目标的尺寸。
	*/
	/**
	*获取渲染目标的尺寸
	*@return 渲染目标的尺寸。
	*/
	__getset(0,__proto,'renderTargetSize',function(){
		return this._renderTargetSize;
		},function(value){
		if (this.renderTarget !=null && this._renderTargetSize !=value){}
			this._renderTargetSize=value;
		this._calculateProjectionMatrix();
	});

	/**
	*设置视野。
	*@param value 视野。
	*/
	/**
	*获取视野。
	*@return 视野。
	*/
	__getset(0,__proto,'fieldOfView',function(){
		return this._fieldOfView;
		},function(value){
		this._fieldOfView=value;
		this._calculateProjectionMatrix();
	});

	/**
	*设置近裁面。
	*@param value 近裁面。
	*/
	/**
	*获取近裁面。
	*@return 近裁面。
	*/
	__getset(0,__proto,'nearPlane',function(){
		return this._nearPlane;
		},function(value){
		this._nearPlane=value;
		this._calculateProjectionMatrix();
	});

	/**
	*设置远裁面。
	*@param value 远裁面。
	*/
	/**
	*获取远裁面。
	*@return 远裁面。
	*/
	__getset(0,__proto,'farPlane',function(){
		return this._farPlane;
		},function(vaule){
		this._farPlane=vaule;
		this._calculateProjectionMatrix();
	});

	/**
	*设置是否正交投影矩阵。
	*@param 是否正交投影矩阵。
	*/
	/**
	*获取是否正交投影矩阵。
	*@return 是否正交投影矩阵。
	*/
	__getset(0,__proto,'orthographic',function(){
		return this._orthographic;
		},function(vaule){
		this._orthographic=vaule;
		this._calculateProjectionMatrix();
	});

	/**
	*设置正交投影垂直矩阵尺寸。
	*@param 正交投影垂直矩阵尺寸。
	*/
	/**
	*获取正交投影垂直矩阵尺寸。
	*@return 正交投影垂直矩阵尺寸。
	*/
	__getset(0,__proto,'orthographicVerticalSize',function(){
		return this._orthographicVerticalSize;
		},function(vaule){
		this._orthographicVerticalSize=vaule;
		this._calculateProjectionMatrix();
	});

	__getset(0,__proto,'renderingOrder',function(){
		return this._renderingOrder;
		},function(value){
		this._renderingOrder=value;
		this._sortCamerasByRenderingOrder();
	});

	BaseCamera.CAMERAPOS=0;
	BaseCamera.VIEWMATRIX=1;
	BaseCamera.PROJECTMATRIX=2;
	BaseCamera.VPMATRIX=3;
	BaseCamera.VPMATRIX_NO_TRANSLATE=4;
	BaseCamera.CAMERADIRECTION=5;
	BaseCamera.CAMERAUP=6;
	BaseCamera.ENVIRONMENTDIFFUSE=7;
	BaseCamera.ENVIRONMENTSPECULAR=8;
	BaseCamera.SIMLODINFO=9;
	BaseCamera.DIFFUSEIRRADMATR=10;
	BaseCamera.DIFFUSEIRRADMATG=11;
	BaseCamera.DIFFUSEIRRADMATB=12;
	BaseCamera.HDREXPOSURE=13;
	BaseCamera.RENDERINGTYPE_DEFERREDLIGHTING="DEFERREDLIGHTING";
	BaseCamera.RENDERINGTYPE_FORWARDRENDERING="FORWARDRENDERING";
	BaseCamera.CLEARFLAG_SOLIDCOLOR=0;
	BaseCamera.CLEARFLAG_SKY=1;
	BaseCamera.CLEARFLAG_DEPTHONLY=2;
	BaseCamera.CLEARFLAG_NONE=3;
	__static(BaseCamera,
	['_invertYScaleMatrix',function(){return this._invertYScaleMatrix=new Matrix4x4(1,0,0,0,0,-1,0,0,0,0,1,0,0,0,0,1);},'_invertYProjectionMatrix',function(){return this._invertYProjectionMatrix=new Matrix4x4();},'_invertYProjectionViewMatrix',function(){return this._invertYProjectionViewMatrix=new Matrix4x4();}
	]);
	return BaseCamera;
})(Sprite3D)


/**
*<code>RenderableSprite3D</code> 类用于可渲染3D精灵的父类，抽象类不允许实例。
*/
//class laya.d3.core.RenderableSprite3D extends laya.d3.core.Sprite3D
var RenderableSprite3D=(function(_super){
	function RenderableSprite3D(name){
		/**@private */
		this._render=null;
		/**@private */
		this._geometryFilter=null;
		RenderableSprite3D.__super.call(this,name)
	}

	__class(RenderableSprite3D,'laya.d3.core.RenderableSprite3D',_super);
	var __proto=RenderableSprite3D.prototype;
	/**
	*@private
	*/
	__proto._addToInitStaticBatchManager=function(){}
	/**
	*@inheritDoc
	*/
	__proto._setBelongScene=function(scene){
		_super.prototype._setBelongScene.call(this,scene);
		scene._renderableSprite3Ds.push(this);
		this._render._applyLightMapParams();
	}

	/**
	*@inheritDoc
	*/
	__proto._setUnBelongScene=function(){
		var renderableSprite3Ds=this._scene._renderableSprite3Ds;
		var index=renderableSprite3Ds.indexOf(this);
		renderableSprite3Ds.splice(index,1);
		this._render._removeShaderDefine(laya.d3.core.RenderableSprite3D.SAHDERDEFINE_LIGHTMAP);
		_super.prototype._setUnBelongScene.call(this);
	}

	/**
	*@inheritDoc
	*/
	__proto._update=function(state){
		state.owner=this;
		if (this._activeInHierarchy){
			this._updateComponents(state);
			this._render._updateOctreeNode();
			this._lateUpdateComponents(state);
			Stat.spriteCount++;
			this._childs.length && this._updateChilds(state);
		}
	}

	/**
	*@inheritDoc
	*/
	__proto.destroy=function(destroyChild){
		(destroyChild===void 0)&& (destroyChild=true);
		_super.prototype.destroy.call(this,destroyChild);
		this._render._destroy();
		this._render=null;
	}

	RenderableSprite3D.__init__=function(){
		RenderableSprite3D.SHADERDEFINE_SCALEOFFSETLIGHTINGMAPUV=RenderableSprite3D.shaderDefines.registerDefine("SCALEOFFSETLIGHTINGMAPUV");
		RenderableSprite3D.SAHDERDEFINE_LIGHTMAP=RenderableSprite3D.shaderDefines.registerDefine("LIGHTMAP");
	}

	RenderableSprite3D.SHADERDEFINE_SCALEOFFSETLIGHTINGMAPUV=0x2;
	RenderableSprite3D.SAHDERDEFINE_LIGHTMAP=0x4;
	RenderableSprite3D.LIGHTMAPSCALEOFFSET=2;
	RenderableSprite3D.LIGHTMAP=3;
	__static(RenderableSprite3D,
	['shaderDefines',function(){return this.shaderDefines=new ShaderDefines$1();}
	]);
	return RenderableSprite3D;
})(Sprite3D)


/**
*<code>LightSprite</code> 类用于创建灯光的父类。
*/
//class laya.d3.core.light.LightSprite extends laya.d3.core.Sprite3D
var LightSprite=(function(_super){
	function LightSprite(){
		/**@private */
		this._intensityColor=null;
		/**@private */
		this._intensity=NaN;
		/**@private */
		this._shadow=false;
		/**@private */
		this._shadowFarPlane=0;
		/**@private */
		this._shadowMapSize=0;
		/**@private */
		this._shadowMapCount=0;
		/**@private */
		this._shadowMapPCFType=0;
		/**@private */
		this._parallelSplitShadowMap=null;
		/**@private */
		this._lightmapBakedType=0;
		/**灯光颜色。 */
		this.color=null;
		LightSprite.__super.call(this);
		this._intensity=1.0;
		this._intensityColor=new Vector3();
		this.color=new Vector3(1.0,1.0,1.0);
		this._shadow=false;
		this._shadowFarPlane=8;
		this._shadowMapSize=512;
		this._shadowMapCount=1;
		this._shadowMapPCFType=0;
		this._lightmapBakedType=LightSprite.LIGHTMAPBAKEDTYPE_REALTIME;
	}

	__class(LightSprite,'laya.d3.core.light.LightSprite',_super);
	var __proto=LightSprite.prototype;
	/**
	*@inheritDoc
	*/
	__proto._parseCustomProps=function(rootNode,innerResouMap,customProps,nodeData){
		var colorData=customProps.color;
		var colorE=this.color.elements;
		colorE[0]=colorData[0];
		colorE[1]=colorData[1];
		colorE[2]=colorData[2];
	}

	/**
	*@inheritDoc
	*/
	__proto._addSelfRenderObjects=function(){
		(this.lightmapBakedType!==LightSprite.LIGHTMAPBAKEDTYPE_BAKED)&& (this._scene._addLight(this));
	}

	/**
	*@inheritDoc
	*/
	__proto._clearSelfRenderObjects=function(){
		(this.lightmapBakedType!==LightSprite.LIGHTMAPBAKEDTYPE_BAKED)&& (this._scene._removeLight(this));
	}

	/**
	*更新灯光相关渲染状态参数。
	*@param state 渲染状态参数。
	*/
	__proto._prepareToScene=function(state){
		return false;
	}

	/**
	*设置灯光烘培类型。
	*/
	/**
	*获取灯光烘培类型。
	*/
	__getset(0,__proto,'lightmapBakedType',function(){
		return this._lightmapBakedType;
		},function(value){
		if (this._lightmapBakedType!==value){
			this._lightmapBakedType=value;
			if (this._activeInHierarchy){
				if (value!==LightSprite.LIGHTMAPBAKEDTYPE_BAKED)
					this._scene._addLight(this);
				else
				this._scene._removeLight(this);
			}
		}
	});

	/**
	*设置阴影PCF类型。
	*@param value PCF类型。
	*/
	/**
	*获取阴影PCF类型。
	*@return PCF类型。
	*/
	__getset(0,__proto,'shadowPCFType',function(){
		return this._shadowMapPCFType;
		},function(value){
		this._shadowMapPCFType=value;
		(this._parallelSplitShadowMap)&& (this._parallelSplitShadowMap.setPCFType(value));
	});

	/**
	*设置灯光强度。
	*@param value 灯光强度
	*/
	/**
	*获取灯光强度。
	*@return 灯光强度
	*/
	__getset(0,__proto,'intensity',function(){
		return this._intensity;
		},function(value){
		this._intensity=value;
	});

	/**
	*设置是否产生阴影。
	*@param value 是否产生阴影。
	*/
	/**
	*获取是否产生阴影。
	*@return 是否产生阴影。
	*/
	__getset(0,__proto,'shadow',function(){
		return this._shadow;
		},function(value){
		throw new Error("LightSprite: must override it.");
	});

	/**
	*设置阴影最远范围。
	*@param value 阴影最远范围。
	*/
	/**
	*获取阴影最远范围。
	*@return 阴影最远范围。
	*/
	__getset(0,__proto,'shadowDistance',function(){
		return this._shadowFarPlane;
		},function(value){
		this._shadowFarPlane=value;
		(this._parallelSplitShadowMap)&& (this._parallelSplitShadowMap.setFarDistance(value));
	});

	/**
	*设置阴影分段数。
	*@param value 阴影分段数。
	*/
	/**
	*获取阴影分段数。
	*@return 阴影分段数。
	*/
	__getset(0,__proto,'shadowPSSMCount',function(){
		return this._shadowMapCount;
		},function(value){
		this._shadowMapCount=value;
		(this._parallelSplitShadowMap)&& (this._parallelSplitShadowMap.PSSMNum=value);
	});

	/**
	*设置阴影贴图尺寸。
	*@param value 阴影贴图尺寸。
	*/
	/**
	*获取阴影贴图尺寸。
	*@return 阴影贴图尺寸。
	*/
	__getset(0,__proto,'shadowResolution',function(){
		return this._shadowMapSize;
		},function(value){
		this._shadowMapSize=value;
		(this._parallelSplitShadowMap)&& (this._parallelSplitShadowMap.setShadowMapTextureSize(value));
	});

	/**
	*设置灯光的漫反射颜色。
	*@param value 灯光的漫反射颜色。
	*/
	/**
	*获取灯光的漫反射颜色。
	*@return 灯光的漫反射颜色。
	*/
	__getset(0,__proto,'diffuseColor',function(){
		console.log("LightSprite: discard property,please use color property instead.");
		return this.color;
		},function(value){
		console.log("LightSprite: discard property,please use color property instead.");
		this.color=value;
	});

	LightSprite.LIGHTMAPBAKEDTYPE_REALTIME=0;
	LightSprite.LIGHTMAPBAKEDTYPE_MIXED=1;
	LightSprite.LIGHTMAPBAKEDTYPE_BAKED=2;
	return LightSprite;
})(Sprite3D)


/**
*<code>Terrain</code> 类用于创建地块。
*/
//class laya.d3.terrain.Terrain extends laya.d3.core.Sprite3D
var Terrain=(function(_super){
	function Terrain(terrainRes){
		this._terrainRes=null;
		this._lightmapScaleOffset=null;
		Terrain.__super.call(this);
		this._lightmapScaleOffset=new Vector4(1,1,0,0);
		if (terrainRes){
			this._terrainRes=terrainRes;
			if (terrainRes.loaded)
				this.buildTerrain(terrainRes);
			else
			terrainRes.once(/*laya.events.Event.LOADED*/"loaded",this,this.buildTerrain);
		}
	}

	__class(Terrain,'laya.d3.terrain.Terrain',_super);
	var __proto=Terrain.prototype;
	/**
	*@inheritDoc
	*/
	__proto._parseCustomProps=function(rootNode,innerResouMap,customProps,json){
		this.terrainRes=Loader.getRes(innerResouMap[customProps.dataPath]);
		var lightmapIndex=customProps.lightmapIndex;
		if (lightmapIndex !=null)
			this.setLightmapIndex(lightmapIndex);
		var lightmapScaleOffsetArray=customProps.lightmapScaleOffset;
		if (lightmapScaleOffsetArray)
			this.setLightmapScaleOffset(new Vector4(lightmapScaleOffsetArray[0],lightmapScaleOffsetArray[1],lightmapScaleOffsetArray[2],lightmapScaleOffsetArray[3]));
	}

	__proto.setLightmapIndex=function(value){
		for (var i=0;i < this._childs.length;i++){
			var terrainChunk=this._childs[i];
			terrainChunk.terrainRender.lightmapIndex=value;
		}
	}

	__proto.setLightmapScaleOffset=function(value){
		if (!value)return;
		value.cloneTo(this._lightmapScaleOffset);
		for (var i=0;i < this._childs.length;i++){
			var terrainChunk=this._childs[i];
			terrainChunk.terrainRender.lightmapScaleOffset=this._lightmapScaleOffset;
		}
	}

	__proto.disableLight=function(){
		for (var i=0,n=this._childs.length;i < n;i++){
			var terrainChunk=this._childs[i];
			for (var j=0,m=terrainChunk._render.sharedMaterials.length;j < m;j++){
				var terrainMaterial=terrainChunk._render.sharedMaterials [j];
				terrainMaterial.disableLight();
			}
		}
	}

	__proto.buildTerrain=function(terrainRes){
		var chunkNumX=terrainRes._chunkNumX;
		var chunkNumZ=terrainRes._chunkNumZ;
		var heightData=terrainRes._heightData;
		var n=0;
		for (var i=0;i < chunkNumZ;i++){
			for (var j=0;j < chunkNumX;j++){
				var terrainChunk=new TerrainChunk(j,i,terrainRes._gridSize,heightData._terrainHeightData,heightData._width,heightData._height,terrainRes._cameraCoordinateInverse);
				var chunkInfo=terrainRes._chunkInfos[n++];
				for (var k=0;k < chunkInfo.alphaMap.length;k++){
					var nNum=chunkInfo.detailID[k].length;
					var sDetialTextureUrl1=(nNum > 0)? terrainRes._detailTextureInfos[chunkInfo.detailID[k][0]].diffuseTexture :null;
					var sDetialTextureUrl2=(nNum > 1)? terrainRes._detailTextureInfos[chunkInfo.detailID[k][1]].diffuseTexture :null;
					var sDetialTextureUrl3=(nNum > 2)? terrainRes._detailTextureInfos[chunkInfo.detailID[k][2]].diffuseTexture :null;
					var sDetialTextureUrl4=(nNum > 3)? terrainRes._detailTextureInfos[chunkInfo.detailID[k][3]].diffuseTexture :null;
					var detialScale1=(nNum > 0)? terrainRes._detailTextureInfos[chunkInfo.detailID[k][0]].scale :null;
					var detialScale2=(nNum > 1)? terrainRes._detailTextureInfos[chunkInfo.detailID[k][1]].scale :null;
					var detialScale3=(nNum > 2)? terrainRes._detailTextureInfos[chunkInfo.detailID[k][2]].scale :null;
					var detialScale4=(nNum > 3)? terrainRes._detailTextureInfos[chunkInfo.detailID[k][3]].scale :null;
					terrainChunk.buildRenderElementAndMaterial(nNum,chunkInfo.normalMap,chunkInfo.alphaMap[k],sDetialTextureUrl1,sDetialTextureUrl2,sDetialTextureUrl3,sDetialTextureUrl4,terrainRes._materialInfo.ambientColor,terrainRes._materialInfo.diffuseColor,terrainRes._materialInfo.specularColor,detialScale1 ? detialScale1.x :1,detialScale1 ? detialScale1.y :1,detialScale2 ? detialScale2.x :1,detialScale2 ? detialScale2.y :1,detialScale3 ? detialScale3.x :1,detialScale3 ? detialScale3.y :1,detialScale4 ? detialScale4.x :1,detialScale4 ? detialScale4.y :1);
				}
				terrainChunk.terrainRender.receiveShadow=true;
				terrainChunk.terrainRender.lightmapScaleOffset=this._lightmapScaleOffset;
				this.addChild(terrainChunk);
			}
		}
	}

	/**
	*获取地形X轴长度。
	*@return 地形X轴长度。
	*/
	__proto.width=function(){
		return this._terrainRes._chunkNumX *TerrainLeaf.CHUNK_GRID_NUM *this._terrainRes._gridSize;
	}

	/**
	*获取地形Z轴长度。
	*@return 地形Z轴长度。
	*/
	__proto.depth=function(){
		return this._terrainRes._chunkNumZ *TerrainLeaf.CHUNK_GRID_NUM *this._terrainRes._gridSize;
	}

	/**
	*获取地形高度。
	*@param x X轴坐标。
	*@param z Z轴坐标。
	*/
	__proto.getHeightXZ=function(x,z){
		if (!this._terrainRes || !this._terrainRes.loaded)
			return NaN;
		x-=this.transform.position.x;
		z-=this.transform.position.z;
		if (!Terrain.__VECTOR3__){
			Terrain.__VECTOR3__=new Vector3();
		}
		Terrain.__VECTOR3__.elements[0]=x;
		Terrain.__VECTOR3__.elements[1]=0;
		Terrain.__VECTOR3__.elements[2]=z;
		Vector3.transformV3ToV3(Terrain.__VECTOR3__,TerrainLeaf.__ADAPT_MATRIX_INV__,Terrain.__VECTOR3__);
		x=Terrain.__VECTOR3__.elements[0];
		z=Terrain.__VECTOR3__.elements[2];
		if (x < 0 || x > this.width()|| z < 0 || z > this.depth())
			return NaN;
		var gridSize=this._terrainRes._gridSize;
		var nIndexX=parseInt(""+x / gridSize);
		var nIndexZ=parseInt(""+z / gridSize);
		var offsetX=x-nIndexX *gridSize;
		var offsetZ=z-nIndexZ *gridSize;
		var h1=NaN;
		var h2=NaN;
		var h3=NaN;
		var u=NaN;
		var v=NaN;
		var heightData=this._terrainRes._heightData;
		if (offsetX+offsetZ > gridSize){
			h1=heightData._terrainHeightData[(nIndexZ+1-1)*heightData._width+nIndexX+1];
			h2=heightData._terrainHeightData[(nIndexZ+1-1)*heightData._width+nIndexX];
			h3=heightData._terrainHeightData[(nIndexZ-1)*heightData._width+nIndexX+1];
			u=(gridSize-offsetX)/ gridSize;
			v=(gridSize-offsetZ)/ gridSize;
			return h1+(h2-h1)*u+(h3-h1)*v;
			}else {
			h1=heightData._terrainHeightData[Math.max(0.0,nIndexZ-1)*heightData._width+nIndexX];
			h2=heightData._terrainHeightData[Math.min(heightData._width *heightData._height-1,(nIndexZ+1-1)*heightData._width+nIndexX)];
			h3=heightData._terrainHeightData[Math.min(heightData._width *heightData._height-1,Math.max(0.0,nIndexZ-1)*heightData._width+nIndexX+1)];
			u=offsetX / gridSize;
			v=offsetZ / gridSize;
			return h1+(h2-h1)*v+(h3-h1)*u;
		}
	}

	__getset(0,__proto,'terrainRes',null,function(value){
		if (value){
			this._terrainRes=value;
			if (value.loaded)
				this.buildTerrain(value);
			else
			value.once(/*laya.events.Event.LOADED*/"loaded",this,this.buildTerrain);
		}
	});

	Terrain.load=function(url){
		return Laya.loader.create(url,null,null,Terrain,null,1,false);
	}

	Terrain.RENDER_LINE_MODEL=false;
	Terrain.LOD_TOLERANCE_VALUE=4;
	Terrain.LOD_DISTANCE_FACTOR=2.0;
	Terrain.__VECTOR3__=null;
	return Terrain;
})(Sprite3D)


/**
*<code>Sphere</code> 类用于创建方体。
*/
//class laya.d3.resource.models.BoxMesh extends laya.d3.resource.models.PrimitiveMesh
var BoxMesh=(function(_super){
	function BoxMesh(long,width,height){
		/**@private */
		this._long=NaN;
		/**@private */
		this._width=NaN;
		/**@private */
		this._height=NaN;
		(long===void 0)&& (long=1);
		(width===void 0)&& (width=1);
		(height===void 0)&& (height=1);
		BoxMesh.__super.call(this);
		this._long=long;
		this._width=width;
		this._height=height;
		this.activeResource();
		this._positions=this._getPositions();
		this._generateBoundingObject();
	}

	__class(BoxMesh,'laya.d3.resource.models.BoxMesh',_super);
	var __proto=BoxMesh.prototype;
	__proto.recreateResource=function(){
		this._numberVertices=24;
		this._numberIndices=36;
		var vertexDeclaration=VertexPositionNormalTexture.vertexDeclaration;
		var vertexFloatStride=vertexDeclaration.vertexStride / 4;
		var halfLong=this._long / 2;
		var halfHeight=this._height / 2;
		var halfWidth=this._width / 2;
		var vertices=new Float32Array([
		-halfLong,halfHeight,-halfWidth,0,1,0,0,0,halfLong,halfHeight,-halfWidth,0,1,0,1,0,halfLong,halfHeight,halfWidth,0,1,0,1,1,-halfLong,halfHeight,halfWidth,0,1,0,0,1,
		-halfLong,-halfHeight,-halfWidth,0,-1,0,0,1,halfLong,-halfHeight,-halfWidth,0,-1,0,1,1,halfLong,-halfHeight,halfWidth,0,-1,0,1,0,-halfLong,-halfHeight,halfWidth,0,-1,0,0,0,
		-halfLong,halfHeight,-halfWidth,-1,0,0,0,0,-halfLong,halfHeight,halfWidth,-1,0,0,1,0,-halfLong,-halfHeight,halfWidth,-1,0,0,1,1,-halfLong,-halfHeight,-halfWidth,-1,0,0,0,1,
		halfLong,halfHeight,-halfWidth,1,0,0,1,0,halfLong,halfHeight,halfWidth,1,0,0,0,0,halfLong,-halfHeight,halfWidth,1,0,0,0,1,halfLong,-halfHeight,-halfWidth,1,0,0,1,1,
		-halfLong,halfHeight,halfWidth,0,0,1,0,0,halfLong,halfHeight,halfWidth,0,0,1,1,0,halfLong,-halfHeight,halfWidth,0,0,1,1,1,-halfLong,-halfHeight,halfWidth,0,0,1,0,1,
		-halfLong,halfHeight,-halfWidth,0,0,-1,1,0,halfLong,halfHeight,-halfWidth,0,0,-1,0,0,halfLong,-halfHeight,-halfWidth,0,0,-1,0,1,-halfLong,-halfHeight,-halfWidth,0,0,-1,1,1]);
		var indices=new Uint16Array([
		0,1,2,2,3,0,
		4,7,6,6,5,4,
		8,9,10,10,11,8,
		12,15,14,14,13,12,
		16,17,18,18,19,16,
		20,23,22,22,21,20]);
		this._vertexBuffer=new VertexBuffer3D(vertexDeclaration,this._numberVertices,/*laya.webgl.WebGLContext.STATIC_DRAW*/0x88E4,true);
		this._indexBuffer=new IndexBuffer3D(/*laya.d3.graphics.IndexBuffer3D.INDEXTYPE_USHORT*/"ushort",this._numberIndices,/*laya.webgl.WebGLContext.STATIC_DRAW*/0x88E4,true);
		this._vertexBuffer.setData(vertices);
		this._indexBuffer.setData(indices);
		this.memorySize=(this._vertexBuffer._byteLength+this._indexBuffer._byteLength)*2;
		this.completeCreate();
	}

	/**
	*设置长度（改变此属性会重新生成顶点和索引）
	*@param value 长度
	*/
	/**
	*返回长度
	*@return 长
	*/
	__getset(0,__proto,'long',function(){
		return this._long;
		},function(value){
		if (this._long!==value){
			this._long=value;
			this.releaseResource();
			this.activeResource();
		}
	});

	/**
	*设置宽度（改变此属性会重新生成顶点和索引）
	*@param value 宽度
	*/
	/**
	*返回宽度
	*@return 宽
	*/
	__getset(0,__proto,'width',function(){
		return this._width;
		},function(value){
		if (this._width!==value){
			this._width=value;
			this.releaseResource();
			this.activeResource();
		}
	});

	/**
	*设置高度（改变此属性会重新生成顶点和索引）
	*@param value 高度
	*/
	/**
	*返回高度
	*@return 高
	*/
	__getset(0,__proto,'height',function(){
		return this._height;
		},function(value){
		if (this._height!==value){
			this._height=value;
			this.releaseResource();
			this.activeResource();
		}
	});

	return BoxMesh;
})(PrimitiveMesh)


/**
*<code>CapsuleMesh</code> 类用于创建胶囊体。
*/
//class laya.d3.resource.models.CapsuleMesh extends laya.d3.resource.models.PrimitiveMesh
var CapsuleMesh=(function(_super){
	function CapsuleMesh(radius,height,stacks,slices){
		/**@private */
		this._radius=NaN;
		/**@private */
		this._height=NaN;
		/**@private */
		this._slices=0;
		/**@private */
		this._stacks=0;
		(radius===void 0)&& (radius=0.5);
		(height===void 0)&& (height=2);
		(stacks===void 0)&& (stacks=16);
		(slices===void 0)&& (slices=32);
		CapsuleMesh.__super.call(this);
		this._radius=radius;
		this._height=height < radius *2 ? radius *2 :height;
		this._stacks=stacks;
		this._slices=slices;
		this.recreateResource();
		this._positions=this._getPositions();
		this._generateBoundingObject();
	}

	__class(CapsuleMesh,'laya.d3.resource.models.CapsuleMesh',_super);
	var __proto=CapsuleMesh.prototype;
	__proto.recreateResource=function(){
		this._numberVertices=(this._stacks+1)*(this.slices+1)*2+(this._slices+1)*2;
		this._numberIndices=(3 *this._stacks *(this._slices+1))*2 *2+2 *this._slices *3;
		var vertexDeclaration=VertexPositionNormalTexture.vertexDeclaration;
		var vertexFloatStride=vertexDeclaration.vertexStride / 4;
		var vertices=new Float32Array(this._numberVertices *vertexFloatStride);
		var indices=new Uint16Array(this._numberIndices);
		var stackAngle=(Math.PI / 2.0)/ this._stacks;
		var sliceAngle=(Math.PI *2.0)/ this._slices;
		var hcHeight=this._height / 2-this._radius;
		var posX=0;
		var posY=0;
		var posZ=0;
		var vc=0;
		var ic=0;
		var verticeCount=0;
		var stack=0,slice=0;
		for (stack=0;stack <=this._stacks;stack++){
			for (slice=0;slice <=this._slices;slice++){
				posX=this._radius *Math.cos(stack *stackAngle)*Math.cos(slice *sliceAngle+Math.PI);
				posY=this._radius *Math.sin(stack *stackAngle);
				posZ=this._radius *Math.cos(stack *stackAngle)*Math.sin(slice *sliceAngle+Math.PI);
				vertices[vc++]=posX;
				vertices[vc++]=posY+hcHeight;
				vertices[vc++]=posZ;
				vertices[vc++]=posX;
				vertices[vc++]=posY;
				vertices[vc++]=posZ;
				vertices[vc++]=1-slice / this._slices;
				vertices[vc++]=(1-stack / this._stacks)*((Math.PI *this._radius / 2)/ (this._height+Math.PI *this._radius));
				if (stack < this._stacks){
					indices[ic++]=(stack *(this._slices+1))+slice+(this._slices+1);
					indices[ic++]=(stack *(this._slices+1))+slice;
					indices[ic++]=(stack *(this._slices+1))+slice+1;
					indices[ic++]=(stack *(this._slices+1))+slice+(this._slices);
					indices[ic++]=(stack *(this._slices+1))+slice;
					indices[ic++]=(stack *(this._slices+1))+slice+(this._slices+1);
				}
			}
		}
		verticeCount+=(this._stacks+1)*(this._slices+1);
		for (stack=0;stack <=this._stacks;stack++){
			for (slice=0;slice <=this._slices;slice++){
				posX=this._radius *Math.cos(stack *stackAngle)*Math.cos(slice *sliceAngle+Math.PI);
				posY=this._radius *Math.sin(-stack *stackAngle);
				posZ=this._radius *Math.cos(stack *stackAngle)*Math.sin(slice *sliceAngle+Math.PI);
				vertices[vc++]=posX;
				vertices[vc++]=posY-hcHeight;
				vertices[vc++]=posZ;
				vertices[vc++]=posX;
				vertices[vc++]=posY;
				vertices[vc++]=posZ;
				vertices[vc++]=1-slice / this._slices;
				vertices[vc++]=((stack / this._stacks)*(Math.PI *this._radius / 2)+(this._height+Math.PI *this._radius / 2))/ (this._height+Math.PI *this._radius);
				if (stack < this._stacks){
					indices[ic++]=verticeCount+(stack *(this._slices+1))+slice;
					indices[ic++]=verticeCount+(stack *(this._slices+1))+slice+(this._slices+1);
					indices[ic++]=verticeCount+(stack *(this._slices+1))+slice+1;
					indices[ic++]=verticeCount+(stack *(this._slices+1))+slice;
					indices[ic++]=verticeCount+(stack *(this._slices+1))+slice+(this._slices);
					indices[ic++]=verticeCount+(stack *(this._slices+1))+slice+(this._slices+1);
				}
			}
		}
		verticeCount+=(this._stacks+1)*(this._slices+1);
		for (slice=0;slice <=this._slices;slice++){
			posX=this._radius *Math.cos(slice *sliceAngle+Math.PI);
			posY=hcHeight;
			posZ=this._radius *Math.sin(slice *sliceAngle+Math.PI);
			vertices[vc++]=posX;
			vertices[vc+(this._slices+1)*8-1]=posX;
			vertices[vc++]=posY;
			vertices[vc+(this._slices+1)*8-1]=-posY;
			vertices[vc++]=posZ;
			vertices[vc+(this._slices+1)*8-1]=posZ;
			vertices[vc++]=posX;
			vertices[vc+(this._slices+1)*8-1]=posX;
			vertices[vc++]=0;
			vertices[vc+(this._slices+1)*8-1]=0;
			vertices[vc++]=posZ;
			vertices[vc+(this._slices+1)*8-1]=posZ;
			vertices[vc++]=1-slice *1 / this._slices;
			vertices[vc+(this._slices+1)*8-1]=1-slice *1 / this._slices;
			vertices[vc++]=(Math.PI *this._radius / 2)/ (this._height+Math.PI *this._radius);
			vertices[vc+(this._slices+1)*8-1]=(Math.PI *this._radius / 2+this._height)/ (this._height+Math.PI *this._radius);
		}
		for (slice=0;slice < this._slices;slice++){
			indices[ic++]=slice+verticeCount+(this._slices+1);
			indices[ic++]=slice+verticeCount+1;
			indices[ic++]=slice+verticeCount;
			indices[ic++]=slice+verticeCount+(this._slices+1);
			indices[ic++]=slice+verticeCount+(this._slices+1)+1;
			indices[ic++]=slice+verticeCount+1;
		}
		verticeCount+=2 *(this._slices+1);
		this._vertexBuffer=new VertexBuffer3D(vertexDeclaration,this._numberVertices,/*laya.webgl.WebGLContext.STATIC_DRAW*/0x88E4,true);
		this._indexBuffer=new IndexBuffer3D(/*laya.d3.graphics.IndexBuffer3D.INDEXTYPE_USHORT*/"ushort",this._numberIndices,/*laya.webgl.WebGLContext.STATIC_DRAW*/0x88E4,true);
		this._vertexBuffer.setData(vertices);
		this._indexBuffer.setData(indices);
		this.memorySize=(this._vertexBuffer._byteLength+this._indexBuffer._byteLength)*2;
		this.completeCreate();
	}

	/**
	*设置半径（改变此属性会重新生成顶点和索引）
	*@param value 半径
	*/
	/**
	*返回半径
	*@return 半径
	*/
	__getset(0,__proto,'radius',function(){
		return this._radius;
		},function(value){
		if (this._radius!==value){
			this._radius=value;
			this.releaseResource();
			this.activeResource();
		}
	});

	/**
	*设置高度（改变此属性会重新生成顶点和索引）
	*@param value 高度
	*/
	/**
	*返回高度
	*@return 高度
	*/
	__getset(0,__proto,'height',function(){
		return this._height;
		},function(value){
		if (this._height!==value){
			this._height=value;
			this.releaseResource();
			this.activeResource();
		}
	});

	/**
	*设置高度分段（改变此属性会重新生成顶点和索引）
	*@param value高度分段
	*/
	/**
	*获取高度分段
	*@return 高度分段
	*/
	__getset(0,__proto,'stacks',function(){
		return this._stacks;
		},function(value){
		if (this._stacks!==value){
			this._stacks=value;
			this.releaseResource();
			this.activeResource();
		}
	});

	/**
	*设置宽度分段（改变此属性会重新生成顶点和索引）
	*@param value 宽度分段
	*/
	/**
	*获取宽度分段
	*@return 宽度分段
	*/
	__getset(0,__proto,'slices',function(){
		return this._slices;
		},function(value){
		if (this._slices!==value){
			this._slices=value;
			this.releaseResource();
			this.activeResource();
		}
	});

	return CapsuleMesh;
})(PrimitiveMesh)


/**
*<code>CylinderMesh</code> 类用于创建圆柱体。
*/
//class laya.d3.resource.models.CylinderMesh extends laya.d3.resource.models.PrimitiveMesh
var CylinderMesh=(function(_super){
	function CylinderMesh(radius,height,slices){
		/**@private */
		this._radius=NaN;
		/**@private */
		this._height=NaN;
		/**@private */
		this._slices=0;
		(radius===void 0)&& (radius=0.5);
		(height===void 0)&& (height=2);
		(slices===void 0)&& (slices=32);
		CylinderMesh.__super.call(this);
		this._radius=radius;
		this._height=height;
		this._slices=slices;
		this.recreateResource();
		this._positions=this._getPositions();
		this._generateBoundingObject();
	}

	__class(CylinderMesh,'laya.d3.resource.models.CylinderMesh',_super);
	var __proto=CylinderMesh.prototype;
	__proto.recreateResource=function(){
		this._numberVertices=(this._slices+1+1)+(this._slices+1)*2+(this._slices+1+1);
		this._numberIndices=3 *this._slices+6 *this._slices+3 *this._slices;
		var vertexDeclaration=VertexPositionNormalTexture.vertexDeclaration;
		var vertexFloatStride=vertexDeclaration.vertexStride / 4;
		var vertices=new Float32Array(this._numberVertices *vertexFloatStride);
		var indices=new Uint16Array(this._numberIndices);
		var sliceAngle=(Math.PI *2.0)/ this._slices;
		var halfHeight=this._height / 2;
		var curAngle=0;
		var verticeCount=0;
		var posX=0;
		var posY=0;
		var posZ=0;
		var vc=0;
		var ic=0;
		for (var tv=0;tv <=this._slices;tv++){
			if (tv===0){
				vertices[vc++]=0;
				vertices[vc++]=halfHeight;
				vertices[vc++]=0;
				vertices[vc++]=0;
				vertices[vc++]=1;
				vertices[vc++]=0;
				vertices[vc++]=0.5;
				vertices[vc++]=0.5;
			}
			curAngle=tv *sliceAngle;
			posX=Math.cos(curAngle)*this._radius;
			posY=halfHeight;
			posZ=Math.sin(curAngle)*this._radius;
			vertices[vc++]=posX;
			vertices[vc++]=posY;
			vertices[vc++]=posZ;
			vertices[vc++]=0;
			vertices[vc++]=1;
			vertices[vc++]=0;
			vertices[vc++]=0.5+Math.cos(curAngle)*0.5;
			vertices[vc++]=0.5+Math.sin(curAngle)*0.5;
		}
		for (var ti=0;ti < this._slices;ti++){
			indices[ic++]=0;
			indices[ic++]=ti+1;
			indices[ic++]=ti+2;
		}
		verticeCount+=this._slices+1+1;
		for (var rv=0;rv <=this._slices;rv++){
			curAngle=rv *sliceAngle;
			posX=Math.cos(curAngle+Math.PI)*this._radius;
			posY=halfHeight;
			posZ=Math.sin(curAngle+Math.PI)*this._radius;
			vertices[vc++]=posX;
			vertices[vc+(this._slices+1)*8-1]=posX;
			vertices[vc++]=posY;
			vertices[vc+(this._slices+1)*8-1]=-posY;
			vertices[vc++]=posZ;
			vertices[vc+(this._slices+1)*8-1]=posZ;
			vertices[vc++]=posX;
			vertices[vc+(this._slices+1)*8-1]=posX;
			vertices[vc++]=0;
			vertices[vc+(this._slices+1)*8-1]=0;
			vertices[vc++]=posZ;
			vertices[vc+(this._slices+1)*8-1]=posZ;
			vertices[vc++]=1-rv *1 / this._slices;
			vertices[vc+(this._slices+1)*8-1]=1-rv *1 / this._slices;
			vertices[vc++]=0;
			vertices[vc+(this._slices+1)*8-1]=1;
		}
		vc+=(this._slices+1)*8;
		for (var ri=0;ri < this._slices;ri++){
			indices[ic++]=ri+verticeCount+(this._slices+1);
			indices[ic++]=ri+verticeCount+1;
			indices[ic++]=ri+verticeCount;
			indices[ic++]=ri+verticeCount+(this._slices+1);
			indices[ic++]=ri+verticeCount+(this._slices+1)+1;
			indices[ic++]=ri+verticeCount+1;
		}
		verticeCount+=2 *(this._slices+1);
		for (var bv=0;bv <=this._slices;bv++){
			if (bv===0){
				vertices[vc++]=0;
				vertices[vc++]=-halfHeight;
				vertices[vc++]=0;
				vertices[vc++]=0;
				vertices[vc++]=-1;
				vertices[vc++]=0;
				vertices[vc++]=0.5;
				vertices[vc++]=0.5;
			}
			curAngle=bv *sliceAngle;
			posX=Math.cos(curAngle+Math.PI)*this._radius;
			posY=-halfHeight;
			posZ=Math.sin(curAngle+Math.PI)*this._radius;
			vertices[vc++]=posX;
			vertices[vc++]=posY;
			vertices[vc++]=posZ;
			vertices[vc++]=0;
			vertices[vc++]=-1;
			vertices[vc++]=0;
			vertices[vc++]=0.5+Math.cos(curAngle)*0.5;
			vertices[vc++]=0.5+Math.sin(curAngle)*0.5;
		}
		for (var bi=0;bi < this._slices;bi++){
			indices[ic++]=0+verticeCount;
			indices[ic++]=bi+2+verticeCount;
			indices[ic++]=bi+1+verticeCount;
		}
		verticeCount+=this._slices+1+1;
		this._vertexBuffer=new VertexBuffer3D(vertexDeclaration,this._numberVertices,/*laya.webgl.WebGLContext.STATIC_DRAW*/0x88E4,true);
		this._indexBuffer=new IndexBuffer3D(/*laya.d3.graphics.IndexBuffer3D.INDEXTYPE_USHORT*/"ushort",this._numberIndices,/*laya.webgl.WebGLContext.STATIC_DRAW*/0x88E4,true);
		this._vertexBuffer.setData(vertices);
		this._indexBuffer.setData(indices);
		this.memorySize=(this._vertexBuffer._byteLength+this._indexBuffer._byteLength)*2;
		this.completeCreate();
	}

	/**
	*设置半径（改变此属性会重新生成顶点和索引）
	*@param value 半径
	*/
	/**
	*返回半径
	*@return 半径
	*/
	__getset(0,__proto,'radius',function(){
		return this._radius;
		},function(value){
		if (this._radius!==value){
			this._radius=value;
			this.releaseResource();
			this.activeResource();
		}
	});

	/**
	*设置高度（改变此属性会重新生成顶点和索引）
	*@param value 高度
	*/
	/**
	*返回高度
	*@return 高度
	*/
	__getset(0,__proto,'height',function(){
		return this._height;
		},function(value){
		if (this._height!==value){
			this._height=value;
			this.releaseResource();
			this.activeResource();
		}
	});

	/**
	*设置宽度分段（改变此属性会重新生成顶点和索引）
	*@param value 宽度分段
	*/
	/**
	*获取宽度分段
	*@return 宽度分段
	*/
	__getset(0,__proto,'slices',function(){
		return this._slices;
		},function(value){
		if (this._slices!==value){
			this._slices=value;
			this.releaseResource();
			this.activeResource();
		}
	});

	return CylinderMesh;
})(PrimitiveMesh)


/**
*<code>QuadMesh</code> 类用于创建平面。
*/
//class laya.d3.resource.models.PlaneMesh extends laya.d3.resource.models.PrimitiveMesh
var PlaneMesh=(function(_super){
	function PlaneMesh(long,width,stacks,slices){
		/**@private */
		this._long=NaN;
		/**@private */
		this._width=NaN;
		/**@private */
		this._stacks=0;
		/**@private */
		this._slices=0;
		(long===void 0)&& (long=10);
		(width===void 0)&& (width=10);
		(stacks===void 0)&& (stacks=10);
		(slices===void 0)&& (slices=10);
		PlaneMesh.__super.call(this);
		this._long=long;
		this._width=width;
		this._stacks=stacks;
		this._slices=slices;
		this.activeResource();
		this._positions=this._getPositions();
		this._generateBoundingObject();
	}

	__class(PlaneMesh,'laya.d3.resource.models.PlaneMesh',_super);
	var __proto=PlaneMesh.prototype;
	__proto.recreateResource=function(){
		this._numberVertices=(this._stacks+1)*(this._slices+1);
		this._numberIndices=this._stacks *this._slices *2 *3;
		var indices=new Uint16Array(this._numberIndices);
		var vertexDeclaration=VertexPositionNormalTexture.vertexDeclaration;
		var vertexFloatStride=vertexDeclaration.vertexStride / 4;
		var vertices=new Float32Array(this._numberVertices *vertexFloatStride);
		var halfLong=this._long / 2;
		var halfWidth=this._width / 2;
		var stacksLong=this._long / this._stacks;
		var slicesWidth=this._width / this._slices;
		var verticeCount=0;
		for (var i=0;i <=this._slices;i++){
			for (var j=0;j <=this._stacks;j++){
				vertices[verticeCount++]=j *stacksLong-halfLong;
				vertices[verticeCount++]=0;
				vertices[verticeCount++]=i *slicesWidth-halfWidth;
				vertices[verticeCount++]=0;
				vertices[verticeCount++]=1;
				vertices[verticeCount++]=0;
				vertices[verticeCount++]=j *1 / this._stacks;
				vertices[verticeCount++]=i *1 / this._slices;
			}
		};
		var indiceIndex=0;
		for (i=0;i < this._slices;i++){
			for (j=0;j < this._stacks;j++){
				indices[indiceIndex++]=(i+1)*(this._stacks+1)+j;
				indices[indiceIndex++]=i *(this._stacks+1)+j;
				indices[indiceIndex++]=(i+1)*(this._stacks+1)+j+1;
				indices[indiceIndex++]=i *(this._stacks+1)+j;
				indices[indiceIndex++]=i *(this._stacks+1)+j+1;
				indices[indiceIndex++]=(i+1)*(this._stacks+1)+j+1;
			}
		}
		this._vertexBuffer=new VertexBuffer3D(vertexDeclaration,this._numberVertices,/*laya.webgl.WebGLContext.STATIC_DRAW*/0x88E4,true);
		this._indexBuffer=new IndexBuffer3D(/*laya.d3.graphics.IndexBuffer3D.INDEXTYPE_USHORT*/"ushort",this._numberIndices,/*laya.webgl.WebGLContext.STATIC_DRAW*/0x88E4,true);
		this._vertexBuffer.setData(vertices);
		this._indexBuffer.setData(indices);
		this.memorySize=(this._vertexBuffer._byteLength+this._indexBuffer._byteLength)*2;
		this.completeCreate();
	}

	/**
	*设置长度（改变此属性会重新生成顶点和索引）
	*@param value 长度
	*/
	/**
	*返回长度
	*@return 长
	*/
	__getset(0,__proto,'long',function(){
		return this._long;
		},function(value){
		if (this._long!==value){
			this._long=value;
			this.releaseResource();
			this.activeResource();
		}
	});

	/**
	*设置宽度（改变此属性会重新生成顶点和索引）
	*@param value 宽度
	*/
	/**
	*返回宽度
	*@return 宽
	*/
	__getset(0,__proto,'width',function(){
		return this._width;
		},function(value){
		if (this._width!==value){
			this._width=value;
			this.releaseResource();
			this.activeResource();
		}
	});

	/**
	*设置长度分段（改变此属性会重新生成顶点和索引）
	*@param value长度分段
	*/
	/**
	*获取长度分段
	*@return 长度分段
	*/
	__getset(0,__proto,'stacks',function(){
		return this._stacks;
		},function(value){
		if (this._stacks!==value){
			this._stacks=value;
			this.releaseResource();
			this.activeResource();
		}
	});

	/**
	*设置宽度分段（改变此属性会重新生成顶点和索引）
	*@param value 宽度分段
	*/
	/**
	*获取宽度分段
	*@return 宽度分段
	*/
	__getset(0,__proto,'slices',function(){
		return this._slices;
		},function(value){
		if (this._slices!==value){
			this._slices=value;
			this.releaseResource();
			this.activeResource();
		}
	});

	return PlaneMesh;
})(PrimitiveMesh)


/**
*<code>QuadMesh</code> 类用于创建四边形。
*/
//class laya.d3.resource.models.QuadMesh extends laya.d3.resource.models.PrimitiveMesh
var QuadMesh=(function(_super){
	function QuadMesh(long,width){
		/**@private */
		this._long=NaN;
		/**@private */
		this._width=NaN;
		(long===void 0)&& (long=1);
		(width===void 0)&& (width=1);
		QuadMesh.__super.call(this);
		this._long=long;
		this._width=width;
		this.activeResource();
		this._positions=this._getPositions();
		this._generateBoundingObject();
	}

	__class(QuadMesh,'laya.d3.resource.models.QuadMesh',_super);
	var __proto=QuadMesh.prototype;
	__proto.recreateResource=function(){
		this._numberVertices=4;
		this._numberIndices=6;
		var vertexDeclaration=VertexPositionNormalTexture.vertexDeclaration;
		var vertexFloatStride=vertexDeclaration.vertexStride / 4;
		var halfLong=this._long / 2;
		var halfWidth=this._width / 2;
		var vertices=new Float32Array([
		-halfLong,halfWidth,0,0,0,1,0,0,halfLong,halfWidth,0,0,0,1,1,0,-halfLong,-halfWidth,0,0,0,1,0,1,halfLong,-halfWidth,0,0,0,1,1,1,]);
		var indices=new Uint16Array([
		0,1,2,3,2,1,]);
		this._vertexBuffer=new VertexBuffer3D(vertexDeclaration,this._numberVertices,/*laya.webgl.WebGLContext.STATIC_DRAW*/0x88E4,true);
		this._indexBuffer=new IndexBuffer3D(/*laya.d3.graphics.IndexBuffer3D.INDEXTYPE_USHORT*/"ushort",this._numberIndices,/*laya.webgl.WebGLContext.STATIC_DRAW*/0x88E4,true);
		this._vertexBuffer.setData(vertices);
		this._indexBuffer.setData(indices);
		this.memorySize=(this._vertexBuffer._byteLength+this._indexBuffer._byteLength)*2;
		this.completeCreate();
	}

	/**
	*设置长度（改变此属性会重新生成顶点和索引）
	*@param value 长度
	*/
	/**
	*返回长度
	*@return 长
	*/
	__getset(0,__proto,'long',function(){
		return this._long;
		},function(value){
		if (this._long!==value){
			this._long=value;
			this.releaseResource();
			this.activeResource();
		}
	});

	/**
	*设置宽度（改变此属性会重新生成顶点和索引）
	*@param value 宽度
	*/
	/**
	*返回宽度
	*@return 宽
	*/
	__getset(0,__proto,'width',function(){
		return this._width;
		},function(value){
		if (this._width!==value){
			this._width=value;
			this.releaseResource();
			this.activeResource();
		}
	});

	return QuadMesh;
})(PrimitiveMesh)


/**
*<code>Sphere</code> 类用于创建球体。
*/
//class laya.d3.resource.models.SphereMesh extends laya.d3.resource.models.PrimitiveMesh
var SphereMesh=(function(_super){
	function SphereMesh(radius,stacks,slices){
		/**@private */
		this._radius=NaN;
		/**@private */
		this._slices=0;
		/**@private */
		this._stacks=0;
		(radius===void 0)&& (radius=0.5);
		(stacks===void 0)&& (stacks=32);
		(slices===void 0)&& (slices=32);
		SphereMesh.__super.call(this);
		this._radius=radius;
		this._stacks=stacks;
		this._slices=slices;
		this.activeResource();
		this._positions=this._getPositions();
		this._generateBoundingObject();
	}

	__class(SphereMesh,'laya.d3.resource.models.SphereMesh',_super);
	var __proto=SphereMesh.prototype;
	__proto.recreateResource=function(){
		this._numberVertices=(this._stacks+1)*(this._slices+1);
		this._numberIndices=(3 *this._stacks *(this._slices+1))*2;
		var indices=new Uint16Array(this._numberIndices);
		var vertexDeclaration=VertexPositionNormalTexture.vertexDeclaration;
		var vertexFloatStride=vertexDeclaration.vertexStride / 4;
		var vertices=new Float32Array(this._numberVertices *vertexFloatStride);
		var stackAngle=Math.PI / this._stacks;
		var sliceAngle=(Math.PI *2.0)/ this._slices;
		var vertexIndex=0;
		var vertexCount=0;
		var indexCount=0;
		for (var stack=0;stack < (this._stacks+1);stack++){
			var r=Math.sin(stack *stackAngle);
			var y=Math.cos(stack *stackAngle);
			for (var slice=0;slice < (this._slices+1);slice++){
				var x=r *Math.sin(slice *sliceAngle+Math.PI *1 / 2);
				var z=r *Math.cos(slice *sliceAngle+Math.PI *1 / 2);
				vertices[vertexCount+0]=x *this._radius;
				vertices[vertexCount+1]=y *this._radius;
				vertices[vertexCount+2]=z *this._radius;
				vertices[vertexCount+3]=x;
				vertices[vertexCount+4]=y;
				vertices[vertexCount+5]=z;
				vertices[vertexCount+6]=slice / this._slices;
				vertices[vertexCount+7]=stack / this._stacks;
				vertexCount+=vertexFloatStride;
				if (stack !=(this._stacks-1)){
					indices[indexCount++]=vertexIndex+(this._slices+1);
					indices[indexCount++]=vertexIndex;
					indices[indexCount++]=vertexIndex+1;
					indices[indexCount++]=vertexIndex+(this._slices);
					indices[indexCount++]=vertexIndex;
					indices[indexCount++]=vertexIndex+(this._slices+1);
					vertexIndex++;
				}
			}
		}
		this._vertexBuffer=new VertexBuffer3D(vertexDeclaration,this._numberVertices,/*laya.webgl.WebGLContext.STATIC_DRAW*/0x88E4,true);
		this._indexBuffer=new IndexBuffer3D(/*laya.d3.graphics.IndexBuffer3D.INDEXTYPE_USHORT*/"ushort",this._numberIndices,/*laya.webgl.WebGLContext.STATIC_DRAW*/0x88E4,true);
		this._vertexBuffer.setData(vertices);
		this._indexBuffer.setData(indices);
		this.memorySize=(this._vertexBuffer._byteLength+this._indexBuffer._byteLength)*2;
		this.completeCreate();
	}

	/**
	*设置半径（改变此属性会重新生成顶点和索引）
	*@param value 半径
	*/
	/**
	*返回半径
	*@return 半径
	*/
	__getset(0,__proto,'radius',function(){
		return this._radius;
		},function(value){
		if (this._radius!==value){
			this._radius=value;
			this.releaseResource();
			this.activeResource();
		}
	});

	/**
	*设置宽度分段（改变此属性会重新生成顶点和索引）
	*@param value 宽度分段
	*/
	/**
	*获取宽度分段
	*@return 宽度分段
	*/
	__getset(0,__proto,'slices',function(){
		return this._slices;
		},function(value){
		if (this._slices!==value){
			this._slices=value;
			this.releaseResource();
			this.activeResource();
		}
	});

	/**
	*设置高度分段（改变此属性会重新生成顶点和索引）
	*@param value高度分段
	*/
	/**
	*获取高度分段
	*@return 高度分段
	*/
	__getset(0,__proto,'stacks',function(){
		return this._stacks;
		},function(value){
		if (this._stacks!==value){
			this._stacks=value;
			this.releaseResource();
			this.activeResource();
		}
	});

	return SphereMesh;
})(PrimitiveMesh)


/**
*<code>Camera</code> 类用于创建摄像机。
*/
//class laya.d3.core.Camera extends laya.d3.core.BaseCamera
var Camera=(function(_super){
	function Camera(aspectRatio,nearPlane,farPlane){
		/**@private */
		//this._aspectRatio=NaN;
		/**@private */
		//this._viewport=null;
		/**@private */
		//this._normalizedViewport=null;
		/**@private */
		//this._viewMatrix=null;
		/**@private */
		//this._projectionMatrix=null;
		/**@private */
		//this._projectionViewMatrix=null;
		/**@private */
		//this._boundFrustumUpdate=false;
		/**@private */
		//this._boundFrustum=null;
		/**@private */
		//this._orientedBoundBox=null;
		(aspectRatio===void 0)&& (aspectRatio=0);
		(nearPlane===void 0)&& (nearPlane=0.3);
		(farPlane===void 0)&& (farPlane=1000);
		this._viewMatrix=new Matrix4x4();
		this._projectionMatrix=new Matrix4x4();
		this._projectionViewMatrix=new Matrix4x4();
		this._viewport=new Viewport(0,0,0,0);
		this._normalizedViewport=new Viewport(0,0,1,1);
		this._aspectRatio=aspectRatio;
		this._boundFrustumUpdate=true;
		this._boundFrustum=new BoundFrustum(Matrix4x4.DEFAULT);
		Camera.__super.call(this,nearPlane,farPlane);
		this.transform.on(/*laya.events.Event.WORLDMATRIX_NEEDCHANGE*/"worldmatrixneedchanged",this,this._onWorldMatrixChanged);
	}

	__class(Camera,'laya.d3.core.Camera',_super);
	var __proto=Camera.prototype;
	/**
	*@private
	*/
	__proto._onWorldMatrixChanged=function(){
		this._boundFrustumUpdate=true;
	}

	/**
	*@inheritDoc
	*/
	__proto._parseCustomProps=function(rootNode,innerResouMap,customProps,json){
		var color=customProps.clearColor;
		this.clearColor=new Vector4(color[0],color[1],color[2],color[3]);
		var viewport=customProps.viewport;
		this.normalizedViewport=new Viewport(viewport[0],viewport[1],viewport[2],viewport[3]);
	}

	/**
	*@inheritDoc
	*/
	__proto._calculateProjectionMatrix=function(){
		if (!this._useUserProjectionMatrix){
			if (this._orthographic){
				var halfWidth=this.orthographicVerticalSize *this.aspectRatio *0.5;
				var halfHeight=this.orthographicVerticalSize *0.5;
				Matrix4x4.createOrthoOffCenterRH(-halfWidth,halfWidth,-halfHeight,halfHeight,this.nearPlane,this.farPlane,this._projectionMatrix);
				}else {
				Matrix4x4.createPerspective(3.1416 *this.fieldOfView / 180.0,this.aspectRatio,this.nearPlane,this.farPlane,this._projectionMatrix);
			}
		}
		this._boundFrustumUpdate=true;
	}

	/**
	*@inheritDoc
	*/
	__proto._update=function(state){
		if (this.conchModel){
			this.conchModel.setViewMatrix(this.viewMatrix.elements);
			this.conchModel.setProjectMatrix(this.projectionMatrix.elements);
		}
		laya.d3.core.Sprite3D.prototype._update.call(this,state);
	}

	/**
	*@inheritDoc
	*/
	__proto._renderCamera=function(gl,state,scene){
		(scene.parallelSplitShadowMaps[0])&& (scene._renderShadowMap(gl,state,this));
		state.camera=this;
		this._prepareCameraToRender();
		scene._preRenderUpdateComponents(state);
		var viewMat,projectMat;
		viewMat=state._viewMatrix=this.viewMatrix;
		var renderTar=this._renderTarget;
		if (renderTar){
			renderTar.start();
			Matrix4x4.multiply(BaseCamera._invertYScaleMatrix,this._projectionMatrix,BaseCamera._invertYProjectionMatrix);
			Matrix4x4.multiply(BaseCamera._invertYScaleMatrix,this.projectionViewMatrix,BaseCamera._invertYProjectionViewMatrix);
			projectMat=state._projectionMatrix=BaseCamera._invertYProjectionMatrix;
			state._projectionViewMatrix=BaseCamera._invertYProjectionViewMatrix;
			}else {
			projectMat=state._projectionMatrix=this._projectionMatrix;
			state._projectionViewMatrix=this.projectionViewMatrix;
		}
		this._prepareCameraViewProject(viewMat,projectMat);
		state._viewport=this.viewport;
		scene._preRenderScene(gl,state,this.boundFrustum);
		scene._clear(gl,state);
		scene._renderScene(gl,state);
		scene._postRenderUpdateComponents(state);
		(renderTar)&& (renderTar.end());
	}

	/**
	*计算从屏幕空间生成的射线。
	*@param point 屏幕空间的位置位置。
	*@return out 输出射线。
	*/
	__proto.viewportPointToRay=function(point,out){
		Picker.calculateCursorRay(point,this.viewport,this._projectionMatrix,this.viewMatrix,null,out);
	}

	/**
	*计算从裁切空间生成的射线。
	*@param point 裁切空间的位置。。
	*@return out 输出射线。
	*/
	__proto.normalizedViewportPointToRay=function(point,out){
		var finalPoint=Camera._tempVector20;
		var vp=this.viewport;
		var nVpPosE=point.elements;
		var vpPosE=finalPoint.elements;
		vpPosE[0]=nVpPosE[0] *vp.width;
		vpPosE[1]=nVpPosE[1] *vp.height;
		Picker.calculateCursorRay(finalPoint,this.viewport,this._projectionMatrix,this.viewMatrix,null,out);
	}

	/**
	*计算从世界空间准换三维坐标到屏幕空间。
	*@param position 世界空间的位置。
	*@return out 输出位置。
	*/
	__proto.worldToViewportPoint=function(position,out){
		Matrix4x4.multiply(this._projectionMatrix,this._viewMatrix,this._projectionViewMatrix);
		this.viewport.project(position,this._projectionViewMatrix,out);
		var outE=out.elements;
		outE[0]=outE[0] / Laya.stage.clientScaleX;
		outE[1]=outE[1] / Laya.stage.clientScaleY;
	}

	/**
	*计算从世界空间准换三维坐标到裁切空间。
	*@param position 世界空间的位置。
	*@return out 输出位置。
	*/
	__proto.worldToNormalizedViewportPoint=function(position,out){
		Matrix4x4.multiply(this._projectionMatrix,this._viewMatrix,this._projectionViewMatrix);
		this.normalizedViewport.project(position,this._projectionViewMatrix,out);
		var outE=out.elements;
		outE[0]=outE[0] / Laya.stage.clientScaleX;
		outE[1]=outE[1] / Laya.stage.clientScaleY;
	}

	/**
	*转换2D屏幕坐标系统到3D正交投影下的坐标系统，注:只有正交模型下有效。
	*@param source 源坐标。
	*@param out 输出坐标。
	*@return 是否转换成功。
	*/
	__proto.convertScreenCoordToOrthographicCoord=function(source,out){
		if (this._orthographic){
			var clientWidth=RenderState.clientWidth;
			var clientHeight=RenderState.clientHeight;
			var ratioX=this.orthographicVerticalSize *this.aspectRatio / clientWidth;
			var ratioY=this.orthographicVerticalSize / clientHeight;
			var sE=source.elements;
			var oE=out.elements;
			oE[0]=(-clientWidth / 2+sE[0])*ratioX;
			oE[1]=(clientHeight / 2-sE[1])*ratioY;
			oE[2]=(this.nearPlane-this.farPlane)*(sE[2]+1)/ 2-this.nearPlane;
			Vector3.transformCoordinate(out,this.transform.worldMatrix,out);
			return true;
			}else {
			return false;
		}
	}

	/**
	*获取视图投影矩阵。
	*@return 视图投影矩阵。
	*/
	__getset(0,__proto,'projectionViewMatrix',function(){
		Matrix4x4.multiply(this.projectionMatrix,this.viewMatrix,this._projectionViewMatrix);
		return this._projectionViewMatrix;
	});

	/**
	*设置横纵比。
	*@param value 横纵比。
	*/
	/**
	*获取横纵比。
	*@return 横纵比。
	*/
	__getset(0,__proto,'aspectRatio',function(){
		if (this._aspectRatio===0){
			var vp=this.viewport;
			return vp.width / vp.height;
		}
		return this._aspectRatio;
		},function(value){
		if (value < 0)
			throw new Error("Camera: the aspect ratio has to be a positive real number.");
		this._aspectRatio=value;
		this._calculateProjectionMatrix();
	});

	/**
	*获取摄像机视锥。
	*/
	__getset(0,__proto,'boundFrustum',function(){
		if (this._boundFrustumUpdate)
			this._boundFrustum.matrix=this.projectionViewMatrix;
		return this._boundFrustum;
	});

	__getset(0,__proto,'needViewport',function(){
		var nVp=this.normalizedViewport;
		return nVp.x===0 && nVp.y===0 && nVp.width===1 && nVp.height===1;
	});

	/**
	*设置屏幕空间的视口。
	*@param 屏幕空间的视口。
	*/
	/**
	*获取屏幕空间的视口。
	*@return 屏幕空间的视口。
	*/
	__getset(0,__proto,'viewport',function(){
		if (this._viewportExpressedInClipSpace){
			var nVp=this._normalizedViewport;
			var size=this.renderTargetSize;
			var sizeW=size.width;
			var sizeH=size.height;
			this._viewport.x=nVp.x *sizeW;
			this._viewport.y=nVp.y *sizeH;
			this._viewport.width=nVp.width *sizeW;
			this._viewport.height=nVp.height *sizeH;
		}
		return this._viewport;
		},function(value){
		if (this.renderTarget !=null && (value.x < 0 || value.y < 0 || value.width==0 || value.height==0))
			throw new Error("Camera: viewport size invalid.","value");
		this._viewportExpressedInClipSpace=false;
		this._viewport=value;
		this._calculateProjectionMatrix();
	});

	/**
	*设置裁剪空间的视口。
	*@return 裁剪空间的视口。
	*/
	/**
	*获取裁剪空间的视口。
	*@return 裁剪空间的视口。
	*/
	__getset(0,__proto,'normalizedViewport',function(){
		if (!this._viewportExpressedInClipSpace){
			var vp=this._viewport;
			var size=this.renderTargetSize;
			var sizeW=size.width;
			var sizeH=size.height;
			this._normalizedViewport.x=vp.x / sizeW;
			this._normalizedViewport.y=vp.y / sizeH;
			this._normalizedViewport.width=vp.width / sizeW;
			this._normalizedViewport.height=vp.height / sizeH;
		}
		return this._normalizedViewport;
		},function(value){
		if (value.x < 0){
			value.x=0;
			console.warn("Camera: viewport.x must large than 0.0.");
		}
		if (value.y < 0){
			value.y=0;
			console.warn("Camera: viewport.y must large than 0.0.");
		}
		if (value.x+value.width > 1.0){
			value.width=1.0-value.x;
			console.warn("Camera: viewport.width + viewport.x must less than 1.0.");
		}
		if ((value.y+value.height)> 1.0){
			value.height=1.0-value.y;
			console.warn("Camera: viewport.height + viewport.y must less than 1.0.");
		}
		this._viewportExpressedInClipSpace=true;
		this._normalizedViewport=value;
		this._calculateProjectionMatrix();
	});

	/**设置投影矩阵。*/
	/**获取投影矩阵。*/
	__getset(0,__proto,'projectionMatrix',function(){
		return this._projectionMatrix;
		},function(value){
		this._projectionMatrix=value;
		this._useUserProjectionMatrix=true;
	});

	/**
	*获取视图矩阵。
	*@return 视图矩阵。
	*/
	__getset(0,__proto,'viewMatrix',function(){
		this.transform.worldMatrix.invert(this._viewMatrix);
		return this._viewMatrix;
	});

	__static(Camera,
	['_tempVector20',function(){return this._tempVector20=new Vector2();}
	]);
	return Camera;
})(BaseCamera)


/**
*<code>Glitter</code> 类用于创建闪光。
*/
//class laya.d3.core.glitter.Glitter extends laya.d3.core.RenderableSprite3D
var Glitter=(function(_super){
	/**
	*创建一个 <code>Glitter</code> 实例。
	*@param settings 配置信息。
	*/
	function Glitter(){
		Glitter.__super.call(this);
		this._render=new GlitterRender(this);
		this._render.on(/*laya.events.Event.MATERIAL_CHANGED*/"materialchanged",this,this._onMaterialChanged);
		var material=new GlitterMaterial();
		this._render.sharedMaterial=material;
		this._geometryFilter=new GlitterTemplet(this);
		material.renderMode=/*laya.d3.core.material.GlitterMaterial.RENDERMODE_DEPTHREAD_ADDTIVEDOUBLEFACE*/8;
		this._changeRenderObject(0);
	}

	__class(Glitter,'laya.d3.core.glitter.Glitter',_super);
	var __proto=Glitter.prototype;
	/**@private */
	__proto._changeRenderObject=function(index){
		var renderObjects=this._render._renderElements;
		var renderElement=renderObjects[index];
		(renderElement)|| (renderElement=renderObjects[index]=new RenderElement());
		renderElement._render=this._render;
		var material=this._render.sharedMaterials[index];
		(material)|| (material=GlitterMaterial.defaultMaterial);
		var element=this._geometryFilter;
		renderElement._mainSortID=0;
		renderElement._sprite3D=this;
		renderElement.renderObj=element;
		renderElement._material=material;
		return renderElement;
	}

	/**@private */
	__proto._onMaterialChanged=function(_glitterRender,index,material){
		var renderElementCount=_glitterRender._renderElements.length;
		(index < renderElementCount)&& this._changeRenderObject(index);
	}

	/**@private */
	__proto._clearSelfRenderObjects=function(){
		this.scene.removeFrustumCullingObject(this._render);
	}

	/**@private */
	__proto._addSelfRenderObjects=function(){
		this.scene.addFrustumCullingObject(this._render);
	}

	__proto._update=function(state){
		(this._geometryFilter)._update(state.elapsedTime);
		_super.prototype._update.call(this,state);
	}

	/**
	*通过位置添加刀光。
	*@param position0 位置0。
	*@param position1 位置1。
	*/
	__proto.addGlitterByPositions=function(position0,position1){
		(this._geometryFilter).addVertexPosition(position0,position1);
	}

	/**
	*通过位置和速度添加刀光。
	*@param position0 位置0。
	*@param velocity0 速度0。
	*@param position1 位置1。
	*@param velocity1 速度1。
	*/
	__proto.addGlitterByPositionsVelocitys=function(position0,velocity0,position1,velocity1){
		(this._geometryFilter).addVertexPositionVelocity(position0,velocity0,position1,velocity1);
	}

	__proto.cloneTo=function(destObject){
		var destGlitter=destObject;
		var destTemplet=destGlitter.templet;
		var templet=this._geometryFilter;
		destTemplet.lifeTime=templet.lifeTime;
		destTemplet.minSegmentDistance=templet.minSegmentDistance;
		destTemplet.minInterpDistance=templet.minInterpDistance;
		destTemplet.maxSlerpCount=templet.maxSlerpCount;
		destTemplet._maxSegments=templet._maxSegments;
		var destGlitterRender=destGlitter._render;
		var glitterRender=this._render;
		destGlitterRender.sharedMaterials=glitterRender.sharedMaterials;
		destGlitterRender.enable=glitterRender.enable;
		laya.d3.core.Sprite3D.prototype.cloneTo.call(this,destObject);
	}

	/**
	*<p>销毁此对象。</p>
	*@param destroyChild 是否同时销毁子节点，若值为true,则销毁子节点，否则不销毁子节点。
	*/
	__proto.destroy=function(destroyChild){
		(destroyChild===void 0)&& (destroyChild=true);
		if (this.destroyed)
			return;
		_super.prototype.destroy.call(this,destroyChild);
		this._geometryFilter._destroy();
		this._geometryFilter=null;
	}

	/**
	*获取闪光模板。
	*@return 闪光模板。
	*/
	__getset(0,__proto,'templet',function(){
		return this._geometryFilter;
	});

	/**
	*获取刀光渲染器。
	*@return 刀光渲染器。
	*/
	__getset(0,__proto,'glitterRender',function(){
		return this._render;
	});

	Glitter.CURRENTTIME=2;
	Glitter.DURATION=3;
	return Glitter;
})(RenderableSprite3D)


/**
*<code>DirectionLight</code> 类用于创建平行光。
*/
//class laya.d3.core.light.DirectionLight extends laya.d3.core.light.LightSprite
var DirectionLight=(function(_super){
	function DirectionLight(){
		/**@private */
		this._direction=null;
		/**@private */
		this._updateDirection=false;
		DirectionLight.__super.call(this);
		this._updateDirection=false;
		this._direction=new Vector3();
		this.transform.on(/*laya.events.Event.WORLDMATRIX_NEEDCHANGE*/"worldmatrixneedchanged",this,this._onWorldMatrixChange);
	}

	__class(DirectionLight,'laya.d3.core.light.DirectionLight',_super);
	var __proto=DirectionLight.prototype;
	/**
	*@private
	*/
	__proto._initShadow=function(){
		if (this._shadow){
			this._parallelSplitShadowMap=new ParallelSplitShadowMap();
			this.scene.parallelSplitShadowMaps.push(this._parallelSplitShadowMap);
			this.transform.worldMatrix.getForward(this._direction);
			Vector3.normalize(this._direction,this._direction);
			this._parallelSplitShadowMap.setInfo(this.scene,this._shadowFarPlane,this._direction,this._shadowMapSize,this._shadowMapCount,this._shadowMapPCFType);
			}else {
			var parallelSplitShadowMaps=this.scene.parallelSplitShadowMaps;
			parallelSplitShadowMaps.splice(parallelSplitShadowMaps.indexOf(this._parallelSplitShadowMap),1);
			this._parallelSplitShadowMap.disposeAllRenderTarget();
			this._parallelSplitShadowMap=null;
			this.scene.removeShaderDefine(ParallelSplitShadowMap.SHADERDEFINE_SHADOW_PSSM1);
			this.scene.removeShaderDefine(ParallelSplitShadowMap.SHADERDEFINE_SHADOW_PSSM2);
			this.scene.removeShaderDefine(ParallelSplitShadowMap.SHADERDEFINE_SHADOW_PSSM3);
		}
	}

	/**
	*@inheritDoc
	*/
	__proto._addSelfRenderObjects=function(){
		_super.prototype._addSelfRenderObjects.call(this);
		this._shadow && (this._initShadow());
	}

	/**
	*@inheritDoc
	*/
	__proto._clearSelfRenderObjects=function(){
		var scene=this.scene;
		var shaderValue=scene._shaderValues;
		shaderValue.setValue(/*laya.d3.core.scene.Scene.LIGHTDIRCOLOR*/4,null);
		shaderValue.setValue(/*laya.d3.core.scene.Scene.LIGHTDIRECTION*/3,null);
		scene.removeShaderDefine(ShaderCompile3D.SHADERDEFINE_DIRECTIONLIGHT);
	}

	/**
	*更新平行光相关渲染状态参数。
	*@param state 渲染状态参数。
	*/
	__proto._prepareToScene=function(state){
		var scene=state.scene;
		if (scene.enableLight && this._activeInHierarchy){
			var shaderValue=scene._shaderValues;
			scene.addShaderDefine(ShaderCompile3D.SHADERDEFINE_DIRECTIONLIGHT);
			Vector3.scale(this.color,this._intensity,this._intensityColor);
			shaderValue.setValue(/*laya.d3.core.scene.Scene.LIGHTDIRCOLOR*/4,this._intensityColor.elements);
			this.transform.worldMatrix.getForward(this._direction);
			Vector3.normalize(this._direction,this._direction);
			shaderValue.setValue(/*laya.d3.core.scene.Scene.LIGHTDIRECTION*/3,this._direction.elements);
			return true;
			}else {
			scene.removeShaderDefine(ShaderCompile3D.SHADERDEFINE_DIRECTIONLIGHT);
			return false;
		}
	}

	/**
	*@private
	*/
	__proto._onWorldMatrixChange=function(){
		this._updateDirection=true;
	}

	/**
	*@inheritDoc
	*/
	__getset(0,__proto,'shadow',_super.prototype._$get_shadow,function(value){
		if (this._shadow!==value){
			this._shadow=value;
			(this.scene)&& (this._initShadow());
		}
	});

	/**
	*设置平行光的方向。
	*@param value 平行光的方向。
	*/
	/**
	*获取平行光的方向。
	*@return 平行光的方向。
	*/
	__getset(0,__proto,'direction',function(){
		console.log("Warning: discard property,please use transform's property instead.");
		if (this._updateDirection){
			this.transform.worldMatrix.getForward(this._direction);
			Vector3.normalize(this._direction,this._direction);
			this._updateDirection=false;
		}
		return this._direction;
		},function(value){
		console.log("Warning: discard property,please use transform's property instead.");
		var worldMatrix=this.transform.worldMatrix;
		worldMatrix.setForward(value);
		this.transform.worldMatrix=worldMatrix;
		Vector3.normalize(value,value);
		this._direction=value;
		(this.shadow && this._parallelSplitShadowMap)&& (this._parallelSplitShadowMap._setGlobalParallelLightDir(this._direction));
	});

	return DirectionLight;
})(LightSprite)


/**
*<code>PointLight</code> 类用于创建点光。
*/
//class laya.d3.core.light.PointLight extends laya.d3.core.light.LightSprite
var PointLight=(function(_super){
	function PointLight(){
		/**@private */
		this._range=NaN;
		/**@private */
		this._attenuation=null;
		PointLight.__super.call(this);
		this._range=6.0;
		this._attenuation=new Vector3(0.6,0.6,0.6);
	}

	__class(PointLight,'laya.d3.core.light.PointLight',_super);
	var __proto=PointLight.prototype;
	/**
	*@inheritDoc
	*/
	__proto._clearSelfRenderObjects=function(){
		var scene=this.scene;
		var shaderValue=scene._shaderValues;
		shaderValue.setValue(/*laya.d3.core.scene.Scene.POINTLIGHTCOLOR*/8,null);
		shaderValue.setValue(/*laya.d3.core.scene.Scene.POINTLIGHTPOS*/5,null);
		shaderValue.setValue(/*laya.d3.core.scene.Scene.POINTLIGHTRANGE*/6,null);
		shaderValue.setValue(/*laya.d3.core.scene.Scene.POINTLIGHTATTENUATION*/7,null);
		scene.removeShaderDefine(ShaderCompile3D.SHADERDEFINE_POINTLIGHT);
	}

	/**
	*更新点光相关渲染状态参数。
	*@param state 渲染状态参数。
	*/
	__proto._prepareToScene=function(state){
		var scene=state.scene;
		if (scene.enableLight && this._activeInHierarchy){
			var shaderValue=scene._shaderValues;
			scene.addShaderDefine(ShaderCompile3D.SHADERDEFINE_POINTLIGHT);
			Vector3.scale(this.color,this._intensity,this._intensityColor);
			shaderValue.setValue(/*laya.d3.core.scene.Scene.POINTLIGHTCOLOR*/8,this._intensityColor.elements);
			shaderValue.setValue(/*laya.d3.core.scene.Scene.POINTLIGHTPOS*/5,this.transform.position.elements);
			shaderValue.setValue(/*laya.d3.core.scene.Scene.POINTLIGHTRANGE*/6,this.range);
			shaderValue.setValue(/*laya.d3.core.scene.Scene.POINTLIGHTATTENUATION*/7,this.attenuation.elements);
			return true;
			}else {
			scene.removeShaderDefine(ShaderCompile3D.SHADERDEFINE_POINTLIGHT);
			return false;
		}
	}

	/**
	*设置点光的范围。
	*@param value 点光的范围。
	*/
	/**
	*获取点光的范围。
	*@return 点光的范围。
	*/
	__getset(0,__proto,'range',function(){
		return this._range;
		},function(value){
		this._range=value;
	});

	/**
	*设置点光的衰减。
	*@param value 点光的衰减。
	*/
	/**
	*获取点光的衰减。
	*@return 点光的衰减。
	*/
	__getset(0,__proto,'attenuation',function(){
		return this._attenuation;
		},function(value){
		this._attenuation=value;
	});

	return PointLight;
})(LightSprite)


/**
*<code>SpotLight</code> 类用于创建聚光。
*/
//class laya.d3.core.light.SpotLight extends laya.d3.core.light.LightSprite
var SpotLight=(function(_super){
	function SpotLight(){
		/**@private */
		this._updateDirection=false;
		/**@private */
		this._direction=null;
		/**@private */
		this._spot=NaN;
		/**@private */
		this._range=NaN;
		/**@private */
		this._attenuation=null;
		SpotLight.__super.call(this);
		this._updateDirection=false;
		this.direction=new Vector3(0.0,-1.0,-1.0);
		this._attenuation=new Vector3(0.6,0.6,0.6);
		this._spot=96.0;
		this._range=6.0;
		this.transform.on(/*laya.events.Event.WORLDMATRIX_NEEDCHANGE*/"worldmatrixneedchanged",this,this._onWorldMatrixChange);
	}

	__class(SpotLight,'laya.d3.core.light.SpotLight',_super);
	var __proto=SpotLight.prototype;
	/**
	*@private
	*/
	__proto._onWorldMatrixChange=function(){
		this._updateDirection=true;
	}

	/**
	*@inheritDoc
	*/
	__proto._clearSelfRenderObjects=function(){
		var scene=this.scene;
		var shaderValue=scene._shaderValues;
		shaderValue.setValue(/*laya.d3.core.scene.Scene.SPOTLIGHTCOLOR*/14,null);
		shaderValue.setValue(/*laya.d3.core.scene.Scene.SPOTLIGHTPOS*/9,null);
		shaderValue.setValue(/*laya.d3.core.scene.Scene.SPOTLIGHTDIRECTION*/10,null);
		shaderValue.setValue(/*laya.d3.core.scene.Scene.SPOTLIGHTRANGE*/12,null);
		shaderValue.setValue(/*laya.d3.core.scene.Scene.SPOTLIGHTSPOT*/11,null);
		shaderValue.setValue(/*laya.d3.core.scene.Scene.SPOTLIGHTATTENUATION*/13,null);
		scene.removeShaderDefine(ShaderCompile3D.SHADERDEFINE_SPOTLIGHT);
	}

	/**
	*更新聚光相关渲染状态参数。
	*@param state 渲染状态参数。
	*/
	__proto._prepareToScene=function(state){
		var scene=state.scene;
		if (scene.enableLight && this._activeInHierarchy){
			var shaderValue=scene._shaderValues;
			scene.addShaderDefine(ShaderCompile3D.SHADERDEFINE_SPOTLIGHT);
			Vector3.scale(this.color,this._intensity,this._intensityColor);
			shaderValue.setValue(/*laya.d3.core.scene.Scene.SPOTLIGHTCOLOR*/14,this._intensityColor.elements);
			shaderValue.setValue(/*laya.d3.core.scene.Scene.SPOTLIGHTPOS*/9,this.transform.position.elements);
			this.transform.worldMatrix.getForward(this._direction);
			Vector3.normalize(this._direction,this._direction);
			shaderValue.setValue(/*laya.d3.core.scene.Scene.SPOTLIGHTDIRECTION*/10,this._direction.elements);
			shaderValue.setValue(/*laya.d3.core.scene.Scene.SPOTLIGHTRANGE*/12,this.range);
			shaderValue.setValue(/*laya.d3.core.scene.Scene.SPOTLIGHTSPOT*/11,this.spot);
			shaderValue.setValue(/*laya.d3.core.scene.Scene.SPOTLIGHTATTENUATION*/13,this.attenuation.elements);
			return true;
			}else {
			scene.removeShaderDefine(ShaderCompile3D.SHADERDEFINE_SPOTLIGHT);
			return false;
		}
	}

	/**
	*设置聚光的聚光值。
	*@param value 聚光的聚光值。
	*/
	/**
	*获取聚光的聚光值。
	*@return 聚光的聚光值。
	*/
	__getset(0,__proto,'spot',function(){
		return this._spot;
		},function(value){
		this._spot=value;
	});

	/**
	*设置平行光的方向。
	*@param value 平行光的方向。
	*/
	/**
	*获取平行光的方向。
	*@return 平行光的方向。
	*/
	__getset(0,__proto,'direction',function(){
		console.log("Warning: discard property,please use transform's property instead.");
		if (this._updateDirection){
			this.transform.worldMatrix.getForward(this._direction);
			this._updateDirection=false;
		}
		return this._direction;
		},function(value){
		console.log("Warning: discard property,please use transform's property instead.");
		var worldMatrix=this.transform.worldMatrix;
		worldMatrix.setForward(value);
		this.transform.worldMatrix=worldMatrix;
		this._direction=value;
	});

	/**
	*设置聚光的范围。
	*@param value 聚光的范围值。
	*/
	/**
	*获取聚光的范围。
	*@return 聚光的范围值。
	*/
	__getset(0,__proto,'range',function(){
		return this._range;
		},function(value){
		this._range=value;
	});

	/**
	*设置聚光的衰减。
	*@param value 聚光的衰减。
	*/
	/**
	*获取聚光的衰减。
	*@return 聚光的衰减。
	*/
	__getset(0,__proto,'attenuation',function(){
		return this._attenuation;
		},function(value){
		this._attenuation=value;
	});

	return SpotLight;
})(LightSprite)


/**
*<code>MeshSprite3D</code> 类用于创建网格。
*/
//class laya.d3.core.MeshSprite3D extends laya.d3.core.RenderableSprite3D
var MeshSprite3D=(function(_super){
	/**
	*创建一个 <code>MeshSprite3D</code> 实例。
	*@param mesh 网格,同时会加载网格所用默认材质。
	*@param name 名字。
	*/
	function MeshSprite3D(mesh,name){
		MeshSprite3D.__super.call(this,name);
		this._geometryFilter=new MeshFilter(this);
		this._render=new MeshRender(this);
		this._geometryFilter.on(/*laya.events.Event.MESH_CHANGED*/"meshchanged",this,this._onMeshChanged);
		this._render.on(/*laya.events.Event.MATERIAL_CHANGED*/"materialchanged",this,this._onMaterialChanged);
		if (mesh){
			(this._geometryFilter).sharedMesh=mesh;
			if ((mesh instanceof laya.d3.resource.models.Mesh ))
				if (mesh.loaded)
			this._render.sharedMaterials=(mesh).materials;
			else
			mesh.once(/*laya.events.Event.LOADED*/"loaded",this,this._applyMeshMaterials);
		}
	}

	__class(MeshSprite3D,'laya.d3.core.MeshSprite3D',_super);
	var __proto=MeshSprite3D.prototype;
	/**
	*@private
	*/
	__proto._changeRenderObjectByMesh=function(index){
		var renderObjects=this._render._renderElements;
		var renderElement=renderObjects[index];
		(renderElement)|| (renderElement=renderObjects[index]=new SubMeshRenderElement());
		renderElement._render=this._render;
		var material=this._render.sharedMaterials[index];
		(material)|| (material=StandardMaterial.defaultMaterial);
		var renderObj=(this._geometryFilter).sharedMesh.getRenderElement(index);
		renderElement._mainSortID=this._getSortID(renderObj,material);
		renderElement._sprite3D=this;
		renderElement.renderObj=renderObj;
		renderElement._material=material;
		return renderElement;
	}

	/**
	*@private
	*/
	__proto._changeRenderObjectByMaterial=function(index,material){
		var renderElement=this._render._renderElements[index];
		(material)|| (material=StandardMaterial.defaultMaterial);
		var renderObj=(this._geometryFilter).sharedMesh.getRenderElement(index);
		renderElement._mainSortID=this._getSortID(renderObj,material);
		renderElement._sprite3D=this;
		renderElement.renderObj=renderObj;
		renderElement._material=material;
		return renderElement;
	}

	/**
	*@private
	*/
	__proto._changeRenderObjectsByMesh=function(){
		var renderElementsCount=(this._geometryFilter).sharedMesh.getRenderElementsCount();
		this._render._renderElements.length=renderElementsCount;
		for (var i=0;i < renderElementsCount;i++)
		this._changeRenderObjectByMesh(i);
	}

	/**
	*@private
	*/
	__proto._onMeshChanged=function(meshFilter){
		var mesh=meshFilter.sharedMesh;
		if (mesh.loaded)
			this._changeRenderObjectsByMesh();
		else
		mesh.once(/*laya.events.Event.LOADED*/"loaded",this,this._onMeshLoaded);
	}

	/**
	*@private
	*/
	__proto._onMeshLoaded=function(sender){
		(sender===this.meshFilter.sharedMesh)&& (this._changeRenderObjectsByMesh());
	}

	/**
	*@private
	*/
	__proto._onMaterialChanged=function(meshRender,index,material){
		var renderElementCount=this._render._renderElements.length;
		(index < renderElementCount)&& this._changeRenderObjectByMaterial(index,material);
	}

	/**
	*@inheritDoc
	*/
	__proto._clearSelfRenderObjects=function(){
		this.scene.removeFrustumCullingObject(this._render);
	}

	/**
	*@inheritDoc
	*/
	__proto._addSelfRenderObjects=function(){
		this.scene.addFrustumCullingObject(this._render);
	}

	/**
	*@inheritDoc
	*/
	__proto._parseCustomProps=function(rootNode,innerResouMap,customProps,json){
		var render=this.meshRender;
		var lightmapIndex=customProps.lightmapIndex;
		(lightmapIndex !=null)&& (render.lightmapIndex=lightmapIndex);
		var lightmapScaleOffsetArray=customProps.lightmapScaleOffset;
		(lightmapScaleOffsetArray)&& (render.lightmapScaleOffset=new Vector4(lightmapScaleOffsetArray[0],lightmapScaleOffsetArray[1],lightmapScaleOffsetArray[2],lightmapScaleOffsetArray[3]));
		var meshPath,mesh;
		if (json.instanceParams){
			meshPath=json.instanceParams.loadPath;
			if (meshPath){
				mesh=Loader.getRes(innerResouMap[meshPath]);
				this.meshFilter.sharedMesh=mesh;
				if (mesh.loaded)
					render.sharedMaterials=mesh.materials;
				else
				mesh.once(/*laya.events.Event.LOADED*/"loaded",this,this._applyMeshMaterials);
			}
			}else {
			meshPath=customProps.meshPath;
			if (meshPath){
				mesh=Loader.getRes(innerResouMap[meshPath]);
				this.meshFilter.sharedMesh=mesh;
			};
			var materials=customProps.materials;
			if (materials){
				var sharedMaterials=render.sharedMaterials;
				var materialCount=materials.length;
				sharedMaterials.length=materialCount;
				for (var i=0;i < materialCount;i++)
				sharedMaterials[i]=Loader.getRes(innerResouMap[materials[i].path]);
				render.sharedMaterials=sharedMaterials;
			}
		}
	}

	/**
	*@private
	*/
	__proto._applyMeshMaterials=function(mesh){
		var shaderMaterials=this._render.sharedMaterials;
		var meshMaterials=mesh.materials;
		for (var i=0,n=meshMaterials.length;i < n;i++)
		(shaderMaterials[i])|| (shaderMaterials[i]=meshMaterials[i]);
		this._render.sharedMaterials=shaderMaterials;
	}

	/**
	*@inheritDoc
	*/
	__proto._addToInitStaticBatchManager=function(){
		MeshSprite3D._staticBatchManager._addInitBatchSprite(this);
	}

	/**
	*@inheritDoc
	*/
	__proto.cloneTo=function(destObject){
		var meshSprite3D=destObject;
		(meshSprite3D._geometryFilter).sharedMesh=(this._geometryFilter).sharedMesh;
		var meshRender=this._render;
		var destMeshRender=meshSprite3D._render;
		destMeshRender.enable=meshRender.enable;
		destMeshRender.sharedMaterials=meshRender.sharedMaterials;
		destMeshRender.castShadow=meshRender.castShadow;
		var lightmapScaleOffset=meshRender.lightmapScaleOffset;
		lightmapScaleOffset && (destMeshRender.lightmapScaleOffset=lightmapScaleOffset.clone());
		destMeshRender.lightmapIndex=meshRender.lightmapIndex;
		destMeshRender.receiveShadow=meshRender.receiveShadow;
		destMeshRender.sortingFudge=meshRender.sortingFudge;
		laya.d3.core.Sprite3D.prototype.cloneTo.call(this,destObject);
	}

	/**
	*@inheritDoc
	*/
	__proto.destroy=function(destroyChild){
		(destroyChild===void 0)&& (destroyChild=true);
		if (this.destroyed)
			return;
		var mesh=this.meshFilter.sharedMesh;
		(mesh.loaded)|| (mesh.off(/*laya.events.Event.LOADED*/"loaded",this,this._applyMeshMaterials));
		_super.prototype.destroy.call(this,destroyChild);
		(this._geometryFilter)._destroy();
	}

	/**
	*获取网格过滤器。
	*@return 网格过滤器。
	*/
	__getset(0,__proto,'meshFilter',function(){
		return this._geometryFilter;
	});

	/**
	*获取网格渲染器。
	*@return 网格渲染器。
	*/
	__getset(0,__proto,'meshRender',function(){
		return this._render;
	});

	MeshSprite3D.__init__=function(){
		StaticBatchManager._staticBatchManagers.push(MeshSprite3D._staticBatchManager);
	}

	MeshSprite3D.load=function(url){
		return Laya.loader.create(url,null,null,MeshSprite3D);
	}

	__static(MeshSprite3D,
	['_staticBatchManager',function(){return this._staticBatchManager=new MeshSprite3DStaticBatchManager();}
	]);
	return MeshSprite3D;
})(RenderableSprite3D)


/**
*<code>ShuriKenParticle3D</code> 3D粒子。
*/
//class laya.d3.core.particleShuriKen.ShuriKenParticle3D extends laya.d3.core.RenderableSprite3D
var ShuriKenParticle3D=(function(_super){
	/**
	*创建一个 <code>Particle3D</code> 实例。
	*@param settings value 粒子配置。
	*/
	function ShuriKenParticle3D(material){
		ShuriKenParticle3D.__super.call(this);
		this._render=new ShurikenParticleRender(this);
		this._render.on(/*laya.events.Event.MATERIAL_CHANGED*/"materialchanged",this,this._onMaterialChanged);
		this._geometryFilter=new ShurikenParticleSystem(this);
		this._createRenderElement(0);
		(material)&& (this._render.sharedMaterial=material);
	}

	__class(ShuriKenParticle3D,'laya.d3.core.particleShuriKen.ShuriKenParticle3D',_super);
	var __proto=ShuriKenParticle3D.prototype;
	/**
	*@private
	*/
	__proto._initParticleVelocity=function(gradientData){
		var gradient=new GradientDataNumber();
		var velocitysData=gradientData.velocitys;
		for (var i=0,n=velocitysData.length;i < n;i++){
			var valueData=velocitysData[i];
			gradient.add(valueData.key,valueData.value);
		}
		return gradient;
	}

	/**
	*@private
	*/
	__proto._initParticleColor=function(gradientColorData){
		var gradientColor=new GradientDataColor();
		var alphasData=gradientColorData.alphas;
		var i=0,n=0;
		for (i=0,n=alphasData.length;i < n;i++){
			var alphaData=alphasData[i];
			gradientColor.addAlpha(alphaData.key,alphaData.value);
		};
		var rgbsData=gradientColorData.rgbs;
		for (i=0,n=rgbsData.length;i < n;i++){
			var rgbData=rgbsData[i];
			var rgbValue=rgbData.value;
			gradientColor.addRGB(rgbData.key,new Vector3(rgbValue[0],rgbValue[1],rgbValue[2]));
		}
		return gradientColor;
	}

	/**
	*@private
	*/
	__proto._initParticleSize=function(gradientSizeData){
		var gradientSize=new GradientDataNumber();
		var sizesData=gradientSizeData.sizes;
		for (var i=0,n=sizesData.length;i < n;i++){
			var valueData=sizesData[i];
			gradientSize.add(valueData.key,valueData.value);
		}
		return gradientSize;
	}

	/**
	*@private
	*/
	__proto._initParticleRotation=function(gradientData){
		var gradient=new GradientDataNumber();
		var angularVelocitysData=gradientData.angularVelocitys;
		for (var i=0,n=angularVelocitysData.length;i < n;i++){
			var valueData=angularVelocitysData[i];
			gradient.add(valueData.key,valueData.value / 180.0 *Math.PI);
		}
		return gradient;
	}

	/**
	*@private
	*/
	__proto._initParticleFrame=function(overTimeFramesData){
		var overTimeFrame=new GradientDataInt();
		var framesData=overTimeFramesData.frames;
		for (var i=0,n=framesData.length;i < n;i++){
			var frameData=framesData[i];
			overTimeFrame.add(frameData.key,frameData.value);
		}
		return overTimeFrame;
	}

	/**
	*@private
	*/
	__proto._createRenderElement=function(index){
		var elements=this._render._renderElements;
		var element=elements[index]=new RenderElement();
		element._render=this._render;
		var material=this._render.sharedMaterials[index];
		(material)|| (material=ShurikenParticleMaterial.defaultMaterial);
		var renderable=this._geometryFilter;
		element._mainSortID=0;
		element._sprite3D=this;
		element.renderObj=renderable;
		element._material=material;
	}

	/**@private */
	__proto._onMaterialChanged=function(_particleRender,index,material){
		var elements=_particleRender._renderElements;
		if (index < elements.length){
			var element=elements[index];
			element._material=material || ShurikenParticleMaterial.defaultMaterial;
		}
	}

	/**@private */
	__proto._clearSelfRenderObjects=function(){
		this.scene.removeFrustumCullingObject(this._render);
	}

	/**@private */
	__proto._addSelfRenderObjects=function(){
		this.scene.addFrustumCullingObject(this._render);
	}

	/**
	*@inheritDoc
	*/
	__proto._parseCustomProps=function(rootNode,innerResouMap,customProps,nodeData){
		var anglelToRad=Math.PI / 180.0;
		var i=0,n=0;
		var particleRender=this.particleRender;
		var material;
		var materialData=customProps.material;
		if (materialData){
			material=Loader.getRes(innerResouMap[materialData.path]);
			}else {
			var materialPath=customProps.materialPath;
			if (materialPath){
				material=Loader.getRes(innerResouMap[materialPath]);
				}else {
				material=new ShurikenParticleMaterial();
				material.diffuseTexture=innerResouMap ? Loader.getRes(innerResouMap[customProps.texturePath]):Texture2D.load(customProps.texturePath);
			}
		}
		particleRender.sharedMaterial=material;
		var meshPath=customProps.meshPath;
		(meshPath)&& (particleRender.mesh=Loader.getRes(innerResouMap[meshPath]));
		particleRender.renderMode=customProps.renderMode;
		particleRender.stretchedBillboardCameraSpeedScale=customProps.stretchedBillboardCameraSpeedScale;
		particleRender.stretchedBillboardSpeedScale=customProps.stretchedBillboardSpeedScale;
		particleRender.stretchedBillboardLengthScale=customProps.stretchedBillboardLengthScale;
		particleRender.sortingFudge=customProps.sortingFudge ? customProps.sortingFudge :0.0;
		var particleSystem=this.particleSystem;
		particleSystem.isPerformanceMode=customProps.isPerformanceMode;
		particleSystem.duration=customProps.duration;
		particleSystem.looping=customProps.looping;
		particleSystem.prewarm=customProps.prewarm;
		particleSystem.startDelayType=customProps.startDelayType;
		particleSystem.startDelay=customProps.startDelay;
		particleSystem.startDelayMin=customProps.startDelayMin;
		particleSystem.startDelayMax=customProps.startDelayMax;
		particleSystem.startLifetimeType=customProps.startLifetimeType;
		particleSystem.startLifetimeConstant=customProps.startLifetimeConstant;
		particleSystem.startLifeTimeGradient=ShuriKenParticle3D._initStartLife(customProps.startLifetimeGradient);
		particleSystem.startLifetimeConstantMin=customProps.startLifetimeConstantMin;
		particleSystem.startLifetimeConstantMax=customProps.startLifetimeConstantMax;
		particleSystem.startLifeTimeGradientMin=ShuriKenParticle3D._initStartLife(customProps.startLifetimeGradientMin);
		particleSystem.startLifeTimeGradientMax=ShuriKenParticle3D._initStartLife(customProps.startLifetimeGradientMax);
		particleSystem.startSpeedType=customProps.startSpeedType;
		particleSystem.startSpeedConstant=customProps.startSpeedConstant;
		particleSystem.startSpeedConstantMin=customProps.startSpeedConstantMin;
		particleSystem.startSpeedConstantMax=customProps.startSpeedConstantMax;
		particleSystem.threeDStartSize=customProps.threeDStartSize;
		particleSystem.startSizeType=customProps.startSizeType;
		particleSystem.startSizeConstant=customProps.startSizeConstant;
		var startSizeConstantSeparateArray=customProps.startSizeConstantSeparate;
		var startSizeConstantSeparateElement=particleSystem.startSizeConstantSeparate.elements;
		startSizeConstantSeparateElement[0]=startSizeConstantSeparateArray[0];
		startSizeConstantSeparateElement[1]=startSizeConstantSeparateArray[1];
		startSizeConstantSeparateElement[2]=startSizeConstantSeparateArray[2];
		particleSystem.startSizeConstantMin=customProps.startSizeConstantMin;
		particleSystem.startSizeConstantMax=customProps.startSizeConstantMax;
		var startSizeConstantMinSeparateArray=customProps.startSizeConstantMinSeparate;
		var startSizeConstantMinSeparateElement=particleSystem.startSizeConstantMinSeparate.elements;
		startSizeConstantMinSeparateElement[0]=startSizeConstantMinSeparateArray[0];
		startSizeConstantMinSeparateElement[1]=startSizeConstantMinSeparateArray[1];
		startSizeConstantMinSeparateElement[2]=startSizeConstantMinSeparateArray[2];
		var startSizeConstantMaxSeparateArray=customProps.startSizeConstantMaxSeparate;
		var startSizeConstantMaxSeparateElement=particleSystem.startSizeConstantMaxSeparate.elements;
		startSizeConstantMaxSeparateElement[0]=startSizeConstantMaxSeparateArray[0];
		startSizeConstantMaxSeparateElement[1]=startSizeConstantMaxSeparateArray[1];
		startSizeConstantMaxSeparateElement[2]=startSizeConstantMaxSeparateArray[2];
		particleSystem.threeDStartRotation=customProps.threeDStartRotation;
		particleSystem.startRotationType=customProps.startRotationType;
		particleSystem.startRotationConstant=customProps.startRotationConstant *anglelToRad;
		var startRotationConstantSeparateArray=customProps.startRotationConstantSeparate;
		var startRotationConstantSeparateElement=particleSystem.startRotationConstantSeparate.elements;
		startRotationConstantSeparateElement[0]=startRotationConstantSeparateArray[0] *anglelToRad;
		startRotationConstantSeparateElement[1]=startRotationConstantSeparateArray[1] *anglelToRad;
		startRotationConstantSeparateElement[2]=startRotationConstantSeparateArray[2] *anglelToRad;
		particleSystem.startRotationConstantMin=customProps.startRotationConstantMin *anglelToRad;
		particleSystem.startRotationConstantMax=customProps.startRotationConstantMax *anglelToRad;
		var startRotationConstantMinSeparateArray=customProps.startRotationConstantMinSeparate;
		var startRotationConstantMinSeparateElement=particleSystem.startRotationConstantMinSeparate.elements;
		startRotationConstantMinSeparateElement[0]=startRotationConstantMinSeparateArray[0] *anglelToRad;
		startRotationConstantMinSeparateElement[1]=startRotationConstantMinSeparateArray[1] *anglelToRad;
		startRotationConstantMinSeparateElement[2]=startRotationConstantMinSeparateArray[2] *anglelToRad;
		var startRotationConstantMaxSeparateArray=customProps.startRotationConstantMaxSeparate;
		var startRotationConstantMaxSeparateElement=particleSystem.startRotationConstantMaxSeparate.elements;
		startRotationConstantMaxSeparateElement[0]=startRotationConstantMaxSeparateArray[0] *anglelToRad;
		startRotationConstantMaxSeparateElement[1]=startRotationConstantMaxSeparateArray[1] *anglelToRad;
		startRotationConstantMaxSeparateElement[2]=startRotationConstantMaxSeparateArray[2] *anglelToRad;
		particleSystem.randomizeRotationDirection=customProps.randomizeRotationDirection;
		particleSystem.startColorType=customProps.startColorType;
		var startColorConstantArray=customProps.startColorConstant;
		var startColorConstantElement=particleSystem.startColorConstant.elements;
		startColorConstantElement[0]=startColorConstantArray[0];
		startColorConstantElement[1]=startColorConstantArray[1];
		startColorConstantElement[2]=startColorConstantArray[2];
		startColorConstantElement[3]=startColorConstantArray[3];
		var startColorConstantMinArray=customProps.startColorConstantMin;
		var startColorConstantMinElement=particleSystem.startColorConstantMin.elements;
		startColorConstantMinElement[0]=startColorConstantMinArray[0];
		startColorConstantMinElement[1]=startColorConstantMinArray[1];
		startColorConstantMinElement[2]=startColorConstantMinArray[2];
		startColorConstantMinElement[3]=startColorConstantMinArray[3];
		var startColorConstantMaxArray=customProps.startColorConstantMax;
		var startColorConstantMaxElement=particleSystem.startColorConstantMax.elements;
		startColorConstantMaxElement[0]=startColorConstantMaxArray[0];
		startColorConstantMaxElement[1]=startColorConstantMaxArray[1];
		startColorConstantMaxElement[2]=startColorConstantMaxArray[2];
		startColorConstantMaxElement[3]=startColorConstantMaxArray[3];
		particleSystem.gravityModifier=customProps.gravityModifier;
		particleSystem.simulationSpace=customProps.simulationSpace;
		particleSystem.scaleMode=customProps.scaleMode;
		particleSystem.playOnAwake=customProps.playOnAwake;
		particleSystem.maxParticles=customProps.maxParticles;
		var autoRandomSeed=customProps.autoRandomSeed;
		(autoRandomSeed !=null)&& (particleSystem.autoRandomSeed=autoRandomSeed);
		var randomSeed=customProps.randomSeed;
		(randomSeed !=null)&& (particleSystem.randomSeed[0]=randomSeed);
		var emissionData=customProps.emission;
		var emission=particleSystem.emission;
		if (emissionData){
			emission.emissionRate=emissionData.emissionRate;
			var burstsData=emissionData.bursts;
			if (burstsData)
				for (i=0,n=burstsData.length;i < n;i++){
				var brust=burstsData[i];
				emission.addBurst(new Burst(brust.time,brust.min,brust.max));
			}
			emission.enbale=emissionData.enable;
			}else {
			emission.enbale=false;
		};
		var shapeData=customProps.shape;
		if (shapeData){
			var shape;
			switch (shapeData.shapeType){
				case 0:;
					var sphereShape;
					shape=sphereShape=new SphereShape();
					sphereShape.radius=shapeData.sphereRadius;
					sphereShape.emitFromShell=shapeData.sphereEmitFromShell;
					sphereShape.randomDirection=shapeData.sphereRandomDirection;
					break ;
				case 1:;
					var hemiSphereShape;
					shape=hemiSphereShape=new HemisphereShape();
					hemiSphereShape.radius=shapeData.hemiSphereRadius;
					hemiSphereShape.emitFromShell=shapeData.hemiSphereEmitFromShell;
					hemiSphereShape.randomDirection=shapeData.hemiSphereRandomDirection;
					break ;
				case 2:;
					var coneShape;
					shape=coneShape=new ConeShape();
					coneShape.angle=shapeData.coneAngle *anglelToRad;
					coneShape.radius=shapeData.coneRadius;
					coneShape.length=shapeData.coneLength;
					coneShape.emitType=shapeData.coneEmitType;
					coneShape.randomDirection=shapeData.coneRandomDirection;
					break ;
				case 3:;
					var boxShape;
					shape=boxShape=new BoxShape();
					boxShape.x=shapeData.boxX;
					boxShape.y=shapeData.boxY;
					boxShape.z=shapeData.boxZ;
					boxShape.randomDirection=shapeData.boxRandomDirection;
					break ;
				case 7:;
					var circleShape;
					shape=circleShape=new CircleShape();
					circleShape.radius=shapeData.circleRadius;
					circleShape.arc=shapeData.circleArc *anglelToRad;
					circleShape.emitFromEdge=shapeData.circleEmitFromEdge;
					circleShape.randomDirection=shapeData.circleRandomDirection;
					break ;
				default :;
					var tempShape;
					shape=tempShape=new CircleShape();
					tempShape.radius=shapeData.circleRadius;
					tempShape.arc=shapeData.circleArc *anglelToRad;
					tempShape.emitFromEdge=shapeData.circleEmitFromEdge;
					tempShape.randomDirection=shapeData.circleRandomDirection;
					break ;
				}
			shape.enable=shapeData.enable;
			particleSystem.shape=shape;
		};
		var velocityOverLifetimeData=customProps.velocityOverLifetime;
		if (velocityOverLifetimeData){
			var velocityData=velocityOverLifetimeData.velocity;
			var velocity;
			switch (velocityData.type){
				case 0:;
					var constantData=velocityData.constant;
					velocity=GradientVelocity.createByConstant(new Vector3(constantData[0],constantData[1],constantData[2]));
					break ;
				case 1:
					velocity=GradientVelocity.createByGradient(this._initParticleVelocity(velocityData.gradientX),this._initParticleVelocity(velocityData.gradientY),this._initParticleVelocity(velocityData.gradientZ));
					break ;
				case 2:;
					var constantMinData=velocityData.constantMin;
					var constantMaxData=velocityData.constantMax;
					velocity=GradientVelocity.createByRandomTwoConstant(new Vector3(constantMinData[0],constantMinData[1],constantMinData[2]),new Vector3(constantMaxData[0],constantMaxData[1],constantMaxData[2]));
					break ;
				case 3:
					velocity=GradientVelocity.createByRandomTwoGradient(this._initParticleVelocity(velocityData.gradientXMin),this._initParticleVelocity(velocityData.gradientXMax),this._initParticleVelocity(velocityData.gradientYMin),this._initParticleVelocity(velocityData.gradientYMax),this._initParticleVelocity(velocityData.gradientZMin),this._initParticleVelocity(velocityData.gradientZMax));
					break ;
				};
			var velocityOverLifetime=new VelocityOverLifetime(velocity);
			velocityOverLifetime.space=velocityOverLifetimeData.space;
			velocityOverLifetime.enbale=velocityOverLifetimeData.enable;
			particleSystem.velocityOverLifetime=velocityOverLifetime;
		};
		var colorOverLifetimeData=customProps.colorOverLifetime;
		if (colorOverLifetimeData){
			var colorData=colorOverLifetimeData.color;
			var color;
			switch (colorData.type){
				case 0:;
					var constColorData=colorData.constant;
					color=GradientColor.createByConstant(new Vector4(constColorData[0],constColorData[1],constColorData[2],constColorData[3]));
					break ;
				case 1:
					color=GradientColor.createByGradient(this._initParticleColor(colorData.gradient));
					break ;
				case 2:;
					var minConstColorData=colorData.constantMin;
					var maxConstColorData=colorData.constantMax;
					color=GradientColor.createByRandomTwoConstant(new Vector4(minConstColorData[0],minConstColorData[1],minConstColorData[2],minConstColorData[3]),new Vector4(maxConstColorData[0],maxConstColorData[1],maxConstColorData[2],maxConstColorData[3]));
					break ;
				case 3:
					color=GradientColor.createByRandomTwoGradient(this._initParticleColor(colorData.gradientMin),this._initParticleColor(colorData.gradientMax));
					break ;
				};
			var colorOverLifetime=new ColorOverLifetime(color);
			colorOverLifetime.enbale=colorOverLifetimeData.enable;
			particleSystem.colorOverLifetime=colorOverLifetime;
		};
		var sizeOverLifetimeData=customProps.sizeOverLifetime;
		if (sizeOverLifetimeData){
			var sizeData=sizeOverLifetimeData.size;
			var size;
			switch (sizeData.type){
				case 0:
					if (sizeData.separateAxes){
						size=GradientSize.createByGradientSeparate(this._initParticleSize(sizeData.gradientX),this._initParticleSize(sizeData.gradientY),this._initParticleSize(sizeData.gradientZ));
						}else {
						size=GradientSize.createByGradient(this._initParticleSize(sizeData.gradient));
					}
					break ;
				case 1:
					if (sizeData.separateAxes){
						var constantMinSeparateData=sizeData.constantMinSeparate;
						var constantMaxSeparateData=sizeData.constantMaxSeparate;
						size=GradientSize.createByRandomTwoConstantSeparate(new Vector3(constantMinSeparateData[0],constantMinSeparateData[1],constantMinSeparateData[2]),new Vector3(constantMaxSeparateData[0],constantMaxSeparateData[1],constantMaxSeparateData[2]));
						}else {
						size=GradientSize.createByRandomTwoConstant(sizeData.constantMin,sizeData.constantMax);
					}
					break ;
				case 2:
					if (sizeData.separateAxes){
						size=GradientSize.createByRandomTwoGradientSeparate(this._initParticleSize(sizeData.gradientXMin),this._initParticleSize(sizeData.gradientYMin),this._initParticleSize(sizeData.gradientZMin),this._initParticleSize(sizeData.gradientXMax),this._initParticleSize(sizeData.gradientYMax),this._initParticleSize(sizeData.gradientZMax));
						}else {
						size=GradientSize.createByRandomTwoGradient(this._initParticleSize(sizeData.gradientMin),this._initParticleSize(sizeData.gradientMax));
					}
					break ;
				};
			var sizeOverLifetime=new SizeOverLifetime(size);
			sizeOverLifetime.enbale=sizeOverLifetimeData.enable;
			particleSystem.sizeOverLifetime=sizeOverLifetime;
		};
		var rotationOverLifetimeData=customProps.rotationOverLifetime;
		if (rotationOverLifetimeData){
			var angularVelocityData=rotationOverLifetimeData.angularVelocity;
			var angularVelocity;
			switch (angularVelocityData.type){
				case 0:
					if (angularVelocityData.separateAxes){
						}else {
						angularVelocity=GradientAngularVelocity.createByConstant(angularVelocityData.constant *anglelToRad);
					}
					break ;
				case 1:
					if (angularVelocityData.separateAxes){
						}else {
						angularVelocity=GradientAngularVelocity.createByGradient(this._initParticleRotation(angularVelocityData.gradient));
					}
					break ;
				case 2:
					if (angularVelocityData.separateAxes){
						var minSep=angularVelocityData.constantMinSeparate;
						var maxSep=angularVelocityData.constantMaxSeparate;
						angularVelocity=GradientAngularVelocity.createByRandomTwoConstantSeparate(new Vector3(minSep[0]*anglelToRad,minSep[1]*anglelToRad,minSep[2]*anglelToRad),new Vector3(maxSep[0]*anglelToRad,maxSep[1]*anglelToRad,maxSep[2]*anglelToRad));
						}else {
						angularVelocity=GradientAngularVelocity.createByRandomTwoConstant(angularVelocityData.constantMin *anglelToRad,angularVelocityData.constantMax *anglelToRad);
					}
					break ;
				case 3:
					if (angularVelocityData.separateAxes){
						}else {
						angularVelocity=GradientAngularVelocity.createByRandomTwoGradient(this._initParticleRotation(angularVelocityData.gradientMin),this._initParticleRotation(angularVelocityData.gradientMax));
					}
					break ;
				};
			var rotationOverLifetime=new RotationOverLifetime(angularVelocity);
			rotationOverLifetime.enbale=rotationOverLifetimeData.enable;
			particleSystem.rotationOverLifetime=rotationOverLifetime;
		};
		var textureSheetAnimationData=customProps.textureSheetAnimation;
		if (textureSheetAnimationData){
			var frameData=textureSheetAnimationData.frame;
			var frameOverTime;
			switch (frameData.type){
				case 0:
					frameOverTime=FrameOverTime.createByConstant(frameData.constant);
					break ;
				case 1:
					frameOverTime=FrameOverTime.createByOverTime(this._initParticleFrame(frameData.overTime));
					break ;
				case 2:
					frameOverTime=FrameOverTime.createByRandomTwoConstant(frameData.constantMin,frameData.constantMax);
					break ;
				case 3:
					frameOverTime=FrameOverTime.createByRandomTwoOverTime(this._initParticleFrame(frameData.overTimeMin),this._initParticleFrame(frameData.overTimeMax));
					break ;
				};
			var startFrameData=textureSheetAnimationData.startFrame;
			var startFrame;
			switch (startFrameData.type){
				case 0:
					startFrame=StartFrame.createByConstant(startFrameData.constant);
					break ;
				case 1:
					startFrame=StartFrame.createByRandomTwoConstant(startFrameData.constantMin,startFrameData.constantMax);
					break ;
				};
			var textureSheetAnimation=new TextureSheetAnimation(frameOverTime,startFrame);
			textureSheetAnimation.enable=textureSheetAnimationData.enable;
			var tilesData=textureSheetAnimationData.tiles;
			textureSheetAnimation.tiles=new Vector2(tilesData[0],tilesData[1]);
			textureSheetAnimation.type=textureSheetAnimationData.type;
			textureSheetAnimation.randomRow=textureSheetAnimationData.randomRow;
			var rowIndex=textureSheetAnimationData.rowIndex;
			(rowIndex!==undefined)&& (textureSheetAnimation.rowIndex=rowIndex);
			textureSheetAnimation.cycles=textureSheetAnimationData.cycles;
			particleSystem.textureSheetAnimation=textureSheetAnimation;
		}
	}

	/**
	*@inheritDoc
	*/
	__proto._activeHierarchy=function(){
		laya.d3.core.Sprite3D.prototype._activeHierarchy.call(this);
		(this.particleSystem.playOnAwake)&& (this.particleSystem.play());
	}

	/**
	*@inheritDoc
	*/
	__proto._inActiveHierarchy=function(){
		laya.d3.core.Sprite3D.prototype._inActiveHierarchy.call(this);
		(this.particleSystem.isAlive)&& (this.particleSystem.simulate(0,true));
	}

	/**
	*@private
	*/
	__proto.cloneTo=function(destObject){
		var destShuriKenParticle3D=destObject;
		var destParticleSystem=destShuriKenParticle3D._geometryFilter;
		(this._geometryFilter).cloneTo(destParticleSystem);
		var destParticleRender=destShuriKenParticle3D._render;
		var particleRender=this._render;
		destParticleRender.sharedMaterials=particleRender.sharedMaterials;
		destParticleRender.enable=particleRender.enable;
		destParticleRender.renderMode=particleRender.renderMode;
		destParticleRender.mesh=particleRender.mesh;
		destParticleRender.stretchedBillboardCameraSpeedScale=particleRender.stretchedBillboardCameraSpeedScale;
		destParticleRender.stretchedBillboardSpeedScale=particleRender.stretchedBillboardSpeedScale;
		destParticleRender.stretchedBillboardLengthScale=particleRender.stretchedBillboardLengthScale;
		destParticleRender.sortingFudge=particleRender.sortingFudge;
		laya.d3.core.Sprite3D.prototype.cloneTo.call(this,destObject);
	}

	/**
	*<p>销毁此对象。</p>
	*@param destroyChild 是否同时销毁子节点，若值为true,则销毁子节点，否则不销毁子节点。
	*/
	__proto.destroy=function(destroyChild){
		(destroyChild===void 0)&& (destroyChild=true);
		if (this.destroyed)
			return;
		_super.prototype.destroy.call(this,destroyChild);
		(this._geometryFilter)._destroy();
		this._geometryFilter=null;
	}

	/**
	*获取粒子系统。
	*@return 粒子系统。
	*/
	__getset(0,__proto,'particleSystem',function(){
		return this._geometryFilter;
	});

	/**
	*获取粒子渲染器。
	*@return 粒子渲染器。
	*/
	__getset(0,__proto,'particleRender',function(){
		return this._render;
	});

	ShuriKenParticle3D.__init__=function(){
		ShuriKenParticle3D.SHADERDEFINE_RENDERMODE_BILLBOARD=ShuriKenParticle3D.shaderDefines.registerDefine("SPHERHBILLBOARD");
		ShuriKenParticle3D.SHADERDEFINE_RENDERMODE_STRETCHEDBILLBOARD=ShuriKenParticle3D.shaderDefines.registerDefine("STRETCHEDBILLBOARD");
		ShuriKenParticle3D.SHADERDEFINE_RENDERMODE_HORIZONTALBILLBOARD=ShuriKenParticle3D.shaderDefines.registerDefine("HORIZONTALBILLBOARD");
		ShuriKenParticle3D.SHADERDEFINE_RENDERMODE_VERTICALBILLBOARD=ShuriKenParticle3D.shaderDefines.registerDefine("VERTICALBILLBOARD");
		ShuriKenParticle3D.SHADERDEFINE_COLOROVERLIFETIME=ShuriKenParticle3D.shaderDefines.registerDefine("COLOROVERLIFETIME");
		ShuriKenParticle3D.SHADERDEFINE_RANDOMCOLOROVERLIFETIME=ShuriKenParticle3D.shaderDefines.registerDefine("RANDOMCOLOROVERLIFETIME");
		ShuriKenParticle3D.SHADERDEFINE_VELOCITYOVERLIFETIMECONSTANT=ShuriKenParticle3D.shaderDefines.registerDefine("VELOCITYOVERLIFETIMECONSTANT");
		ShuriKenParticle3D.SHADERDEFINE_VELOCITYOVERLIFETIMECURVE=ShuriKenParticle3D.shaderDefines.registerDefine("VELOCITYOVERLIFETIMECURVE");
		ShuriKenParticle3D.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCONSTANT=ShuriKenParticle3D.shaderDefines.registerDefine("VELOCITYOVERLIFETIMERANDOMCONSTANT");
		ShuriKenParticle3D.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCURVE=ShuriKenParticle3D.shaderDefines.registerDefine("VELOCITYOVERLIFETIMERANDOMCURVE");
		ShuriKenParticle3D.SHADERDEFINE_TEXTURESHEETANIMATIONCURVE=ShuriKenParticle3D.shaderDefines.registerDefine("TEXTURESHEETANIMATIONCURVE");
		ShuriKenParticle3D.SHADERDEFINE_TEXTURESHEETANIMATIONRANDOMCURVE=ShuriKenParticle3D.shaderDefines.registerDefine("TEXTURESHEETANIMATIONRANDOMCURVE");
		ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIME=ShuriKenParticle3D.shaderDefines.registerDefine("ROTATIONOVERLIFETIME");
		ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMESEPERATE=ShuriKenParticle3D.shaderDefines.registerDefine("ROTATIONOVERLIFETIMESEPERATE");
		ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMECONSTANT=ShuriKenParticle3D.shaderDefines.registerDefine("ROTATIONOVERLIFETIMECONSTANT");
		ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMECURVE=ShuriKenParticle3D.shaderDefines.registerDefine("ROTATIONOVERLIFETIMECURVE");
		ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCONSTANTS=ShuriKenParticle3D.shaderDefines.registerDefine("ROTATIONOVERLIFETIMERANDOMCURVES");
		ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCURVES=ShuriKenParticle3D.shaderDefines.registerDefine("ROTATIONOVERLIFETIMERANDOMCURVES");
		ShuriKenParticle3D.SHADERDEFINE_SIZEOVERLIFETIMECURVE=ShuriKenParticle3D.shaderDefines.registerDefine("SIZEOVERLIFETIMECURVE");
		ShuriKenParticle3D.SHADERDEFINE_SIZEOVERLIFETIMECURVESEPERATE=ShuriKenParticle3D.shaderDefines.registerDefine("SIZEOVERLIFETIMECURVESEPERATE");
		ShuriKenParticle3D.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVES=ShuriKenParticle3D.shaderDefines.registerDefine("SIZEOVERLIFETIMERANDOMCURVES");
		ShuriKenParticle3D.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVESSEPERATE=ShuriKenParticle3D.shaderDefines.registerDefine("SIZEOVERLIFETIMERANDOMCURVESSEPERATE");
		ShuriKenParticle3D.SHADERDEFINE_RENDERMODE_MESH=ShuriKenParticle3D.shaderDefines.registerDefine("RENDERMODE_MESH");
		ShuriKenParticle3D.SHADERDEFINE_SHAPE=ShuriKenParticle3D.shaderDefines.registerDefine("SHAPE");
	}

	ShuriKenParticle3D.load=function(url){
		return Laya.loader.create(url,null,null,ShuriKenParticle3D);
	}

	ShuriKenParticle3D._initStartLife=function(gradientData){
		var gradient=new GradientDataNumber();
		var startLifetimesData=gradientData.startLifetimes;
		for (var i=0,n=startLifetimesData.length;i < n;i++){
			var valueData=startLifetimesData[i];
			gradient.add(valueData.key,valueData.value);
		}
		return gradient;
	}

	ShuriKenParticle3D.SHADERDEFINE_RENDERMODE_BILLBOARD=0;
	ShuriKenParticle3D.SHADERDEFINE_RENDERMODE_STRETCHEDBILLBOARD=0;
	ShuriKenParticle3D.SHADERDEFINE_RENDERMODE_HORIZONTALBILLBOARD=0;
	ShuriKenParticle3D.SHADERDEFINE_RENDERMODE_VERTICALBILLBOARD=0;
	ShuriKenParticle3D.SHADERDEFINE_COLOROVERLIFETIME=0;
	ShuriKenParticle3D.SHADERDEFINE_RANDOMCOLOROVERLIFETIME=0;
	ShuriKenParticle3D.SHADERDEFINE_VELOCITYOVERLIFETIMECONSTANT=0;
	ShuriKenParticle3D.SHADERDEFINE_VELOCITYOVERLIFETIMECURVE=0;
	ShuriKenParticle3D.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCONSTANT=0;
	ShuriKenParticle3D.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCURVE=0;
	ShuriKenParticle3D.SHADERDEFINE_TEXTURESHEETANIMATIONCURVE=0;
	ShuriKenParticle3D.SHADERDEFINE_TEXTURESHEETANIMATIONRANDOMCURVE=0;
	ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIME=0;
	ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMESEPERATE=0;
	ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMECONSTANT=0;
	ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMECURVE=0;
	ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCONSTANTS=0;
	ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCURVES=0;
	ShuriKenParticle3D.SHADERDEFINE_SIZEOVERLIFETIMECURVE=0;
	ShuriKenParticle3D.SHADERDEFINE_SIZEOVERLIFETIMECURVESEPERATE=0;
	ShuriKenParticle3D.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVES=0;
	ShuriKenParticle3D.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVESSEPERATE=0;
	ShuriKenParticle3D.SHADERDEFINE_RENDERMODE_MESH=0;
	ShuriKenParticle3D.SHADERDEFINE_SHAPE=0;
	ShuriKenParticle3D.WORLDPOSITION=0;
	ShuriKenParticle3D.WORLDROTATION=1;
	ShuriKenParticle3D.POSITIONSCALE=4;
	ShuriKenParticle3D.SIZESCALE=5;
	ShuriKenParticle3D.SCALINGMODE=6;
	ShuriKenParticle3D.GRAVITY=7;
	ShuriKenParticle3D.THREEDSTARTROTATION=8;
	ShuriKenParticle3D.STRETCHEDBILLBOARDLENGTHSCALE=9;
	ShuriKenParticle3D.STRETCHEDBILLBOARDSPEEDSCALE=10;
	ShuriKenParticle3D.SIMULATIONSPACE=11;
	ShuriKenParticle3D.CURRENTTIME=12;
	ShuriKenParticle3D.VOLVELOCITYCONST=13;
	ShuriKenParticle3D.VOLVELOCITYGRADIENTX=14;
	ShuriKenParticle3D.VOLVELOCITYGRADIENTY=15;
	ShuriKenParticle3D.VOLVELOCITYGRADIENTZ=16;
	ShuriKenParticle3D.VOLVELOCITYCONSTMAX=17;
	ShuriKenParticle3D.VOLVELOCITYGRADIENTXMAX=18;
	ShuriKenParticle3D.VOLVELOCITYGRADIENTYMAX=19;
	ShuriKenParticle3D.VOLVELOCITYGRADIENTZMAX=20;
	ShuriKenParticle3D.VOLSPACETYPE=21;
	ShuriKenParticle3D.COLOROVERLIFEGRADIENTALPHAS=22;
	ShuriKenParticle3D.COLOROVERLIFEGRADIENTCOLORS=23;
	ShuriKenParticle3D.MAXCOLOROVERLIFEGRADIENTALPHAS=24;
	ShuriKenParticle3D.MAXCOLOROVERLIFEGRADIENTCOLORS=25;
	ShuriKenParticle3D.SOLSIZEGRADIENT=26;
	ShuriKenParticle3D.SOLSIZEGRADIENTX=27;
	ShuriKenParticle3D.SOLSIZEGRADIENTY=28;
	ShuriKenParticle3D.SOLSizeGradientZ=29;
	ShuriKenParticle3D.SOLSizeGradientMax=30;
	ShuriKenParticle3D.SOLSIZEGRADIENTXMAX=31;
	ShuriKenParticle3D.SOLSIZEGRADIENTYMAX=32;
	ShuriKenParticle3D.SOLSizeGradientZMAX=33;
	ShuriKenParticle3D.ROLANGULARVELOCITYCONST=34;
	ShuriKenParticle3D.ROLANGULARVELOCITYCONSTSEPRARATE=35;
	ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENT=36;
	ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTX=37;
	ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTY=38;
	ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTZ=39;
	ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTW=40;
	ShuriKenParticle3D.ROLANGULARVELOCITYCONSTMAX=41;
	ShuriKenParticle3D.ROLANGULARVELOCITYCONSTMAXSEPRARATE=42;
	ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTMAX=43;
	ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTXMAX=44;
	ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTYMAX=45;
	ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTZMAX=46;
	ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTWMAX=47;
	ShuriKenParticle3D.TEXTURESHEETANIMATIONCYCLES=48;
	ShuriKenParticle3D.TEXTURESHEETANIMATIONSUBUVLENGTH=49;
	ShuriKenParticle3D.TEXTURESHEETANIMATIONGRADIENTUVS=50;
	ShuriKenParticle3D.TEXTURESHEETANIMATIONGRADIENTMAXUVS=51;
	__static(ShuriKenParticle3D,
	['shaderDefines',function(){return this.shaderDefines=new ShaderDefines$1(RenderableSprite3D.shaderDefines);}
	]);
	return ShuriKenParticle3D;
})(RenderableSprite3D)


/**
*<code>SkinnedMeshSprite3D</code> 类用于创建网格。
*/
//class laya.d3.core.SkinnedMeshSprite3D extends laya.d3.core.RenderableSprite3D
var SkinnedMeshSprite3D=(function(_super){
	function SkinnedMeshSprite3D(mesh,name){
		/**@private */
		this._subMeshOffset=null;
		SkinnedMeshSprite3D.__super.call(this,name);
		this._subMeshOffset=[];
		this._geometryFilter=new MeshFilter(this);
		this._render=new SkinnedMeshRender(this);
		this._geometryFilter.on(/*laya.events.Event.MESH_CHANGED*/"meshchanged",this,this._onMeshChanged);
		this._render.on(/*laya.events.Event.MATERIAL_CHANGED*/"materialchanged",this,this._onMaterialChanged);
		(mesh)&& ((this._geometryFilter).sharedMesh=mesh);
	}

	__class(SkinnedMeshSprite3D,'laya.d3.core.SkinnedMeshSprite3D',_super);
	var __proto=SkinnedMeshSprite3D.prototype;
	/**
	*@private
	*/
	__proto._changeRenderObjectByMesh=function(index){
		var renderObjects=this._render._renderElements;
		var renderElement=renderObjects[index];
		(renderElement)|| (renderElement=renderObjects[index]=new SubMeshRenderElement());
		renderElement._render=this._render;
		var material=this._render.sharedMaterials[index];
		(material)|| (material=StandardMaterial.defaultMaterial);
		var renderObj=(this._geometryFilter).sharedMesh.getRenderElement(index);
		renderElement._mainSortID=this._getSortID(renderObj,material);
		renderElement._sprite3D=this;
		renderElement.renderObj=renderObj;
		renderElement._material=material;
		return renderElement;
	}

	/**
	*@private
	*/
	__proto._changeRenderObjectByMaterial=function(index,material){
		var renderElement=this._render._renderElements[index];
		(material)|| (material=StandardMaterial.defaultMaterial);
		var renderObj=(this._geometryFilter).sharedMesh.getRenderElement(index);
		renderElement._mainSortID=this._getSortID(renderObj,material);
		renderElement._sprite3D=this;
		renderElement.renderObj=renderObj;
		renderElement._material=material;
		return renderElement;
	}

	/**
	*@private
	*/
	__proto._changeRenderObjectsByMesh=function(){
		var renderElementsCount=(this._geometryFilter).sharedMesh.getRenderElementsCount();
		this._render._renderElements.length=renderElementsCount;
		for (var i=0;i < renderElementsCount;i++)
		this._changeRenderObjectByMesh(i);
	}

	/**
	*@private
	*/
	__proto._onMeshChanged=function(meshFilter){
		var mesh=meshFilter.sharedMesh;
		if (mesh.loaded)
			this._changeRenderObjectsByMesh();
		else
		mesh.once(/*laya.events.Event.LOADED*/"loaded",this,this._changeRenderObjectsByMesh);
	}

	/**
	*@private
	*/
	__proto._onMaterialChanged=function(meshRender,index,material){
		var renderElementCount=this._render._renderElements.length;
		(index < renderElementCount)&& this._changeRenderObjectByMaterial(index,material);
	}

	/**
	*@inheritDoc
	*/
	__proto._parseCustomProps=function(rootNode,innerResouMap,customProps,json){
		var render=this.skinnedMeshRender;
		var lightmapIndex=customProps.lightmapIndex;
		(lightmapIndex !=null)&& (render.lightmapIndex=lightmapIndex);
		var lightmapScaleOffsetArray=customProps.lightmapScaleOffset;
		(lightmapScaleOffsetArray)&& (render.lightmapScaleOffset=new Vector4(lightmapScaleOffsetArray[0],lightmapScaleOffsetArray[1],lightmapScaleOffsetArray[2],lightmapScaleOffsetArray[3]));
		var meshPath,mesh;
		if (json.instanceParams){
			meshPath=json.instanceParams.loadPath;
			if (meshPath){
				mesh=Loader.getRes(innerResouMap[meshPath]);
				this.meshFilter.sharedMesh=mesh;
				if (mesh.loaded)
					render.sharedMaterials=mesh.materials;
				else
				mesh.once(/*laya.events.Event.LOADED*/"loaded",this,this._applyMeshMaterials);
			}
			}else {
			meshPath=customProps.meshPath;
			if (meshPath){
				mesh=Loader.getRes(innerResouMap[meshPath]);
				this.meshFilter.sharedMesh=mesh;
			};
			var materials=customProps.materials;
			if (materials){
				var sharedMaterials=render.sharedMaterials;
				var materialCount=materials.length;
				sharedMaterials.length=materialCount;
				for (var i=0;i < materialCount;i++)
				sharedMaterials[i]=Loader.getRes(innerResouMap[materials[i].path]);
				render.sharedMaterials=sharedMaterials;
			};
			var rootBone=customProps.rootBone;
			(rootBone)&& (render._setRootBone(rootBone));
			var boundBox=customProps.boundBox;
			if (boundBox){
				var min=boundBox.min;
				var max=boundBox.max;
				var localBoundBox=new BoundBox(new Vector3(min[0],min[1],min[2]),new Vector3(max[0],max[1],max[2]));
				render.localBoundBox=localBoundBox;
				}else {
				render._hasIndependentBound=false;
			};
			var boundSphere=customProps.boundSphere;
			if (boundSphere){
				var center=boundSphere.center;
				var localBoundSphere=new BoundSphere(new Vector3(center[0],center[1],center[2]),boundSphere.radius);
				render.localBoundSphere=localBoundSphere;
			}
		}
	}

	/**
	*@inheritDoc
	*/
	__proto._changeHierarchyAnimator=function(animator){
		if (animator){
			var render=this.skinnedMeshRender;
			render._setCacheAnimator(animator);
			var avatar=animator.avatar;
			(avatar)&& (render._setCacheAvatar(avatar));
		}
		laya.d3.core.Sprite3D.prototype._changeHierarchyAnimator.call(this,animator);
	}

	/**
	*@inheritDoc
	*/
	__proto._clearSelfRenderObjects=function(){
		this._scene.removeFrustumCullingObject(this._render);
	}

	/**
	*@inheritDoc
	*/
	__proto._addSelfRenderObjects=function(){
		this._scene.addFrustumCullingObject(this._render);
	}

	/**
	*@private
	*/
	__proto._applyMeshMaterials=function(mesh){
		var shaderMaterials=this._render.sharedMaterials;
		var meshMaterials=mesh.materials;
		for (var i=0,n=meshMaterials.length;i < n;i++)
		(shaderMaterials[i])|| (shaderMaterials[i]=meshMaterials[i]);
		this._render.sharedMaterials=shaderMaterials;
	}

	/**
	*@inheritDoc
	*/
	__proto.cloneTo=function(destObject){
		var meshSprite3D=destObject;
		(meshSprite3D._geometryFilter).sharedMesh=(this._geometryFilter).sharedMesh;
		var meshRender=this._render;
		var destMeshRender=meshSprite3D._render;
		destMeshRender.enable=meshRender.enable;
		destMeshRender.sharedMaterials=meshRender.sharedMaterials;
		destMeshRender.castShadow=meshRender.castShadow;
		var lightmapScaleOffset=meshRender.lightmapScaleOffset;
		lightmapScaleOffset && (destMeshRender.lightmapScaleOffset=lightmapScaleOffset.clone());
		destMeshRender.receiveShadow=meshRender.receiveShadow;
		destMeshRender.sortingFudge=meshRender.sortingFudge;
		destMeshRender._rootBone=meshRender._rootBone;
		var lbp=meshRender.localBoundSphere;
		(lbp)&& (destMeshRender.localBoundSphere=lbp.clone());
		var lbb=meshRender.localBoundBox;
		(lbb)&& (destMeshRender.localBoundBox=lbb.clone());
		destMeshRender._hasIndependentBound=meshRender._hasIndependentBound;
		laya.d3.core.Sprite3D.prototype.cloneTo.call(this,destObject);
	}

	/**
	*@inheritDoc
	*/
	__proto.destroy=function(destroyChild){
		(destroyChild===void 0)&& (destroyChild=true);
		if (this.destroyed)
			return;
		_super.prototype.destroy.call(this,destroyChild);
		(this._geometryFilter)._destroy();
	}

	/**
	*获取网格过滤器。
	*@return 网格过滤器。
	*/
	__getset(0,__proto,'meshFilter',function(){
		return this._geometryFilter;
	});

	/**
	*获取网格渲染器。
	*@return 网格渲染器。
	*/
	__getset(0,__proto,'skinnedMeshRender',function(){
		return this._render;
	});

	SkinnedMeshSprite3D.__init__=function(){
		SkinnedMeshSprite3D.SHADERDEFINE_BONE=SkinnedMeshSprite3D.shaderDefines.registerDefine("BONE");
	}

	SkinnedMeshSprite3D.load=function(url){
		return Laya.loader.create(url,null,null,SkinnedMeshSprite3D);
	}

	SkinnedMeshSprite3D.SHADERDEFINE_BONE=0x8;
	SkinnedMeshSprite3D.BONES=0;
	__static(SkinnedMeshSprite3D,
	['shaderDefines',function(){return this.shaderDefines=new ShaderDefines$1(RenderableSprite3D.shaderDefines);}
	]);
	return SkinnedMeshSprite3D;
})(RenderableSprite3D)


/**
*<code>Camera</code> 类用于创建VR摄像机。
*/
//class laya.d3.core.VRCamera extends laya.d3.core.BaseCamera
var VRCamera=(function(_super){
	function VRCamera(pupilDistande,leftAspectRatio,rightAspectRatio,nearPlane,farPlane){
		/**@private */
		//this._tempMatrix=null;
		/**@private 左横纵比。*/
		//this._leftAspectRatio=NaN;
		/**@private 在屏幕空间中摄像机的左视口。*/
		//this._leftViewport=null;
		/**@private 在裁剪空间中摄像机的视口。*/
		//this._leftNormalizedViewport=null;
		/**@private 左视图矩阵。*/
		//this._leftViewMatrix=null;
		/**@private 左投影矩阵。*/
		//this._leftProjectionMatrix=null;
		/**@private 左投影视图矩阵。*/
		//this._leftProjectionViewMatrix=null;
		/**@private 左横纵比。*/
		//this._rightAspectRatio=NaN;
		/**@private 在屏幕空间中摄像机的左视口。*/
		//this._rightViewport=null;
		/**@private 在裁剪空间中摄像机的视口。*/
		//this._rightNormalizedViewport=null;
		/**@private 左视图矩阵。*/
		//this._rightViewMatrix=null;
		/**@private 左投影矩阵。*/
		//this._rightProjectionMatrix=null;
		/**@private 左投影视图矩阵。*/
		//this._rightProjectionViewMatrix=null;
		/**@private 瞳距。*/
		//this._pupilDistande=0;
		/**@private */
		//this._leftBoundFrustumUpdate=false;
		/**@private */
		//this._rightBoundFrustumUpdate=false;
		/**@private */
		//this._leftBoundFrustum=null;
		/**@private */
		//this._rightBoundFrustum=null;
		(pupilDistande===void 0)&& (pupilDistande=0.1);
		(leftAspectRatio===void 0)&& (leftAspectRatio=0);
		(rightAspectRatio===void 0)&& (rightAspectRatio=0);
		(nearPlane===void 0)&& (nearPlane=0.3);
		(farPlane===void 0)&& (farPlane=1000);
		this._tempMatrix=new Matrix4x4();
		this._leftViewMatrix=new Matrix4x4();
		this._leftProjectionMatrix=new Matrix4x4();
		this._leftProjectionViewMatrix=new Matrix4x4();
		this._leftViewport=new Viewport(0,0,0,0);
		this._leftNormalizedViewport=new Viewport(0,0,0.5,1);
		this._leftAspectRatio=leftAspectRatio;
		this._rightViewMatrix=new Matrix4x4();
		this._rightProjectionMatrix=new Matrix4x4();
		this._rightProjectionViewMatrix=new Matrix4x4();
		this._rightViewport=new Viewport(0,0,0,0);
		this._rightNormalizedViewport=new Viewport(0.5,0,0.5,1);
		this._rightAspectRatio=rightAspectRatio;
		this._pupilDistande=pupilDistande;
		this._leftBoundFrustumUpdate=true;
		this._leftBoundFrustum=new BoundFrustum(Matrix4x4.DEFAULT);
		this._rightBoundFrustumUpdate=true;
		this._rightBoundFrustum=new BoundFrustum(Matrix4x4.DEFAULT);
		VRCamera.__super.call(this,nearPlane,farPlane);
		this.transform.on(/*laya.events.Event.WORLDMATRIX_NEEDCHANGE*/"worldmatrixneedchanged",this,this._onWorldMatrixChanged);
	}

	__class(VRCamera,'laya.d3.core.VRCamera',_super);
	var __proto=VRCamera.prototype;
	/**
	*@private
	*/
	__proto._onWorldMatrixChanged=function(){
		this._leftBoundFrustumUpdate=this._rightBoundFrustumUpdate=true;
	}

	/**
	*@private
	*计算瞳距。
	*/
	__proto._calculatePupilOffset=function(){
		var offset=this._tempVector3;
		Vector3.scale(this.right,this._pupilDistande / 2,offset);
		return offset.elements;
	}

	/**
	*@private
	*计算左投影矩阵。
	*/
	__proto._calculateLeftProjectionMatrix=function(){
		if (!this._useUserProjectionMatrix){
			if (this._orthographic){
				var leftHalfWidth=this.orthographicVerticalSize *this.leftAspectRatio *0.5;
				var leftHalfHeight=this.orthographicVerticalSize *0.5;
				Matrix4x4.createOrthoOffCenterRH(-leftHalfWidth,leftHalfWidth,-leftHalfHeight,leftHalfHeight,this.nearPlane,this.farPlane,this._leftProjectionMatrix);
				}else {
				Matrix4x4.createPerspective(3.1416 *this.fieldOfView / 180.0,this.leftAspectRatio,this.nearPlane,this.farPlane,this._rightProjectionMatrix);
			}
		}
		this._leftBoundFrustumUpdate=true;
	}

	/**
	*@private
	*计算右投影矩阵。
	*/
	__proto._calculateRightProjectionMatrix=function(){
		if (!this._useUserProjectionMatrix){
			if (this._orthographic){
				var rightHalfWidth=this.orthographicVerticalSize *this.rightAspectRatio *0.5;
				var rightHalfHeight=this.orthographicVerticalSize *0.5;
				Matrix4x4.createOrthoOffCenterRH(-rightHalfWidth,rightHalfWidth,rightHalfHeight,rightHalfHeight,this.nearPlane,this.farPlane,this._rightProjectionMatrix);
				}else {
				Matrix4x4.createPerspective(3.1416 *this.fieldOfView / 180.0,this.rightAspectRatio,this.nearPlane,this.farPlane,this._rightProjectionMatrix);
			}
		}
		this._rightBoundFrustumUpdate=true;
	}

	/**
	*@inheritDoc
	*/
	__proto._calculateProjectionMatrix=function(){
		if (!this._useUserProjectionMatrix){
			if (this._orthographic){
				var leftHalfWidth=this.orthographicVerticalSize *this.leftAspectRatio *0.5;
				var leftHalfHeight=this.orthographicVerticalSize *0.5;
				var rightHalfWidth=this.orthographicVerticalSize *this.rightAspectRatio *0.5;
				var rightHalfHeight=this.orthographicVerticalSize *0.5;
				Matrix4x4.createOrthoOffCenterRH(-leftHalfWidth,leftHalfWidth,-leftHalfHeight,leftHalfHeight,this.nearPlane,this.farPlane,this._leftProjectionMatrix);
				Matrix4x4.createOrthoOffCenterRH(-rightHalfWidth,rightHalfWidth,rightHalfHeight,rightHalfHeight,this.nearPlane,this.farPlane,this._rightProjectionMatrix);
				}else {
				Matrix4x4.createPerspective(3.1416 *this.fieldOfView / 180.0,this.leftAspectRatio,this.nearPlane,this.farPlane,this._leftProjectionMatrix);
				Matrix4x4.createPerspective(3.1416 *this.fieldOfView / 180.0,this.rightAspectRatio,this.nearPlane,this.farPlane,this._rightProjectionMatrix);
			}
		}
		this._leftBoundFrustumUpdate=this._rightBoundFrustumUpdate=true;
	}

	/**
	*@inheritDoc
	*/
	__proto._renderCamera=function(gl,state,scene){
		state.camera=this;
		this._prepareCameraToRender();
		scene._preRenderUpdateComponents(state);
		var leftViewMat,leftProjectMatrix;
		leftViewMat=state._viewMatrix=this.leftViewMatrix;
		var renderTar=this._renderTarget;
		if (renderTar){
			renderTar.start();
			Matrix4x4.multiply(BaseCamera._invertYScaleMatrix,this._leftProjectionMatrix,BaseCamera._invertYProjectionMatrix);
			Matrix4x4.multiply(BaseCamera._invertYScaleMatrix,this.leftProjectionViewMatrix,BaseCamera._invertYProjectionViewMatrix);
			leftProjectMatrix=state._projectionMatrix=BaseCamera._invertYProjectionMatrix;
			state._projectionViewMatrix=BaseCamera._invertYProjectionViewMatrix;
			}else {
			leftProjectMatrix=state._projectionMatrix=this._leftProjectionMatrix;
			state._projectionViewMatrix=this.leftProjectionViewMatrix;
		}
		this._prepareCameraViewProject(leftViewMat,leftProjectMatrix);
		state._viewport=this.leftViewport;
		scene._preRenderScene(gl,state,this.leftBoundFrustum);
		scene._clear(gl,state);
		scene._renderScene(gl,state);
		var rightViewMat,rightProjectMatrix;
		rightViewMat=state._viewMatrix=this.rightViewMatrix;
		if (renderTar){
			renderTar.start();
			Matrix4x4.multiply(BaseCamera._invertYScaleMatrix,this._rightProjectionMatrix,BaseCamera._invertYProjectionMatrix);
			Matrix4x4.multiply(BaseCamera._invertYScaleMatrix,this.rightProjectionViewMatrix,BaseCamera._invertYProjectionViewMatrix);
			state._projectionMatrix=BaseCamera._invertYProjectionMatrix;
			rightProjectMatrix=state._projectionViewMatrix=BaseCamera._invertYProjectionViewMatrix;
			}else {
			rightProjectMatrix=state._projectionMatrix=this._rightProjectionMatrix;
			state._projectionViewMatrix=this.rightProjectionViewMatrix;
		}
		this._prepareCameraViewProject(rightViewMat,rightProjectMatrix);
		state._viewport=this.rightViewport;
		scene._preRenderScene(gl,state,this.rightBoundFrustum);
		scene._clear(gl,state);
		scene._renderScene(gl,state);
		scene._postRenderUpdateComponents(state);
		(renderTar)&& (renderTar.end());
	}

	/**
	*获取摄像机右视锥。
	*/
	__getset(0,__proto,'rightBoundFrustum',function(){
		if (this._rightBoundFrustumUpdate)
			this._rightBoundFrustum.matrix=this.rightProjectionViewMatrix;
		return this._rightBoundFrustum;
	});

	/**
	*获取裁剪空间的左视口。
	*@return 裁剪空间的左视口。
	*/
	__getset(0,__proto,'leftNormalizedViewport',function(){
		if (!this._viewportExpressedInClipSpace){
			var vp=this._leftViewport;
			var size=this.renderTargetSize;
			var sizeW=size.width;
			var sizeH=size.height;
			this._leftNormalizedViewport.x=vp.x / sizeW;
			this._leftNormalizedViewport.y=vp.y / sizeH;
			this._leftNormalizedViewport.width=vp.width / sizeW;
			this._leftNormalizedViewport.height=vp.height / sizeH;
		}
		return this._leftNormalizedViewport;
	});

	/**
	*获取屏幕空间的右视口。
	*@return 屏幕空间的右视口。
	*/
	__getset(0,__proto,'rightViewport',function(){
		if (this._viewportExpressedInClipSpace){
			var nVp=this._rightNormalizedViewport;
			var size=this.renderTargetSize;
			var sizeW=size.width;
			var sizeH=size.height;
			this._rightViewport.x=nVp.x *sizeW;
			this._rightViewport.y=nVp.y *sizeH;
			this._rightViewport.width=nVp.width *sizeW;
			this._rightViewport.height=nVp.height *sizeH;
		}
		return this._rightViewport;
	});

	/**
	*设置屏幕空间的视口。
	*@param 屏幕空间的视口。
	*/
	__getset(0,__proto,'viewport',null,function(value){
		if (this.renderTarget !=null && (value.x < 0 || value.y < 0 || value.width==0 || value.height==0))
			throw new Error("VRCamera: viewport size invalid.","value");
		this._viewportExpressedInClipSpace=false;
		this._leftViewport=new Viewport(0,0,value.width / 2,value.height);
		this._rightViewport=new Viewport(value.width / 2,0,value.width / 2,value.height);
		this._calculateProjectionMatrix();
	});

	/**
	*获取左横纵比。
	*@return 左横纵比。
	*/
	__getset(0,__proto,'leftAspectRatio',function(){
		if (this._leftAspectRatio===0){
			var lVp=this.leftViewport;
			return lVp.width / lVp.height;
		}
		return this._leftAspectRatio;
	});

	/**
	*获取右横纵比。
	*@return 右横纵比。
	*/
	__getset(0,__proto,'rightAspectRatio',function(){
		if (this._rightAspectRatio===0){
			var rVp=this.rightViewport;
			return rVp.width / rVp.height;
		}
		return this._rightAspectRatio;
	});

	/**
	*设置横纵比。
	*@param value 横纵比。
	*/
	__getset(0,__proto,'aspectRatio',null,function(value){
		if (value < 0)
			throw new Error("VRCamera: the aspect ratio has to be a positive real number.");
		this._leftAspectRatio=value;
		this._rightAspectRatio=value;
		this._calculateRightProjectionMatrix();
	});

	/**
	*获取裁剪空间的右视口。
	*@return 裁剪空间的右视口。
	*/
	__getset(0,__proto,'rightNormalizedViewport',function(){
		if (!this._viewportExpressedInClipSpace){
			var vp=this._rightViewport;
			var size=this.renderTargetSize;
			var sizeW=size.width;
			var sizeH=size.height;
			this._rightNormalizedViewport.x=vp.x / sizeW;
			this._rightNormalizedViewport.y=vp.y / sizeH;
			this._rightNormalizedViewport.width=vp.width / sizeW;
			this._rightNormalizedViewport.height=vp.height / sizeH;
		}
		return this._rightNormalizedViewport;
	});

	/**
	*设置裁剪空间的视口。
	*@return 裁剪空间的视口。
	*/
	__getset(0,__proto,'normalizedViewport',null,function(value){
		if (value.x < 0 || value.y < 0 || (value.x+value.width)> 1 || (value.x+value.height)> 1)
			throw new Error("VRCamera: viewport size invalid.","value");
		this._viewportExpressedInClipSpace=true;
		this._leftNormalizedViewport=new Viewport(0,0,value.width / 2,value.height);
		this._rightNormalizedViewport=new Viewport(value.width / 2,0,value.width / 2,value.height);
		this._calculateProjectionMatrix();
	});

	/**
	*获取屏幕空间的左视口。
	*@return 屏幕空间的左视口。
	*/
	__getset(0,__proto,'leftViewport',function(){
		if (this._viewportExpressedInClipSpace){
			var nVp=this._leftNormalizedViewport;
			var size=this.renderTargetSize;
			var sizeW=size.width;
			var sizeH=size.height;
			this._leftViewport.x=nVp.x *sizeW;
			this._leftViewport.y=nVp.y *sizeH;
			this._leftViewport.width=nVp.width *sizeW;
			this._leftViewport.height=nVp.height *sizeH;
		}
		return this._leftViewport;
	});

	__getset(0,__proto,'needLeftViewport',function(){
		var nVp=this.leftNormalizedViewport;
		return nVp.x===0 && nVp.y===0 && nVp.width===1 && nVp.height===1;
	});

	__getset(0,__proto,'needRightViewport',function(){
		var nVp=this.rightNormalizedViewport;
		return nVp.x===0 && nVp.y===0 && nVp.width===1 && nVp.height===1;
	});

	/**
	*获取左视图矩阵。
	*@return 左视图矩阵。
	*/
	__getset(0,__proto,'leftViewMatrix',function(){
		var offsetE=this._calculatePupilOffset();
		var tempWorldMat=this._tempMatrix;
		this.transform.worldMatrix.cloneTo(tempWorldMat);
		var worldMatE=tempWorldMat.elements;
		worldMatE[12]-=offsetE[0];
		worldMatE[13]-=offsetE[1];
		worldMatE[14]-=offsetE[2];
		tempWorldMat.invert(this._leftViewMatrix);
		return this._leftViewMatrix;
	});

	/**
	*获取右视图矩阵。
	*@return 右视图矩阵。
	*/
	__getset(0,__proto,'rightViewMatrix',function(){
		var offsetE=this._calculatePupilOffset();
		var tempWorldMat=this._tempMatrix;
		this.transform.worldMatrix.cloneTo(tempWorldMat);
		var worldMatE=tempWorldMat.elements;
		worldMatE[12]+=offsetE[0];
		worldMatE[13]+=offsetE[1];
		worldMatE[14]+=offsetE[2];
		tempWorldMat.invert(this._rightViewMatrix);
		return this._rightViewMatrix;
	});

	/**
	*获取左投影矩阵。
	*@return 左投影矩阵。
	*/
	__getset(0,__proto,'leftProjectionMatrix',function(){
		return this._leftProjectionMatrix;
	});

	/**
	*获取左投影视图矩阵。
	*@return 左投影视图矩阵。
	*/
	__getset(0,__proto,'leftProjectionViewMatrix',function(){
		Matrix4x4.multiply(this.leftProjectionMatrix,this.leftViewMatrix,this._leftProjectionViewMatrix);
		return this._leftProjectionViewMatrix;
	});

	/**
	*获取右投影矩阵。
	*@return 右投影矩阵。
	*/
	__getset(0,__proto,'rightProjectionMatrix',function(){
		return this._rightProjectionMatrix;
	});

	/**
	*获取右投影视图矩阵。
	*@return 右投影视图矩阵。
	*/
	__getset(0,__proto,'rightProjectionViewMatrix',function(){
		Matrix4x4.multiply(this.rightProjectionMatrix,this.rightViewMatrix,this._rightProjectionViewMatrix);
		return this._rightProjectionViewMatrix;
	});

	/**
	*获取摄像机左视锥。
	*/
	__getset(0,__proto,'leftBoundFrustum',function(){
		if (this._leftBoundFrustumUpdate)
			this._leftBoundFrustum.matrix=this.leftProjectionViewMatrix;
		return this._leftBoundFrustum;
	});

	return VRCamera;
})(BaseCamera)


/**
*...
*@author ...
*/
//class laya.d3.core.trail.TrailSprite3D extends laya.d3.core.RenderableSprite3D
var TrailSprite3D=(function(_super){
	function TrailSprite3D(){
		TrailSprite3D.__super.call(this);
		this._geometryFilter=new TrailFilter(this);
		this._render=new TrailRenderer(this);
		this._changeRenderObjectsByMaterial(this._render,0,TrailMaterial.defaultMaterial);
		this._render.on(/*laya.events.Event.MATERIAL_CHANGED*/"materialchanged",this,this._changeRenderObjectsByMaterial);
		this._geometryFilter.on(/*laya.events.Event.TRAIL_FILTER_CHANGE*/"trailfilterchange",this,this._changeRenderObjectsByRenderElement);
	}

	__class(TrailSprite3D,'laya.d3.core.trail.TrailSprite3D',_super);
	var __proto=TrailSprite3D.prototype;
	__proto._changeRenderObjectsByMaterial=function(sender,index,material){
		var renderElementsCount=(this._geometryFilter).getRenderElementsCount();
		this._render._renderElements.length=renderElementsCount;
		for (var i=0;i < renderElementsCount;i++){
			this._changeRenderObjectByMaterial(i,material);
		}
	}

	__proto._changeRenderObjectByMaterial=function(index,material){
		var renderObjects=this._render._renderElements;
		(material)|| (material=TrailMaterial.defaultMaterial);
		var renderElement=renderObjects[index];
		(renderElement)|| (renderElement=renderObjects[index]=new RenderElement());
		renderElement._sprite3D=this;
		renderElement.renderObj=(this._geometryFilter).getRenderElement(index);
		renderElement._render=this._render;
		renderElement._material=material;
	}

	__proto._changeRenderObjectsByRenderElement=function(index,trailRenderElement){
		var renderObjects=this._render._renderElements;
		var renderElement=renderObjects[index];
		(renderElement)|| (renderElement=renderObjects[index]=new RenderElement());
		renderElement._sprite3D=this;
		renderElement.renderObj=trailRenderElement;
		renderElement._render=this._render;
		renderElement._material=this._render.sharedMaterial;
	}

	/**@private */
	__proto._clearSelfRenderObjects=function(){
		this.scene.removeFrustumCullingObject(this._render);
	}

	/**@private */
	__proto._addSelfRenderObjects=function(){
		this.scene.addFrustumCullingObject(this._render);
	}

	__proto._update=function(state){
		_super.prototype._update.call(this,state);
		(this._geometryFilter)._update(state);
	}

	/**
	*@inheritDoc
	*/
	__proto._parseCustomProps=function(rootNode,innerResouMap,customProps,json){
		var render=this._render;
		var filter=this._geometryFilter;
		var i=0,j=0;
		var materials=customProps.materials;
		if (materials){
			var sharedMaterials=render.sharedMaterials;
			var materialCount=materials.length;
			sharedMaterials.length=materialCount;
			for (i=0;i < materialCount;i++)
			sharedMaterials[i]=Loader.getRes(innerResouMap[materials[i].path]);
			render.sharedMaterials=sharedMaterials;
		};
		var props=json.props;
		filter.time=props.time;
		filter.minVertexDistance=props.minVertexDistance;
		filter.widthMultiplier=props.widthMultiplier;
		filter.textureMode=props.textureMode;
		var _widthCurve=[];
		var widthCurve=customProps.widthCurve;
		for (i=0,j=widthCurve.length;i < j;i++){
			var trailkeyframe=new TrailKeyFrame();
			trailkeyframe.time=widthCurve[i].time;
			trailkeyframe.inTangent=widthCurve[i].inTangent;
			trailkeyframe.outTangent=widthCurve[i].outTangent;
			trailkeyframe.value=widthCurve[i].value;
			_widthCurve.push(trailkeyframe);
		}
		filter.widthCurve=_widthCurve;
		var colorGradientNode=customProps.colorGradient;
		var _colorGradient=new Gradient();
		_colorGradient.mode=colorGradientNode.mode;
		var colorKeys=[];
		var colorKey;
		var _colorKeys=colorGradientNode.colorKeys;
		var _colorKey;
		for (i=0,j=_colorKeys.length;i < j;i++){
			_colorKey=_colorKeys[i];
			colorKey=new GradientColorKey(new Color$1(_colorKey.value[0],_colorKey.value[1],_colorKey.value[2],1.0),_colorKey.time);
			colorKeys.push(colorKey);
		};
		var alphaKeys=[];
		var alphaKey;
		var _alphaKeys=colorGradientNode.alphaKeys;
		var _alphaKey;
		for (i=0,j=_alphaKeys.length;i < j;i++){
			_alphaKey=_alphaKeys[i];
			alphaKey=new GradientAlphaKey(_alphaKey.value,_alphaKey.time);
			alphaKeys.push(alphaKey);
		}
		_colorGradient.setKeys(colorKeys,alphaKeys);
		filter.colorGradient=_colorGradient;
	}

	__proto.reset=function(){
		this.trailFilter.reset();
	}

	/**
	*@inheritDoc
	*/
	__proto.cloneTo=function(destObject){
		laya.d3.core.Sprite3D.prototype.cloneTo.call(this,destObject);
		var i=0,j=0;
		var _trailSprite3D=destObject;
		var _trailFilter=_trailSprite3D.trailFilter;
		_trailFilter.time=this.trailFilter.time;
		_trailFilter.minVertexDistance=this.trailFilter.minVertexDistance;
		_trailFilter.widthMultiplier=this.trailFilter.widthMultiplier;
		var widthCurve=this.trailFilter.widthCurve;
		var _widthCurve=[];
		for (i=0,j=widthCurve.length;i < j;i++){
			var _keyFrame=new TrailKeyFrame();
			widthCurve[i].cloneTo(_keyFrame);
			_widthCurve.push(_keyFrame);
		}
		_trailFilter.widthCurve=_widthCurve;
		var _colorGradient=new Gradient();
		this.trailFilter.colorGradient.cloneTo(_colorGradient);
		_trailFilter.colorGradient=_colorGradient;
		_trailFilter.textureMode=this.trailFilter.textureMode;
		var _trailRender=_trailSprite3D.trailRender;
		_trailRender.sharedMaterial=this.trailRender.sharedMaterial;
	}

	/**
	*<p>销毁此对象。</p>
	*@param destroyChild 是否同时销毁子节点，若值为true,则销毁子节点，否则不销毁子节点。
	*/
	__proto.destroy=function(destroyChild){
		(destroyChild===void 0)&& (destroyChild=true);
		if (this.destroyed)
			return;
		_super.prototype.destroy.call(this,destroyChild);
		(this._geometryFilter)._destroy();
		this._geometryFilter=null;
	}

	/**
	*获取Trail过滤器。
	*@return Trail过滤器。
	*/
	__getset(0,__proto,'trailFilter',function(){
		return this._geometryFilter;
	});

	/**
	*获取Trail渲染器。
	*@return Trail渲染器。
	*/
	__getset(0,__proto,'trailRender',function(){
		return this._render;
	});

	TrailSprite3D.__init__=function(){
		TrailSprite3D.SHADERDEFINE_GRADIENTMODE_BLEND=TrailSprite3D.shaderDefines.registerDefine("GRADIENTMODE_BLEND");
	}

	TrailSprite3D.CURTIME=3;
	TrailSprite3D.LIFETIME=4;
	TrailSprite3D.WIDTHCURVE=5;
	TrailSprite3D.WIDTHCURVEKEYLENGTH=6;
	TrailSprite3D.GRADIENTCOLORKEY=7;
	TrailSprite3D.GRADIENTALPHAKEY=8;
	TrailSprite3D.SHADERDEFINE_GRADIENTMODE_BLEND=0;
	__static(TrailSprite3D,
	['shaderDefines',function(){return this.shaderDefines=new ShaderDefines$1(RenderableSprite3D.shaderDefines);}
	]);
	return TrailSprite3D;
})(RenderableSprite3D)


/**
*<code>TerrainChunk</code> 类用于创建地块。
*/
//class laya.d3.terrain.TerrainChunk extends laya.d3.core.RenderableSprite3D
var TerrainChunk=(function(_super){
	/**
	*创建一个 <code>MeshSprite3D</code> 实例。
	*@param mesh 网格,同时会加载网格所用默认材质。
	*@param name 名字。
	*/
	function TerrainChunk(chunkOffsetX,chunkOffsetZ,girdSize,terrainHeightData,heightDataWidth,heightDataHeight,cameraCoordinateInverse,name){
		TerrainChunk.__super.call(this,name);
		this._geometryFilter=new TerrainFilter(this,chunkOffsetX,chunkOffsetZ,girdSize,terrainHeightData,heightDataWidth,heightDataHeight,cameraCoordinateInverse);
		this._render=new TerrainRender(this);
	}

	__class(TerrainChunk,'laya.d3.terrain.TerrainChunk',_super);
	var __proto=TerrainChunk.prototype;
	__proto.buildRenderElementAndMaterial=function(detailNum,normalMap,alphaMapUrl,detailUrl1,detailUrl2,detailUrl3,detailUrl4,ambientColor,diffuseColor,specularColor,sx1,sy1,sx2,sy2,sx3,sy3,sx4,sy4){
		(sx1===void 0)&& (sx1=1);
		(sy1===void 0)&& (sy1=1);
		(sx2===void 0)&& (sx2=1);
		(sy2===void 0)&& (sy2=1);
		(sx3===void 0)&& (sx3=1);
		(sy3===void 0)&& (sy3=1);
		(sx4===void 0)&& (sx4=1);
		(sy4===void 0)&& (sy4=1);
		var terrainMaterial=new TerrainMaterial();
		if (diffuseColor)terrainMaterial.diffuseColor=diffuseColor;
		if (ambientColor)terrainMaterial.ambientColor=ambientColor;
		if (specularColor)terrainMaterial.specularColor=specularColor;
		terrainMaterial.splatAlphaTexture=Loader.getRes(alphaMapUrl);
		terrainMaterial.normalTexture=normalMap ? Loader.getRes(normalMap):null;
		terrainMaterial.diffuseTexture1=detailUrl1 ? Loader.getRes(detailUrl1):null;
		terrainMaterial.diffuseTexture2=detailUrl2 ? Loader.getRes(detailUrl2):null;
		terrainMaterial.diffuseTexture3=detailUrl3 ? Loader.getRes(detailUrl3):null;
		terrainMaterial.diffuseTexture4=detailUrl4 ? Loader.getRes(detailUrl4):null;
		terrainMaterial.setDiffuseScale1(sx1,sy1);
		terrainMaterial.setDiffuseScale2(sx2,sy2);
		terrainMaterial.setDiffuseScale3(sx3,sy3);
		terrainMaterial.setDiffuseScale4(sx4,sy4);
		terrainMaterial.setDetailNum(detailNum);
		if (this._render._renderElements.length !=0){
			terrainMaterial.renderMode=/*laya.d3.core.material.TerrainMaterial.RENDERMODE_TRANSPARENT*/2;
		};
		var renderElement=new RenderElement();
		renderElement._mainSortID=0;
		renderElement._sprite3D=this;
		renderElement.renderObj=this._geometryFilter;
		renderElement._material=terrainMaterial;
		this._render._materials.push(terrainMaterial);
		this._render._renderElements.push(renderElement);
	}

	/**
	*@private
	*/
	__proto._clearSelfRenderObjects=function(){
		this.scene.removeFrustumCullingObject(this._render);
	}

	/**
	*@private
	*/
	__proto._addSelfRenderObjects=function(){
		this.scene.addFrustumCullingObject(this._render);
	}

	/**
	*@private
	*/
	__proto._applyMeshMaterials=function(mesh){
		var shaderMaterials=this._render.sharedMaterials;
		var meshMaterials=mesh.materials;
		for (var i=0,n=meshMaterials.length;i < n;i++)
		(shaderMaterials[i])|| (shaderMaterials[i]=meshMaterials[i]);
		this._render.sharedMaterials=shaderMaterials;
	}

	__proto.cloneTo=function(destObject){
		console.log("Terrain Chunk can't clone");
	}

	__proto.destroy=function(destroyChild){
		(destroyChild===void 0)&& (destroyChild=true);
		if (this.destroyed)
			return;
		_super.prototype.destroy.call(this,destroyChild);
		(this._geometryFilter)._destroy();
	}

	/**
	*获取地形过滤器。
	*@return 地形过滤器。
	*/
	__getset(0,__proto,'terrainFilter',function(){
		return this._geometryFilter;
	});

	/**
	*获取地形渲染器。
	*@return 地形渲染器。
	*/
	__getset(0,__proto,'terrainRender',function(){
		return this._render;
	});

	TerrainChunk.load=function(url){
		return Laya.loader.create(url,null,null,TerrainChunk,null,1,false);
	}

	return TerrainChunk;
})(RenderableSprite3D)


/**
*<code>TerrainMeshSprite3D</code> 类用于创建网格。
*/
//class laya.d3.core.MeshTerrainSprite3D extends laya.d3.core.MeshSprite3D
var MeshTerrainSprite3D=(function(_super){
	function MeshTerrainSprite3D(mesh,heightMap,name){
		/**@private */
		this._minX=NaN;
		/**@private */
		this._minZ=NaN;
		/**@private */
		this._cellSize=null;
		/**@private */
		this._heightMap=null;
		MeshTerrainSprite3D.__super.call(this,mesh,name);
		this._heightMap=heightMap;
		this._cellSize=new Vector2();
	}

	__class(MeshTerrainSprite3D,'laya.d3.core.MeshTerrainSprite3D',_super);
	var __proto=MeshTerrainSprite3D.prototype;
	/**
	*@private
	*/
	__proto._disableRotation=function(){
		var rotation=this.transform.rotation;
		rotation.elements[0]=0;
		rotation.elements[1]=0;
		rotation.elements[2]=0;
		rotation.elements[3]=1;
		this.transform.rotation=rotation;
	}

	/**
	*@private
	*/
	__proto._getScaleX=function(){
		var worldMat=this.transform.worldMatrix;
		var worldMatE=worldMat.elements;
		var m11=worldMatE[0];
		var m12=worldMatE[1];
		var m13=worldMatE[2];
		return Math.sqrt((m11 *m11)+(m12 *m12)+(m13 *m13));
	}

	/**
	*@private
	*/
	__proto._getScaleZ=function(){
		var worldMat=this.transform.worldMatrix;
		var worldMatE=worldMat.elements;
		var m31=worldMatE[8];
		var m32=worldMatE[9];
		var m33=worldMatE[10];
		return Math.sqrt((m31 *m31)+(m32 *m32)+(m33 *m33));
	}

	/**
	*@private
	*/
	__proto._initCreateFromMesh=function(heightMapWidth,heightMapHeight){
		this._heightMap=HeightMap.creatFromMesh(this.meshFilter.sharedMesh,heightMapWidth,heightMapHeight,this._cellSize);
		var boundingBox=this.meshFilter.sharedMesh.boundingBox;
		var min=boundingBox.min;
		var max=boundingBox.max;
		this._minX=min.x;
		this._minZ=min.z;
	}

	/**
	*@private
	*/
	__proto._initCreateFromMeshHeightMap=function(texture,minHeight,maxHeight){
		var _$this=this;
		var boundingBox=this.meshFilter.sharedMesh.boundingBox;
		if (texture.loaded){
			this._heightMap=HeightMap.createFromImage(texture,minHeight,maxHeight);
			this._computeCellSize(boundingBox);
			}else {
			texture.once(/*laya.events.Event.LOADED*/"loaded",null,function(){
				_$this._heightMap=HeightMap.createFromImage(texture,minHeight,maxHeight);
				_$this._computeCellSize(boundingBox);
			});
		};
		var min=boundingBox.min;
		var max=boundingBox.max;
		this._minX=min.x;
		this._minZ=min.z;
	}

	/**
	*@private
	*/
	__proto._computeCellSize=function(boundingBox){
		var min=boundingBox.min;
		var max=boundingBox.max;
		var minX=min.x;
		var minZ=min.z;
		var maxX=max.x;
		var maxZ=max.z;
		var widthSize=maxX-minX;
		var heightSize=maxZ-minZ;
		this._cellSize.elements[0]=widthSize / (this._heightMap.width-1);
		this._cellSize.elements[1]=heightSize / (this._heightMap.height-1);
	}

	/**
	*@private
	*/
	__proto._update=function(state){
		this._disableRotation();
		laya.d3.core.RenderableSprite3D.prototype._update.call(this,state);
	}

	/**
	*获取地形高度。
	*@param x X轴坐标。
	*@param z Z轴坐标。
	*/
	__proto.getHeight=function(x,z){
		MeshTerrainSprite3D._tempVector3.elements[0]=x;
		MeshTerrainSprite3D._tempVector3.elements[1]=0;
		MeshTerrainSprite3D._tempVector3.elements[2]=z;
		this._disableRotation();
		var worldMat=this.transform.worldMatrix;
		worldMat.invert(MeshTerrainSprite3D._tempMatrix4x4);
		Vector3.transformCoordinate(MeshTerrainSprite3D._tempVector3,MeshTerrainSprite3D._tempMatrix4x4,MeshTerrainSprite3D._tempVector3);
		x=MeshTerrainSprite3D._tempVector3.elements[0];
		z=MeshTerrainSprite3D._tempVector3.elements[2];
		var c=(x-this._minX)/ this._cellSize.x;
		var d=(z-this._minZ)/ this._cellSize.y;
		var row=Math.floor(d);
		var col=Math.floor(c);
		var s=c-col;
		var t=d-row;
		var uy=NaN;
		var vy=NaN;
		var worldMatE=worldMat.elements;
		var m21=worldMatE[4];
		var m22=worldMatE[5];
		var m23=worldMatE[6];
		var scaleY=Math.sqrt((m21 *m21)+(m22 *m22)+(m23 *m23));
		var translateY=worldMatE[13];
		var h01=this._heightMap.getHeight(row,col+1);
		var h10=this._heightMap.getHeight((row+1),col);
		if (isNaN(h01)|| isNaN(h10))
			return NaN;
		if (s+t <=1.0){
			var h00=this._heightMap.getHeight(row,col);
			if (isNaN(h00))
				return NaN;
			uy=h01-h00;
			vy=h10-h00;
			return (h00+s *uy+t *vy)*scaleY+translateY;
			}else {
			var h11=this._heightMap.getHeight((row+1),col+1);
			if (isNaN(h11))
				return NaN;
			uy=h10-h11;
			vy=h01-h11;
			return (h11+(1.0-s)*uy+(1.0-t)*vy)*scaleY+translateY;
		}
	}

	/**
	*获取地形X轴最小位置。
	*@return 地形X轴最小位置。
	*/
	__getset(0,__proto,'minX',function(){
		var worldMat=this.transform.worldMatrix;
		var worldMatE=worldMat.elements;
		return this._minX *this._getScaleX()+worldMatE[12];
	});

	/**
	*获取地形X轴长度。
	*@return 地形X轴长度。
	*/
	__getset(0,__proto,'width',function(){
		return (this._heightMap.width-1)*this._cellSize.x *this._getScaleX();
	});

	/**
	*获取地形Z轴最小位置。
	*@return 地形X轴最小位置。
	*/
	__getset(0,__proto,'minZ',function(){
		var worldMat=this.transform.worldMatrix;
		var worldMatE=worldMat.elements;
		return this._minZ *this._getScaleZ()+worldMatE[14];
	});

	/**
	*获取地形Z轴长度。
	*@return 地形Z轴长度。
	*/
	__getset(0,__proto,'depth',function(){
		return (this._heightMap.height-1)*this._cellSize.y *this._getScaleZ();
	});

	MeshTerrainSprite3D.createFromMesh=function(mesh,heightMapWidth,heightMapHeight,name){
		var meshTerrainSprite3D=new MeshTerrainSprite3D(mesh,null,name);
		if (mesh.loaded)
			meshTerrainSprite3D._initCreateFromMesh(heightMapWidth,heightMapHeight);
		else
		mesh.once(/*laya.events.Event.LOADED*/"loaded",meshTerrainSprite3D,meshTerrainSprite3D._initCreateFromMesh,[heightMapWidth,heightMapHeight]);
		return meshTerrainSprite3D;
	}

	MeshTerrainSprite3D.createFromMeshAndHeightMap=function(mesh,texture,minHeight,maxHeight,name){
		var meshTerrainSprite3D=new MeshTerrainSprite3D(mesh,null,name);
		if (mesh.loaded)
			meshTerrainSprite3D._initCreateFromMeshHeightMap(texture,minHeight,maxHeight);
		else
		mesh.once(/*laya.events.Event.LOADED*/"loaded",meshTerrainSprite3D,meshTerrainSprite3D._initCreateFromMeshHeightMap,[texture,minHeight,maxHeight]);
		return meshTerrainSprite3D;
	}

	__static(MeshTerrainSprite3D,
	['_tempVector3',function(){return this._tempVector3=new Vector3();},'_tempMatrix4x4',function(){return this._tempMatrix4x4=new Matrix4x4();}
	]);
	return MeshTerrainSprite3D;
})(MeshSprite3D)



})(window,document,Laya);

if (typeof define === 'function' && define.amd){
	define('laya.core', ['require', "exports"], function(require, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        for (var i in Laya) {
			var o = Laya[i];
            o && o.__isclass && (exports[i] = o);
        }
    });
}
var yftools;
(function (yftools) {
    var defImg = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADQAAAA0CAYAAADFeBvrAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAACGqSURBVGhDjXoHVFR3t/3A9D4wtKFJtZeoqLF3jV1jjImmaL5EjcYYNWpij73GEo3EEjs27CKKJajYC4qoKB0EpEsZ6ty7357Rb733/uu9/3p3rbtmKDP89jn77L0PIPn/XM7tvRrsaGJwLfWVKoSu3j5CJy+LMLxFY+H7Tu2EL7p0EkK0WmF0WFuhmdEkzBveV2jo4iqE+foIJmeF4Gs0CI34scWoF7RSqdDUwyyo+djI7Co00OqEFmazMLhhkBCs0Qq9mrYQxnXvLmz4dqxwZtMS4ebecGHWVyOEFQqtcD+uv1AU6iFYO3oLVR383xYN7bTvwYQJ8vdn/L9dPX2DY9p5+2NAcAjau3pgTNv2GPVBC2z8+hOcWzwD03p1wZqxn2D1mKHYNuFzbJ/+HUaFtcGHfj74qFlD9GkaiiHNGmFYq4b4tkd7BOp06NcwAEF6A9r6WtDOxxP9QvzweesmWDK8O5YM7oGRbZri845tkZdwG3UVpYj8dgx2L1qAgyOH4ISzE67LnHBb4YwEP1eUtvRESrDrtffH/d+vKm9vv8pgd6GNTwBGNGmEkQTUw+KLX/r1wvPIrbi/fQWurJ6F7CN/4N7muYheNQNP969FzNIZWPvlUGyf+CmO/TIBFxdNxYoR3bBl3GD8/vVgbPhiMMa0a4EwLy+Eubujf2ADfNWqESa2b4ElQ7rh6JTRuDhjPHZ/Mwp/z/oe1eVlqC/PxldSKX4b/TmOjByACLUCp6VOiCOo+3oVtht02DumhVg0sHWT98f/79dOs9k73eyKPkYz/DQGjGndgofqjQOTxyHvfDhKLu5Ebf5ziK/voe71fZxeMBlVd46gMv4siv/Zj9r4C8g7ugZC5mW8PROOwui/kH5sDdIi1iHn3Das/mww+rZsig4Bfvh1UC/09vfGyqE9sG10f5z7+Su8+H0GCnYvR86BVci4egivHtzFlq7tcKizFzZ/9TVmazVYpdBhq1yOYwRWObQrqnEF+Y08URg3q9F7GP953erQSZBKnBGsN6GJuxtGNm+E9Z8NRMycz1ARfwLWnPsQylJQk/8IB8YMh1CVDbEii5XMhC33LsSyDNjKkiEUPINYX4j0iBUQS5Mg5D6EUFuBrRPHIMjVFWGNQ/BhaAPM+2wQjs+fjNvLfkRa+Hyk/r0YFTciUMWClCfFIHH/evyzbQPWtvkACyUSxJ7ci5ove8E2dTjCScGTOg2SD7sja6EF1twl4nsY766S57GR+7fvgYvWAC+9DgEmA1qykgNY0YL7p1D0LAb1WTfx9v5ZXP9jIWxv4iGUZ8FWlYWKuMNAfTHEkheoTb3OLj7Fw0N/QizPA/g5W/YtlD67hh8Gd8dfMydBLVfAqNTiO3Zn6uA+qMp7ipq0S3zvo8g9tg5VWbdQk34FJXGRyI49gTvhK1A7cQTWuZmxiN1Bz8aIcJYiRuaM0656bAxWICl6Mba2s1x5D0ciOfD9D1hJTg4wmjCUj9c8XFDva4LV0wiriwZCkDsyerTFy5vH8GDpVFQmxEAoScOrrfMhWgvxfNcqPAj/DU8iNuDWwilIvXIYr45uwolZE5B2eAO+6xQGfxapJvMOjiybB6NKA5NWjWGd2+DIgmkQ3z6DlSAKb+9HfuweVGfEoPRFNCrTLiDh4gncO7QHa5wkuDRxLM77GPFI7ozjrips7dwOWfG/4nif1ng1KQQOML80Cf15l4crXnm7IfXycUT7+mCmwQA/hQErRg3EiUmfYmuLxki0uKGY3/P04EZcmf8jRWEhXl87jGenIjA0NBA/D+uLTaMHY9wHjRG3/CcMpwh817szRrVrja97d8HEIX1IyzzStBD3I3Yg1OIDN6pf2wb+iGXX38TuQ1rkOiTvWYoX7FTx42MoS4qGNesuJvfuiUNzpuPIvNlYze7sdJYhY1YoxKoWKHoZjspLHZB/sC/ODwv4QxLp7V5wzNcLCSeOAKKI2ppq7NMZcd3diGy1FIKHBp/4eKN3y+ao9HfBr/17Yd/P32LRgG6IXfYrunq5w66KHf390L2BNyb0aovGPGwTiwWN3V1g1mjh72pG2tltBFMGlBfxIOXo1ao5mnhZEOLhjo7Bftg7bxIurJiCZzsW4unh1bi0YTbqEk7j+ckt+H3GJJxYNAcbxg3DVCrffjc9rGP6YrNJyvf7E8ctKlg7BaKunVeJ5LLBYN1jMKI3D5B7KBxb+/WDQaZFa4snNnw5HF9QHOoJxMvNBceogocCfTC1ZzfMHzEAYd4WmBQqaJUKtPH1RViQH4J5QDOpq1erEOhpwYchDaEi94WHURAqSxyAUF7sKJ63qwsC3NzRjq8b9EFzRM4Zh0Uje+MGwWz7djju/b0ch5b+iMmf9senHbpg29gh2OKiQnWvZigOC8Q+iwHFKbuwmApY0doDNa09aiURcrk4X63Fr3IVOjvJ4KvS4ZxGg+9D/NEtrAW8KBTgPH0Q2gj73NwQYfHA4BZN0IUdMSqVCHF1Q1tKcEMObXMapkom5eDL0IQAA81u8DTosWrS56gvpSo6wBQAFfmOx4qSAuhkMjRjR8d0C0OPJqGYNbALlnwxCMPbNMYvY+hf3duxKAFo36ABnhzYgxd+elS198MVfzWWKsx4cnYKfpK6oK6lGTVtPETJUIVK6KzSY71WBxelGrd1amhY9WkKJTJZwTxvEz7WGeDp5gGrvxsmsXMfNvCFha7vrlbD38UED70Cfi4GyEkHjUJOMP6knQW+/Jovu1p/k92xvuEM5cBml/myd7dd6iO2rudrTaSmGl/17IgpfTrhR/pfkJsRA1s3Rk8ypLmPF/b//D2+G/QRotihSxY15iuMWKk0YrmzCuu9fHA7wBU1zc2iZGGgQtARwA8c0P6sZm+VFjfZwsGkgESlhERGmTWYEeXrhvpG7lCZXOGt1aOByYTu3g34XAeTRkEgUhiUGvi6eeKHTp14SBfoFArU3r4A1JJqZblAMbtUmApbgd2v7HcKQKBqdqmltwfCGI9MShXu/TEbjX3c0SG4Acmhx5hO7fDNgO7oHRSCRX5+2KA3Y4XKgJUq8/vbFas1Lqj0VYmSCW4KwajQoLFah0uUabmzMwYrtAhXK5FsNqEo2AyhoSesAZ4w8vDeriY05jCb+YN7+fkyVWigcpZA6uQMM4EuHT4MBnqNlh0uuncJdQRhByOU5hBMCk04CXXZCbyf0NsSUZ/3EqMH9kI3Ri1/Gq+F8/wofC6C6TH+LIovWTKU1J/Yrwt6t2iKBY0b42++92p62RqlAWt5r1S74DeFK3K8ZaJEr1QIfXr2wvCPh+MpO+TPN9ByiBvx4B1Y8S9d3NCScUjH5x7snI4eouEbHpw8Hu7Ocrip5I4iuLJi33fthFUTvqa6uaM84TpqSjKAtwTzNgcoTAdeJyLvdhTijm7HmXWLEfPnGmTduYDoPeEIDWiAUPqfh1GP/b98i74tQtHAw4wgdzOGMBhP6t0RY2kDf7QPwy4W7yCpnXY5Boc+HYS1ZNI6lRpn2hpFiUKhEOoqinEx6jRmstqt/fwRaDSiuZc3tDxoIIH5c15MVDIzq9LW3x9zB/dG1yB/+JKqLnxjo0yD7+j6V9b/hvDVK1Cd9QS2ag5/OWlWQiBvs7Bp8lcUEm9snjAGLyPDUf2AVCxMhvgmCa8eXkL3Di3RPsSbXVbjhyG9MGNIVzRgt4LcXCpH8WudQv3Ro2UjLPPxxTKVFJfHf4SaolQUJJ7CUtrLWoMGf4QqRYlSoRTyrkZgbq/2MPOA2ccPY8606fiAec7EGWjl4wNPu2BQBQ2UYn93E+4u/wU+9u6wkzqZGou++RiJu9aj/m0BKlOeArYKoLKINMuFWJyKRc0Dkbl9OaqjdqPs7C6UxxxF5c3TqEmIY1x6iPLURxjVrRMa+7qjsZ8Xpg3qgp6BnqisqkJxeTmyDx9Bdng4KtLSkPf2LUprajFbpcDDzdNwac5ErDeosM6oxkalVJR06dRe6PZhJ/jozJj0zdewX7Xl+WjdqBGMrH5zTy/oZXLKsQIf+PuiZttyDCKPtZRmE2X+0qa5KLm0H2JloSMFoJoeU1UMW2UehOJ01Gc8QXXcKRTHHED23nUojY1EHbNd5f0olF9hGGV3Sl/cxKjuHyLIbEBDTzPG9miDUIMWqSkpyI+Px5W2bXGGxSu8fx9llZXILSrCQma5dUYN1vC2g7Hfv6sJqConQSAn4K4yweLhidyDf6HiWTK86DE6uRSN6CU6h4IpcI2LXOm981ARiIeTE9JJnfK44wA9RuDgiwTBwXGAEkg3sSAV9ax+DelVejEC9a9uQHiTgvr0BxCSbqI+8SrK75xBzv1o9GnbEk0tXpR5Iz7r0hZNzDpkZGXh1YoVeDRqFBK++grnaQs5Fy8iv6QECxyA1KQawZj+C6D8f/YIaSfmwaTzQDNXujyBeHCWmrq5Ur2cEEpAfqTcnP49UcOKBpLXrXkvGtwTq4b0xq3f56L+5U0I+S85/PQWa/67u/w1QFkWUh/A9iQWNXfOwfY8FrbUu6jPfoo7x3cg7ehWxB/YiNjta+Ht5Qk3elEQqd6taRCaMd5k5uQgadkyFMbE4BwLeHfoUMSGhaGgoMABaCELnRp1Fsv46ACkICCNSi24aM3wNnkhiGLQs0EAOvsHcE32hjeN1k1Ob+FKUbVrDWZ/1A2T6OCPVkxG8fa5yNvxG96e3olqHlZIewAxn97y9r1MF2dwF3pBQNyjSDFbPIPm48uooxBM6NcVQR4e0HP3asSE8UmH1gigyhWRSv4s5NgeYRwBHbJycpF37hyyt23DGZUKt7t1Q2VGBvJLSzGblK+qr0fyixcoTnqOxfx4vZSA1GqVEGgJhomyZ1a6oG+jQEzo2BEtPbzgTYk2y1S4OnsSTs4ah2qKR87fC5ETvgDFuxYje/sC1HOVwItrEF/dhphiB5VIBttN8wXE3CcQ0+/B9uwqAUXBlnwVZh7M3WCCgt6lZ9U1VFKdWoO3HP50Dr21uhotPfVcL7QElIMrAQHI2LgRZ5lKMrdswY0PP0ROcTGyHz9ExiX6HMGdp9nWEdwMuUJkGFAJIW5BUHIr7BLSDFO6dsTygX0RYqQnsENtLP5I2rcKVfdOovjSHi5hm3F/7r9QnRlPSc6A+OQibElxsCXGENBNiHkEVEpARU/ZoccEdAvi88sUh/v4loHWk8p5ec0cvL28F1U3jsH6KBr5BBJLEbrcqhWKctmVN2/gotcgizNUXVPjEKr6MiZ1XlUEnJmZiRcREail4p0n8NTVTOcUqvy6OjsgpeBDf/F29cawlm3x5+ihWDCgF3x1egqFCt90bImyyweoZPuQd2wj7i+ZgVHtW8FH4wq1kxxdmoUg/thfTAHpEF9TsnMe8vlTyvVL2IpeAG+eQ8jjWl7w1JHNhORY0pM05PeK/Foeu5B++DCeTp6Ma61bI378eCStWYPcwkKkUOWqKN3/9bJarcgg7ax5eYhkh1PXrcOTCROQe/Qo8vLy3gGyO35oQAs00Lqga3BDfN6mBbntBq1UhdmMHG+Ob+H+vgEryX2l3ARnJ6oeE7rRmTmPSijlxwvGjOSeQ+nOf04QT9i9VxCLkiAUEhQfbYVJ7B4pWEig9i4STElpCTIePsTtkSORsnKlg1rnvLzw5tgxxLRpg1R24n8ClEOVi7DnRBajODYWScuXI4tz9h6QSghgIG3btj8CvULwRVgrDOGG2opp2Y3c/rpdMzzftgi3f/seLRmLnEhNP09v7Nm5G26kpTdjkT0pn9y1Fy9jOU8VTNXFzygKTwmCYPKevwPGbonFae+Sg/2xIAkvX6U4jPMqO/No2DDc7NoVr3fvRnFcHLL27EFKaur/CCgtla+vt+IsvamMBUmYMQPXOVv5FRXvAAWbPBkELZDSQLsEBGMUO9SSm2gDLnVDWjXEgzUz8FFwENOChsFThjYt+3Pn4XOJFCaTH7zURpSXFKIunVSq5kZaRsku4RwV2sFQ6ezASuxg3t1CUQo7xQ4WJiIjJw+lPHTy0qV4NGIEqkmn4uvXHYdPTk52ABC5DP77rrTZYH31GDWkbRU7eI5jYQdtV755ag1VTqUSfI1uXAcsaBjSAQpG+dZ+FnQODkSwiysXN3dET/8Cy3t1pCIpEL5wETr0mosmbcchtNkQfPzDUUwcsxa3Tp5g1HlFyaYXlWdBqEhlJ1I5O3YACewOZ6mIIPk5+6O9ayKVUMh/ivyCQhSyU29Z7XQq2b8vO6BKJgMbQfz7Ln2VgJrEa6jNSoBNIEACzue8/SswAIud5aLkUwJykcrQIqA5V2ktzAZPhNDcGnm4oamXmTPVANu/HYmoLwfClbMSfyUGS5b/hZ/CX2JVbD7mr72GhOvRTAiMOlZ2poKB1FpAPyK18ki1Cq4NTAZiXjzni4coeAZbPinJrtkKOG8ZD2F7dR33GWteU9WqqGqCwPDyHlBFRQXqKcn228YOWe+edkSnuqJslLMIrykOP3fogI/1anTSq0XJcwLSUi28Ddw9jBZmNDX0aj3CmLq9dFqEelqw4pNBuDJ/Ei7M+he6G12xfdJ4rOgXhqOLppNerHiNPb8xHVQxYTNlO8ShIosHvUmu18D29ArqLu6DmP2Qikcpz37EVYIAKRJC2m1smD4B9w6uQ0VOBrKysx1dsYN69eqV49C1tbWOu7JOQPVtMuH5NZRXViEtPR1LhwzB10w0nzlJ0M+kFyX7CKi3I2hK0JhZzqx1g0qug7+HBS19LcxwSqqZHNeXTkP8H7/i7YUdqPjnCKtNxSrjBlpfTjBFvAmGj/bYYxcGno5Z7Rpujx+Gwt3LmOV2Q6DJIvMuhIy77Nod+tZtFN85DyH+Aqpi9jCn7caxPzYjNTUF1iorniWlUAnfOmakmgAznz5AffxFCC+vIes1TXfRbxhOkRpKQBuYRX+XcmNV2inHDtl3nw6enBlmN19XD8g4Sw0tXIFd9HClS4cxaWcfWIncM3+i9vEFhtFM0okBlAdHJWlVYacbnztuft6+C5XnMIxydhJi6U/3YY09jCebFwMp1+hHcahPvoG6xxdRcysSVpr2nvD1OPXZWBTMXYDyB5dFK1eM+pd3uPVm4E7vXiiKjYLwIpY/7gUe7I/ACiab1Wqu32o3xxq+xpkL3hpGHwMBNbOYEbt0On5o6w+L3ogArt8eWiqd2YN0NHAzVWFa/x548fcKVNyIhI3VFTjYKOaAl9JU7fdbJge7KDDP2ZVOrMxFTdwZlNyOQT7pc+7nWZjFBRF5j1D3lLGF6aLq7klUxx6E9epuBFh88HOThohfNAOvd87n1wmc67ojRmU/puCkO7rz/NABrg8uWK705O1KMHZAblhrB1RKQGqpHBaTDtHMa/vHDcKaj9o6/MWfoDwp3RatnqCM3I+UuLB0BkrO7UL1fbY+9R7d/t2Ag2lbdMgxb6bsqmexSN6/Da+jzuARV4Kanp1Q9lFXnG8cRNrdRt2js0zgJ2G9dhDl0dtRXpZMYWoIf26kuX8vQ93Di471ouxeFH2J3/eUeZBRSmBXj3TtguVGP4Jxx3KFHZTZcTsAbSSgRm4WaMjFtIjfcWv5zzg9eTQuzvyS6boTApmKvX28YCb1/JjGzTSzDoGBDJsXUMkfWvPqFgf7HoedM2WPOEwBYg5znjUDk9h52P9S8f1YiIu+h/jTOGRO/AR1N4+i7u5xVF4/gMrzO1B+dhumkvJ+Ci1iwteiLDqc70cPe3mPSf4MrPfPO1Z1G2+7f33m64lonRJxh8fjM6kOiyUmLJBwj7LPkJ4zpKShBnsEwqzWofbJJVQn3uGecQTPTkfi+oa1OPzjj+gcGopgJgQ/xvoW3j6O1Xzm2FFUsBjUvvgHItcHIfMJbPbfJ2Q+gDXxBrIv7kflv0ahdt0vqD34J8omjcTbeT+i7voRVMUSzIVdKN27AtErFmCwpy+Wq2VcTebh2do5qKP61WdTBe3vl0upt68jSTRcWx2auZvwTOWEL3zdsGFYa0RN7o6IcV1xdnJXUaJVqwW9TAkVaaeQKyCTOCFm37Z3Qy3aUF9ZAsFWRj6fwYqe7dDCzxdBLgbM/2QAjiz8AcmRW/D25glUJV6BwG7V8657doPmF8v1OhplZ/fAunoBrOdOomj+L7Ae2IyK2P0oj9mFAlIr9XIkBppcMErhhAnsaOGRzahJuoOq+FhUP7mCWs5RfcYjFukp6p9fR2RkJBpRvGI1MiRLnTGxW3NE/DQYd+eMQuofM+1JQS1o5M4waZTozCwld5Ziu1KGSa6uSDlyDPUlzGY0OSt3kLqXN7CuUxME2ueKHjV/eD9kHtmCvLM7qEBHUE5JrU64CisPUhl/mVSJQvlt8j9mPwoiNqGGnax6wEXvJsGd2IQ3d85iiFSCkXIJJjLkzpBJ8fZoOHL3bUTRzuV4c2ANKmIo948uwZYW75D7wV3awVMtxRcGFW6pnNE1wBd//zgKy3q1wsqBYe8AKQnIzf47BO4/3xi1mExf2mFU4bK73mGMFYmvkHngEKoe3cftAG8sbxwAHUXExISxsF9nPNu4AOn7NiD3/B68jTuOijvReHvvHMrvnEbFvbO8z6GWYOt42x/tc1GXGI3udg9RSjCE9JmmcMYfndojb8sSLnLzsat7K7zZscQxX3V8jzoH3Uqg5yLaKdAHvjxvhsYZn7hp8VVjC5b+MALddFzw7FlOTWOy/yJExSrVeiowm8i36+SI83ZBsQvnKu0xB/k88v09cLNRAI7Tk8Yr5QhiAZpotI5f5a5lcohfPBEp+9ci6wyrHP03Ci4fYrw/hrK4w6h7cJ4U4rzZHykGf7JoFQYZEvlzesicMUnphO94jqpr+5H4w6d4sXgKcrbNR+mpTe8KYPef4mw00LviI7KjS6gvnuqccC7Egq+bBGLZiB7Y9G1/UWIioCbu3E7pM/Yw2tVLjT+DZZjJH7JLp8YNd08kcWvN8g7FTXMADnq54mxHVxz8RI2Hc5SI3+iMA9+ZEDvTiJWdvfFn+5bY2a0R9vb/ABcmj8DTTXOQe2o7ck79hczDv+POkik4PPhD7NRJcEwrxSWNFGV6KQaQdpNVEkzTOePpwi+Qs+5X5Oych4qozah9eJYb8QXMmvQderkZ+BoZeht0SDfKcJjFH9e5NdZ+1gcrBvcRJUMCvMW+DYMd22kTs55Kp6CSyXB+lAZ5U2SwrVVC3GcALrkyLZpRc1OLvK0yPPxYiX+6O+PaEBkypylRzs+JV6UQLkhwc7wFx0f3xsnPuyJqfF+c+aYXzk0YgAtThuLyjyOwr3Nzyq4U0RpWWOuMCK0Mg2UStGH4tc1S4OWKPkhbNxv5+35DZfRWdvWEI1UolGQPxeMNX5McoEEJwR8yafBp6yboTn/7uT9VbkGfLlXj27RGoMmApu5m9CU/5U4yKKVSeJmMkFIkXCQyXHdSIJszk8jP3+Qb3lSTkhoNMj9Q4qZJgervFYjifl9xUIn6YzIUrZLg0pwJuPDTpzhPEP/MG4cby6bg7pqfcGZIb2xVO2M/u7OR1J05yBWVR1mw6zJcHc2u/70GWX/99g7QRfsMRaLqTQJ2UQUXURAy2dHKYXzUKfCjRo8BzRq++/OOSlkn6epmKpzaOQy9AxvAnRtqb0aTrn7ecOKL5QylFq0av5Pbf7G1QVIFrKTJDfJ+B58f5ZJ3nbGoboQUx/VKPPZV4LzEGVdnKmA75Qzxjgxl+w14uHcvnu9fh2cHGTyjduDs6BGIpTGOlTqhLsELOC7F9YEyzOVczVDJUBgTQUBLkL97EWoo8fX3j3AjycBs0vIYi5kdqkBVLwWesMPeLkY0t3hR0Mgsrb5UMqxLtxXjWzdDL64LfqxwE0pydy54H3IFt/9V4XzkIZQm/oP0i4cQ3TQEq1RSzGPbT+lUOMLV/apeh3+0rrAtIOWWOoNI8aidEmc/kCNnrhx46Qch0Qs3136N0idXUfsmHVHfjsFLDQ8U2QBCuAzrXRWonS5HYlcFxlL5yinrWTuXIuOP6bBe3knKnXX8nm+8QoF0vRPKJ5P27VV4pXXCZo0cAWSWSa1kOPA65PhL+MdNgigGFnSheslZYReVgmmAleNKIHBJQw7zWs5jVNw6jQe92+AAQR0jZeINXCuoghfZsast5cgKkyO/tRyFLeSoHqhAZgcloji4eORJYG6IO37csWKkenvggFYBcbMMZwNUeNBejkPtFIjrLsevFKN/1v6KzB1Lkbx6Ko2WXsSlzvYmBc9OHUMy1xxEmfGC1E8PVOCBmj4WGsgwzUZ07y5zAOpscb/qSzEII9JuQf6Q2R37NaMGc5mQ++4WmXrtfykovXoYdxr54jk9IMHefirODfpIYlcV3rg6o0QvQ4FRjtKWFJTjOghx3jjPQ4pHZXjylxJpc+eiVCtBcW4ohCNS5E9gd3Y7w/qpEgV9ZYj1leFfPFz+vnV4vmY6snYtRMmVfYxBz3CXObLgRxfUHPZCGv1LPO6Gx2onXKbku3u4P3KA+ffVXK8TLfSV5u5GTBv6EcC4/m8wNjug1wSUwozGlJ2ycyUy2Jl0qlOWHRSH9L5EClAMrKu0sF3XolDvjGKKCFJ98LK9BuUH1KSjBPvNSpTtDoK4yhlF7EjCaCOqxivwxlmBsvEyxPsqMYmzknRoE16snYlXG6aj4OQW1GTEI5fdsb3yQ2obFbI/0qB2vgmJ9pkmuPcw/vP60N+/jTfXAw8O6vF1i5igHznA1BOIvTu2zMeoSb7voF1R7FFcoIkWKSQooPyWG5xRSgnNbcsKDlehbLkeKUYpCoKlEFMbomiAEoWLlKhdqUTCNCPEcNImQoq8+Tq8DFGgfKoeQiS/d5Wc8ynFD/SYzqH0vh2L8WzNNKRun4vnO5bjGecLVSHI/VhPdjAEbDIg1eiMczpVt/cw/vs1zcOl41SZk3hm7lQGzDjUZj1men6M+nSGw+S7jC2xKLtyBCXXIvFkyzzc6dgURQYnZLJLFRzWCj1XkBA53vRQIFnpjJRmSmS2keKhzAn1e9W40FgDYZcSVcuVeKFXONStjDJct1kH60wVdnvJMZXdOTNvEnq3CEbshvl4vo5dWj8T178cimwfzmaML7IG0hf3GIEDJgqSsc/74//v1/puHZLqbp1BzTMm3RcExvRc/egiKi4TTNRelF086PgfnqjpnyPPDoYzUUGKWRlFajlDSUwYcbSA8tXs2M/s2FY16g5IsVuiotewo4NlyOfKUn9YierOciQpZLjFiqcyPQxqGIIve3aAD1V2CjtSfGoLbk/9FPuZULJClSj6WENqm/G6ozz1/XH/b9eWRYu8ck7sTKi9dbK64tIhsfjsLrH45E6x8PTfYsn5fWLusW3ipflfixVSJ/GxUStmG5zEcoNMtOqdxCqDXLTx47sKjXjZaBCv+OrF3RKNGNdFIdYcloqJoXKxbruzWPWTXHzaSi4+1DqJC9UqcblRJbayeIqBZlfRIpWKc9VS8ZqTREzVOIt39VKx0MmpJvsvz6SparXv+2P+P5dE8h/2K/pVFme88gAAAABJRU5ErkJggg==";
    var httpReq = function (ip, callback) {
        var xhr = new XMLHttpRequest();
        xhr.open("GET", ip, true);
        xhr.onreadystatechange = function () {
            if (xhr.readyState == 4) {
                var result = {};
                if (xhr.status == 200) {
                    var response = xhr.responseText;
                    result = JSON.parse(response);
                }
                if (callback) {
                    callback(result);
                }
            }
        };
        xhr.send();
    };
    var btnClick = function (btn, func, caller, clear) {
        if (clear === void 0) { clear = false; }
        if (clear) {
            btn.offAll();
        }
        btn.on(Laya.Event.CLICK, caller, func);
    };
    var YFWindow = /** @class */ (function () {
        function YFWindow(adr, attr) {
            if (attr === void 0) { attr = {}; }
            var _this = this;
            this.address = adr;
            this.count = 0;
            this.arg = attr;
            httpReq(this.address, function (res) {
                _this.init(res);
            });
            Laya.timer.loop(10, this, this.refresh);
        }
        YFWindow.prototype.init = function (info) {
            var _this = this;
            this.reqInfo = info;
            var sprite = new Laya.Sprite();
            sprite.width = Laya.stage.width;
            sprite.height = Laya.stage.height;
            sprite.pos(0, 0);
            sprite.zOrder = 999999;
            sprite.mouseThrough = true;
            Laya.stage.addChild(sprite);
            var btn = new Laya.Button();
            // btn.loadImage(res.icon + "mc.png",0,0,0,0,Handler.create(this,(a,b)=>{
            // 	btn.pos(Laya.stage.width - btn.width / 2,100);
            // }));
            btn.stateNum = 1;
            sprite.addChild(btn);
            Laya.loader.load((info.icon || "") + "mc.png", Laya.Handler.create(this, function (a, b) {
                if (a) {
                    btn.skin = info.icon + "mc.png";
                }
                else {
                    btn.loadImage(defImg);
                }
                btn.anchorX = 0.5;
                btn.anchorY = 0.5;
                btn.pos(Laya.stage.width - btn.width, 200);
            }));
            btnClick(btn, function () {
                if (btn["skip"]) {
                    btn["skip"] = null;
                }
                else {
                    if (_this.arg["fCallback"]) {
                        _this.arg["fCallback"](_this.reqInfo);
                    }
                    else {
                        var tip = new Laya.Label("请传入浮标回调【fCallback】");
                        tip.anchorX = 0.5;
                        tip.x = Laya.stage.width / 2;
                        tip.y = Laya.stage.height / 2;
                        tip.fontSize = 50;
                        tip.color = "#00ffff";
                        sprite.addChild(tip);
                        Laya.Tween.to(tip, { y: 200 }, 1500, null, Laya.Handler.create(_this, function () {
                            sprite.removeChild(tip);
                        }));
                    }
                }
            }, this);
            sprite.mouseEnabled = true;
            sprite.on(Laya.Event.MOUSE_DOWN, this, function (obj, e) {
                if (obj.getBounds().contains(e.stageX, e.stageY)) {
                    obj.drag = true;
                    _this.startP = new Laya.Point(e.stageX, e.stageY);
                }
            }, [btn]);
            // sprite.on(Laya.Event.MOUSE_MOVE, this, (obj, e)=>{
            // 	if(obj.drag){
            // 		obj.x = e.stageX;
            // 		obj.y = e.stageY;
            // 		if(startP.distance(e.stageX, e.stageY) > 50){
            // 			obj.skip = true; //跳过点击事件
            // 		}
            // 	}
            // },[btn]);
            sprite.on(Laya.Event.MOUSE_UP, this, function (obj, e) {
                if (obj.drag) {
                    if (obj.x < Laya.stage.width / 2) {
                        obj.x = obj.width / 2;
                    }
                    else {
                        obj.x = Laya.stage.width - obj.width / 2;
                    }
                    if (obj.y < obj.height / 2) {
                        obj.y = obj.height / 2;
                    }
                    else if (obj.y > Laya.stage.height - obj.height / 2) {
                        obj.y = Laya.stage.height - obj.height / 2;
                    }
                }
                obj.drag = null;
                _this.startP = null;
            }, [btn]);
            this.touchSp = sprite;
            this.floatIcon = btn;
        };
        YFWindow.prototype.refresh = function () {
            var _this = this;
            if (!this.touchSp) {
                return;
            }
            if (!this.touchSp.parent) {
                Laya.stage.addChild(this.touchSp);
            }
            if (this.floatIcon["drag"]) {
                this.floatIcon.x = Laya.stage.mouseX;
                this.floatIcon.y = Laya.stage.mouseY;
                if (this.startP.distance(Laya.stage.mouseX, Laya.stage.mouseY) > 50) {
                    this.floatIcon["skip"] = true; //跳过点击事件
                }
            }
            this.count++;
            if (this.count > 1000) {
                this.count = 0;
                httpReq(this.address, function (res) {
                    if (_this.floatIcon) {
                        console.log(res);
                    }
                });
            }
        };
        return YFWindow;
    }());
    yftools.YFWindow = YFWindow;
})(yftools || (yftools = {}));
//# sourceMappingURL=FWindow.js.map
/* 当前场景 */
let VIEW = null;
/* 默认立方体的尺寸 */
let CubeSize = { X: 0.8, Y: 0.5, Z: 5 };
/* 背景图的尺寸 */
let bgsize = { X: 30, Y: 80, Z: 0.001 };
/* 圆周运动参数 */
let GLOB_Circumferential = {
    angularVelocity: 0.01,
    speed: 0.001,
    increment: 0,
};
/*  全局插件 */
var TOOLS = {
    // 切换场景并清空上级场景
    runScene: (scene, arg = null) => {
        Laya.stage.removeChildren();
        Laya.stage.removeSelf();
        VIEW = new scene(arg);
    },
    // 获取两个坐标间的距离
    getline: (coordinateA, coordinateB) => {
        let point = new laya.maths.Point(coordinateA.x, coordinateA.y);
        return point.distance(coordinateB.x, coordinateB.y);
    },
    // 获取两点之间角度
    getRad: (x1, y1, x2, y2) => {
        var x = Math.abs(x1 - x2);
        var y = Math.abs(y1 - y2);
        var z = Math.sqrt(x * x + y * y);
        return Math.round((Math.asin(y / z) / Math.PI * 180));
    },
    // 根据弧长计算角度
    getAngle: (radian, radius) => {
        return radian / (Math.PI * radius) * 180;
    },
    // 计算以 (X1,Y1) 为标准 （X2,Y2) 在标准坐标系下的角度
    _getAngle: (x1, y1, x2, y2) => {
        x1 = Math.abs(x1);
        x2 = Math.abs(x2);
        y1 = Math.abs(y1);
        y2 = Math.abs(y2);
        //console.log("传入", x1, y1, x2, y2);
        var x = Math.abs(x1 - x2);
        var y = Math.abs(y1 - y2);
        var z = Math.sqrt(x * x + y * y);
        var angle = Math.round((Math.asin(y / z) / Math.PI * 180));
        if (x2 > x1 && y2 > y1) {
            //console.log("第一象限");
        }
        else if (x2 < x1 && y2 > y1) {
            angle += 90;
            //console.log("第二象限");
        }
        else if (x2 < x1 && y2 < y1) {
            angle += 180;
            //console.log("第三象限");
        }
        else if (x2 > x1 && y2 < y1) {
            angle += 270;
            // console.log("第四象限");
        }
        else if (x2 === x1 && y2 > y1) {
            angle = 90;
            //console.log("Y轴正半轴");
        }
        else if (x2 > x1 && y2 === y1) {
            angle = 0;
            // console.log("X轴正半轴");
        }
        else if (x2 < x1 && y2 === y1) {
            angle = 180;
            // console.log("X轴负半轴");
        }
        else if (x2 === x1 && y2 < y1) {
            angle = 270;
            // console.log("Y轴负半轴");
        }
        // console.log(angle);
        return angle;
    },
    // 弧度与角度互转
    getAngleTransform: (value, type) => {
        if (type === "ang") {
            // 弧度转角度 返回角度
            return value * (180 / Math.PI);
        }
        else if (type === "rad") {
            // 角度转弧度 返回弧度
            return value * (Math.PI / 180);
        }
    },
    // AJAX
    Ajax: (request) => {
        return new Promise((resolve, reject) => {
            let ajax = new XMLHttpRequest();
            ajax.open('GET', request, true);
            ajax.onreadystatechange = () => {
                if (ajax.readyState === 4) {
                    if (ajax.status === 200) {
                        resolve(ajax.response);
                    }
                    else {
                        reject(this.response);
                    }
                }
            };
            ajax.send();
        });
    },
    // 获取json数据
    getJSON: url => {
        let promise = new Promise(function (resolve, reject) {
            let handler = function () {
                if (this.readyState !== 4)
                    return;
                if (this.status === 200) {
                    resolve(this.response);
                }
                else {
                    reject(new Error(this.statusText));
                }
                ;
            };
            let client = new XMLHttpRequest();
            client.open("GET", url);
            client.onreadystatechange = handler;
            client.responseType = "json";
            client.setRequestHeader("Accept", "application/json");
            client.send();
        });
        return promise;
    },
    // 随机算法
    getRandomInt: function (min, max) {
        return Math.floor(Math.random() * (max - min) + min);
    },
};
/* 动画 */
var animation = {
    // 平移
    move: (target, type, length, time, delay, loop = false) => {
        if (type === "y") {
            // 水平
            if (loop) {
                // 循环
                var ctr = false;
                var _ = () => {
                    ctr = !ctr;
                    if (ctr) {
                        Laya.Tween.to(target, { top: length }, time, Laya.Ease.bounceOut, Laya.Handler.create(this, _), delay);
                    }
                    else {
                        Laya.Tween.to(target, { top: length }, time, Laya.Ease.bounceOut, Laya.Handler.create(this, _), delay);
                    }
                };
                _();
            }
            else {
                Laya.Tween.to(target, { top: length }, time, Laya.Ease.bounceOut, null, delay);
            }
        }
        else if (type === "x") {
            // 垂直
            Laya.Tween.to(target, { left: length }, time, Laya.Ease.bounceOut, null, delay);
        }
    },
    // 缩放
    scale: (target, Xscale, Yscale, time, delay) => {
        Laya.Tween.to(target, { scaleX: Xscale, scaleY: Yscale }, time, Laya.Ease.bounceOut, null, delay);
    }
};
/* 音频管理 */
let AUDIO = {
    play: (type) => {
        let url = null, audio_type = "Musice";
        switch (type) {
            case "bg_1":
                url = "https://shop.yunfanshidai.com/xcxht/pqxcx/res/01.mp3";
                break;
            case "bg_2":
                url = "https://shop.yunfanshidai.com/xcxht/pqxcx/res/02.mp3";
                break;
        }
        ;
        if (audio_type === "Musice") {
            Laya.SoundManager.playMusic(url, 0); // 音乐
        }
        else {
            Laya.SoundManager.playSound(url, 1); // 音效
        }
    },
    stop: (url) => {
        Laya.SoundManager.stopSound(url);
    }
};
//# sourceMappingURL=common.js.map
var WetchGame;
(function (WetchGame) {
    class gameScene {
        constructor() {
            this.Router_game = null; // 路由表
            this.cube_bg_type = true; // 贴图控制
            this.Lead_cube = null; // 主角模型
            this.FourcePointRouter = []; // 着力点路由表
            this._Fraction = "0"; // 当前分数
            this.dataform = 1; // 当前使用配置表id
            this.dataInfoArray = []; // 激光点信息表
            this._index = 0; // 激光表读取 index 
            this.rendelist = []; // 渲染队列
            this.Recordspot = 0; // 当前主角使用激光点 index 值
            this.scoreCalculation = true; // 分数计算开关
            this.Scorevalue = 0; // 当前分数
            // 临时变量
            this.TemporaryVariable = {
                cleateBoxStatus: true // 对象创建控制
            };
            this.main = () => {
                this.animationobj = new WetchGame.animationUI(this);
                this.Propobj = new WetchGame.Propobj(this);
                this.npc = new WetchGame.npc(this);
                this.Shopping = new WetchGame.Shopping(this);
                this.wx = new WetchGame.Wetch(this);
                let request = TOOLS.Ajax(`https://shop.yunfanshidai.com/xcxht/pqxcx/conf/${this.dataform}.json`);
                request.then(data => {
                    let _data = JSON.parse(Object(data)).data;
                    this.Router_game = _data;
                    this.dataFormat(_data);
                    this.Main3D();
                    this.dataform += 1;
                });
                request.catch(err => {
                    Laya.loader.load("res/router/Router2.json", Laya.Handler.create(this, () => {
                        let _data = Array.from(Laya.Loader.getRes('res/router/Router2.json').data);
                        this.Router_game = _data;
                        this.dataFormat(_data);
                        this.Main3D();
                    }));
                });
            };
            this.Main3D = () => {
                let self = this;
                let _ = this.animationobj.initScene();
                this.Game_scene = _.scene; // 3D场景
                this.camera = _.camera;
                this.npc.init({
                    scene: _.scene,
                    skin: 0,
                });
                this.Lead_cube = this.npc.ME;
                this.Propobj.init();
                this.Propobj.halo("add", (new Laya.Vector3(0.8, 7, 0)), 0); // 光环            
                this.ForceLineObj = this.Propobj.Laserline; // 激光线
                this.Controller("start"); // 进入游戏    
                this.Global_obj();
                // console.log(this.dataInfoArray);
                // console.log(this.Router_game);
                // 更多游戏跳转
                // this.animationobj.mask({type:1});
                // this.animationobj.mask({type:1});
                //this.CountDown(()=>{});
                new yftools.YFWindow("https://shop.yunfanshidai.com/xcxht/slyxhz/api/getothergamelist.php?gameid=4&openid=test");
            };
            // 开始游戏
            this.startGame = () => {
                let setup = this.scene2D
                    .getChildByName("home")
                    .getChildByName("btn_groug")
                    .getChildByName("setup");
                let btn = this.scene2D
                    .getChildByName("home")
                    .getChildByName("btn_groug")
                    .getChildByName("start");
                let skin = this.scene2D
                    .getChildByName("home")
                    .getChildByName("btn_groug")
                    .getChildByName("skin");
                setup.offAll();
                btn.offAll();
                skin.offAll();
                btn.on(Laya.Event.CLICK, this, (e) => {
                    btn.offAll();
                    e.stopPropagation();
                    var _ = this.scene2D.getChildByName("home");
                    _.destroy();
                    // this.Propobj.halo("delete");
                    this.fractoinatr(); // 分数控制
                    this.rendelist = [this._whereabouts, this.collisionDetection.bind(this)]; // 开启抛物
                    this.updata();
                    this.eventSwitch();
                });
                setup.on(Laya.Event.CLICK, this, (e) => {
                    let target = this.scene2D.getChildByName("home");
                    target.visible = false;
                    let sure = this.scene2D.getChildByName("sure");
                    sure.visible = true;
                    this.wx.list();
                    sure.on(Laya.Event.CLICK, this, () => {
                        this.wx.off();
                        sure.visible = false;
                        target.visible = true;
                    });
                    console.log("好友排行榜");
                });
                // 皮肤
                skin.on(Laya.Event.CLICK, this, (e) => {
                    this.scene2D.destroy();
                    this.Shopping.renderUI(null, () => {
                        this.Propobj.halo("add", (new Laya.Vector3(-4.6, 30.5, 7)), 0);
                        this.Lead_cube.transform.position = new Laya.Vector3(-4.6, 31.1, 7);
                        this.camera.transform.position = new Laya.Vector3(-6.4, 32, 10.6);
                        this.scene2D = this.animationobj.shopping();
                    });
                });
            };
            // 状态控制
            this.Controller = data => {
                if (data === "start") {
                    if (!!this.scene2D)
                        this.scene2D.destroy();
                    this._index = 0;
                    this.Recordspot = 0;
                    this.rendelist = "end"; // 清空渲染队列
                    Laya.stage.offAll();
                    this.camera.transform.position = new Laya.Vector3(-1, 10, 6);
                    this.camera.transform.localRotationEuler = new Laya.Vector3(-15, -25, 2);
                    this.Lead_cube.transform.position = new Laya.Vector3(0.8, 7, 0);
                    this.Lead_cube.transform.localRotationEuler = new Laya.Vector3(0, 0, 0);
                    this.Circumferential = {
                        angularVelocity: GLOB_Circumferential.angularVelocity,
                        angle: 0,
                        speed: GLOB_Circumferential.speed,
                        increment: GLOB_Circumferential.increment,
                        radius: 0,
                        Circular_point: new Laya.Vector3(0.8, 8, 0) // 圆心坐标
                    };
                    this.SlantingThrow = {
                        pos: new Laya.Vector3(0.8, 7, 0),
                        gravity: 8,
                        v0: 5,
                        acceleration: 0,
                        angle: 45,
                        time: 0,
                    };
                    this.RenderCube(3);
                    this.cameraAnimation(() => {
                        this.scene2D = this.animationobj.indexUI();
                        this.loadAdn();
                        this.Propobj.halo("add", (new Laya.Vector3(0.8, 7, 0)), 0);
                        this.npc.comeout(this.Lead_cube, () => {
                            this.circumference(new Laya.Vector3(0.79, 7, 0)); // 绘制激光线
                            this.rendelist = [];
                        });
                        this.startGame(); // 开始游戏按钮
                    });
                    AUDIO.play(TOOLS.getRandomInt(0, 2) ? "bg_1" : "bg_2");
                }
                else if (data === "Restart") {
                }
            };
            // 筛取下一个激光点
            this.Choicespot = data => {
                let pos, index = 1;
                let _before = this.dataInfoArray[this.Recordspot][this.dataInfoArray[this.Recordspot].length - 1].pos;
                let _after = this.dataInfoArray[this.Recordspot + index][this.dataInfoArray[this.Recordspot + index].length - 1].pos;
                let callback = () => {
                    if (data.x > _before.x && data.x < _after.x) {
                        pos = _after;
                    }
                    else if (data.x > _after.x) {
                        index += 1;
                        _after = this.dataInfoArray[this.Recordspot + index][this.dataInfoArray[this.Recordspot + index].length - 1].pos;
                        callback();
                    }
                    else {
                        pos = _before;
                    }
                };
                callback();
                this.Recordspot += index;
                return new Laya.Vector3(pos.x, pos.y, 0);
            };
            // 控制激光线
            this.Renderingline = (type, angle = null, length = null, pos = null) => {
                let target = this.ForceLineObj;
                if (type === true) {
                    target.transform.position = pos;
                    target.transform.localRotationEuler = new Laya.Vector3(0, 0, angle + 90);
                    target._childs[0]._childs[0].transform.localScale = new Laya.Vector3(5, length * 95, 5);
                }
                else if (type === false) {
                    target.transform.position = new Laya.Vector3(0, 0, 0);
                }
            };
            // 计算圆周运动参数
            this.circumference = pos => {
                let FoucePosition = this.Choicespot(pos); // 激光点
                let angle = TOOLS._getAngle(FoucePosition.x, FoucePosition.y, pos.x, pos.y); // 标准角度
                let length = TOOLS.getline(FoucePosition, pos); // 标准距离
                // 开启激光线
                this.Renderingline(true, angle, length, FoucePosition);
                // 圆周运动参数
                this.SlantingThrow.time = 0; // 清空斜抛运动的时间
                this.Circumferential.angle = angle; // 当前角度
                this.Circumferential.Circular_point = FoucePosition; // 圆心
                this.Circumferential.radius = length; // 圆半径
                this.Circumferential.angularVelocity = this.SlantingThrow.v0 / length; // 计算角速度
                // 开启圆周运动
                this.rendelist = [this._accelerate, this.collisionDetection.bind(this)];
            };
            // 计算抛物运动参数
            this.parabolic = data => {
                this.SlantingThrow.pos = data; // 主角坐标
                this.SlantingThrow.v0 = this.Circumferential.angularVelocity * this.Circumferential.radius; // 线速度
                this.SlantingThrow.angle = 90 - (360 - (this.Circumferential.angle - Math.round(this.Circumferential.angle / 360) * 360)); // 斜抛角度
                this.Circumferential.speed = GLOB_Circumferential.speed; // 加速度
                this.rendelist = [this._whereabouts, this.collisionDetection.bind(this)]; // 开启抛物
                this.Renderingline(false); //关闭激光线
            };
            // 数据格式化
            this.dataFormat = data => {
                let _ = [], count = 0;
                // 存在已用数据时叠加index下标
                if (this.dataInfoArray.length > 0) {
                    let _ = this.dataInfoArray[this.dataInfoArray.length - 1];
                    count = _[_.length - 1].index + 1;
                }
                ;
                data.forEach((element, index) => {
                    element.index = index + count;
                    _.push(element);
                    if (!!element.skill && element.skill === "1") {
                        element.pos = { x: (index + count + 1) / 2 * 0.8, y: (this.Propobj.CubeSize.Z / 2) + Number(element.hp) };
                        this.dataInfoArray.push(_);
                        _ = [];
                    }
                    ;
                });
            };
            // 摄像机矫正
            this._camareCorrect = () => {
                let leadpos = new Laya.Vector3(0.8, 7, 0); // 主角初始位置
                let pos = this.Lead_cube.transform.position; // 当前主角位置
                var x = pos.x - leadpos.x, y = pos.y - leadpos.y; // 主角位置偏移
                var a = 0, b = 0, time = 100;
                // x轴偏移
                var xb = window.setInterval(() => {
                    b += Math.abs(x / time);
                    if (b >= Math.abs(x)) {
                        window.clearInterval(xb);
                    }
                    this.camera.transform.translate(new Laya.Vector3(x / time, 0, 0));
                }, Math.abs(x / time));
                // y轴偏移
                var yb = window.setInterval(() => {
                    a += Math.abs(y / time);
                    if (a >= Math.abs(y)) {
                        window.clearInterval(yb);
                    }
                    this.camera.transform.translate(new Laya.Vector3(y / time, 0, 0));
                }, Math.abs(y / time));
            };
            // ui动画
            this.loadAdn = () => {
                let btn_ground = this.scene2D.getChildByName("home").getChildByName("btn_groug");
                let logo = this.scene2D.getChildByName("home").getChildByName("logo");
                animation.move(btn_ground, "y", 700, 500, 0);
                animation.scale(logo, 1, 1, 1000, 0);
            };
            // 广告
            this.Advertisement = (type) => {
                if (window["wx"])
                    return;
                let bannerAd = window["wx"].createBannerAd({
                    adUnitId: 'adunit-d707f0634076fb0b',
                    style: {
                        left: 0,
                        top: window.innerHeight,
                        width: window.innerWidth
                    }
                });
                bannerAd.show();
                setTimeout(data => { bannerAd.style.top = window.innerHeight - bannerAd.style.realHeight; }, 1000);
            };
            // 事件
            this.eventSwitch = () => {
                Laya.stage.on(Laya.Event.MOUSE_DOWN, this, this.Event_DOWN);
                Laya.stage.on(Laya.Event.MOUSE_UP, this, this.Event_UP);
            };
            this.Event_DOWN = event => {
                let pos = this.Lead_cube.transform.position;
                this.circumference(pos); // 计算参数
            };
            this.Event_UP = event => {
                this.rendelist = [];
                let pos = this.Lead_cube.transform.position;
                this.parabolic(pos); // 计算参数
            };
            // 摄像机动画
            this.cameraAnimation = (call) => {
                this.camera.transform.translate((new Laya.Vector3(0, 0, 20)), false);
                var a = 0;
                let anim = () => {
                    if (a >= 20) {
                        Laya.timer.clear(this, anim);
                        window.setTimeout(() => {
                            call(); //执行回调
                        }, 300);
                    }
                    ;
                    this.camera.transform.translate(new Laya.Vector3(0, 0, -0.2), false);
                    a += 0.2;
                };
                Laya.timer.loop(1, this, anim);
            };
            this.RenderCube = (size) => {
                if (this.dataInfoArray.length - (this._index + size) <= 5) {
                    let request = TOOLS.Ajax(`https://shop.yunfanshidai.com/xcxht/pqxcx/conf/${this.dataform}.json`);
                    request.then(data => {
                        let _data = JSON.parse(Object(data)).data;
                        this.Router_game = _data;
                        this.dataFormat(_data);
                        this.dataform += 1;
                    });
                    request.catch(err => {
                        Laya.loader.load("res/router/Router2.json", Laya.Handler.create(this, () => {
                            let data = Array.from(Laya.Loader.getRes('res/router/Router2.json').data);
                            this.Router_game = data;
                            this.dataFormat(data);
                        }));
                    });
                }
                for (let i = size; i--;) {
                    let data;
                    if (this._index >= this.dataInfoArray.length) {
                        data = this.dataInfoArray[this.dataInfoArray.length - 1];
                        this.dataInfoArray[this.dataInfoArray.length - 1].index += 1;
                    }
                    else {
                        data = this.dataInfoArray[this._index];
                    }
                    data.forEach(element => {
                        this.AddBox(element);
                    });
                    this._index += 1;
                }
                this.TemporaryVariable.cleateBoxStatus = true;
            };
            this.AddBox = data => {
                let box = this.Propobj.pullcube((this.cube_bg_type) ? "top" : "bottom"), index = data.index, height = Number(data.hp);
                this.Game_scene.addChild(box);
                if (!box)
                    console.log("无法从对象池请求对象");
                if (index % 2 === 0) { // 下部
                    let Box_X = (index + 2) / 2 * this.Propobj.CubeSize.X;
                    let Box_Y = (this.Propobj.CubeSize.Z / 2) + height;
                    box.transform.translate(new Laya.Vector3(Box_X, Box_Y, 0));
                    this.cube_bg_type = !this.cube_bg_type;
                }
                else {
                    let Box_X = ((index + 1) / 2) * this.Propobj.CubeSize.X;
                    let Box_Y = (this.Propobj.CubeSize.Z / 2) + height;
                    // 道具
                    if (!!data.drop) {
                        let top = height;
                        let bottom = this.Propobj.CubeSize.Z + Number(this.Router_game[data.index - 1].hp);
                        let pos = new Laya.Vector3(Box_X, (top - bottom) / 2 + bottom, 0);
                        if (data.drop === "1") {
                            this.Propobj.getProp(0, pos);
                        }
                        else if (data.drop === "2") {
                            this.Propobj.getProp(1, pos);
                        }
                        else if (data.drop === "3") {
                            this.Propobj.getProp(2, pos);
                        }
                    }
                    box.transform.translate(new Laya.Vector3(Box_X, Box_Y, 0));
                }
            };
            this.fractoinatr = () => {
                // 分数控制逻辑
                var _ = (this.scene2D.getChildByName("game").getChildByName("Fraction"));
                _.visible = true;
                window.setInterval(() => {
                    if (this.scoreCalculation) {
                        this._Fraction = _.value = String(this.Scorevalue += 1);
                    }
                    ;
                }, 1500);
            };
            // 圆周运动
            this._accelerate = data => {
                let self = this, pos = data.pos;
                let office = self.circularMotion(self.Circumferential.angle, pos, this.Circumferential.Circular_point, this.Circumferential.radius, this.Lead_cube);
                let tg = ((Laya.timer.delta / 1000 * self.Circumferential.angularVelocity) * 180 / Math.PI); // 角度增量    
                self.Circumferential.angle += tg; // 计算角度
                self.Circumferential.angularVelocity += self.Circumferential.speed; // 递增角速度
                this.Lead_cube.transform.rotate(new Laya.Vector3(0, 0.05, 0));
                this.ForceLineObj.transform.localRotationEuler = new Laya.Vector3(0, 0, self.Circumferential.angle + 90);
                self.camera.transform.translate(new Laya.Vector3(office.x, office.y, 0), false);
            };
            // 斜抛运动
            this._whereabouts = data => {
                let self = this, pos = data.pos;
                let _ = self.SlantingMotion(self.SlantingThrow.angle, self.SlantingThrow.time, self.SlantingThrow.v0, 1);
                self.SlantingThrow.time += (Laya.timer.delta / 1000);
                let vect3 = new Laya.Vector3(this.SlantingThrow.pos.x + _.X, this.SlantingThrow.pos.y + _.Y, 0); // 位移向量
                this.camera.transform.translate(new Laya.Vector3(vect3.x - pos.x, vect3.y - pos.y), false);
                this.Lead_cube.transform.position = vect3;
                this.Lead_cube.transform.rotate(new Laya.Vector3(0, 0.1, 0));
                self.Circumferential.angularVelocity -= self.Circumferential.speed; // 递减角速度
            };
            Laya.loader.load([
                "res/atlas/index.atlas"
            ], Laya.Handler.create(this, this.main));
        }
        // 圆周运动算法
        circularMotion(angle, pos, contercircle, radius, target) {
            let target_X = contercircle.x + radius * Math.cos(angle * Math.PI / 180);
            let target_Y = contercircle.y + radius * Math.sin(angle * Math.PI / 180);
            target.transform.position = new Laya.Vector3(target_X, target_Y, 0);
            return { x: target_X - pos.x, y: target_Y - pos.y, pos: { x: target_X, y: target_Y } };
        }
        // 斜抛运动算法
        SlantingMotion(angle, time, speed, scale = 1) {
            let X, Y;
            X = speed * Math.cos(angle * Math.PI / 180) * time; // 水平距离
            Y = speed * Math.sin(angle * Math.PI / 180) * time - (this.SlantingThrow.gravity * (time * time)) / 2; // 垂直距离
            X = X * scale;
            Y = Y * scale;
            return { X, Y };
        }
        // 碰撞检测
        collisionDetection(target) {
            let pos = target.pos;
            let Targetpoint = this.dataInfoArray[this._index - 1][this.dataInfoArray[this._index - 1].length - 1].pos; // 当前页面已渲染且最远距离的激光点坐标
            let i = Math.round(pos.x / this.Propobj.CubeSize.X);
            if (i <= 0)
                i = 1;
            let top = 2 * i - 1; //上方数据索引
            let bottom = top - 1; //下方数据索引
            let max = Number(this.Router_game[top].hp); // 上部数据
            let min = Number(this.Router_game[bottom].hp); // 下部数据
            let max_height = max; // 最高高度
            let min_height = min + this.Propobj.CubeSize.Z; // 最低高度 
            if (pos.y >= max_height || pos.y <= min_height) {
                this.rendelist = "end";
                this.scoreCalculation = false;
                Laya.stage.off(Laya.Event.MOUSE_DOWN, this, this.Event_DOWN);
                Laya.stage.off(Laya.Event.MOUSE_UP, this, this.Event_UP);
                this.animationobj.shake(this.camera, 100, () => {
                    this.ForceLineObj.transform.position = new Laya.Vector3(-5, 0, 0);
                    this.animationobj.CountDown({
                        callback: () => {
                            this.gameover();
                        }
                    });
                });
            }
            if ("drop" in this.Router_game[top] && this.Router_game[top].drop.length > 0) {
                let topY = Number(this.Router_game[top].hp);
                let bottomY = this.Propobj.CubeSize.Z + Number(this.Router_game[bottom].hp);
                let dropMaxheight = (topY - bottomY) / 2 + bottomY; // 道具Y轴范围
                if (pos.y <= dropMaxheight + 0.25 && pos.y >= dropMaxheight - 0.25) {
                    console.log("获得道具", dropMaxheight);
                }
            }
            if (pos.x >= Targetpoint.x - 3.2 && this.TemporaryVariable.cleateBoxStatus) {
                this.TemporaryVariable.cleateBoxStatus = false;
                this.RenderCube(1);
            }
        }
        gameover() {
            this.scene2D.destroy(); //清空index场景
            let scene = Laya.stage.addChild(new ui.alertUI);
            this.scene2D = scene;
            scene.zOrder = 999;
            let btn = scene.getChildByName("reset");
            let share = scene.getChildByName("share");
            btn.on(Laya.Event.CLICK, this, () => {
                this.Controller("start");
            });
            share.on(Laya.Event.CLICK, this, () => {
                //分享
                this.wx.share();
            });
        }
        // 渲染队列
        updata() {
            let _callback = () => {
                let pos = this.Lead_cube.transform.position;
                if (this.rendelist === "end") {
                    console.log("结束帧循环");
                    return;
                }
                ;
                this.rendelist.forEach((fun) => {
                    fun({ pos: pos });
                });
                window.requestAnimationFrame(_callback);
            };
            window.requestAnimationFrame(_callback);
        }
        // 全局变量转换接口
        Global_obj() {
            window['Lead'] = this.Lead_cube; // 主角
            window["camera"] = this.camera; // 摄像机
            window["foce"] = this.ForceLineObj; //着力线
            window["scene2D"] = this.scene2D; //2d场景
            window["move"] = this.SlantingMotion; //斜抛算法
            window["add"] = this.RenderCube; // 方块生成
            window["Controller"] = this.Controller; // 游戏状态切换
            window["Choicespot"] = this.Choicespot; // 激光点选取
            window["aa"] = this.circularMotion.bind(this);
            window["over"] = this.animationobj.CountDown;
            window["shake"] = this.animationobj.shake;
            window["moveto"] = this.animationobj.moveto;
            window["gameover"] = this.gameover.bind(this);
            window["getProp"] = this.Propobj.getProp;
            window["halo"] = this.Propobj.halo;
        }
    }
    WetchGame.gameScene = gameScene;
})(WetchGame || (WetchGame = {}));
//# sourceMappingURL=game.js.map
const wx = window["wx"];
var WetchGame;
(function (WetchGame) {
    class Wetch {
        constructor(ctx) {
            this.main = () => {
                if (!wx)
                    return;
                let screenHeight = window.innerHeight;
                let screenWidth = window.innerWidth;
                let openDataContext = wx.getOpenDataContext();
                let sharedCanvas = openDataContext.canvas;
                let ratio = wx.getSystemInfoSync().pixelRatio;
                sharedCanvas.width = screenWidth * ratio;
                sharedCanvas.height = screenHeight * ratio;
                var sprite = new Laya.Sprite();
                sprite.pos(0, 0);
                this.render = sprite;
                let self = this;
                wx.request({
                    url: 'https://shop.yunfanshidai.com/xcxht/bigbattle/api/share_info.php?gameid=18',
                    header: {
                        'content-type': 'application/json' // 默认值
                    },
                    success: function (res) {
                        // console.log(res.data);
                        // 主动转发
                        self.share = () => {
                            wx.shareAppMessage(function () {
                                return {
                                    title: res.data.info,
                                    imageUrl: res.data.image
                                };
                            });
                        };
                        // 被动转发
                        wx.showShareMenu({ withShareTicket: true });
                        wx.onShareAppMessage(function () {
                            return {
                                title: res.data.info,
                                imageUrl: res.data.image
                            };
                        });
                    }
                });
                wx.setPreferredFramesPerSecond(60);
                let bannerAd = wx.createBannerAd({
                    adUnitId: 'adunit-d707f0634076fb0b',
                    style: {
                        left: 0,
                        top: 500,
                        width: window.innerWidth
                    }
                });
                let videoAd = wx.createRewardedVideoAd({
                    adUnitId: 'adunit-68bfd9849e874c25'
                });
                this.bannerAd = bannerAd;
                this.videoAd = videoAd;
                bannerAd.show();
                setTimeout(() => { bannerAd.style.top = window.innerHeight - bannerAd.style.realHeight; }, 1000);
            };
            // 排行榜
            this.list = () => {
                wx.postMessage({ type: 2 });
                this.render.clearTimer(this, this.callback);
                this.callback = () => {
                    console.log("排行榜");
                    var texture = new Laya.Texture(Laya.Browser.window.sharedCanvas);
                    this.render.graphics.drawTexture(texture, 0, 0, texture.width, texture.height);
                    Laya.stage.addChild(this.render);
                };
                this.render.timer.frameLoop(10, this, this.callback);
            };
            // 得分面板
            this.Scorelist = (score) => {
                wx.postMessage({ type: 1, data: { score: score } });
                this.render.clearTimer(this, this.callback);
                this.callback = () => {
                    console.log("得分面板");
                    var texture = new Laya.Texture(Laya.Browser.window.sharedCanvas);
                    this.render.graphics.drawTexture(texture, 0, 0, texture.width, texture.height);
                    Laya.stage.addChild(this.render);
                };
                this.render.timer.frameLoop(10, this, this.callback);
            };
            // 关闭渲染
            this.off = () => {
                this.render.clearTimer(this, this.callback);
                this.render.destroy();
            };
            // 主动分享
            this.share = () => {
            };
            this.main();
        }
    }
    WetchGame.Wetch = Wetch;
})(WetchGame || (WetchGame = {}));
//# sourceMappingURL=wx.js.map
// 方块 道具
var WetchGame;
(function (WetchGame) {
    class Propobj {
        constructor(ctx) {
            this.CubeLength = 20;
            this.CubeSize = { X: 0.8, Y: 0.5, Z: 5 };
            this.Cubelist = []; // 方块池
            this.proplist = []; // 道具池
            this.haloObj = null; // 光环
            this.texturelist = [
                [
                    "res/image/color/1.png",
                    "res/image/color/1-1.png"
                ],
                [
                    "res/image/color/2.png",
                    "res/image/color/2-2.png"
                ],
                [
                    "res/image/color/3.png",
                    "res/image/color/3-3.png"
                ],
                [
                    "res/image/color/4.png",
                    "res/image/color/4-4.png"
                ],
            ];
            // 道具
            this.balltexture = [
                "https://shop.yunfanshidai.com/xcxht/pqxcx/conf/prop/Sign_1.lh",
                "https://shop.yunfanshidai.com/xcxht/pqxcx/conf/prop/Sign_2.lh",
                "https://shop.yunfanshidai.com/xcxht/pqxcx/conf/prop/Sign_3.lh"
            ];
            // 光环
            this.haloTexture = [
                "https://shop.yunfanshidai.com/xcxht/pqxcx/model/Halo2.lh"
            ];
            // 激光线
            this._line = [
                "https://shop.yunfanshidai.com/xcxht/pqxcx/model/line/Cube.lh"
            ];
            this.init = () => {
                var box2 = Laya.Sprite3D.load(this._line[0]);
                // var box2: Laya.Sprite3D = Laya.Sprite3D.load("res/model/line1.lh");
                box2.on(Laya.Event.HIERARCHY_LOADED, this, () => {
                    box2.transform.position = new Laya.Vector3(0, 0, 0);
                });
                this.ctx.Game_scene.addChild(box2);
                // 创建方块队列
                let list = [[], []];
                for (let i = this.CubeLength; i--;) {
                    if (i < this.CubeLength / 2) {
                        list[0].push(this.createCube("bottom"));
                    }
                    else {
                        list[1].push(this.createCube("top"));
                    }
                }
                // 创建道具队列
                for (let i = 0; i < this.balltexture.length; i++) {
                    let obj = [];
                    for (let j = 0; j < 2; j++) {
                        var sprite3D = Laya.Sprite3D.load(this.balltexture[i]);
                        sprite3D.on(Laya.Event.HIERARCHY_LOADED, this, () => {
                            sprite3D.transform.localScale = new Laya.Vector3(0.1, 0.1, 0.1);
                        });
                        obj.push(sprite3D);
                    }
                    this.proplist.push(obj);
                }
                console.log(this.proplist);
                this.Laserline = box2;
                this.Cubelist = list;
            };
            // 光环
            this.halo = (type, pos = null, texture = null) => {
                if (type === "add") {
                    if (!!this.haloObj) {
                        this.haloObj.transform.position = pos;
                        if (!this.haloObj.displayedInStage)
                            this.ctx.Game_scene.addChild(halo_obj);
                    }
                    else {
                        var halo_obj = Laya.Sprite3D.load(this.haloTexture[texture]);
                        halo_obj.on(Laya.Event.HIERARCHY_LOADED, this, () => {
                            halo_obj.transform.position = pos;
                        });
                        if (!halo_obj.displayedInStage)
                            this.ctx.Game_scene.addChild(halo_obj);
                        this.haloObj = halo_obj;
                    }
                }
                else if (type === "delete") {
                    if (!!this.haloObj) {
                        this.haloObj.destroy();
                    }
                }
                return this.haloObj;
            };
            // 创建立方体
            this.createCube = type => {
                let box = new Laya.MeshSprite3D(new Laya.BoxMesh(this.CubeSize.X, this.CubeSize.Y, this.CubeSize.Z));
                let material = new Laya.StandardMaterial();
                if (type === "top") {
                    material.diffuseTexture = Laya.Texture2D.load(this.texturelist[1][0]);
                }
                else if (type === "bottom") {
                    material.diffuseTexture = Laya.Texture2D.load(this.texturelist[1][1]);
                }
                box.meshRender.material = material;
                return box;
            };
            // 获取立方体
            this.pullcube = type => {
                let data;
                if (type === "top") {
                    data = this.Cubelist[1].shift();
                    this.Cubelist[1].push(data);
                }
                else if (type === "bottom") {
                    data = this.Cubelist[0].shift();
                    this.Cubelist[0].push(data);
                }
                data.transform.position = new Laya.Vector3(0, 0, 0);
                return data;
            };
            // 旋转动画
            this.rotateadmin = data => {
                data.transform.rotate(new Laya.Vector3(0, 0.05, 0));
            };
            // 添加道具
            this.getProp = (type, pos) => {
                let target = this.proplist[type].shift();
                target.transform.localScale = (new Laya.Vector3(0.3, 0.3, 0.3));
                target.clearTimer(this, this.rotateadmin);
                this.proplist[type].push(target);
                target.transform.position = pos;
                if (!target.displayedInStage)
                    this.ctx.Game_scene.addChild(target);
                target.frameLoop(2, this, this.rotateadmin, [target]);
                return target;
            };
            this.ctx = ctx;
        }
    }
    WetchGame.Propobj = Propobj;
})(WetchGame || (WetchGame = {}));
//# sourceMappingURL=obj.js.map
// 主角类
var WetchGame;
(function (WetchGame) {
    class npc {
        constructor(ctx) {
            this.skinURL = [
                "https://shop.yunfanshidai.com/xcxht/pqxcx/model/Lead1.lh",
                "https://shop.yunfanshidai.com/xcxht/pqxcx/model/Lead2.lh",
                "https://shop.yunfanshidai.com/xcxht/pqxcx/model/Lead3.lh",
                "https://shop.yunfanshidai.com/xcxht/pqxcx/model/Lead4.lh"
            ];
            this._over = [
                "https://shop.yunfanshidai.com/xcxht/pqxcx/model/over.lh"
            ];
            this.init = (data) => {
                if (!data || !("skin" in data) || !("scene" in data)) {
                    console.log("error =>class npc", "参数不对");
                }
                else {
                    var sprite3D = Laya.Sprite3D.load(this.skinURL[data.skin]);
                    this.ME = sprite3D;
                    sprite3D.on(Laya.Event.HIERARCHY_LOADED, this, () => {
                        sprite3D.transform.position = new Laya.Vector3(0.8, 9, 0);
                        sprite3D.transform.localScale = new Laya.Vector3(0.1, 0.1, 0.1);
                    });
                    data.scene.addChild(this.ME);
                }
            };
            this.comeout = (data, callback = null) => {
                // 主角出场动画
                if (!!this.admincomeout)
                    return;
                var target = data.transform.position.y - 7, value = 0;
                var a = window.setInterval(() => {
                    value += 0.01;
                    if (value >= target) {
                        if (!!callback)
                            callback();
                        window.clearInterval(a);
                        data.transform.localRotationEuler = new Laya.Vector3(0, 0, 0);
                        data.transform.position = new Laya.Vector3(0.8, 7, 0);
                    }
                    data.transform.translate(new Laya.Vector3(0, -0.01, 0));
                    data.transform.rotate(new Laya.Vector3(0, -0.03, 0));
                }, 1);
                this.admincomeout = a;
            };
            this.over = (data, callback) => {
                this.ME.transform.position = new Laya.Vector3(0.8, 7, 0);
                var sprite3D = Laya.Sprite3D.load(this._over[0]);
                sprite3D.on(Laya.Event.HIERARCHY_LOADED, this, () => {
                    sprite3D.transform.position = data;
                    if (!!callback)
                        callback();
                });
                this.ctx.Game_scene.scene.addChild(sprite3D);
            };
            this.skinRender = data => {
            };
            this.Destroy = data => {
            };
            this.ctx = ctx;
        }
    }
    WetchGame.npc = npc;
})(WetchGame || (WetchGame = {}));
//# sourceMappingURL=npc.js.map
// 动画与UI类
var WetchGame;
(function (WetchGame) {
    class animationUI {
        constructor(ctx) {
            this.shakeadmin = null; // 抖动对象
            // 复活倒计时界面
            this.CountDown = (data = null) => {
                let _size = {
                    btn1: { w: Laya.stage.width / 2.5, h: Laya.stage.width / 2.5 },
                }, _time = 500;
                let target = new Laya.Sprite();
                target.size(_size.btn1.w, _size.btn1.h);
                target.pos(Laya.stage.width / 2 - _size.btn1.w / 2, Laya.stage.height / 4 - _size.btn1.h / 2);
                target.zOrder = 101;
                target.alpha = .9;
                var img = new Laya.Sprite();
                img.zOrder = 101;
                img.loadImage("res/image/color/play_again.png");
                img.size(_size.btn1.w, _size.btn1.h / 2);
                img.pos(Laya.stage.width / 2 - _size.btn1.w / 2, Laya.stage.height / 1.5 - _size.btn1.h / 2);
                let mask = new Laya.Sprite();
                mask.alpha = .5;
                mask.zOrder = 99;
                mask.graphics.drawRect(0, 0, Laya.stage.width, Laya.stage.height, "#000000");
                let label = new Laya.Text();
                label.text = "跳过";
                label.fontSize = 50;
                label.color = "#ffffff";
                label.x = Laya.stage.width / 2 - 50;
                label.y = Laya.stage.height / 2.3;
                label.zOrder = 101;
                Laya.stage.addChild(img);
                Laya.stage.addChild(target);
                Laya.stage.addChild(label);
                Laya.stage.addChild(mask);
                target.on(Laya.Event.CLICK, this, () => {
                    Laya.timer.clear(this, fun);
                    this.ctx.wx.videoAd.shadow();
                });
                img.on(Laya.Event.CLICK, this, () => {
                    this.ctx.Controller("start"); // 进入游戏    
                    target.destroy();
                    Laya.timer.clear(this, fun);
                    target.offAll(Laya.Event.CLICK);
                    img.offAll(Laya.Event.CLICK);
                    label.offAll(Laya.Event.CLICK);
                    target.destroy();
                    img.destroy();
                    mask.destroy();
                    label.destroy();
                    return;
                });
                label.on(Laya.Event.CLICK, this, () => {
                    // this.ctx.Controller("start");// 进入游戏    
                    target.destroy();
                    Laya.timer.clear(this, fun);
                    target.offAll(Laya.Event.CLICK);
                    img.offAll(Laya.Event.CLICK);
                    label.offAll(Laya.Event.CLICK);
                    target.destroy();
                    img.destroy();
                    mask.destroy();
                    label.destroy();
                    if (!!data && "callback" in data)
                        data.callback();
                    return;
                });
                // 圆环转动
                var fun = () => {
                    _time -= 1;
                    target.graphics.clear();
                    target.graphics.drawCircle(_size.btn1.w / 2, _size.btn1.h / 2, _size.btn1.w / 2, "#cccccc"); // 背景
                    target.graphics.drawPie(_size.btn1.w / 2, _size.btn1.h / 2, _size.btn1.w / 2, 0, 360 * (_time / 500), "#1fbb25"); // 进度环
                    target.graphics.drawCircle(_size.btn1.w / 2, _size.btn1.h / 2, _size.btn1.w / 2 - 40, "#ffffff");
                    target.graphics.fillText("复活", _size.btn1.w / 2, _size.btn1.h / 2.5, "40px SimHei", "#1fbb25", "center");
                    if (_time <= 1) {
                        Laya.timer.clear(this, fun);
                        if (!!data && "callback" in data)
                            data.callback();
                        target.offAll(Laya.Event.CLICK);
                        img.offAll(Laya.Event.CLICK);
                        target.destroy();
                        img.destroy();
                        mask.destroy();
                        label.destroy();
                        return;
                    }
                };
                Laya.timer.frameLoop(1, this, fun);
            };
            // 3d场景
            this.initScene = () => {
                let bgobj = [];
                //添加3D场景
                var scene = Laya.stage.addChild(new Laya.Scene());
                //添加摄像机
                var camera = (scene.addChild(new Laya.Camera(0, 0.1, 100)));
                camera.transform.position = new Laya.Vector3(-1, 10, 6);
                camera.transform.localRotationEuler = new Laya.Vector3(-15, -25, 2);
                camera.clearColor = new Laya.Vector4(0.2, 0.5, 0.6, 1);
                //平行光
                var directionLight = scene.addChild(new Laya.DirectionLight());
                directionLight.direction = new Laya.Vector3(2, -2, -3);
                directionLight.shadow = false;
                // for (let i = 0; i < 3; i++) {
                //     //添加背景
                //     var bottombox: Laya.MeshSprite3D = scene.addChild(new Laya.MeshSprite3D(new Laya.BoxMesh(bgsize.X, bgsize.Y, bgsize.Z))) as Laya.MeshSprite3D;
                //     var material: Laya.StandardMaterial = new Laya.StandardMaterial();
                //     material.diffuseTexture = Laya.Texture2D.load("res/image/color/floor.png");
                //     bottombox.meshRender.material = material;
                //     bottombox.transform.position = new Laya.Vector3(5 + bgsize.X * i, 0, -10);
                //     bgobj.push(bottombox);
                // }
                //开启雾化效果
                scene.enableFog = true;
                //设置雾化的颜色
                scene.fogColor = new Laya.Vector3(0.2, 0.5, 0.6);
                //设置雾化的起始位置，相对于相机的距离
                scene.fogStart = 10;
                //设置雾化最浓处的距离。
                scene.fogRange = 30;
                return {
                    scene: scene,
                    camera: camera,
                    directionLight: directionLight,
                    bgobj: bgobj
                };
            };
            // index界面
            this.indexUI = () => {
                let scene = Laya.stage.addChild(new ui.indexUI);
                scene.stage.scaleMode = Laya.Stage.SCALE_EXACTFIT;
                scene.stage.screenMode = Laya.Stage.SCREEN_NONE;
                scene.zOrder = 100;
                return scene;
            };
            this._a = () => {
                this.ctx.Lead_cube.transform.rotate(new Laya.Vector3(0, -.01, 0));
            };
            // 商城界面
            this.shopping = () => {
                this.ctx.Lead_cube.timerLoop(10, this, this._a);
                let scene = Laya.stage.addChild(new ui.shoppingUI);
                scene.stage.scaleMode = Laya.Stage.SCALE_EXACTFIT;
                scene.stage.screenMode = Laya.Stage.SCREEN_NONE;
                scene.zOrder = 101;
                var sure = scene.getChildByName("Sure");
                var returnbtn = scene.getChildByName("return");
                sure.on(Laya.Event.CLICK, this, () => {
                    this.ctx.camera.transform.position = new Laya.Vector3(-1, 10, 6);
                    this.ctx.camera.transform.localRotationEuler = new Laya.Vector3(-15, -25, 2);
                    this.ctx.Lead_cube.transform.position = new Laya.Vector3(0.8, 7, 0);
                    scene.destroy();
                    this.ctx.Lead_cube.clearTimer(this, this._a);
                    // this.ctx.Controller("start");
                    this.ctx.scene2D = this.indexUI();
                    this.ctx.loadAdn();
                    this.ctx.startGame();
                    this.ctx.Propobj.halo("add", (new Laya.Vector3(0.8, 7, 0)), 0);
                });
                returnbtn.on(Laya.Event.CLICK, this, () => {
                    this.ctx.camera.transform.position = new Laya.Vector3(-1, 10, 6);
                    this.ctx.camera.transform.localRotationEuler = new Laya.Vector3(-15, -25, 2);
                    this.ctx.Lead_cube.transform.position = new Laya.Vector3(0.8, 7, 0);
                    scene.destroy();
                    this.ctx.Lead_cube.clearTimer(this, this._a);
                    // this.ctx.Controller("start");         
                    this.ctx.scene2D = this.indexUI();
                    this.ctx.loadAdn();
                    this.ctx.startGame();
                });
                return scene;
            };
            // 摄像机抖动
            this.shake = (target, frequency, callback = null) => {
                let pos = target.transform.position;
                let a = true, _frequency = 0;
                let admin = window.setInterval(() => {
                    if (_frequency >= frequency) {
                        window.clearInterval(admin);
                        target.transform.position = pos;
                        if (!!callback)
                            callback();
                    }
                    ;
                    a = !a;
                    _frequency += 1;
                    if (a) {
                        target.transform.translate(new Laya.Vector3(0.1, 0.1, 0));
                    }
                    else {
                        target.transform.translate(new Laya.Vector3(-0.1, -0.1, 0));
                    }
                }, 6);
            };
            // 位移动画函数
            this.moveto = (target, value, time, callback = null) => {
                let pos = target.transform.position;
                // 速度
                let speed_X = Math.abs(value.x - pos.x) / time, speed_Y = Math.abs(value.y - pos.y) / time, speed_Z = Math.abs(value.z - pos.z) / time;
                // 单位时间移动量
                let office_X = (value.x - pos.x) / time * 0.006;
                let office_Y = (value.y - pos.y) / time * 0.006;
                let office_Z = (value.z - pos.z) / time * 0.006;
                window.setTimeout(() => {
                    window.clearInterval(a);
                    console.log("停止动画");
                    if (!!callback)
                        callback();
                }, time * 1000);
                var a = window.setInterval(() => {
                    target.transform.translate(new Laya.Vector3(office_X, office_Y, office_Z));
                }, 6);
            };
            this.ctx = ctx;
        }
    }
    WetchGame.animationUI = animationUI;
})(WetchGame || (WetchGame = {}));
//# sourceMappingURL=animation.js.map
// 商城 
var WetchGame;
(function (WetchGame) {
    class Shopping {
        constructor(ctx) {
            this.objpool = []; // 对象池
            this.main = () => {
                for (let i = 0; i < this.skin.length; i++) {
                    console.log(this.skin[i]);
                    // let sprite3D: Laya.Sprite3D = Laya.loader.getRes(this.skin[i].url);
                    // this.objpool.push(sprite3D);
                }
                // console.log(this.objpool);
            };
            // 开启商城界面
            this.renderUI = (data = null, callback = null) => {
                this.ctx.animationobj.moveto(this.ctx.camera, new Laya.Vector3(-3, 30, 18), 1, () => {
                    if (!!callback)
                        callback();
                });
            };
            // 清空资源并回收
            this.delete = data => {
            };
            this.ctx = ctx;
            // this.skin = ctx.npc.skinURL;
            // console.log(ctx.npc.skinURL);
            // Laya.loader.create(this.skin, Laya.Handler.create(this, this.main));
        }
    }
    WetchGame.Shopping = Shopping;
})(WetchGame || (WetchGame = {}));
//# sourceMappingURL=Shopping.js.map
var View = laya.ui.View;
var Dialog = laya.ui.Dialog;
var ui;
(function (ui) {
    class alertUI extends Dialog {
        constructor() { super(); }
        createChildren() {
            super.createChildren();
            this.createView(ui.alertUI.uiView);
        }
    }
    alertUI.uiView = { "type": "Dialog", "props": { "width": 720, "height": 1280 }, "child": [{ "type": "Button", "props": { "y": 794, "x": 134, "var": "reset", "stateNum": 1, "skin": "index/btn_play_againx.png", "name": "reset" } }, { "type": "Button", "props": { "y": 970, "x": 257, "width": 185, "var": "share", "stateNum": 1, "skin": "index/share.png", "name": "share", "height": 107 } }] };
    ui.alertUI = alertUI;
})(ui || (ui = {}));
(function (ui) {
    class indexUI extends Dialog {
        constructor() { super(); }
        createChildren() {
            super.createChildren();
            this.createView(ui.indexUI.uiView);
        }
    }
    indexUI.uiView = { "type": "Dialog", "props": { "width": 720, "height": 1280 }, "child": [{ "type": "Box", "props": { "y": 0, "x": 3, "width": 720, "var": "home", "name": "home", "height": 1280 }, "child": [{ "type": "Image", "props": { "y": 215, "x": 342, "width": 395, "var": "logo", "skin": "index/logo.png", "scaleY": 0.5, "scaleX": 0.5, "name": "logo", "height": 336, "anchorY": 0.5, "anchorX": 0.5 } }, { "type": "Box", "props": { "x": 36, "var": "btn_groug", "top": 1280, "name": "btn_groug" }, "child": [{ "type": "Image", "props": { "y": 77, "x": 30, "width": 100, "var": "setup", "skin": "index/frans.png", "name": "setup", "height": 120 } }, { "type": "Image", "props": { "y": 78, "x": 530, "width": 100, "var": "skin", "skin": "index/skin.png", "name": "skin", "height": 120 } }, { "type": "Button", "props": { "y": 69, "x": 169, "width": 320, "var": "start", "stateNum": 1, "skin": "index/stat.png", "name": "start", "height": 130 } }] }, { "type": "Image", "props": { "y": 35, "x": 31, "var": "audio", "skin": "index/audio_on.png", "name": "audio" } }, { "type": "Image", "props": { "y": 32, "x": 141, "width": 63, "skin": "index/shock.png", "height": 69 } }] }, { "type": "Box", "props": { "y": 158, "x": 340, "var": "game", "name": "game" }, "child": [{ "type": "FontClip", "props": { "y": 8, "x": 2, "visible": false, "var": "Fraction", "value": "0", "skin": "index/num.png", "sheet": "0123456789", "name": "Fraction" } }] }, { "type": "Image", "props": { "y": 835, "x": 234, "visible": false, "var": "sure", "skin": "index/sure.png", "name": "sure" } }] };
    ui.indexUI = indexUI;
})(ui || (ui = {}));
(function (ui) {
    class shoppingUI extends Dialog {
        constructor() { super(); }
        createChildren() {
            super.createChildren();
            this.createView(ui.shoppingUI.uiView);
        }
    }
    shoppingUI.uiView = { "type": "Dialog", "props": { "width": 720, "height": 1280 }, "child": [{ "type": "Image", "props": { "y": 929, "x": 231, "var": "Sure", "skin": "index/sure.png", "name": "Sure" } }, { "type": "Image", "props": { "y": 568, "x": 27, "width": 52, "skin": "index/return.png", "pivotY": 1, "pivotX": 1, "height": 78 } }, { "type": "Image", "props": { "y": 642, "x": 682, "width": 52, "skin": "index/return.png", "rotation": 180, "pivotY": 1, "pivotX": 1, "height": 78 } }, { "type": "Image", "props": { "y": 0, "x": 0, "width": 720, "skin": "index/store.png" } }, { "type": "Image", "props": { "y": 35, "x": 52, "width": 36, "var": "return", "skin": "index/return.png", "pivotY": 1, "pivotX": 1, "name": "return", "height": 54 } }] };
    ui.shoppingUI = shoppingUI;
})(ui || (ui = {}));
//# sourceMappingURL=layaUI.max.all.js.map
// 程序入口
class LayaAir3D {
    constructor() {
        //初始化微信小游戏
        Laya.MiniAdpter.init();
        //初始化引擎
        Laya3D.init(720, 1280, true);
        //适配模式
        Laya.stage.alignV = "middle";
        Laya.stage.alignH = "center";
        Laya.stage.scaleMode = "fixedwidth";
        Laya.stage.screenMode = "none";
        //开启统计信息
        // Laya.Stat.show();
        // 初始化场景
        TOOLS.runScene(WetchGame.gameScene);
    }
}
new LayaAir3D();
//# sourceMappingURL=LayaAir3D.js.map